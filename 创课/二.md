### 二、前端性能优化基础

#### 1. 资源加载优化

##### 1.1 工作要点

- **资源压缩与合并**（5 分钟）
  - 压缩图片、CSS、JavaScript 文件，减少文件大小。
  - 合并多个 CSS 和 JavaScript 文件，减少 HTTP 请求数量。

##### 1.2 工作方法

- **使用 HTTP/2 和 Tree Shaking 技术**（10 分钟）

  - **HTTP/2**：多路复用和头部压缩，减少延迟，提高并发加载速度。

    - **示例代码**：在 Nginx 中启用 HTTP/2

      ```nginx
      server {
          listen 443 ssl http2;
          server_name example.com;
          ssl_certificate /etc/nginx/ssl/example.com.crt;
          ssl_certificate_key /etc/nginx/ssl/example.com.key;

          location / {
              root /var/www/html;
              index index.html;
          }
      }
      ```

  - **Tree Shaking**：移除未使用的代码，减少最终打包文件大小。
    - **示例代码**：在 Webpack 中启用 Tree Shaking
      ```javascript
      // webpack.config.js
      module.exports = {
        mode: "production",
        entry: "./src/index.js",
        output: {
          filename: "bundle.js",
          path: __dirname + "/dist",
        },
        optimization: {
          usedExports: true,
        },
      };
      ```

##### 1.3 常用问题与解决思路

- **长加载时间的处理方案**（5 分钟）

  - **问题**：页面加载时间过长，用户等待时间过久。
  - **解决方案**：

    - **图片优化**：使用合适的图片格式和压缩工具，如 JPEG、PNG、WebP 等。
      - **示例代码**：使用 ImageMagick 压缩图片
        ```sh
        convert input.jpg -quality 85% output.jpg
        ```
    - **延迟加载**：仅在需要时加载图像和其他资源，减少初次加载时间。

      - **示例代码**：使用 Intersection Observer 实现图片懒加载

        ```javascript
        document.addEventListener("DOMContentLoaded", function () {
          let lazyImages = [].slice.call(document.querySelectorAll("img.lazy"));

          if ("IntersectionObserver" in window) {
            let lazyImageObserver = new IntersectionObserver(function (
              entries,
              observer
            ) {
              entries.forEach(function (entry) {
                if (entry.isIntersecting) {
                  let lazyImage = entry.target;
                  lazyImage.src = lazyImage.dataset.src;
                  lazyImage.classList.remove("lazy");
                  lazyImageObserver.unobserve(lazyImage);
                }
              });
            });

            lazyImages.forEach(function (lazyImage) {
              lazyImageObserver.observe(lazyImage);
            });
          }
        });
        ```

#### 2. 代码分割和懒加载

##### 2.1 工作要点

- **动态引入和按需加载**（5 分钟）
  - 将代码分割成较小的块，根据需要动态加载，减少初次加载时间。

##### 2.2 工作方法

- **配置 Webpack 进行代码分割**（10 分钟）
  - 使用 Webpack 的代码分割功能，按需加载模块。
    - **示例代码**：在 Webpack 中配置代码分割
      ```javascript
      // webpack.config.js
      module.exports = {
        mode: "production",
        entry: {
          main: "./src/index.js",
          vendor: "./src/vendor.js",
        },
        output: {
          filename: "[name].[contenthash].js",
          path: __dirname + "/dist",
        },
        optimization: {
          splitChunks: {
            chunks: "all",
          },
        },
      };
      ```

##### 2.3 常用问题与解决思路

- **懒加载带来的初次加载时间问题**（5 分钟）
  - **问题**：懒加载可能导致初次加载时间延长。
  - **解决方案**：
    - **关键路径优化**：确保关键资源优先加载，减少初次加载时间。
    - **预加载**：在空闲时间预加载将要使用的资源。
      - **示例代码**：使用 Preload 标签预加载资源
        ```html
        <link rel="preload" href="main.js" as="script" />
        ```
    - **示例代码**：使用 Webpack 的 prefetch 功能
      ```javascript
      // src/index.js
      import(/* webpackPrefetch: true */ "./moduleA.js").then((moduleA) => {
        moduleA.doSomething();
      });
      ```

#### 3. 静态资源缓存

##### 3.1 工作要点

- **利用浏览器缓存**（5 分钟）
  - 配置缓存策略，减少重复加载，提升页面加载速度。

##### 3.2 工作方法

- **使用 Service Worker 进行缓存管理**（10 分钟）

  - Service Worker 可以拦截网络请求，缓存静态资源，提高页面加载速度。

    - **示例代码**：使用 Service Worker 缓存静态资源

      ```javascript
      // sw.js
      self.addEventListener("install", function (event) {
        event.waitUntil(
          caches.open("v1").then(function (cache) {
            return cache.addAll(["/index.html", "/main.js", "/styles.css"]);
          })
        );
      });

      self.addEventListener("fetch", function (event) {
        event.respondWith(
          caches.match(event.request).then(function (response) {
            return response || fetch(event.request);
          })
        );
      });
      ```

##### 3.3 常用问题与解决思路

- **缓存更新策略**（5 分钟）
  - **问题**：缓存内容过时，影响用户体验。
  - **解决方案**：
    - **版本控制**：为静态资源添加版本号，确保更新及时。
      - **示例代码**：在 Webpack 中配置版本控制
        ```javascript
        // webpack.config.js
        module.exports = {
          output: {
            filename: "[name].[contenthash].js",
            path: __dirname + "/dist",
          },
        };
        ```
    - **缓存失效策略**：设置合理的缓存失效时间，确保资源更新。
      - **示例代码**：在 Nginx 中配置缓存失效策略
        ```nginx
        location / {
            expires 1y;
            add_header Cache-Control "public, max-age=31536000";
        }
        ```

### 课程结构：

- 资源加载优化（20 分钟）
  - 描述资源压缩与合并的重要性和方法
  - 提供 HTTP/2 和 Tree Shaking 技术的具体实施步骤和示例代码
- 代码分割和懒加载（20 分钟）
  - 介绍动态引入和按需加载的概念
  - 详细讲解 Webpack 代码分割的配置和实施，包括示例代码
- 静态资源缓存（20 分钟）
  - 解释利用浏览器缓存的策略和方法
  - 演示 Service Worker 进行缓存管理的具体操作和示例代码

这部分课程大约为 60 分钟。请确认这部分内容是否符合要求，如果需要调整或补充，请告知。确认后我们继续制作下一章节的内容。
