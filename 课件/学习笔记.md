# Get System Arguments 获取系统参数
```
import sys

# 输出文件名
print sys.argv[0]

# 输出第一个参数
sys.argv[1]
```

# Define a class 定义类
```
class Person:
    self.name = ''
    self.id = 0
    self.father = 1
    self.mother = 2 

    def __init__(self, name):
        self.name = name
	self.born()
    
    def born(self):
        self.id = self.father + self.mother

me = Person('Solomon')
print(me.id)
```

# Python path路径问题
## 路径解析
文件名

>>> s = '/Users/me/movie/abc.mp4'
>>> os.path.basename(s)
'abc.mp4'

文件名（不含扩展名）

>>> s = '/Users/me/movie/abc.mp4'
>>> os.path.basename(os.path.splitext(s)[0])
'abc'

目录名

>>> s = '/Users/me/movie/'
>>> os.path.basename(os.path.realpath(s))
'movie'

## 获取系统相关路径
```
# 也就是解析命令行里`~`指向的地址
path = os.path.expanduser("~")

# 延伸：
path = os.path.expanduser('~/.tmux')

```

- 当前工作区: os.getcwd()，注意，这不是脚本的位置，而是命令行中的工作区位置。
- 比如当你在~/A/执行~/B/文件夹中的一个python代码，那么返回的是~/A/，因为命令行- 中的工作区在~/A/.
- 当前文件名：sys.argv[0]或__file__，注意，两个变量都不稳定。__file__这个默认- 变量在一些环境下是没有被定义的，sys.argv[0]有时是完整路径有时只是一个文件名，- 所以，慎用。最好都配合os.path的各种方法运用。
- 所以正确方法是：os.path.basename(sys.argv[0])
- 当前文件完整路径：os.path.realpath(sys.argv[0])
- 当前文件所在文件夹：os.path.dirname(os.path.realpath(sys.argv[0]))
- 当前脚本完整路径：os.path.split(os.path.realpath(__file__))[0]
- 当前脚本父级目录：os.path.dirname( os.path.split(os.path.realpath- (__file__))[0] )
- 当前脚本的父父级目录：os.path.dirname( os.path.dirname(....) )


# python调用命令行
```
import os

#只返回结果
os.system(command)

#或者，返回结果与终端显示信息
with os.popen(command, mode) as f: 
    print(f.read())
```

# Virtualenv虚拟环境的正确使用方法
步骤是这样的：
随便建一个位置，比如cd ~/，然后virtualenv venv，创建了一个叫venv的文件夹并且在里面配置了虚拟python环境。
配置命令行别名：alias venv="source ~/venv/bin/activate"，这样就能一键开启虚拟空间，带上小帽子。
安装自己所有需要的包，代替系统环境：pip install PACKAGE-1 PACKAGE-2...，或者pip install -r PATH/requirements.txt从之前的备份列表中一键恢复安装。

# python将某个目录打包为zip文件
比较古老的方法是用zipfile库创建zip包，但是要写各种循环迭代需要很多行代码。
还有另一种python自带库shutil,可以一句话打包为zip文件。
```
import shutil
shutil.make_archive(base_name, format, root_dir, base_dir)
```
很快就打包好了！
唯一注意的是，怎样把它安装自己想象的结构打包。

- base_name，是加上完整路径（不能缩写）的文件或文件夹名
- format一般是zip，其它tar之类也行
- root_dir是要压缩的目录或文件
- base_dir是压缩包里的文件层级。如你写a/b/c，这样所有文件都会塞到最底层的c文件夹中。

# Python 日期和时间
- 日期加减：
```
import datetime

today = datetime.date.today()

oneday = datetime.timedelta(days=1)

yesterday = today - oneday

tommorrow = today + oneday

print(yesterday, today, tommorrow)
#[out]: 2011-06-02      2011-06-03      2011-06-04
```

# Python调试工具pdb —— Python Debuger
启动方法一：python -m pdb PATH-TO-SCRIPT.py
启动方法二：代码中写入import pdb;pdb.set_trace()，即插入了一个断点。


# 用requests报错requests.exceptions.SSLError
明明没有改代码，突然就报这种错误。
调查发现，原来是被服务器拒了。可能是今天来回调试，多次访问同一个地址，就被屏蔽了。
但是，同样是没有设置请求Headers的客户端postman和insomnia就还能正常访问，不知道为什么。
后来知道了，原来是服务器拒绝给我传送数据，因为访问量太大了！
Github的API是比较好的，它会在response中返回一个当前访问剩余量和下次能再次开始访问的时间。所以搞明白这个就知道，不是自己代码的事，而是访问量的事了。解决方法就是request访问时加上auth认证，这样就会从默认的每小时60次访问增加到每小时5000次。基本上够用了。

# Python操作Git库 GitPython
试了一圈发现，git库的用法设置非常符合原生git命令，只不过之间加了个.而已。
比如原本命令行里是git add .，这里就是repo.git.add('.')，
原本是git commit -m "信息"，这里就是repo.git.commit(m='信息')
可以说减少了很多学习时间，基本上我很多都是没参考文档自己猜出来的也能用。

sudo pip install gitpython
库安装好后可以直接在python中用了。

创建、识别、克隆仓库

文件夹地址可以是全路径，也可以是.当前文件夹、../上级文件夹等用法。

- 在文件夹里新建一个仓库，如果已存在git仓库也不报错不覆盖没问题
repo = git.Repo.init(path='文件夹地址')

- 选择已有仓库
repo = git.Repo( '仓库地址' )

- 克隆仓库
repo = git.Repo.clone_from(url='git@github.com:USER/REPO.git', to_path='../new')
常用语句：

- 查看repo状态
print repo.git.status()   # 返回通常的status几句信息
print repo.is_dirty()    # 返回是否有改动（包括未add和未commit的）

- 添加文件 可以是单个文件名，也可以是`[ ]`数组，还可以是`.`代表全部
print repo.git.add( '文件名' )

- commit提交
print repo.git.commit( m='提交信息' )
远程交互操作

- 创建remote：
remote = repo.create_remote(name='gitlab', url='git@gitlab.com:USER/REPO.git')

- 远程交互：
remote = repo.remote()
remote.fetch()
remote.pull()
remote.push()
实验效果

- 原意是返回工作区是否改变的状态
- 但是测试发现，工作区有变动它返回False，没变动却返回True
print repo.is_dirty()
生成tar压缩包

- 压缩到 tar 文件
with open('repo.tar', 'wb') as fp:
    repo.archive(fp)

# pip 常用操作
```
## 安装pip
$ curl https://bootstrap.pypa.io/get-pip.py >> get-pip.py
$ python get-pip.py

## 安装包
pip install <package name>

## 删除包
pip uninstall <package name>

## 升级某个包
pip install --upgrade <package name>

## 安装某个版本的包
pip install django==1.9

## 升级自己
pip install --upgrade pip

## 显示模块包的安装路径
pip show <package name>

## 查看已经过期的软件（不是最新版）
pip list --outdated

## 列出已安装的包 (二者皆可)
pip list
pip freeze

## 导出已安装包到requirements.txt
pip freeze > requirements.txt

## 批量安装包
pip install -r requirements.txt

## 搜索包
pip search

## 查询可升级的包
pip list -o
```


# Python 删除某文件夹
os.remove() will remove a file
os.rmdir() will remove an empty directory
shutil.rmtree() will delete a directory and all its contents
```
# 删除某个目录及里面所有内容，第二个参数为True时忽略所有错误中断
shutil.rmtree('<path>', True)
```

# Python 文件读取的练习
## 基本的txt文件读写
```
start = time.clock()
f = open('hello.txt', 'r+')
f2 = open('hello2.txt', 'w')
f2.write(f.read())
f2.close
f.close()
end = time.clock()
print str(end - start)
```
## 将14M的txt文件逐行复制到新文件的速度
```
start = time.clock()
f = open('hello.txt', 'r+') # 14M的txt文件
f2 = open('hello2.txt', 'w') # 逐行复制到新文件里
n = 0
while True:
    line = f.readline()
    n += 1
    if line:
        f2.write(line)
        #print '现在正在写入第 %s 行数据。' % n
    else:
        break
f2.close
f.close()
end = time.clock()
print str(end - start)
```
## 生成1.4G的txt文件
```
start = time.clock()
f = open('hello.txt', 'r') # 原文件14M
f2 = open('hello-1g.txt','a')
content = f.read()
f.close()
# 想要生成1.4G的txt文件
# 用来测试各种方式读写大文件的速度
for i in range(1000):
    f2.write(content)
f2.close()
end = time.clock()
print str(end-start) # 用了446秒，无所谓了，主要是弄出一个1G的文件
```

## 用readline()来逐行读取1G文件的速度
```
start = time.clock()
f = open('hello-1g.txt', 'r')
print f.readline().decode('gb2312')
print f.readline().decode('gb2312')
print f.readline().decode('gb2312')
print f.readline().decode('gb2312')
print f.readline().decode('gb2312')
f.close()
end = time.clock()
print str(end-start) #用了0.08秒
```

## 用read()和来读取1G文件的速度
```
// ，把1G的内容赋予变量——也就是一个变量在内存中占据1G以上的地盘，直接报错，如下图：
几十M的小文件的话，read()和readline()哪个都无所谓了，方便就行。
大文件的话，绝对不能read()直接读取。
start = time.clock()
f = open('hello-1g.txt', 'r')
content = f.read() # print出1G是不可能的，直接赋予变量吧
f.close()
end = time.clock()
print str(end-start) 
```

# Python Logging 日志记录入门
## 常用设置语句
```
#   main.py
import logging
import otherMod2   # 等下会调用到的子模块

def main():
    """
    这个文件是程序的主入口
    """

    define_logger()

    log = logging.getLogger('exampleApp')

    # 输出信息测试
    logger.info("Program started")
    result = otherMod2.add(7, 8)     # 这个是来自别的模块的方法
    logger.info("Done!")

def define_logger():
    logger = logging.getLogger("exampleApp")
    logger.setLevel(logging.INFO)

    # 设置输出格式
    formatter = logging.Formatter('\n%(asctime)s - %(name)s - %(levelname)s :\n\n\t %(message)s')
 
    # 设置日志文件处理器
    fh = logging.FileHandler("new_snake.log")
    fh.setFormatter(formatter)    # 为这个处理器添加格式

    # 设置屏幕stdout输出处理器
    sh  = logging.StreamHandler(stream=None)
    sh.setFormatter(formatter)
 
    # 把处理器加到logger上
    logger.addHandler(fh)
    logger.addHandler(sh)
 
if __name__ == "__main__":
    main()
```
## 子模块中的调用方法
```
# otherMod2.py
import logging
 
module_logger = logging.getLogger("exampleApp.otherMod2")

def add(x, y):
    # 这里一句`getLogger`就继承到父级的logger了
    logger = logging.getLogger("exampleApp.otherMod2.add")

    # 输出测试
    logger.info("added %s and %s to get %s" % (x, y, x+y))
    return x+y
```

# Python2 处理含中文特殊字符的CSV
## 使用第三方库轻松解决
```
>>> import unicodecsv as csv
>>> from io import BytesIO
>>> f = BytesIO()
>>> w = csv.writer(f, encoding='utf-8')
>>> _ = w.writerow((u'é', u'ñ'))
>>> _ = f.seek(0)
>>> r = csv.reader(f, encoding='utf-8')
>>> next(r) == [u'é', u'ñ']
True
```
## YAML
```
>>> import json
>>> import yaml
>>> list_org = ['a', 'b']
>>> list_dump = json.dumps(list_org)
>>> list_dump
'["a", "b"]'
>>> json.loads(list_dump)
[u'a', u'b']
>>> yaml.safe_load(list_dump)
['a', 'b']
```