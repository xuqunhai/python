# 动态添加脚本类似async，即加载不阻塞，但是下载完成后会尽快执行，且执行阻塞
# js脚本下载顺序不一定和书写顺序一样，但是js执行顺序和书写顺序一样，即后面可能先下载完成，但是一定等前面js下载且执行完才执行
# 浏览器可能在不同线程上执行脚本处理和页面渲染，浏览器策略是优化渲染效率、尽快显示内容
# css文件书写在js文件之后，但因为浏览器认为css文件优先级更高，所以会出现js执行过程中新的渲染结果已经显示在屏幕上，但CSSOM内部某些状态可能还没完全同步更新，所以此时js查询得到的还是旧样式值
# 页面滚动时，浏览器会提高即将进入视口的资源优先级

# 动态添加的脚本document.createElement('script');
- 通过 document.createElement 动态添加的脚本行为类似于 async。下载不会阻塞页面的解析，但会在下载完成后尽快执行。
- 通过将网速调到1kb后查看demo/appendChild.html的网络面板得知动态加载的脚本的加载优先级较低，因为log3几乎都是最后出现的，还可以发现css下载和渲染会比书写位置提前，也就是浏览器认为css有更高优先级
- demo/appendBody.html说明如论css插入到head还是body，即使js书写顺序在前面，也会出现css先加载并渲染

# async 和 defer 的区别：
- 使用 async 或 defer 属性时，脚本将被异步加载。这意味着浏览器可以继续解析和渲染页面，同时并行下载脚本
- async：脚本一旦下载完毕就会尽快执行，而不管页面加载到哪个阶段。这可能会导致脚本执行顺序与脚本在HTML中的顺序不同。
- defer：脚本会按照在HTML中出现的顺序执行，并且会等到整个页面解析完成后才执行，即在 DOMContentLoaded 事件之前执行。

# 资源的加载顺序并不完全遵循HTML中的书写顺序
- 现代浏览器能够同时发起多个网络请求
- 浏览器根据资源类型和当前页面的解析状态给予不同的加载优先级。通常，CSS文件被赋予高优先级，因为它们会影响到页面的布局和绘制；
- 当HTML文档被解析时，浏览器的预加载扫描器尝试预测并提前加载重要资源。这通常导致一些资源比实际在HTML中解析到的位置更早被加载，特别是当这些资源被预测为对首屏渲染非常重要时。

# 浏览器的资源处理机制
1. 解析HTML和发现资源：使用HTML解析器逐字节解析文档内容。解析器的任务是构建DOM（文档对象模型），同时也识别文档中的资源需求，如图片、样式表、JavaScript文件等。
2. 资源请求队列：浏览器会把识别的资源的请求信息添加到资源请求队列中。此时，资源状态可能显示为“待处理”
3. 网络请求调度：决定何时实际发起网络请求，影响因素有资源优先级（css因影响布局绘制所以通常优先级高于js）、并发限制（同域名）、预加载扫描器（提前识别并提前加载关键资源）
4. 发起网络请求：解析url、DNS查询、建立tcp连接、发起请求
5. 资源接收与处理：对js如异步脚本可立刻执行，同步脚本需等待先前同步脚本执行完毕

# 渲染引擎动态调整资源的优先级
- 如用户滚动页面时，新进入视口的图片的加载优先级会提高。

# DOMContentLoaded事件表示当整个HTML文档被完全加载和解析后触发，但不等待样式表、图片和iframe的加载完成？
## 测试demo/getStyle.html结果显示
- DOMContentLoaded回调触发时机是在前面所有js执行完，
- 而且如果js后面有样式表，js里获取的样式是前面的样式结果
- 但是从页面渲染效果看，js执行过程中，后面样式表已经生效（网速调到1kb）
- demo/appendBody.html也证明从页面渲染效果看，js执行过程中，后面样式表已经生效，但是js里获取的样式是前面的样式结果