## 4 概述
本节包含ECMAScript语言的非规范性概述。

ECMAScript是一种面向对象的编程语言，用于在主机环境中执行计算和操作计算对象。本文定义的ECMAScript并不打算在计算上完全自给自足；实际上，本规范中没有为输入外部数据或输出计算结果提供规定。相反，期望ECMAScript程序的计算环境不仅提供本文描述的对象和其他设施，还提供某些环境特定的对象，这些对象的描述和行为超出了本文规范的范围，只提到它们可能提供某些可以访问的属性和可以从ECMAScript程序中调用的函数。

ECMAScript最初被设计为一种脚本语言，但已被广泛用作通用编程语言。脚本语言是一种用于操作、定制和自动化现有系统功能的编程语言。在这样的系统中，通过用户界面已经可以使用有用的功能，而脚本语言是一种将这些功能暴露给程序控制的机制。通过这种方式，现有系统提供了一套对象和设施的主机环境，从而补全了脚本语言的能力。脚本语言旨在供专业和非专业程序员使用。

ECMAScript最初被设计为Web脚本语言，为浏览器中的网页提供生动的机制，并在基于Web的客户端-服务器架构中执行服务器计算。如今，ECMAScript用于为各种主机环境提供核心脚本功能。因此，本文件中规定的核心语言与任何特定主机环境无关。

ECMAScript的使用已经超越了简单的脚本编写，现在用于许多不同环境和规模的全方位编程任务。随着ECMAScript使用的扩展，它提供的功能和设施也随之增加。ECMAScript现在是一种功能齐全的通用编程语言。

### 4.1 Web脚本
Web浏览器为客户端计算提供了一个ECMAScript主机环境，包括表示窗口、菜单、弹出窗口、对话框、文本区域、锚、框架、历史记录、cookie以及输入/输出的对象。此外，主机环境还提供了一种将脚本代码附加到事件（如焦点变化、页面和图像加载、卸载、错误和中止、选择、表单提交以及鼠标操作）的方法。脚本代码出现在HTML中，显示的页面是用户界面元素以及固定和计算文本和图像的组合。脚本代码对用户交互作出反应，无需主程序。

Web服务器为服务器端计算提供了一个不同的主机环境，包括表示请求、客户端和文件的对象；以及锁定和共享数据的机制。通过结合使用浏览器端和服务器端脚本，可以在客户端和服务器之间分配计算，同时为基于Web的应用程序提供定制的用户界面。

每个支持ECMAScript的Web浏览器和服务器都提供了自己的主机环境，完成ECMAScript执行环境。

### 4.2 主机和实现
为了帮助将ECMAScript集成到主机环境中，本规范将某些设施（如抽象操作）的定义，全部或部分地延迟到本规范之外的来源。编辑上，本规范区分以下几种延迟类型。

实现是进一步定义在附录D中列举的设施或标记为实现定义或实现近似的那些设施的外部来源。在非正式用法中，实现指具体的人工制品，例如特定的Web浏览器。

实现定义的设施是指其定义完全延迟到外部来源，而没有进一步的限定。本规范对特定行为不作任何建议，符合规范的实现可以在本规范提出的约束内选择任何行为。

实现近似的设施是指其定义完全延迟到外部来源，同时推荐一种理想的行为。虽然符合规范的实现可以在本规范提出的约束内选择任何行为，但鼓励其努力接近理想行为。一些数学操作，如Math.exp，是实现近似的。

主机是进一步定义在附录D中列出的设施的外部来源，但不进一步定义其他实现定义或实现近似的设施。在非正式用法中，主机指通过附录D以相同方式接口的所有实现的集合，如所有Web浏览器的集合。主机通常是一个外部规范，例如WHATWG HTML（https://html.spec.whatwg.org/）。换句话说，主机定义的设施通常在外部规范中进一步定义。

主机钩子是一个抽象操作，其定义完全或部分由外部来源提供。所有主机钩子必须列在附录D中。主机钩子必须至少符合以下要求：
- 它必须返回正常完成或抛出完成。
主机定义的设施是指其定义完全延迟到外部来源并列在附录D中的设施。不是主机的实现也可以为主机定义的设施提供定义。

主机环境是对所有主机定义设施的定义的特定选择。主机环境通常包括允许获取输入和提供输出的对象或函数，作为全局对象的主机定义属性。

本规范遵循总是使用最具体术语的编辑惯例。例如，如果一个设施是主机定义的，就不应称其为实现定义的。

主机和实现都可以通过本文定义的语言类型、规范类型、抽象操作、语法生成、内置对象和内置符号与本规范接口。

### 4.3 ECMAScript概述
以下是对ECMAScript的非正式概述——并未描述该语言的所有部分。此概述不是标准的一部分。

ECMAScript是面向对象的：基本语言和主机设施由对象提供，ECMAScript程序是相互通信的对象集群。在ECMAScript中，对象是包含零个或多个属性的集合，每个属性都有决定如何使用该属性的特性——例如，当属性的Writable特性设置为false时，任何试图通过执行的ECMAScript代码为该属性分配不同值的操作都会失败。属性是容纳其他对象、原始值或函数的容器。原始值是以下内置类型之一的成员：Undefined、Null、Boolean、Number、BigInt、String和Symbol；对象是内置类型Object的成员；函数是可调用对象。通过属性与对象关联的函数称为方法。

ECMAScript定义了一组内置对象，以完善ECMAScript实体的定义。这些内置对象包括全局对象；对语言的运行时语义至关重要的对象，包括Object、Function、Boolean、Symbol和各种Error对象；表示和操作数值的对象，包括Math、Number和Date；文本处理对象String和RegExp；值的索引集合的对象，包括Array和九种不同类型的Typed Arrays，这些Typed Arrays的元素都有特定的数值数据表示；键控集合，包括Map和Set对象；支持结构化数据的对象，包括JSON对象、ArrayBuffer、SharedArrayBuffer和DataView；支持控制抽象的对象，包括生成器函数和Promise对象；以及反射对象，包括Proxy和Reflect。

ECMAScript还定义了一组内置操作符。ECMAScript操作符包括各种一元操作、乘法操作符、加法操作符、位移操作符、关系操作符、等式操作符、二进制位操作符、二进制逻辑操作符、赋值操作符和逗号操作符。

大型ECMAScript程序通过模块得到支持，这些模块允许程序分成多个语句和声明序列。每个模块明确标识其需要由其他模块提供的声明，以及其声明中哪些可供其他模块使用。

ECMAScript语法故意类似于Java语法。ECMAScript语法是宽松的，以使其成为易于使用的脚本语言。例如，不要求变量声明其类型，也不将类型与属性关联，定义的函数也不要求其声明出现在调用之前。

### 4.3.1 对象
尽管ECMAScript包括类定义的语法，ECMAScript对象并不是像C++、Smalltalk或Java那样的根本基于类的。相反，可以通过多种方式创建对象，包括通过字面量表示法或通过构造函数，这些构造函数创建对象并执行代码，通过为其属性赋初值来初始化对象的一部分或全部。每个构造函数都是一个具有名为"prototype"的属性的函数，用于实现基于原型的继承和共享属性。对象通过在new表达式中使用构造函数创建；例如，new Date(2009, 11)创建一个新的Date对象。不使用new调用构造函数的结果取决于构造函数。例如，Date()产生当前日期和时间的字符串表示而不是对象。

每个由构造函数创建的对象都有一个隐式引用（称为对象的原型）指向其构造函数的"prototype"属性的值。此外，原型可能有一个非null的隐式引用指向其原型，依此类推；这称为原型链。当对对象中的属性进行引用时，该引用指向原型链中第一个包含该名称属性的对象中的属性。换句话说，首先检查直接提到的对象是否包含该属性；如果该对象包含所命名的属性，则该引用指向的就是该属性；如果该对象不包含所命名的属性，则检查该对象的原型；依此类推。

#### 图1：对象/原型关系
一个图像展示了许多方框和箭头。

在基于类的面向对象语言中，通常状态由实例承载，方法由类承载，继承仅仅是结构和行为的继承。而在ECMAScript中，状态和方法都由对象承载，而结构、行为和状态都可以继承。

所有不直接包含其原型所包含的特定属性的对象共享该属性及其值。图1对此进行了说明：

CF是一个构造函数（也是一个对象）。通过new表达式创建了五个对象：cf1、cf2、cf3、cf4和cf5。每个对象都包含名为"q1"和"q2"的属性。虚线表示隐式原型关系；例如，cf3的原型是CFp。构造函数CF本身有两个属性，分别名为"P1"和"P2"，这些属性对CFp、cf1、cf2、cf3、cf4或cf5不可见。CFp中的属性"CFP1"由cf1、cf2、cf3、cf4和cf5共享（但不包括CF），同样共享的还有CFp隐式原型链中找到的未命名为"q1"、"q2"或"CFP1"的任何属性。注意，CF和CFp之间没有隐式原型链接。

与大多数基于类的面向对象语言不同，可以通过为对象赋值来动态添加属性。也就是说，构造函数不需要命名或为所有或任何构造对象的属性赋值。在上图中，可以通过在CFp中为属性赋一个新值，为cf1、cf2、cf3、cf4和cf5添加一个新的共享属性。

尽管ECMAScript对象本质上不是基于类的，但通常方便使用基于构造函数、原型对象和方法的常见模式来定义类似类的抽象。ECMAScript内置对象本身就遵循这种类似类的模式。从ECMAScript 2015开始，ECMAScript语言包含语法类定义，使程序员能够简洁地定义符合内置对象使用的类似类的抽象模式的对象。

### 4.3.2 ECMAScript的严格变体
ECMAScript语言认识到某些语言用户可能希望限制他们对某些语言功能的使用。他们可能出于安全考虑，避免他们认为容易出错的功能，获得增强的错误检查，或出于其他选择的原因。为了支持这种可能性，ECMAScript定义了语言的严格变体。语言的严格变体排除了一些常规ECMAScript语言的特定语法和语义特性，并修改了一些特性的详细语义。严格变体还指定了必须通过抛出错误异常来报告的附加错误情况，这些情况在非严格形式的语言中未指定为错误。

ECMAScript的严格变体通常称为语言的严格模式。严格模式的选择和使用严格模式语法和语义的ECMAScript是在单个ECMAScript源文本单元的层面上显式进行的，如11.2.2节所述。因为严格模式是在语法源文本单元的层面上选择的，严格模式只施加在这样的源文本单元内的局部效应。严格模式不会限制或修改必须在多个源文本单元中一致操作的任何ECMAScript语义。当执行一个由严格模式和非严格模式的ECMAScript源文本单元组成的完整程序时，严格模式仅适用于在严格模式源文本单元内定义的代码。

为了符合本规范，ECMAScript实现必须实现完整的无限制的ECMAScript语言和本规范定义的ECMAScript语言的严格变体。此外，实现必须支持将无限制和严格模式源文本单元组合成一个复合程序。

### 4.4 术语和定义
为了本文件的目的，适用以下术语和定义。

#### 4.4.1 实现近似
实现近似的设施由外部来源全部或部分定义，但在本规范中推荐一种理想的行为。

#### 4.4.2 实现定义
实现定义的设施由本规范外部的来源全部或部分定义。

#### 4.4.3 主机定义
与实现定义相同。

**注意**：编辑上，见4.2节。

#### 4.4.4 类型
如第6节定义的数据值集合。

#### 4.4.5 原始值
是以下类型之一的成员：Undefined、Null、Boolean、Number、BigInt、Symbol或String。

**注意**：原始值是语言实现最低层次上直接表示的数据。

#### 4.4.6 对象
类型Object的成员。

**注意**：对象是属性的集合，并且有一个单一的原型对象。原型可以为null。

#### 4.4.7 构造函数
创建并初始化对象的函数对象。

**注意**：构造函数的"prototype"属性值是一个原型对象，用于实现继承和共享属性。

#### 4.4.8 原型
为其他对象提供共享属性的对象。

**注意**：当构造函数创建对象时，该对象隐式引用构造函数的"prototype"属性用于解析属性引用。程序表达式constructor.prototype可以引用构造函数的"prototype"属性，并且通过继承，添加到对象原型的属性由共享该原型的所有对象共享。或者，可以使用Object.create内置函数创建具有显式指定原型的新对象。

#### 4.4.9 普通对象
具有所有必须支持的基本内部方法的默认行为的对象。

#### 4.4.10 特殊对象
不具有一个或多个基本内部方法的默认行为的对象。

**注意**：任何非普通对象都是特殊对象。

#### 4.4.11 标准对象
其语义由本规范定义的对象。

#### 4.4.12 内置对象
由ECMAScript实现指定和提供的对象。

**注意**：本规范定义了标准内置对象。ECMAScript实现可以指定和提供其他类型的内置对象。

#### 4.4.13 未定义值
当变量未赋值时使用的原始值。

#### 4.4.14 未定义类型
其唯一值为未定义值的类型。

#### 4.4.15 空值
表示故意缺少任何对象值的原始值。

#### 4.4.16 空类型
其唯一值为空值的类型。

#### 4.4.17 布尔值
布尔类型的成员。

**注意**：只有两个布尔值，true和false。

#### 4.4.18 布尔类型
由原始值true和false组成的类型。

#### 4.4.19 布尔对象
类型Object的成员，是标准内置Boolean构造函数的实例。

**注意**：布尔对象通过在new表达式中使用Boolean构造函数创建，提供布尔值作为参数。结果对象有一个内部槽，其值为布尔值。可以将布尔对象强制转换为布尔值。

#### 4.4.20 字符串值
有限的有序序列的原始值，由零个或多个16位无符号整数值组成。

**注意**：字符串值是字符串类型的成员。序列中的每个整数值通常表示UTF-16文本的单个16位单元。然而，ECMAScript不对这些值施加任何限制或要求，除了它们必须是16位无符号整数。

#### 4.4.21 字符串类型
所有可能的字符串值的集合。

#### 4.4.22 字符串对象
类型Object的成员，是标准内置String构造函数的实例。

**注意**：字符串对象通过在new表达式中使用String构造函数创建，提供字符串值作为参数。结果对象有一个内部槽，其值为字符串值。可以通过调用String构造函数作为函数来将字符串对象强制转换为字符串值（22.1.1.1）。

#### 4.4.23 数值
与双精度64位二进制格式IEEE 754-2019值相对应的原始值。

**注意**：数值是数字类型的成员，是数字的直接表示。

#### 4.4.24 数字类型
所有可能的数值的集合，包括特殊的“非数字”（NaN）值、正无穷大和负无穷大。

#### 4.4.25 数字对象
类型Object的成员，是标准内置Number构造函数的实例。

**注意**：数字对象通过在new表达式中使用Number构造函数创建，提供数值作为参数。结果对象有一个内部槽，其值为数值。可以通过调用Number构造函数作为函数来将数字对象强制转换为数值（21.1.1.1）。

#### 4.4.26 无穷大
数值，即正无穷大数值。

#### 4.4.27 NaN
数值，即NaN（Not-a-Number）值，是IEEE 754-2019的“非数字”值。

#### 4.4.28 BigInt值
原始值，表示任意精度的整数值。

#### 4.4.29 BigInt类型
所有可能的BigInt值的集合。

#### 4.4.30 BigInt对象
类型Object的成员，是标准内置BigInt构造函数的实例。

#### 4.4.31 Symbol值
原始值，表示唯一的、非字符串的对象属性键。

#### 4.4.32 Symbol类型
所有可能的Symbol值的集合。

#### 4.4.33 Symbol对象
类型Object的成员，是标准内置Symbol构造函数的实例。

#### 4.4.34 函数
类型Object的成员，可以作为子程序调用。

**注意**：除了其属性外，函数还包含可执行代码和状态，这些代码和状态决定了它在调用时的行为。函数的代码可能不是用ECMAScript编写的。

#### 4.4.35 内置函数
内置对象，且是一个函数。

**注意**：内置函数的例子包括parseInt和Math.exp。主机或实现可以提供其他不在本规范描述的内置函数。

#### 4.4.36 内置构造函数
内置函数，且是一个构造函数。

**注意**：内置构造函数的例子包括Object和Function。主机或实现可以提供其他不在本规范描述的内置构造函数。

#### 4.4.37 属性
对象的一部分，关联一个键（字符串值或Symbol值）和一个值。

**注意**：根据属性的形式，值可以直接表示为数据值（原始值、对象或函数对象），或间接由一对访问器函数表示。

#### 4.4.38 方法
作为属性值的函数。

**注意**：当函数作为对象的方法调用时，对象被传递给函数作为其this值。

#### 4.4.39 内置方法
作为内置函数的方法。

**注意**：本规范定义了标准内置方法。主机或实现可以提供其他不在本规范描述的内置方法。

#### 4.4.40 属性特性
定义属性某些特征的内部值。

#### 4.4.41 自有属性
直接包含在对象中的属性。

#### 4.4.42 继承属性
对象的原型的属性（包括自有或继承属性），但不是该对象的自有属性。

### 4.5 本规范的组织
本规范的其余部分组织如下：

第5节定义了贯穿整个规范使用的符号约定。

第6至10节定义了ECMAScript程序运行的执行环境。

第11至17节定义了实际的ECMAScript编程语言，包括其语法编码和所有语言特性的执行语义。

第18至28节定义了ECMAScript标准库。它们包括所有标准对象的定义，这些对象在ECMAScript程序执行时可供使用。

第29节描述了在SharedArrayBuffer支持的内存上访问的内存一致性模型以及Atomics对象的方法。
