# 7 抽象操作

这些操作不是 ECMAScript 语言的一部分；它们在此定义仅用于帮助指定 ECMAScript 语言的语义。其他更专业的抽象操作在整个规范中有定义。

## 7.1 类型转换

ECMAScript 语言根据需要隐式地执行自动类型转换。为了澄清某些构造的语义，定义了一组转换抽象操作。这些转换抽象操作是多态的；它们可以接受任何 ECMAScript 语言类型的值。但这些操作不使用其他规范类型。

BigInt 类型在 ECMAScript 语言中没有隐式转换；程序员必须显式调用 BigInt 来从其他类型转换值。

### 7.1.1 ToPrimitive ( input [ , preferredType ] )

抽象操作 ToPrimitive 接受参数 input（一个 ECMAScript 语言值）和可选参数 preferredType（STRING 或 NUMBER），并返回一个包含 ECMAScript 语言值的正常完成或一个抛出完成。它将其输入参数转换为非对象类型。如果对象能够转换为多种原始类型，它可以使用可选的提示 preferredType 来偏好该类型。调用时执行以下步骤：

1. 如果 input 是一个对象，则
   1. 令 exoticToPrim 为 ? GetMethod(input, @@toPrimitive)。
   2. 如果 exoticToPrim 不为 undefined，则
      1. 如果未提供 preferredType，则
         1. 令 hint 为 "default"。
      2. 否则如果 preferredType 为 STRING，则
         1. 令 hint 为 "string"。
      3. 否则，
         1. 断言：preferredType 为 NUMBER。
         2. 令 hint 为 "number"。
      4. 令 result 为 ? Call(exoticToPrim, input, « hint »)。
      5. 如果 result 不是一个对象，则返回 result。
      6. 抛出一个 TypeError 异常。
   3. 如果未提供 preferredType，令 preferredType 为 NUMBER。
   4. 返回 ? OrdinaryToPrimitive(input, preferredType)。
2. 返回 input。

**注意**
当 ToPrimitive 在没有提示的情况下调用时，它通常表现得好像提示是 NUMBER。然而，对象可以通过定义 @@toPrimitive 方法来重写此行为。在本规范中定义的对象中，只有 Date（参见 21.4.4.45）和 Symbol 对象（参见 20.4.3.5）重写了默认的 ToPrimitive 行为。Dates 在提示缺失时将其视为 STRING。

### 7.1.1.1 OrdinaryToPrimitive ( O, hint )

抽象操作 OrdinaryToPrimitive 接受参数 O（一个对象）和 hint（STRING 或 NUMBER），并返回一个包含 ECMAScript 语言值的正常完成或一个抛出完成。调用时执行以下步骤：

1. 如果 hint 是 STRING，则
   1. 令 methodNames 为 « "toString", "valueOf" »。
2. 否则，
   1. 令 methodNames 为 « "valueOf", "toString" »。
3. 对于 methodNames 的每个元素 name，执行
   1. 令 method 为 ? Get(O, name)。
   2. 如果 IsCallable(method) 为 true，则
      1. 令 result 为 ? Call(method, O)。
      2. 如果 result 不是一个对象，则返回 result。
4. 抛出一个 TypeError 异常。

### 7.1.2 ToBoolean ( argument )

抽象操作 ToBoolean 接受参数 argument（一个 ECMAScript 语言值）并返回一个布尔值。它将 argument 转换为布尔类型的值。调用时执行以下步骤：

1. 如果 argument 是布尔值，返回 argument。
2. 如果 argument 是 undefined、null、+0𝔽、-0𝔽、NaN、0ℤ 或空字符串之一，返回 false。
3. **注意**：此步骤在第 B.3.6.1 节中被替换。
4. 返回 true。

### 7.1.3 ToNumeric ( value )

抽象操作 ToNumeric 接受参数 value（一个 ECMAScript 语言值）并返回一个包含 Number 或 BigInt 的正常完成，或一个抛出完成。它返回转换为 Number 或 BigInt 的 value。调用时执行以下步骤：

1. 令 primValue 为 ? ToPrimitive(value, NUMBER)。
2. 如果 primValue 是 BigInt，返回 primValue。
3. 返回 ? ToNumber(primValue)。

### 7.1.4 ToNumber ( argument )

抽象操作 ToNumber 接受参数 argument（一个 ECMAScript 语言值）并返回一个包含 Number 的正常完成或一个抛出完成。它将 argument 转换为 Number 类型的值。调用时执行以下步骤：

1. 如果 argument 是 Number，返回 argument。
2. 如果 argument 是 Symbol 或 BigInt，抛出一个 TypeError 异常。
3. 如果 argument 是 undefined，返回 NaN。
4. 如果 argument 是 null 或 false，返回 +0𝔽。
5. 如果 argument 是 true，返回 1𝔽。
6. 如果 argument 是字符串，返回 StringToNumber(argument)。
7. 断言：argument 是一个对象。
8. 令 primValue 为 ? ToPrimitive(argument, NUMBER)。
9. 断言：primValue 不是一个对象。
10. 返回 ? ToNumber(primValue)。

### 7.1.4.1 ToNumber 应用于字符串类型

抽象操作 StringToNumber 指定如何将字符串值转换为 Number 值，使用以下语法。

#### 语法

```plaintext
StringNumericLiteral :::
StrWhiteSpaceopt
StrWhiteSpaceopt StrNumericLiteral StrWhiteSpaceopt
StrWhiteSpace :::
StrWhiteSpaceChar StrWhiteSpaceopt
StrWhiteSpaceChar :::
WhiteSpace
LineTerminator
StrNumericLiteral :::
StrDecimalLiteral
NonDecimalIntegerLiteral[~Sep]
StrDecimalLiteral :::
StrUnsignedDecimalLiteral
+ StrUnsignedDecimalLiteral
- StrUnsignedDecimalLiteral
StrUnsignedDecimalLiteral :::
Infinity
DecimalDigits[~Sep] . DecimalDigits[~Sep]opt ExponentPart[~Sep]opt
. DecimalDigits[~Sep] ExponentPart[~Sep]opt
DecimalDigits[~Sep] ExponentPart[~Sep]opt
```

所有未明确定义的语法符号在数值字面量的词法语法（12.9.3）中有定义。

**注意**
StringNumericLiteral 的语法与 NumericLiteral 的语法之间有一些差异：

1. StringNumericLiteral 可能包含前导和/或尾随的空白字符和/或行终止符。
2. 作为十进制的 StringNumericLiteral 可以有任意数量的前导 0 数字。
3. 作为十进制的 StringNumericLiteral 可以包含 + 或 - 来表示其符号。
4. 空字符串或仅包含空白字符的 StringNumericLiteral 转换为 +0𝔽。
5. Infinity 和 -Infinity 被识别为 StringNumericLiteral，但不是 NumericLiteral。
6. StringNumericLiteral 不能包含 BigIntLiteralSuffix。
7. StringNumericLiteral 不能包含 NumericLiteralSeparator。

#### 7.1.4.1.1 StringToNumber ( str )

抽象操作 StringToNumber 接受参数 str（一个字符串）并返回一个 Number。调用时执行以下步骤：

1. 令 literal 为 ParseText(str, StringNumericLiteral)。
2. 如果 literal 是一个错误列表，返回 NaN。
3. 返回 literal 的 StringNumericValue。

7.1.4.1.2 运行时语义：StringNumericValue

语法定向操作 StringNumericValue 不接受参数并返回一个 Number。

**注意**
StringNumericLiteral 转换为 Number 值的过程总体上类似于确定 NumericLiteral 的 NumericValue（参见 12.9.3），但某些细节有所不同。

它分段定义在以下生成式上：

StringNumericLiteral ::: StrWhiteSpaceopt
1. 返回 +0𝔽。
StringNumericLiteral ::: StrWhiteSpaceopt StrNumericLiteral StrWhiteSpaceopt
1. 返回 StrNumericLiteral 的 StringNumericValue。
StrNumericLiteral ::: NonDecimalIntegerLiteral
1. 返回 𝔽(MV of NonDecimalIntegerLiteral)。
StrDecimalLiteral ::: - StrUnsignedDecimalLiteral
1. 令 a 为 StrUnsignedDecimalLiteral 的 StringNumericValue。
2. 如果 a 是 +0𝔽，返回 -0𝔽。
3. 返回 -a。
StrUnsignedDecimalLiteral ::: Infinity
1. 返回 +∞𝔽。
StrUnsignedDecimalLiteral ::: DecimalDigits . DecimalDigitsopt ExponentPartopt
1. 令 a 为第一个 DecimalDigits 的 MV。
2. 如果第二个 DecimalDigits 存在，则
   1. 令 b 为第二个 DecimalDigits 的 MV。
   2. 令 n 为第二个 DecimalDigits 中代码点的数量。
3. 否则，
   1. 令 b 为 0。
   2. 令 n 为 0。
4. 如果 ExponentPart 存在，则令 e 为 ExponentPart 的 MV。否则，令 e 为 0。
5. 返回 RoundMVResult((a + (b × 10**-n)) × 10**e)。
StrUnsignedDecimalLiteral ::: . DecimalDigits ExponentPartopt
1. 令 b 为 DecimalDigits 的 MV。
2. 如果 ExponentPart 存在，则令 e 为 ExponentPart 的 MV。否则，令 e 为 0。
3. 令 n 为 DecimalDigits 中代码点的数量。
4. 返回 RoundMVResult(b × 10**(e - n))。
StrUnsignedDecimalLiteral ::: DecimalDigits ExponentPartopt
1. 令 a 为 DecimalDigits 的 MV。
2. 如果 ExponentPart 存在，则令 e 为 ExponentPart 的 MV。否则，令 e 为 0。
3. 返回 RoundMVResult(a × 10**e)。

### 7.1.4.1.3 RoundMVResult ( n )

抽象操作 RoundMVResult 接受参数 n（一个数学值）并返回一个 Number。它以实现定义的方式将 n 转换为一个 Number。对于此抽象操作，如果一个数字在其左侧和右侧都有非零数字，则该数字是有效数字。对于此抽象操作，“数学值表示”的数学值是“十进制表示”的数学值的逆。调用时执行以下步骤：

1. 如果 n 的十进制表示有 20 个或更少的有效数字，返回 𝔽(n)。
2. 令 option1 为用 0 替换 n 的十进制表示中第 20 位后的每个有效数字所得的数学值。
3. 令 option2 为用 0 替换 n 的十进制表示中第 20 位后的每个有效数字后，在第 20 位上加 1（必要时进位）所得的数学值。
4. 令 chosen 为实现定义的选择 option1 或 option2。
5. 返回 𝔽(chosen)。
### 7.2 测试和比较操作

#### 7.2.1 RequireObjectCoercible ( argument )
抽象操作 RequireObjectCoercible 接受参数 argument（一个 ECMAScript 语言值）并返回包含 ECMAScript 语言值的正常完成或抛出完成。如果 argument 是无法使用 ToObject 转换为对象的值，则抛出错误。它由表14定义：

**表14：RequireObjectCoercible 结果**
| 参数类型 | 结果 |
| --- | --- |
| Undefined | 抛出一个 TypeError 异常。 |
| Null | 抛出一个 TypeError 异常。 |
| Boolean | 返回 argument。 |
| Number | 返回 argument。 |
| String | 返回 argument。 |
| Symbol | 返回 argument。 |
| BigInt | 返回 argument。 |
| Object | 返回 argument。 |

#### 7.2.2 IsArray ( argument )
抽象操作 IsArray 接受参数 argument（一个 ECMAScript 语言值）并返回包含布尔值的正常完成或抛出完成。调用时执行以下步骤：

1. 如果 argument 不是对象，返回 false。
2. 如果 argument 是一个数组特殊对象，返回 true。
3. 如果 argument 是一个代理特殊对象，则
   1. 执行 ? ValidateNonRevokedProxy(argument)。
   2. 令 proxyTarget 为 argument.[[ProxyTarget]]。
   3. 返回 ? IsArray(proxyTarget)。
4. 返回 false。

#### 7.2.3 IsCallable ( argument )
抽象操作 IsCallable 接受参数 argument（一个 ECMAScript 语言值）并返回布尔值。它确定 argument 是否为具有 [[Call]] 内部方法的可调用函数。调用时执行以下步骤：

1. 如果 argument 不是对象，返回 false。
2. 如果 argument 具有 [[Call]] 内部方法，返回 true。
3. 返回 false。

#### 7.2.4 IsConstructor ( argument )
抽象操作 IsConstructor 接受参数 argument（一个 ECMAScript 语言值）并返回布尔值。它确定 argument 是否为具有 [[Construct]] 内部方法的函数对象。调用时执行以下步骤：

1. 如果 argument 不是对象，返回 false。
2. 如果 argument 具有 [[Construct]] 内部方法，返回 true。
3. 返回 false。

#### 7.2.5 IsExtensible ( O )
抽象操作 IsExtensible 接受参数 O（一个对象）并返回包含布尔值的正常完成或抛出完成。它用于确定是否可以向 O 添加额外的属性。调用时执行以下步骤：

1. 返回 ? O.[[IsExtensible]]()。

#### 7.2.6 IsRegExp ( argument )
抽象操作 IsRegExp 接受参数 argument（一个 ECMAScript 语言值）并返回包含布尔值的正常完成或抛出完成。调用时执行以下步骤：

1. 如果 argument 不是对象，返回 false。
2. 令 matcher 为 ? Get(argument, @@match)。
3. 如果 matcher 不是 undefined，返回 ToBoolean(matcher)。
4. 如果 argument 具有 [[RegExpMatcher]] 内部槽，返回 true。
5. 返回 false。

#### 7.2.7 静态语义：IsStringWellFormedUnicode ( string )
抽象操作 IsStringWellFormedUnicode 接受参数 string（一个字符串）并返回布尔值。它将字符串解释为 UTF-16 编码的代码点序列，如 6.1.4 中描述，并确定其是否为格式良好的 UTF-16 序列。调用时执行以下步骤：

1. 令 len 为 string 的长度。
2. 令 k 为 0。
3. 重复，直到 k < len,
   1. 令 cp 为 CodePointAt(string, k)。
   2. 如果 cp.[[IsUnpairedSurrogate]] 为 true，返回 false。
   3. 将 k 设为 k + cp.[[CodeUnitCount]]。
4. 返回 true。

#### 7.2.8 SameValue ( x, y )
抽象操作 SameValue 接受参数 x（一个 ECMAScript 语言值）和 y（一个 ECMAScript 语言值）并返回布尔值。它确定两个参数是否为相同的值。调用时执行以下步骤：

1. 如果 Type(x) 不是 Type(y)，返回 false。
2. 如果 x 是 Number，则
   1. 返回 Number::sameValue(x, y)。
3. 返回 SameValueNonNumber(x, y)。

**注意**：
此算法不同于 IsStrictlyEqual 算法，因为它将所有 NaN 值视为等价，并区分 +0𝔽 和 -0𝔽。

#### 7.2.9 SameValueZero ( x, y )
抽象操作 SameValueZero 接受参数 x（一个 ECMAScript 语言值）和 y（一个 ECMAScript 语言值）并返回布尔值。它确定两个参数是否为相同的值（忽略 +0𝔽 和 -0𝔽 的差异）。调用时执行以下步骤：

1. 如果 Type(x) 不是 Type(y)，返回 false。
2. 如果 x 是 Number，则
   1. 返回 Number::sameValueZero(x, y)。
3. 返回 SameValueNonNumber(x, y)。

**注意**：
SameValueZero 与 SameValue 的区别在于它将 +0𝔽 和 -0𝔽 视为等价。

#### 7.2.10 SameValueNonNumber ( x, y )
抽象操作 SameValueNonNumber 接受参数 x（一个 ECMAScript 语言值，但不是 Number）和 y（一个 ECMAScript 语言值，但不是 Number）并返回布尔值。调用时执行以下步骤：

1. 断言：Type(x) 是 Type(y)。
2. 如果 x 是 null 或 undefined，返回 true。
3. 如果 x 是 BigInt，则
   1. 返回 BigInt::equal(x, y)。
4. 如果 x 是 String，则
   1. 如果 x 和 y 具有相同的长度且在相同位置具有相同的代码单位，返回 true；否则，返回 false。
5. 如果 x 是 Boolean，则
   1. 如果 x 和 y 均为 true 或均为 false，返回 true；否则，返回 false。
6. **注意**：所有其他 ECMAScript 语言值通过身份比较。
7. 如果 x 是 y，返回 true；否则，返回 false。

**注意1**：为了说明目的，即使不必要，在此算法中某些情况也被单独处理。

**注意2**：“x 是 y”的具体含义在 5.2.7 中详细说明。

#### 7.2.11 IsLessThan ( x, y, LeftFirst )
抽象操作 IsLessThan 接受参数 x（一个 ECMAScript 语言值），y（一个 ECMAScript 语言值）和 LeftFirst（一个布尔值）并返回包含布尔值或 undefined 的正常完成或抛出完成。它提供 x < y 的比较语义，返回 true、false 或 undefined（表示至少一个操作数为 NaN）。LeftFirst 标志用于控制对 x 和 y 进行操作的顺序，尤其是可能具有可见副作用的操作顺序。这是必要的，因为 ECMAScript 规定从左到右评估表达式。如果 LeftFirst 为 true，则 x 参数对应于表达式中的左侧；如果 LeftFirst 为 false，则操作顺序相反。调用时执行以下步骤：

1. 如果 LeftFirst 为 true，则
   1. 令 px 为 ? ToPrimitive(x, NUMBER)。
   2. 令 py 为 ? ToPrimitive(y, NUMBER)。
2. 否则，
   1. **注意**：为了保留从左到右的评估顺序，需要反转评估顺序。
   2. 令 py 为 ? ToPrimitive(y, NUMBER)。
   3. 令 px 为 ? ToPrimitive(x, NUMBER)。
3. 如果 px 是 String 且 py 是 String，则
   1. 令 lx 为 px 的长度。
   2. 令 ly 为 py 的长度。
   3. 对于每个整数 i（0 ≤ i < min(lx, ly)），按升序进行，
      1. 令 cx 为 px 中索引 i 处代码单位的数值。
      2. 令 cy 为 py 中索引 i 处代码单位的数值。
      3. 如果 cx < cy，返回 true。
      4. 如果 cx > cy，返回 false。
   4. 如果 lx < ly，返回 true；否则返回 false。
4. 否则，
   1. 如果 px 是 BigInt 且 py 是 String，则
      1. 令 ny 为 StringToBigInt(py)。
      2. 如果 ny 是 undefined，返回 undefined。
      3. 返回 BigInt::lessThan(px, ny)。
   2. 如果 px 是 String 且 py 是 BigInt，则
      1. 令 nx 为 StringToBigInt(px)。
      2. 如果 nx 是 undefined，返回 undefined。
      3. 返回 BigInt::lessThan(nx, py)。
   3. **注意**：因为 px 和 py 是原始值，所以评估顺序不重要。
好的，继续翻译：

   4. 令 nx 为 ? ToNumeric(px)。
   5. 令 ny 为 ? ToNumeric(py)。
   6. 如果 Type(nx) 是 Type(ny)，则
      1. 如果 nx 是 Number，则
         1. 返回 Number::lessThan(nx, ny)。
      2. 否则，
         1. 断言：nx 是 BigInt。
         2. 返回 BigInt::lessThan(nx, ny)。
   7. 断言：nx 是 BigInt 且 ny 是 Number，或 nx 是 Number 且 ny 是 BigInt。
   8. 如果 nx 或 ny 是 NaN，返回 undefined。
   9. 如果 nx 是 -∞𝔽 或 ny 是 +∞𝔽，返回 true。
   10. 如果 nx 是 +∞𝔽 或 ny 是 -∞𝔽，返回 false。
   11. 如果 ℝ(nx) < ℝ(ny)，返回 true；否则返回 false。

**注意1**：步骤 3 与处理加法运算符 +（13.15.3）的算法中的步骤 1.c 不同，使用逻辑与运算代替逻辑或运算。

**注意2**：字符串的比较使用对 UTF-16 代码单位值序列的简单字典排序。没有尝试使用 Unicode 规范中定义的更复杂、语义导向的字符或字符串相等和排序顺序。因此，根据 Unicode 标准规范但不在相同规范化形式中的字符串可能测试为不相等。还需注意，按代码单位的字典排序与包含代理对的字符串按代码点排序不同。

#### 7.2.12 IsLooselyEqual ( x, y )
抽象操作 IsLooselyEqual 接受参数 x（一个 ECMAScript 语言值）和 y（一个 ECMAScript 语言值）并返回包含布尔值的正常完成或抛出完成。它提供 == 运算符的语义。调用时执行以下步骤：

1. 如果 Type(x) 是 Type(y)，则
   1. 返回 IsStrictlyEqual(x, y)。
2. 如果 x 是 null 且 y 是 undefined，返回 true。
3. 如果 x 是 undefined 且 y 是 null，返回 true。
4. **注意**：此步骤在 B.3.6.2 节中替换。
5. 如果 x 是 Number 且 y 是 String，返回 ! IsLooselyEqual(x, ! ToNumber(y))。
6. 如果 x 是 String 且 y 是 Number，返回 ! IsLooselyEqual(! ToNumber(x), y)。
7. 如果 x 是 BigInt 且 y 是 String，则
   1. 令 n 为 StringToBigInt(y)。
   2. 如果 n 是 undefined，返回 false。
   3. 返回 ! IsLooselyEqual(x, n)。
8. 如果 x 是 String 且 y 是 BigInt，返回 ! IsLooselyEqual(y, x)。
9. 如果 x 是 Boolean，返回 ! IsLooselyEqual(! ToNumber(x), y)。
10. 如果 y 是 Boolean，返回 ! IsLooselyEqual(x, ! ToNumber(y))。
11. 如果 x 是 String、Number、BigInt 或 Symbol 且 y 是对象，返回 ! IsLooselyEqual(x, ? ToPrimitive(y))。
12. 如果 x 是对象且 y 是 String、Number、BigInt 或 Symbol，返回 ! IsLooselyEqual(? ToPrimitive(x), y)。
13. 如果 x 是 BigInt 且 y 是 Number，或 x 是 Number 且 y 是 BigInt，则
    1. 如果 x 不是有限值或 y 不是有限值，返回 false。
    2. 如果 ℝ(x) = ℝ(y)，返回 true；否则返回 false。
14. 返回 false。

#### 7.2.13 IsStrictlyEqual ( x, y )
抽象操作 IsStrictlyEqual 接受参数 x（一个 ECMAScript 语言值）和 y（一个 ECMAScript 语言值）并返回布尔值。它提供 === 运算符的语义。调用时执行以下步骤：

1. 如果 Type(x) 不是 Type(y)，返回 false。
2. 如果 x 是 Number，则
   1. 返回 Number::equal(x, y)。
3. 返回 SameValueNonNumber(x, y)。

**注意**：
此算法在处理带符号的零和 NaN 时与 SameValue 算法不同。

#### 7.3 对象上的操作

#### 7.3.1 MakeBasicObject ( internalSlotsList )
抽象操作 MakeBasicObject 接受参数 internalSlotsList（一个内部槽名称列表）并返回一个对象。它是所有通过算法创建的 ECMAScript 对象的来源，包括普通对象和异类对象。它将创建所有对象的常用步骤分离出来，并集中在对象创建上。调用时执行以下步骤：

1. 令 obj 为一个新创建的对象，其内部槽为 internalSlotsList 中的每个名称分配一个内部槽。
2. 将 obj 的基本内部方法设置为 10.1 规范中的普通对象定义的默认值。
3. 断言：如果调用者不会覆盖 obj 的 [[GetPrototypeOf]] 和 [[SetPrototypeOf]] 基本内部方法，则 internalSlotsList 包含 [[Prototype]]。
4. 断言：如果调用者不会覆盖 obj 的 [[SetPrototypeOf]]、[[IsExtensible]] 和 [[PreventExtensions]] 所有的基本内部方法，则 internalSlotsList 包含 [[Extensible]]。
5. 如果 internalSlotsList 包含 [[Extensible]]，设置 obj.[[Extensible]] 为 true。
6. 返回 obj。

**注意**：在此规范中，异类对象通过诸如 ArrayCreate 和 BoundFunctionCreate 等抽象操作创建，首先调用 MakeBasicObject 获取基础对象，然后覆盖该对象的一些或全部内部方法。为了封装异类对象的创建，绝不会在这些操作之外修改对象的基本内部方法。

#### 7.3.2 Get ( O, P )
抽象操作 Get 接受参数 O（一个对象）和 P（一个属性键）并返回包含 ECMAScript 语言值的正常完成或抛出完成。它用于检索对象的特定属性的值。调用时执行以下步骤：

1. 返回 ? O.[[Get]](P, O)。

#### 7.3.3 GetV ( V, P )
抽象操作 GetV 接受参数 V（一个 ECMAScript 语言值）和 P（一个属性键）并返回包含 ECMAScript 语言值的正常完成或抛出完成。它用于检索 ECMAScript 语言值的特定属性的值。如果该值不是对象，则使用适用于该值类型的包装对象进行属性查找。调用时执行以下步骤：

1. 令 O 为 ? ToObject(V)。
2. 返回 ? O.[[Get]](P, V)。

#### 7.3.4 Set ( O, P, V, Throw )
抽象操作 Set 接受参数 O（一个对象）、P（一个属性键）、V（一个 ECMAScript 语言值）和 Throw（一个布尔值）并返回包含 UNUSED 的正常完成或抛出完成。它用于设置对象的特定属性的值。V 是该属性的新值。调用时执行以下步骤：

1. 令 success 为 ? O.[[Set]](P, V, O)。
2. 如果 success 为 false 且 Throw 为 true，抛出一个 TypeError 异常。
3. 返回 UNUSED。

#### 7.3.5 CreateDataProperty ( O, P, V )
抽象操作 CreateDataProperty 接受参数 O（一个对象）、P（一个属性键）和 V（一个 ECMAScript 语言值）并返回包含布尔值的正常完成或抛出完成。它用于创建对象的一个新自有属性。调用时执行以下步骤：

1. 令 newDesc 为 PropertyDescriptor { [[Value]]: V, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true }。
2. 返回 ? O.[[DefineOwnProperty]](P, newDesc)。

**注意**：此抽象操作创建的属性的属性设置为与 ECMAScript 语言赋值操作符创建的属性相同的默认值。通常，该属性不会已经存在。如果它确实存在且不可配置，或如果 O 不可扩展，则 [[DefineOwnProperty]] 将返回 false。

#### 7.3.6 CreateDataPropertyOrThrow ( O, P, V )
抽象操作 CreateDataPropertyOrThrow 接受参数 O（一个对象）、P（一个属性键）和 V（一个 ECMAScript 语言值）并返回包含 UNUSED 的正常完成或抛出完成。它用于创建对象的一个新自有属性。如果请求的属性更新无法执行，则抛出 TypeError 异常。调用时执行以下步骤：

1. 令 success 为 ? CreateDataProperty(O, P, V)。
2. 如果 success 为 false，抛出一个 TypeError 异常。
3. 返回 UNUSED。

**注意**：此抽象操作创建的属性的属性设置为与 ECMAScript 语言赋值操作符创建的属性相同的默认值。通常，该属性不会已经存在。如果它确实存在且不可配置，或如果 O 不可扩展，则 [[DefineOwnProperty]] 将返回 false，导致此操作抛出 TypeError 异常。

#### 7.3.7 CreateNonEnumerableDataPropertyOrThrow ( O, P, V )
抽象操作 CreateNonEnumerableDataPropertyOrThrow 接受参数 O（一个对象）、P（一个属性键）和 V（一个 ECMAScript 语言值）并返回 UNUSED。它用于创建普通对象的一个新不可枚举自有属性。调用时执行以下步骤：

1. 断言：O 是一个普通的可扩展对象，没有不可配置的属性。
2. 令 newDesc 为 PropertyDescriptor { [[Value]]: V, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true }。
3. 执行 ! DefinePropertyOrThrow(O, P, newDesc)。
4. 返回 UNUSED。

**注意**：此抽象操作创建的属性的属性设置为与 ECMAScript 语言赋值操作符创建的属性相同的默认值，除了它不可枚举。通常，该属性不会已经存在。如果它确实存在，DefinePropertyOrThrow 保证正常完成。

#### 7.3.8 DefinePropertyOrThrow ( O, P, desc )
抽象操作 DefinePropertyOrThrow 接受参数 O（一个对象）、P（一个属性键）和 desc（一个属性描述符）并返回包含 UNUSED 的正常完成或抛出完成。它用于以一种在请求的属性更新无法执行时会抛出 TypeError 异常的方式调用对象的 [[DefineOwnProperty]] 内部方法。调用时执行以下步骤：

1. 令 success 为 ? O.[[DefineOwnProperty]](P, desc)。
2. 如果 success 为 false，抛出一个 TypeError 异常。
3. 返回 UNUSED。

#### 7.3.9 DeletePropertyOrThrow ( O, P )
抽象操作 DeletePropertyOrThrow 接受参数 O（一个对象）和 P（一个属性键）并返回包含 UNUSED 的正常完成或抛出完成。它用于删除对象的一个特定自有属性。如果该属性不可配置，则抛出异常。调用时执行以下步骤：

1. 令 success 为 ? O.[[Delete]](P)。
2. 如果 success 为 false，抛出一个 TypeError 异常。
3. 返回 UNUSED。

#### 7.3.10 GetMethod ( V, P )
抽象操作 GetMethod 接受参数 V（一个 ECMAScript 语言值）和 P（一个属性键）并返回包含函数对象或 undefined 的正常完成或抛出完成。它用于获取 ECMAScript 语言值的特定属性的值，当该属性的值预期为函数时。调用时执行以下步骤：

1. 令 func 为 ? GetV(V, P)。
2. 如果 func 为 undefined 或 null，返回 undefined。
3. 如果 IsCallable(func) 为 false，抛出一个 TypeError 异常。
4. 返回 func。

#### 7.3.11 HasProperty ( O, P )
抽象操作 HasProperty 接受参数 O（一个对象）和 P（一个属性键）并返回包含布尔值的正常完成或抛出完成。它用于确定对象是否具有指定属性键的属性。该属性可以是自有的或继承的。调用时执行以下步骤：

1. 返回 ? O.[[HasProperty]](P)。

#### 7.3.12 HasOwnProperty ( O, P )
抽象操作 HasOwnProperty 接受参数 O（一个对象）和 P（一个属性键）并返回包含布尔值的正常完成或抛出完成。它用于确定对象是否具有指定属性键的自有属性。调用时执行以下步骤：

1. 令 desc 为 ? O.[[GetOwnProperty]](P)。
2. 如果 desc 为 undefined，返回 false。
3. 返回 true。

#### 7.3.13 Call ( F, V [ , argumentsList ] )
抽象操作 Call 接受参数 F（一个 ECMAScript 语言值）和 V（一个 ECMAScript 语言值）及可选参数 argumentsList（一个 ECMAScript 语言值列表）并返回包含 ECMAScript 语言值的正常完成或抛出完成。它用于调用函数对象的 [[Call]] 内部方法。F 是函数对象，V 是 [[Call]] 的 this 值，argumentsList 是传递给内部方法的参数列表。如果 argumentsList 不存在，则使用一个新的空列表作为其值。调用时执行以下步骤：

1. 如果 argumentsList 不存在，则将 argumentsList 设置为一个新的空列表。
2. 如果 IsCallable(F) 为 false，则抛出一个 TypeError 异常。
3. 返回 ? F.[[Call]](V, argumentsList)。

#### 7.3.14 Construct ( F [ , argumentsList [ , newTarget ] ] )
抽象操作 Construct 接受参数 F（一个构造函数）及可选参数 argumentsList（一个 ECMAScript 语言值列表）和 newTarget（一个构造函数）并返回包含对象的正常完成或抛出完成。它用于调用函数对象的 [[Construct]] 内部方法。argumentsList 和 newTarget 是传递给内部方法的对应参数的值。如果 argumentsList 不存在，则使用一个新的空列表作为其值。如果 newTarget 不存在，则使用 F 作为其值。调用时执行以下步骤：

1. 如果 newTarget 不存在，则将 newTarget 设置为 F。
2. 如果 argumentsList 不存在，则将 argumentsList 设置为一个新的空列表。
3. 返回 ? F.[[Construct]](argumentsList, newTarget)。

**注意**：如果 newTarget 不存在，此操作等同于：new F(...argumentsList)

#### 7.3.15 SetIntegrityLevel ( O, level )
抽象操作 SetIntegrityLevel 接受参数 O（一个对象）和 level（SEALED 或 FROZEN）并返回包含布尔值的正常完成或抛出完成。它用于固定对象的自有属性集。调用时执行以下步骤：

1. 令 status 为 ? O.[[PreventExtensions]]()。
2. 如果 status 为 false，返回 false。
3. 令 keys 为 ? O.[[OwnPropertyKeys]]()。
4. 如果 level 是 SEALED，则
   a. 对于 keys 的每个元素 k，执行
      i. 执行 ? DefinePropertyOrThrow(O, k, PropertyDescriptor { [[Configurable]]: false })。
5. 否则，
   a. 断言：level 是 FROZEN。
   b. 对于 keys 的每个元素 k，执行
      i. 令 currentDesc 为 ? O.[[GetOwnProperty]](k)。
      ii. 如果 currentDesc 不为 undefined，则
         1. 如果 IsAccessorDescriptor(currentDesc) 为 true，则
            a. 令 desc 为 PropertyDescriptor { [[Configurable]]: false }。
         2. 否则，
            a. 令 desc 为 PropertyDescriptor { [[Configurable]]: false, [[Writable]]: false }。
         3. 执行 ? DefinePropertyOrThrow(O, k, desc)。
6. 返回 true。

#### 7.3.16 TestIntegrityLevel ( O, level )
抽象操作 TestIntegrityLevel 接受参数 O（一个对象）和 level（SEALED 或 FROZEN）并返回包含布尔值的正常完成或抛出完成。它用于确定对象的自有属性集是否已固定。调用时执行以下步骤：

1. 令 extensible 为 ? IsExtensible(O)。
2. 如果 extensible 为 true，返回 false。
3. **注意**：如果对象是可扩展的，则不会检查其任何属性。
4. 令 keys 为 ? O.[[OwnPropertyKeys]]()。
5. 对于 keys 的每个元素 k，执行
   a. 令 currentDesc 为 ? O.[[GetOwnProperty]](k)。
   b. 如果 currentDesc 不为 undefined，则
      i. 如果 currentDesc.[[Configurable]] 为 true，返回 false。
      ii. 如果 level 是 FROZEN 且 IsDataDescriptor(currentDesc) 为 true，则
         1. 如果 currentDesc.[[Writable]] 为 true，返回 false。
6. 返回 true。

#### 7.3.17 CreateArrayFromList ( elements )
抽象操作 CreateArrayFromList 接受参数 elements（一个 ECMAScript 语言值列表）并返回一个数组。它用于创建一个数组，其元素由 elements 提供。调用时执行以下步骤：

1. 令 array 为 ! ArrayCreate(0)。
2. 令 n 为 0。
3. 对于 elements 的每个元素 e，执行
   a. 执行 ! CreateDataPropertyOrThrow(array, ! ToString(𝔽(n)), e)。
   b. 设置 n 为 n + 1。
4. 返回 array。

#### 7.3.18 LengthOfArrayLike ( obj )
抽象操作 LengthOfArrayLike 接受参数 obj（一个对象）并返回包含非负整数的正常完成或抛出完成。它返回类数组对象的 "length" 属性的值。调用时执行以下步骤：

1. 返回 ℝ(? ToLength(? Get(obj, "length")))。

类数组对象是任何此操作返回正常完成的对象。

**注意 1**：通常，类数组对象也会有一些具有整数索引名称的属性。然而，这不是该定义的要求。
**注意 2**：数组和字符串对象是类数组对象的示例。

#### 7.3.19 CreateListFromArrayLike ( obj [ , elementTypes ] )
抽象操作 CreateListFromArrayLike 接受参数 obj（一个 ECMAScript 语言值）和可选参数 elementTypes（一个 ECMAScript 语言类型名称列表）并返回包含 ECMAScript 语言值列表的正常完成或抛出完成。它用于创建一个列表值，其元素由 obj 的索引属性提供。elementTypes 包含允许作为创建的列表元素值的 ECMAScript 语言类型的名称。调用时执行以下步骤：

1. 如果 elementTypes 不存在，则将 elementTypes 设置为 « Undefined, Null, Boolean, String, Symbol, Number, BigInt, Object »。
2. 如果 obj 不是对象，则抛出一个 TypeError 异常。
3. 令 len 为 ? LengthOfArrayLike(obj)。
4. 令 list 为一个新的空列表。
5. 令 index 为 0。
6. 重复，直到 index < len，
   a. 令 indexName 为 ! ToString(𝔽(index))。
   b. 令 next 为 ? Get(obj, indexName)。
   c. 如果 elementTypes 不包含 Type(next)，则抛出一个 TypeError 异常。
   d. 将 next 附加到 list。
   e. 设置 index 为 index + 1。
7. 返回 list。

#### 7.3.20 Invoke ( V, P [ , argumentsList ] )
抽象操作 Invoke 接受参数 V（一个 ECMAScript 语言值）和 P（一个属性键）及可选参数 argumentsList（一个 ECMAScript 语言值列表）并返回包含 ECMAScript 语言值的正常完成或抛出完成。它用于调用 ECMAScript 语言值的方法属性。V 作为属性的查找点和调用的 this 值。argumentsList 是传递给方法的参数列表。如果 argumentsList 不存在，则使用一个新的空列表作为其值。调用时执行以下步骤：

1. 如果 argumentsList 不存在，则将 argumentsList 设置为一个新的空列表。
2. 令 func 为 ? GetV(V, P)。
3. 返回 ? Call(func, V, argumentsList)。

#### 7.3.21 OrdinaryHasInstance ( C, O )
抽象操作 OrdinaryHasInstance 接受参数 C（一个 ECMAScript 语言值）和 O（一个 ECMAScript 语言值）并返回包含布尔值的正常完成或抛出完成。它实现了确定 O 是否继承自 C 提供的实例对象继承路径的默认算法。调用时执行以下步骤：

1. 如果 IsCallable(C) 为 false，返回 false。
2. 如果 C 具有 [[BoundTargetFunction]] 内部槽，则
   a. 令 BC 为 C.[[BoundTargetFunction]]。
   b. 返回 ? InstanceofOperator(O, BC)。
3. 如果 O 不是对象，返回 false。
4. 令 P 为 ? Get(C, "prototype")。
5. 如果 P 不是对象，抛出一个 TypeError 异常。
6. 重复，
   a. 设置 O 为 ? O.[[GetPrototypeOf]]()。
   b. 如果 O 为 null，返回 false。
   c. 如果 SameValue(P, O) 为 true，返回 true。

#### 7.3.22 SpeciesConstructor ( O, defaultConstructor )
抽象操作 SpeciesConstructor 接受参数 O（一个对象）和 defaultConstructor（一个构造函数）并返回包含构造函数的正常完成或抛出完成。它用于检索应使用的构造函数以创建从 O 派生的新对象。defaultConstructor 是在从 O 开始找不到构造函数 @@species 属性时使用的构造函数。调用时执行以下步骤：

1. 令 C 为 ? Get(O, "constructor")。
2. 如果 C 是 undefined，返回 defaultConstructor。
3. 如果 C 不是对象，抛出一个 TypeError 异常。
4. 令 S 为 ? Get(C, @@species)。
5. 如果 S 是 undefined 或 null，返回 defaultConstructor。
6. 如果 IsConstructor(S) 为 true，返回 S。
7. 抛出一个 TypeError 异常。

#### 7.3.23 EnumerableOwnProperties ( O, kind )
抽象操作 EnumerableOwnProperties 接受参数 O（一个对象）和 kind（KEY、VALUE 或 KEY+VALUE）并返回包含 ECMAScript 语言值列表的正常完成或抛出完成。调用时执行以下步骤：

1. 令 ownKeys 为 ? O.[[OwnPropertyKeys]]()。
2. 令 results 为一个新的空列表。
3. 对于 ownKeys 的每个元素 key，执行
   a. 如果 key 是一个字符串，则
      i. 令 desc 为 ? O.[[GetOwnProperty]](key)。
      ii. 如果 desc 不为 undefined 且 desc.[[Enumerable]] 为 true，则
         1. 如果 kind 是 KEY，则
            a. 将 key 附加到 results。
         2. 否则，
            a. 令 value 为 ? Get(O, key)。
            b. 如果 kind 是 VALUE，则
               i. 将 value 附加到 results。
            c. 否则，
               i. 断言：kind 是 KEY+VALUE。
               ii. 令 entry 为 CreateArrayFromList(« key, value »)。
               iii. 将 entry 附加到 results。
4. 返回 results。

#### 7.3.24 GetFunctionRealm ( obj )
抽象操作 GetFunctionRealm 接受参数 obj（一个函数对象）并返回包含 Realm Record 的正常完成或抛出完成。调用时执行以下步骤：

1. 如果 obj 具有 [[Realm]] 内部槽，则
   a. 返回 obj.[[Realm]]。
2. 如果 obj 是一个绑定函数异类对象，则
   a. 令 boundTargetFunction 为 obj.[[BoundTargetFunction]]。
   b. 返回 ? GetFunctionRealm(boundTargetFunction)。
3. 如果 obj 是一个代理异类对象，则
   a. 执行 ? ValidateNonRevokedProxy(obj)。
   b. 令 proxyTarget 为 obj.[[ProxyTarget]]。
   c. 返回 ? GetFunctionRealm(proxyTarget)。
4. 返回当前 Realm Record。

**注意**：步骤 4 只会在 obj 是一个不具有 [[Realm]] 内部槽的非标准函数异类对象时才会到达。

#### 7.3.25 CopyDataProperties ( target, source, excludedItems )
抽象操作 CopyDataProperties 接受参数 target（一个对象）、source（一个 ECMAScript 语言值）和 excludedItems（一个属性键列表）并返回包含 UNUSED 的正常完成或抛出完成。调用时执行以下步骤：

1. 如果 source 是 undefined 或 null，返回 UNUSED。
2. 令 from 为 ! ToObject(source)。
3. 令 keys 为 ? from.[[OwnPropertyKeys]]()。
4. 对于 keys 的每个元素 nextKey，执行
   a. 令 excluded 为 false。
   b. 对于 excludedItems 的每个元素 e，执行
      i. 如果 SameValue(e, nextKey) 为 true，则
         1. 将 excluded 设置为 true。
   c. 如果 excluded 为 false，则
      i. 令 desc 为 ? from.[[GetOwnProperty]](nextKey)。
      ii. 如果 desc 不为 undefined 且 desc.[[Enumerable]] 为 true，则
         1. 令 propValue 为 ? Get(from, nextKey)。
         2. 执行 ! CreateDataPropertyOrThrow(target, nextKey, propValue)。
5. 返回 UNUSED。

**注意**：传入的 target 总是一个新创建的对象，在抛出错误时无法直接访问。

#### 7.3.26 PrivateElementFind ( O, P )
抽象操作 PrivateElementFind 接受参数 O（一个对象）和 P（一个私有名称）并返回一个 PrivateElement 或 EMPTY。调用时执行以下步骤：

1. 如果 O.[[PrivateElements]] 包含一个 PrivateElement pe 使得 pe.[[Key]] 是 P，则
   a. 返回 pe。
2. 返回 EMPTY。

#### 7.3.27 PrivateFieldAdd ( O, P, value )
抽象操作 PrivateFieldAdd 接受参数 O（一个对象）、P（一个私有名称）和 value（一个 ECMAScript 语言值）并返回包含 UNUSED 的正常完成或抛出完成。调用时执行以下步骤：

1. 如果主机是一个 Web 浏览器，则
   a. 执行 ? HostEnsureCanAddPrivateElement(O)。
2. 令 entry 为 PrivateElementFind(O, P)。
3. 如果 entry 不是 EMPTY，抛出一个 TypeError 异常。
4. 将 PrivateElement { [[Key]]: P, [[Kind]]: FIELD, [[Value]]: value } 附加到 O.[[PrivateElements]]。
5. 返回 UNUSED。

#### 7.3.28 PrivateMethodOrAccessorAdd ( O, method )
抽象操作 PrivateMethodOrAccessorAdd 接受参数 O（一个对象）和 method（一个 PrivateElement）并返回包含 UNUSED 的正常完成或抛出完成。调用时执行以下步骤：

1. 断言：method.[[Kind]] 是 METHOD 或 ACCESSOR。
2. 如果主机是一个 Web 浏览器，则
   a. 执行 ? HostEnsureCanAddPrivateElement(O)。
3. 令 entry 为 PrivateElementFind(O, method.[[Key]])。
4. 如果 entry 不是 EMPTY，抛出一个 TypeError 异常。
5. 将 method 附加到 O.[[PrivateElements]]。
6. 返回 UNUSED。

**注意**：私有方法和访问器的值在实例间共享。此操作不会创建方法或访问器的新副本。

#### 7.3.29 HostEnsureCanAddPrivateElement ( O )
主机定义的抽象操作 HostEnsureCanAddPrivateElement 接受参数 O（一个对象）并返回包含 UNUSED 的正常完成或抛出完成。它允许主机环境阻止将私有元素添加到特定的主机定义的异类对象。

HostEnsureCanAddPrivateElement 的实现必须符合以下要求：

- 如果 O 不是主机定义的异类对象，此抽象操作必须返回 NormalCompletion(UNUSED) 并且不执行其他步骤。
- 此抽象操作的两次调用，如果参数相同，必须返回相同种类的完成记录。
- HostEnsureCanAddPrivateElement 的默认实现是返回 NormalCompletion(UNUSED)。

此抽象操作仅由作为 Web 浏览器的 ECMAScript 主机调用。

#### 7.3.30 PrivateGet ( O, P )
抽象操作 PrivateGet 接受参数 O（一个对象）和 P（一个私有名称）并返回包含 ECMAScript 语言值的正常完成或抛出完成。调用时执行以下步骤：

1. 令 entry 为 PrivateElementFind(O, P)。
2. 如果 entry 是 EMPTY，抛出一个 TypeError 异常。
3. 如果 entry.[[Kind]] 是 FIELD 或 METHOD，则
   a. 返回 entry.[[Value]]。
4. 断言：entry.[[Kind]] 是 ACCESSOR。
5. 如果 entry.[[Get]] 是 undefined，抛出一个 TypeError 异常。
6. 令 getter 为 entry.[[Get]]。
7. 返回 ? Call(getter, O)。

#### 7.3.31 PrivateSet ( O, P, value )
抽象操作 PrivateSet 接受参数 O（一个对象）、P（一个私有名称）和 value（一个 ECMAScript 语言值）并返回包含 UNUSED 的正常完成或抛出完成。调用时执行以下步骤：

1. 令 entry 为 PrivateElementFind(O, P)。
2. 如果 entry 是 EMPTY，抛出一个 TypeError 异常。
3. 如果 entry.[[Kind]] 是 FIELD，则
   a. 设置 entry.[[Value]] 为 value。
4. 否则如果 entry.[[Kind]] 是 METHOD，则
   a. 抛出一个 TypeError 异常。
5. 否则，
   a. 断言：entry.[[Kind]] 是 ACCESSOR。
   b. 如果 entry.[[Set]] 是 undefined，抛出一个 TypeError 异常。
   c. 令 setter 为 entry.[[Set]]。
   d. 执行 ? Call(setter, O, « value »)。
6. 返回 UNUSED。

#### 7.3.32 DefineField ( receiver, fieldRecord )
抽象操作 DefineField 接受参数 receiver（一个对象）和 fieldRecord（一个 ClassFieldDefinition 记录）并返回包含 UNUSED 的正常完成或抛出完成。调用时执行以下步骤：

1. 令 fieldName 为 fieldRecord.[[Name]]。
2. 令 initializer 为 fieldRecord.[[Initializer]]。
3. 如果 initializer 不是 EMPTY，则
   a. 令 initValue 为 ? Call(initializer, receiver)。
4. 否则，
   a. 令 initValue 为 undefined。
5. 如果 fieldName 是一个私有名称，则
   a. 执行 ? PrivateFieldAdd(receiver, fieldName, initValue)。
6. 否则，
   a. 断言：fieldName 是一个属性键。
   b. 执行 ? CreateDataPropertyOrThrow(receiver, fieldName, initValue)。
7. 返回 UNUSED。

#### 7.3.33 InitializeInstanceElements ( O, constructor )
抽象操作 InitializeInstanceElements 接受参数 O（一个对象）和 constructor（一个 ECMAScript 函数对象）并返回包含 UNUSED 的正常完成或抛出完成。调用时执行以下步骤：

1. 令 methods 为 constructor.[[PrivateMethods]] 的值。
2. 对于 methods 的每个 PrivateElement 方法，执行
   a. 执行 ? PrivateMethodOrAccessorAdd(O, method)。
3. 令 fields 为 constructor.[[Fields]] 的值。
4. 对于 fields 的每个元素 fieldRecord，执行
   a. 执行 ? DefineField(O, fieldRecord)。
5. 返回 UNUSED。

#### 7.3.34 AddValueToKeyedGroup ( groups, key, value )
抽象操作 AddValueToKeyedGroup 接受参数 groups（一个包含字段 [[Key]]（一个 ECMAScript 语言值）和 [[Elements]]（一个 ECMAScript 语言值列表）的记录列表）、key（一个 ECMAScript 语言值）和 value（一个 ECMAScript 语言值）并返回 UNUSED。调用时执行以下步骤：

1. 对于 groups 的每个记录 { [[Key]], [[Elements]] } g，执行
   a. 如果 SameValue(g.[[Key]], key) 为 true，则
      i. 断言：恰好一个元素符合此条件。
      ii. 将 value 附加到 g.[[Elements]]。
      iii. 返回 UNUSED。
2. 令 group 为记录 { [[Key]]: key, [[Elements]]: « value » }。
3. 将 group 附加到 groups。
4. 返回 UNUSED。

#### 7.3.35 GroupBy ( items, callbackfn, keyCoercion )
抽象操作 GroupBy 接受参数 items（一个 ECMAScript 语言值）、callbackfn（一个 ECMAScript 语言值）和 keyCoercion（PROPERTY 或 COLLECTION）并返回包含字段 [[Key]]（一个 ECMAScript 语言值）和 [[Elements]]（一个 ECMAScript 语言值列表）的记录列表的正常完成或抛出完成。调用时执行以下步骤：

1. 执行 ? RequireObjectCoercible(items)。
2. 如果 IsCallable(callbackfn) 为 false，则抛出一个 TypeError 异常。
3. 令 groups 为一个新的空列表。
4. 令 iteratorRecord 为 ? GetIterator(items, SYNC)。
5. 令 k 为 0。
6. 重复，
   a. 如果 k ≥ 2**53 - 1，则
      i. 令 error 为 ThrowCompletion(一个新创建的 TypeError 对象)。
      ii. 返回 ? IteratorClose(iteratorRecord, error)。
   b. 令 next 为 ? IteratorStepValue(iteratorRecord)。
   c. 如果 next 是 DONE，则
      i. 返回 groups。
   d. 令 value 为 next。
   e. 令 key 为 Completion(Call(callbackfn, undefined, « value, 𝔽(k) »))。
   f. IfAbruptCloseIterator(key, iteratorRecord)。
   g. 如果 keyCoercion 是 PROPERTY，则
      i. 设置 key 为 Completion(ToPropertyKey(key))。
      ii. IfAbruptCloseIterator(key, iteratorRecord)。
   h. 否则，
      i. 断言：keyCoercion 是 COLLECTION。
      ii. 设置 key 为 CanonicalizeKeyedCollectionKey(key)。
   i. 执行 AddValueToKeyedGroup(groups, key, value)。
   j. 设置 k 为 k + 1。
  
### 7.4 对迭代器对象的操作

参见通用迭代接口 (27.1)。

#### 7.4.1 迭代器记录
迭代器记录是一种用于封装迭代器或异步迭代器及其 next 方法的记录值。

迭代器记录具有表 15 中列出的字段。

表 15: 迭代器记录字段
| 字段名称     | 值                        | 含义                                          |
| ------------ | ------------------------- | --------------------------------------------- |
| [[Iterator]] | 一个对象                  | 一个符合迭代器或异步迭代器接口的对象。        |
| [[NextMethod]] | 一个 ECMAScript 语言值   | [[Iterator]] 对象的 next 方法。               |
| [[Done]]     | 一个布尔值                | 迭代器是否已完成或已关闭。                    |

#### 7.4.2 GetIteratorFromMethod ( obj, method )
抽象操作 GetIteratorFromMethod 接受参数 obj（一个 ECMAScript 语言值）和 method（一个函数对象），并返回包含迭代器记录的正常完成或抛出完成。调用时执行以下步骤：

1. 令 iterator 为 ? Call(method, obj)。
2. 如果 iterator 不是一个对象，抛出一个 TypeError 异常。
3. 令 nextMethod 为 ? Get(iterator, "next")。
4. 令 iteratorRecord 为迭代器记录 { [[Iterator]]: iterator, [[NextMethod]]: nextMethod, [[Done]]: false }。
5. 返回 iteratorRecord。

#### 7.4.3 GetIterator ( obj, kind )
抽象操作 GetIterator 接受参数 obj（一个 ECMAScript 语言值）和 kind（SYNC 或 ASYNC），并返回包含迭代器记录的正常完成或抛出完成。调用时执行以下步骤：

1. 如果 kind 是 ASYNC，则
   a. 令 method 为 ? GetMethod(obj, @@asyncIterator)。
   b. 如果 method 是 undefined，则
      i. 令 syncMethod 为 ? GetMethod(obj, @@iterator)。
      ii. 如果 syncMethod 是 undefined，抛出一个 TypeError 异常。
      iii. 令 syncIteratorRecord 为 ? GetIteratorFromMethod(obj, syncMethod)。
      iv. 返回 CreateAsyncFromSyncIterator(syncIteratorRecord)。
2. 否则，
   a. 令 method 为 ? GetMethod(obj, @@iterator)。
3. 如果 method 是 undefined，抛出一个 TypeError 异常。
4. 返回 ? GetIteratorFromMethod(obj, method)。

#### 7.4.4 IteratorNext ( iteratorRecord [ , value ] )
抽象操作 IteratorNext 接受参数 iteratorRecord（一个迭代器记录）和可选参数 value（一个 ECMAScript 语言值），并返回包含对象的正常完成或抛出完成。调用时执行以下步骤：

1. 如果 value 不存在，则
   a. 令 result 为 Completion(Call(iteratorRecord.[[NextMethod]], iteratorRecord.[[Iterator]]))。
2. 否则，
   a. 令 result 为 Completion(Call(iteratorRecord.[[NextMethod]], iteratorRecord.[[Iterator]], « value »))。
3. 如果 result 是一个抛出完成，则
   a. 设置 iteratorRecord.[[Done]] 为 true。
   b. 返回 ? result。
4. 设置 result 为 ! result。
5. 如果 result 不是一个对象，则
   a. 设置 iteratorRecord.[[Done]] 为 true。
   b. 抛出一个 TypeError 异常。
6. 返回 result。

#### 7.4.5 IteratorComplete ( iterResult )
抽象操作 IteratorComplete 接受参数 iterResult（一个对象）并返回包含布尔值的正常完成或抛出完成。调用时执行以下步骤：

1. 返回 ToBoolean(? Get(iterResult, "done"))。

#### 7.4.6 IteratorValue ( iterResult )
抽象操作 IteratorValue 接受参数 iterResult（一个对象）并返回包含 ECMAScript 语言值的正常完成或抛出完成。调用时执行以下步骤：

1. 返回 ? Get(iterResult, "value")。

#### 7.4.7 IteratorStep ( iteratorRecord )
抽象操作 IteratorStep 接受参数 iteratorRecord（一个迭代器记录）并返回包含对象或 DONE 的正常完成或抛出完成。它通过调用 iteratorRecord.[[NextMethod]] 请求 iteratorRecord.[[Iterator]] 的下一个值，并返回 DONE 表示迭代器已到达末尾，或返回 IteratorResult 对象表示有下一个值。调用时执行以下步骤：

1. 令 result 为 ? IteratorNext(iteratorRecord)。
2. 令 done 为 Completion(IteratorComplete(result))。
3. 如果 done 是一个抛出完成，则
   a. 设置 iteratorRecord.[[Done]] 为 true。
   b. 返回 ? done。
4. 设置 done 为 ! done。
5. 如果 done 为 true，则
   a. 设置 iteratorRecord.[[Done]] 为 true。
   b. 返回 DONE。
6. 返回 result。

#### 7.4.8 IteratorStepValue ( iteratorRecord )
抽象操作 IteratorStepValue 接受参数 iteratorRecord（一个迭代器记录）并返回包含 ECMAScript 语言值或 DONE 的正常完成或抛出完成。它通过调用 iteratorRecord.[[NextMethod]] 请求 iteratorRecord.[[Iterator]] 的下一个值，并返回 DONE 表示迭代器已到达末尾，或从 IteratorResult 对象中返回下一个值。调用时执行以下步骤：

1. 令 result 为 ? IteratorStep(iteratorRecord)。
2. 如果 result 是 DONE，则
   a. 返回 DONE。
3. 令 value 为 Completion(IteratorValue(result))。
4. 如果 value 是一个抛出完成，则
   a. 设置 iteratorRecord.[[Done]] 为 true。
5. 返回 ? value。

#### 7.4.9 IteratorClose ( iteratorRecord, completion )
抽象操作 IteratorClose 接受参数 iteratorRecord（一个迭代器记录）和 completion（一个完成记录），并返回一个完成记录。它用于通知迭代器应执行任何在达到完成状态时通常执行的操作。调用时执行以下步骤：

1. 断言：iteratorRecord.[[Iterator]] 是一个对象。
2. 令 iterator 为 iteratorRecord.[[Iterator]]。
3. 令 innerResult 为 Completion(GetMethod(iterator, "return"))。
4. 如果 innerResult 是一个正常完成，则
   a. 令 return 为 innerResult.[[Value]]。
   b. 如果 return 是 undefined，返回 ? completion。
   c. 设置 innerResult 为 Completion(Call(return, iterator))。
5. 如果 completion 是一个抛出完成，返回 ? completion。
6. 如果 innerResult 是一个抛出完成，返回 ? innerResult。
7. 如果 innerResult.[[Value]] 不是一个对象，抛出一个 TypeError 异常。
8. 返回 ? completion。

#### 7.4.10 IfAbruptCloseIterator ( value, iteratorRecord )
IfAbruptCloseIterator 是一个简写，表示使用迭代器记录的一系列算法步骤。形式为 IfAbruptCloseIterator(value, iteratorRecord) 的算法步骤意味着：

1. 断言：value 是一个完成记录。
2. 如果 value 是一个突然完成，则返回 ? IteratorClose(iteratorRecord, value)。
3. 否则，设置 value 为 ! value。

#### 7.4.11 AsyncIteratorClose ( iteratorRecord, completion )
抽象操作 AsyncIteratorClose 接受参数 iteratorRecord（一个迭代器记录）和 completion（一个完成记录），并返回一个完成记录。它用于通知异步迭代器应执行任何在达到完成状态时通常执行的操作。调用时执行以下步骤：

1. 断言：iteratorRecord.[[Iterator]] 是一个对象。
2. 令 iterator 为 iteratorRecord.[[Iterator]]。
3. 令 innerResult 为 Completion(GetMethod(iterator, "return"))。
4. 如果 innerResult 是一个正常完成，则
   a. 令 return 为 innerResult.[[Value]]。
   b. 如果 return 是 undefined，返回 ? completion。
   c. 设置 innerResult 为 Completion(Call(return, iterator))。
   d. 如果 innerResult 是一个正常完成，则设置 innerResult 为 Completion(Await(innerResult.[[Value]]))。
5. 如果 completion 是一个抛出完成，返回 ? completion。
6. 如果 innerResult 是一个抛出完成，返回 ? innerResult。
7. 如果 innerResult.[[Value]] 不是一个对象，抛出一个 TypeError 异常。
8. 返回 ? completion。

#### 7.4.12 CreateIterResultObject ( value, done )
抽象操作 CreateIterResultObject 接受参数 value（一个 ECMAScript 语言值）和 done（一个布尔值），并返回一个符合 IteratorResult 接口的对象。它创建一个符合 IteratorResult 接口的对象。调用时执行以下步骤：

1. 令 obj 为 OrdinaryObjectCreate(%Object.prototype%)。
2. 执行 ! CreateDataPropertyOrThrow(obj, "value", value)。
3. 执行 ! CreateDataPropertyOrThrow(obj, "done", done)。
4. 返回 obj。

### 7.4 对迭代器对象的操作 (继续)

#### 7.4.13 CreateListIteratorRecord ( list )
抽象操作 CreateListIteratorRecord 接受参数 list（一个 ECMAScript 语言值的列表），并返回一个迭代器记录。它创建一个迭代器对象记录，该记录的 next 方法返回 list 的后续元素。调用时执行以下步骤：

1. 令 closure 为一个没有参数的新抽象闭包，它捕获 list 并在调用时执行以下步骤：
   a. 对于 list 的每个元素 E，执行
      i. 执行 ? GeneratorYield(CreateIterResultObject(E, false))。
   b. 返回 NormalCompletion(undefined)。
2. 令 iterator 为 CreateIteratorFromClosure(closure, EMPTY, %IteratorPrototype%)。
3. 返回迭代器记录 { [[Iterator]]: iterator, [[NextMethod]]: %GeneratorFunction.prototype.prototype.next%, [[Done]]: false }。
   
注意：
list 迭代器对象对 ECMAScript 代码是不可直接访问的。

#### 7.4.14 IteratorToList ( iteratorRecord )
抽象操作 IteratorToList 接受参数 iteratorRecord（一个迭代器记录），并返回包含 ECMAScript 语言值列表的正常完成或抛出完成。调用时执行以下步骤：

1. 令 values 为一个新的空列表。
2. 重复，
   a. 令 next 为 ? IteratorStepValue(iteratorRecord)。
   b. 如果 next 是 DONE，则
      i. 返回 values。
   c. 将 next 添加到 values。
