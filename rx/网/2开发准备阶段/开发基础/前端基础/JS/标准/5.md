## 5 符号约定

### 5.1 语法和词法语法

#### 5.1.1 上下文无关语法
上下文无关语法由多个生成式组成。每个生成式的左侧是一个称为非终结符的抽象符号，右侧是一系列零个或多个非终结符和终结符。对于每个语法，终结符来自一个指定的字母表。

链式生成式是右侧正好有一个非终结符和零个或多个终结符的生成式。

从一个由单个非终结符（称为目标符号）组成的句子开始，给定的上下文无关语法指定了一种语言，即通过不断将序列中的任何非终结符替换为一个生成式的右侧，其中非终结符是左侧的非终结符，可以得到的可能的终结符序列（可能是无限的）集合。

#### 5.1.2 词法和正则表达式语法
ECMAScript的词法语法在第12节给出。此语法的终结符是符合11.1节中定义的SourceCharacter规则的Unicode代码点。它定义了一组生成式，从目标符号InputElementDiv、InputElementTemplateTail、InputElementRegExp、InputElementRegExpOrTemplateTail或InputElementHashbangOrRegExp开始，描述了如何将这些代码点序列翻译为输入元素序列。

除空白和注释外的输入元素构成ECMAScript语法的终结符，称为ECMAScript标记。这些标记是ECMAScript语言的保留字、标识符、字面量和标点符号。此外，行终止符虽然不被认为是标记，但也成为输入元素流的一部分，并指导自动分号插入的过程（12.10）。简单的空白和单行注释被丢弃，不会出现在语法的输入元素流中。如果多行注释（即形式为/*...*/的注释，无论它是否跨越多行）不包含行终止符，则也会被丢弃；但如果多行注释包含一个或多个行终止符，则它将被一个单独的行终止符替换，成为语法的输入元素流的一部分。

ECMAScript的正则表达式语法在22.2.1节给出。此语法的终结符也是由SourceCharacter定义的代码点。它定义了一组生成式，从目标符号Pattern开始，描述了如何将代码点序列翻译为正则表达式模式。

词法和正则表达式语法的生成式通过两个冒号“::”作为分隔符来区分。词法和正则表达式语法共享一些生成式。

#### 5.1.3 数字字符串语法
数字字符串语法出现在7.1.4.1节。其终结符是SourceCharacter，用于将字符串从目标符号StringNumericLiteral开始翻译为数值（类似于但不同于数字字面量的词法语法）。

数字字符串语法的生成式通过三个冒号“:::”作为标点符号来区分，并且从不用于解析源文本。

#### 5.1.4 语法语法
ECMAScript的语法在第13至16节中给出。此语法的终结符是由词法语法定义的ECMAScript标记（5.1.2）。它定义了一组生成式，从两个替代目标符号Script和Module开始，描述了标记序列如何形成语法正确的独立ECMAScript程序组件。

当要将代码点序列解析为ECMAScript脚本或模块时，首先通过反复应用词法语法将其转换为输入元素流；然后通过一次应用语法语法解析此输入元素流。如果输入元素流中的标记不能解析为目标非终结符（脚本或模块）的单个实例，并且没有剩余标记，则输入流在语法上是错误的。

当解析成功时，它会构建一个解析树，这是一个根树结构，其中每个节点都是解析节点。每个解析节点都是语法符号的一个实例；它表示可以从该符号导出的源文本范围。解析树的根节点，代表整个源文本，是解析的目标符号的一个实例。当解析节点是非终结符的实例时，它也是一个具有该非终结符作为左侧的生成式的实例。此外，它有零个或多个子节点，每个符号右侧的每个符号对应一个子节点：每个子节点都是对应符号的解析节点实例。

每次调用解析器时都会实例化新的解析节点，即使是对相同源文本的解析也不会重复使用解析节点。只有当解析节点表示相同的源文本范围、是相同语法符号的实例并且来自相同解析器调用时，它们才被认为是相同的解析节点。

**注意1**：多次解析相同字符串将导致不同的解析节点。例如，考虑以下代码：
```javascript
let str = "1 + 1;";
eval(str);
eval(str);
```
每次调用`eval`都会将`str`的值转换为ECMAScript源文本，并执行独立的解析，创建自己的解析节点树。这些树是不同的，尽管每次解析都操作从相同字符串值派生的源文本。

**注意2**：解析节点是规范工件，实现不需要使用类似的数据结构。

语法生成式通过一个冒号“:”作为标点符号来区分。

第13至16节中展示的语法并未完全描述接受为正确ECMAScript脚本或模块的标记序列。某些附加的标记序列也被接受，即在某些地方仅添加分号后的序列（例如在行终止符之前）。此外，如果在某些“尴尬”位置出现行终止符，则某些由语法描述的标记序列将不被接受。

在某些情况下，为了避免歧义，语法使用了泛化生成式，允许不形成有效ECMAScript脚本或模块的标记序列。例如，这种技术用于对象字面量和对象解构模式。在这种情况下，提供了更严格的补充语法，进一步限制了可接受的标记序列。通常，早期错误规则将声明，在某些上下文中，“P必须覆盖N”，其中P是解析节点（泛化生成式的实例），N是补充语法中的非终结符。这意味着：

最初由P匹配的标记序列再次使用N作为目标符号进行解析。如果N有语法参数，则设置为P最初解析时使用的相同值。
如果标记序列可以解析为N的单个实例，并且没有剩余标记，则：
我们将该N的实例（解析节点，特定P唯一）称为“P覆盖的N”。
N及其派生生成式的所有早期错误规则也适用于P覆盖的N。
否则（如果解析失败），这是一个早期语法错误。

#### 5.1.5 语法符号

##### 5.1.5.1 终结符
在ECMAScript语法中，某些终结符以等宽字体显示。这些必须按书写形式出现在源文本中。所有这样指定的终结符代码点都应理解为基本拉丁块中的适当Unicode代码点，而不是来自其他Unicode范围的任何相似代码点。终结符中的代码点不能通过\ UnicodeEscapeSequence表示。

在终结符是单个Unicode代码点（即词法、正则表达式和数字字符串语法）的语法中，生成式中出现的连续多个等宽代码点是一种简单的简写，表示相同的代码点序列，写成单独的终结符。

例如，生成式：
```plaintext
HexIntegerLiteral :: 0x HexDigits
```
是以下形式的简写：
```plaintext
HexIntegerLiteral :: 0 x HexDigits
```
相反，在语法语法中，连续的等宽代码点是一个单一的终结符。

终结符还有两种形式：

在词法和正则表达式语法中，没有常规打印表示的Unicode代码点以“<ABBREV>”形式显示，其中“ABBREV”是代码点或代码点集合的助记符。这些形式在Unicode格式控制字符、空白和行终止符中定义。
在语法语法中，某些终结符（如IdentifierName和RegularExpressionLiteral）以斜体显示，因为它们引用词法语法中同名的非终结符。

##### 5.1.5.2 非终结符和生成式
非终结符以斜体显示。非终结符的定义（也称为“生成式”）以被定义的非终结符的名称引入，后面跟一个或多个冒号（冒号的数量表示生成式所属的语法）。非终结符的一个或多个右侧替代随后在接## 5 符号约定

### 5.1 语法和词法语法

#### 5.1.1 上下文无关语法
上下文无关语法由多个生成式组成。每个生成式的左侧是一个称为非终结符的抽象符号，右侧是一系列零个或多个非终结符和终结符。对于每个语法，终结符来自一个指定的字母表。

链式生成式是右侧正好有一个非终结符和零个或多个终结符的生成式。

从一个由单个非终结符（称为目标符号）组成的句子开始，给定的上下文无关语法指定了一种语言，即通过不断将序列中的任何非终结符替换为一个生成式的右侧，其中非终结符是左侧的非终结符，可以得到的可能的终结符序列（可能是无限的）集合。

#### 5.1.2 词法和正则表达式语法
ECMAScript的词法语法在第12节给出。此语法的终结符是符合11.1节中定义的SourceCharacter规则的Unicode代码点。它定义了一组生成式，从目标符号InputElementDiv、InputElementTemplateTail、InputElementRegExp、InputElementRegExpOrTemplateTail或InputElementHashbangOrRegExp开始，描述了如何将这些代码点序列翻译为输入元素序列。

除空白和注释外的输入元素构成ECMAScript语法的终结符，称为ECMAScript标记。这些标记是ECMAScript语言的保留字、标识符、字面量和标点符号。此外，行终止符虽然不被认为是标记，但也成为输入元素流的一部分，并指导自动分号插入的过程（12.10）。简单的空白和单行注释被丢弃，不会出现在语法的输入元素流中。如果多行注释（即形式为/*...*/的注释，无论它是否跨越多行）不包含行终止符，则也会被丢弃；但如果多行注释包含一个或多个行终止符，则它将被一个单独的行终止符替换，成为语法的输入元素流的一部分。

ECMAScript的正则表达式语法在22.2.1节给出。此语法的终结符也是由SourceCharacter定义的代码点。它定义了一组生成式，从目标符号Pattern开始，描述了如何将代码点序列翻译为正则表达式模式。

词法和正则表达式语法的生成式通过两个冒号“::”作为分隔符来区分。词法和正则表达式语法共享一些生成式。

#### 5.1.3 数字字符串语法
数字字符串语法出现在7.1.4.1节。其终结符是SourceCharacter，用于将字符串从目标符号StringNumericLiteral开始翻译为数值（类似于但不同于数字字面量的词法语法）。

数字字符串语法的生成式通过三个冒号“:::”作为标点符号来区分，并且从不用于解析源文本。

#### 5.1.4 语法语法
ECMAScript的语法在第13至16节中给出。此语法的终结符是由词法语法定义的ECMAScript标记（5.1.2）。它定义了一组生成式，从两个替代目标符号Script和Module开始，描述了标记序列如何形成语法正确的独立ECMAScript程序组件。

当要将代码点序列解析为ECMAScript脚本或模块时，首先通过反复应用词法语法将其转换为输入元素流；然后通过一次应用语法语法解析此输入元素流。如果输入元素流中的标记不能解析为目标非终结符（脚本或模块）的单个实例，并且没有剩余标记，则输入流在语法上是错误的。

当解析成功时，它会构建一个解析树，这是一个根树结构，其中每个节点都是解析节点。每个解析节点都是语法符号的一个实例；它表示可以从该符号导出的源文本范围。解析树的根节点，代表整个源文本，是解析的目标符号的一个实例。当解析节点是非终结符的实例时，它也是一个具有该非终结符作为左侧的生成式的实例。此外，它有零个或多个子节点，每个符号右侧的每个符号对应一个子节点：每个子节点都是对应符号的解析节点实例。

每次调用解析器时都会实例化新的解析节点，即使是对相同源文本的解析也不会重复使用解析节点。只有当解析节点表示相同的源文本范围、是相同语法符号的实例并且来自相同解析器调用时，它们才被认为是相同的解析节点。

**注意1**：多次解析相同字符串将导致不同的解析节点。例如，考虑以下代码：
```javascript
let str = "1 + 1;";
eval(str);
eval(str);
```
每次调用`eval`都会将`str`的值转换为ECMAScript源文本，并执行独立的解析，创建自己的解析节点树。这些树是不同的，尽管每次解析都操作从相同字符串值派生的源文本。

**注意2**：解析节点是规范工件，实现不需要使用类似的数据结构。

语法生成式通过一个冒号“:”作为标点符号来区分。

第13至16节中展示的语法并未完全描述接受为正确ECMAScript脚本或模块的标记序列。某些附加的标记序列也被接受，即在某些地方仅添加分号后的序列（例如在行终止符之前）。此外，如果在某些“尴尬”位置出现行终止符，则某些由语法描述的标记序列将不被接受。

在某些情况下，为了避免歧义，语法使用了泛化生成式，允许不形成有效ECMAScript脚本或模块的标记序列。例如，这种技术用于对象字面量和对象解构模式。在这种情况下，提供了更严格的补充语法，进一步限制了可接受的标记序列。通常，早期错误规则将声明，在某些上下文中，“P必须覆盖N”，其中P是解析节点（泛化生成式的实例），N是补充语法中的非终结符。这意味着：

最初由P匹配的标记序列再次使用N作为目标符号进行解析。如果N有语法参数，则设置为P最初解析时使用的相同值。
如果标记序列可以解析为N的单个实例，并且没有剩余标记，则：
我们将该N的实例（解析节点，特定P唯一）称为“P覆盖的N”。
N及其派生生成式的所有早期错误规则也适用于P覆盖的N。
否则（如果解析失败），这是一个早期语法错误。

#### 5.1.5 语法符号

##### 5.1.5.1 终结符
在ECMAScript语法中，某些终结符以等宽字体显示。这些必须按书写形式出现在源文本中。所有这样指定的终结符代码点都应理解为基本拉丁块中的适当Unicode代码点，而不是来自其他Unicode范围的任何相似代码点。终结符中的代码点不能通过\ UnicodeEscapeSequence表示。

在终结符是单个Unicode代码点（即词法、正则表达式和数字字符串语法）的语法中，生成式中出现的连续多个等宽代码点是一种简单的简写，表示相同的代码点序列，写成单独的终结符。

例如，生成式：
```plaintext
HexIntegerLiteral :: 0x HexDigits
```
是以下形式的简写：
```plaintext
HexIntegerLiteral :: 0 x HexDigits
```
相反，在语法语法中，连续的等宽代码点是一个单一的终结符。

终结符还有两种形式：

在词法和正则表达式语法中，没有常规打印表示的Unicode代码点以“<ABBREV>”形式显示，其中“ABBREV”是代码点或代码点集合的助记符。这些形式在Unicode格式控制字符、空白和行终止符中定义。
在语法语法中，某些终结符（如IdentifierName和RegularExpressionLiteral）以斜体显示，因为它们引用词法语法中同名的非终结符。

##### 5.1.5.2 非终结符和生成式
非终结符以斜体显示。非终结符的定义（也称为“生成式”）以被定义的非终结符的名称引入，后面跟一个或多个冒号（冒号的数量表示生成式所属的语法）。非终结符的一个或多个右侧替代随后在接生成式的右侧可以使用短语“but not”来指定不允许的扩展，然后指示要排除的扩展。例如，生成式：
```plaintext
Identifier ::
    IdentifierName but not ReservedWord
```
表示非终结符`Identifier`可以替换为任何可以替换`IdentifierName`的代码点序列，但前提是相同的代码点序列不能替换为`ReservedWord`。

#### 5.1.5.10 描述性短语
最后，在列出所有替代项不切实际的情况下，少数非终结符符号通过无衬线体的描述性短语来描述：
```plaintext
SourceCharacter ::
    any Unicode code point
```

### 5.2 算法约定
规范经常使用编号列表来指定算法步骤。这些算法用于精确指定ECMAScript语言构造的必要语义。算法并不意味着采用任何特定的实现技术。在实践中，可能有更有效的算法来实现给定的功能。

算法可以通过一个有序的、逗号分隔的别名序列显式参数化，这些别名可以在算法步骤中引用所传递的参数。可选参数用方括号（[ , name ]）表示，在算法步骤中与必需参数没有区别。参数列表末尾可能出现一个剩余参数，前缀为省略号（, ...name）。剩余参数捕获所有在必需和可选参数之后提供的参数到一个列表中。如果没有这样的附加参数，该列表为空。

算法步骤可以细分为顺序子步骤。子步骤缩进，并且可以进一步分为缩进的子步骤。使用大纲编号约定来标识子步骤，第一层子步骤标记为小写字母，第二层子步骤标记为小写罗马数字。如果需要超过三层，这些规则重复，第四层使用数字标签。例如：
```plaintext
1. 顶级步骤
    a. 子步骤。
    b. 子步骤。
        i. 子子步骤。
            1. 子子子步骤
                a. 子子子子步骤
                    i. 子子子子子步骤
```
步骤或子步骤可以写为“if”谓词，条件其子步骤。在这种情况下，仅在谓词为真时才应用子步骤。如果步骤或子步骤以“else”开头，则它是与同级前一个“if”谓词步骤的否定。

一个步骤可以指定其子步骤的迭代应用。

以“Assert:”开头的步骤断言其算法的不变量。这样的断言用于明确本来隐含的算法不变量。这样的断言不增加额外的语义要求，因此实现不需要检查它们。它们仅用于澄清算法。

算法步骤可以使用“Let x be someValue”形式声明任何值的命名别名。这些别名是类似引用的，因为x和someValue都引用相同的底层数据，对任意一方的修改对双方可见。希望避免这种引用行为的算法步骤应显式地复制右侧：“Let x be a copy of someValue”创建someValue的浅拷贝。

一旦声明，别名可以在任何后续步骤中引用，且不得在别名声明之前的步骤中引用。可以使用“Set x to someOtherValue”修改别名。

#### 5.2.1 抽象操作
为了便于在规范的多个部分中使用，一些算法称为抽象操作，以参数化函数形式命名和编写，以便可以在其他算法中按名称引用。抽象操作通常使用函数应用样式引用，如`OperationName(arg1, arg2)`。一些抽象操作被视为类规范抽象的多态分派方法。这种方法样式的抽象操作通常使用方法应用样式引用，如`someValue.OperationName(arg1, arg2)`。

#### 5.2.2 语法指向操作
语法指向操作是一个命名操作，其定义包含与ECMAScript语法中的一个或多个生成式关联的算法。具有多个替代定义的生成式通常对每个替代都有一个独特的算法。当算法与语法生成式关联时，它可以引用生成式替代中的终结符和非终结符，就像它们是算法的参数一样。以这种方式使用时，非终结符指的是解析源文本时匹配的实际替代定义。由语法生成式或其派生的解析节点匹配的源文本是从参与匹配的第一个终结符开始到参与匹配的最后一个终结符结束的源文本部分。

当算法与生成式替代关联时，替代通常显示不带任何“[ ]”语法注释。此类注释仅影响替代的语法识别，对替代的关联语义没有影响。

语法指向操作通过使用以下算法步骤1、3和4中的约定，用解析节点和其他参数（可选）调用：
```plaintext
1. 令status为SomeNonTerminal的SyntaxDirectedOperation。
2. 令someParseNode为某些源文本的解析。
3. 执行someParseNode的SyntaxDirectedOperation。
4. 使用参数"value"执行someParseNode的SyntaxDirectedOperation。
```
除非另有明确规定，否则所有链生成式都隐含定义了该生成式左侧非终结符的每个操作的定义。隐含定义只是将相同操作与相同参数（如果有）重新应用于链生成式的唯一右侧非终结符，然后返回结果。例如，假设某个算法有一个形式为“Return Evaluation of Block”的步骤，并且有一个生成式：
```plaintext
Block :
    { StatementList }
```
但是Evaluation操作没有与该生成式关联的算法。在这种情况下，Evaluation操作隐含包括以下形式的关联：
```plaintext
运行时语义：Evaluation

Block : { StatementList }
    1. 返回StatementList的Evaluation。
```

#### 5.2.3 运行时语义
指定在运行时必须调用语义的算法称为运行时语义。运行时语义由抽象操作或语法指向操作定义。

##### 5.2.3.1 Completion（完成记录）
抽象操作Completion接受参数completionRecord（一个完成记录）并返回一个完成记录。调用时执行以下步骤：
```plaintext
1. 断言：completionRecord是一个完成记录。
2. 返回completionRecord。
```

##### 5.2.3.2 抛出异常
算法步骤如果说明要抛出异常，例如：
```plaintext
1. 抛出TypeError异常。
```
其含义与：
```plaintext
1. 返回ThrowCompletion（新创建的TypeError对象）。
```
相同。

##### 5.2.3.3 ReturnIfAbrupt（返回如果中断）
算法步骤说明或等同于：
```plaintext
1. ReturnIfAbrupt(argument)。
```
其含义与：
```plaintext
1. 断言：argument是一个完成记录。
2. 如果argument是一个中断完成，返回Completion（argument）。
3. 否则，将argument设置为argument.[[Value]]。
```
算法步骤说明或等同于：
```plaintext
1. ReturnIfAbrupt（AbstractOperation()）。
```
其含义与：
```plaintext
1. 令hygienicTemp为AbstractOperation()。
2. 断言：hygienicTemp是一个完成记录。
3. 如果hygienicTemp是一个中断完成，返回Completion（hygienicTemp）。
4. 否则，将hygienicTemp设置为hygienicTemp.[[Value]]。
```
其中hygienicTemp是临时变量，仅在涉及ReturnIfAbrupt的步骤中可见。

算法步骤说明或等同于：
```plaintext
1. 令result为AbstractOperation（ReturnIfAbrupt（argument））。
```
其含义与：
```plaintext
1. 断言：argument是一个完成记录。
2. 如果argument是一个中断完成，返回Completion（argument）。
3. 否则，将argument设置为argument.[[Value]]。
4. 令result为AbstractOperation（argument）。
```

##### 5.2.3.4 ReturnIfAbrupt简写
以?前缀的抽象操作和语法指向操作调用表示应将ReturnIfAbrupt应用于生成的完成记录。例如，步骤：
```plaintext
1. ? OperationName()。
```
等同于以下步骤：
```plaintext
1. ReturnIfAbrupt（OperationName()）。
```
类似地，对于方法应用样式，步骤：
```plaintext
1. ? someValue.OperationName()。
```
等同于：
```plaintext
1. ReturnIfAbrupt（someValue.OperationName()）。
```
同样，前缀!用于指示后续的抽象或语法指向操作调用不会返回中断完成，并且生成的完成记录的[[Value]]字段应代替操作的返回值。例如，步骤：
```plaintext
1. 令val为! OperationName()。
```
等同于以下步骤：
```plaintext
1. 令val为OperationName()。
2. 断言：val是一个正常完成。
3. 将val设置为val.[```plaintext
[[Value]]。
```
语法指向操作的运行时语义使用这种简写，在操作调用前放置!或?：
```plaintext
1. 执行! SyntaxDirectedOperation of NonTerminal。
```

##### 5.2.3.5 隐式正常完成
在声明返回完成记录的抽象操作中的算法中，以及在所有内置函数中，返回的值首先传递给NormalCompletion，并使用结果代替。这条规则不适用于Completion算法内部或在明确标记为返回完成记录的步骤中；这些情况包括：
- 直接返回Completion、NormalCompletion或ThrowCompletion的结果。
- 直接返回构造完成记录的结果。

如果通过任何其他方式从抽象操作返回完成记录，则为编辑错误。例如，在这些抽象操作中：
```plaintext
1. Return true。
```
其含义与：
```plaintext
1. Return NormalCompletion（true）。
```
或：
```plaintext
1. 令completion为NormalCompletion（true）。
2. 返回Completion（completion）。
```
或：
```plaintext
1. Return Completion Record { [[Type]]: NORMAL, [[Value]]: true, [[Target]]: EMPTY }。
```
相同。请注意，通过ReturnIfAbrupt扩展，以下示例是允许的，因为在扩展步骤中，在中断情况下返回应用Completion的结果，在正常情况下解包后应用隐式NormalCompletion。
```plaintext
1. Return ? completion。
```
以下示例将是编辑错误，因为返回的完成记录未在该步骤中进行注释。
```plaintext
1. 令completion为NormalCompletion（true）。
2. 返回completion。
```

#### 5.2.4 静态语义
上下文无关语法不足以表达所有定义输入元素流是否形成可评估的有效ECMAScript脚本或模块的规则。在某些情况下，需要额外的规则，可以使用ECMAScript算法约定或叙述要求表达。这些规则总是与语法生成式关联，称为生成式的静态语义。

静态语义规则有名称，通常使用算法定义。命名的静态语义规则与语法生成式关联，一个具有多个替代定义的生成式通常对每个适用的命名静态语义规则的每个替代都有一个独特的算法。

一种特殊的静态语义规则是早期错误规则。早期错误规则定义了与特定语法生成式关联的早期错误条件（见第17节）。大多数早期错误规则的评估不是在本规范的算法中显式调用的。符合规范的实现必须在首次评估脚本或模块之前，验证用于解析该脚本或模块的生成式的所有早期错误规则。如果违反任何早期错误规则，则脚本或模块无效，无法评估。

#### 5.2.5 数学运算
本规范引用了这些种类的数值：
- 数学值：任意实数，用作默认的数值类型。
- 扩展数学值：数学值以及+∞和-∞。
- 数字：IEEE 754-2019 binary64（双精度浮点）值。
- BigInts：ECMAScript语言值，表示与数学整数一一对应的任意精度整数。

在本规范的语言中，通过下标后缀来区分不同类型的数值。下标𝔽指代数字，下标ℤ指代BigInts。没有下标后缀的数值指代数学值。本规范以十进制表示大多数数值；它也使用形如0x后跟0-9或A-F的数字作为十六进制值。

一般来说，当本规范引用数值（例如“y的长度”或“由四个十六进制数字表示的整数”）时，如果未明确指定数值类型，则该短语指代数学值。指代数字或BigInt值的短语会明确注明；例如“表示...的代码点数量的数字值”或“...的BigInt值”。

在本规范中使用整数一词时，指代数学整数集合中的值，除非另有说明。使用整数数字一词时，指代有限数字值，其数学值在整数集合中。

数值运算符如+、×、=和≥的含义取决于操作数的类型。当应用于数学值时，运算符指代通常的数学运算。当应用于扩展数学值时，运算符指代扩展实数上的通常数学运算；未定义的不定形式应视为编辑错误。当应用于数字时，运算符指代IEEE 754-2019中的相关运算。当应用于BigInts时，运算符指代应用于BigInt数学值的通常数学运算。应用于混合类型操作数（如数字和数学值）的数值运算符未定义，应视为本规范的编辑错误。

在本文档中，数学值与数字或BigInt之间的转换总是显式的。将数学值或扩展数学值x转换为数字表示为“x的数字值”或𝔽(x)，定义见6.1.6.1。将整数x转换为BigInt表示为“x的BigInt值”或ℤ(x)。将数字或BigInt x转换为数学值表示为“x的数学值”或ℝ(x)。+0𝔽和-0𝔽的数学值为数学值0。非有限值的数学值未定义。x的扩展数学值为有限值的数学值，+∞𝔽和-∞𝔽分别为+∞和-∞；NaN的扩展数学值未定义。

数学函数abs(x)生成x的绝对值，若x<0，则为-x，否则为x本身。

数学函数min(x1, x2, ..., xN)生成x1到xN中数学上最小的值。数学函数max(x1, x2, ..., xN)生成x1到xN中数学上最大的值。这些数学函数的定义域和值域是扩展数学值。

“x模y”的表示法（y必须是有限且非零的）计算一个与y同号（或零）的值k，使得abs(k) < abs(y)且x - k = q × y，其中q是整数。

短语“将x限制在lower和upper之间的结果”（其中x是扩展数学值，lower和upper是数学值，且lower ≤ upper）生成lower（若x < lower），生成upper（若x > upper），否则生成x。

数学函数floor(x)生成不大于x的最大整数（最接近+∞）。
```plaintext
注意：floor(x) = x - (x模1)。
```
数学函数truncate(x)通过向零舍入去除x的小数部分，生成若x < 0则为-floor(-x)，否则为floor(x)。

数学函数min、max、abs、floor和truncate未定义数字和BigInts，对于非数学值参数使用这些方法应视为本规范的编辑错误。

从下界a到上界b的区间是一个可能无限、可能为空的同种数值的集合。每个界限将被描述为包含或排除，但不能两者兼有。区间有四种类型，分别如下：
- 从a（包含）到b（包含）的区间，也称为从a到b的包含区间，包含所有a ≤ x ≤ b的同种数值，不包括其他数值。
- 从a（包含）到b（排除）的区间，包含所有a ≤ x < b的同种数值，不包括其他数值。
- 从a（排除）到b（包含）的区间，包含所有a < x ≤ b的同种数值，不包括其他数值。
- 从a（排除）到b（排除）的区间，包含所有a < x < b的同种数值，不包括其他数值。

例如，从1（包含）到2（排除）的区间包含1和2之间的所有数学值，包括1但不包括2。为定义区间的目的，-0𝔽 < +0𝔽，因此，例如，以+0𝔽为下界的包含区间包含+0𝔽但不包含-0𝔽。NaN从不包含在区间内。

#### 5.2.6 值表示法
在本规范中，ECMAScript语言值以粗体显示。示例包括null、true或"hello"。这些与ECMAScript源文本如Function.prototype.apply或let n = 42;区分开来。

#### 5.2.7 标识
在本规范中，规范值和ECMAScript语言值都可以进行相等性比较。比较相等性时，值分为两类。有标识的值仅与自身相等。没有标识的值如果其所有固有特性都相同则相等——特性如整数的大小或序列的长度。没有标识的值可以通过完全描述其特性来显现。相比之下，每个有标识的值都是唯一的，因此仅与自身相等。有标识的值类似于没有标识的值，但具有一个额外的无法猜测、不可改变的、普遍唯一的特性，称为标识。对现有有标识值的引用不能仅通过描述它们来显现，而必须明确地从一个地方传递到另一个地方。有些有标识的值是可变的，因此可以就地改变其特性（除标识外），使所有持有该值的地方都能观察到新特性。没有标识的值永远不会与有标识的值相等。

从本规范的角度来看，词语“is”用于比较两个值的相等性，例如“如果bool is true，则...”中的“is”，以及词语“contains”用于使用相等性比较在列表中搜索值，例如“如果list包含一个Record r，使得r.[[Foo]] is true，则...”中的“contains”。规范值的标识决定了这些比较的结果，并在本规范中是公理性的。

从ECMAScript语言的角度来看，语言值使用SameValue抽象操作及其递归调用的抽象操作进行相等性比较。这些比较抽象操作的算法决定了ECMAScript语言值的语言标识。

对于规范值，没有规范标识的值包括但不限于：数学值和扩展数学值；ECMAScript源文本、代理对、指令序言等；UTF-16代码单元；Unicode代码点；枚举；抽象操作，包括语法指向操作、主机钩子等；以及有序对。有规范标识的值包括但不限于：任何类型的记录，包括属性描述符、私有元素等；解析节点；列表；集合和关系；抽象闭包；数据块；私有名称；执行上下文和执行上下文栈；代理标识符；以及侍者列表记录。

规范标识与所有ECMAScript语言值的语言标识一致，除了由Symbol.for生成的Symbol值。没有规范标识和语言标识的ECMAScript语言值是undefined、null、布尔值、字符串、数字和BigInts。有规范标识和语言标识的ECMAScript语言值是未由Symbol.for生成的Symbol和对象。由Symbol.for生成的Symbol值有规范标识，但没有语言标识。
