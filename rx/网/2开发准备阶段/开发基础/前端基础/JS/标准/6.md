## 6 ECMAScript 数据类型和值

本规范中的算法操作处理的每个值都具有相关的类型。可能的值类型正是本条款中定义的那些类型。类型进一步细分为 ECMAScript 语言类型和规范类型。

在本规范中，符号 “Type(x)” 用作 “x 的类型” 的简写，其中 “类型” 是指本条款定义的 ECMAScript 语言类型和规范类型。

### 6.1 ECMAScript 语言类型

ECMAScript 语言类型对应于由 ECMAScript 程序员使用 ECMAScript 语言直接操作的值。ECMAScript 语言类型包括 Undefined、Null、Boolean、String、Symbol、Number、BigInt 和 Object。ECMAScript 语言值是由 ECMAScript 语言类型特征化的值。

#### 6.1.1 Undefined 类型

Undefined 类型只有一个值，称为 undefined。任何未被赋值的变量其值都是 undefined。

#### 6.1.2 Null 类型

Null 类型只有一个值，称为 null。

#### 6.1.3 Boolean 类型

Boolean 类型表示一个逻辑实体，有两个值：true 和 false。

#### 6.1.4 String 类型

String 类型是一组所有有序序列的零或多个 16 位无符号整数值（“元素”），最长长度为 2**53 - 1 个元素。String 类型通常用于表示正在运行的 ECMAScript 程序中的文本数据，在这种情况下，String 中的每个元素都被视为 UTF-16 代码单元值。每个元素都被认为在序列中占据一个位置。位置用非负整数索引。第一个元素（如果有）位于索引 0，下一个元素（如果有）位于索引 1，依此类推。String 的长度是其包含的元素数量（即 16 位值）。空字符串的长度为零，因此不包含任何元素。

不解释 String 内容的 ECMAScript 操作不应用其他语义。解释 String 值的操作将每个元素视为单个 UTF-16 代码单元。然而，ECMAScript 并不限制这些代码单元的值或它们之间的关系，因此进一步将 String 内容解释为使用 UTF-16 编码的 Unicode 代码点序列的操作必须考虑格式错误的子序列。这样的操作对数值在 0xD800 到 0xDBFF（Unicode 标准定义为前导代理，或正式称为高代理代码单元）和数值在 0xDC00 到 0xDFFF（定义为尾随代理，或正式称为低代理代码单元）之间的每个代码单元应用以下规则：

- 不是前导代理也不是尾随代理的代码单元被解释为具有相同值的代码点。
- 两个代码单元的序列，其中第一个代码单元 c1 是前导代理，第二个代码单元 c2 是尾随代理，是一个代理对，并被解释为值为 (c1 - 0xD800) × 0x400 + (c2 - 0xDC00) + 0x10000 的代码点。
- 是前导代理或尾随代理但不是代理对的一部分的代码单元被解释为具有相同值的代码点。

String.prototype.normalize 函数（见 22.1.3.15）可以显式地标准化 String 值。String.prototype.localeCompare（见 22.1.3.12）内部标准化 String 值，但其他操作不会隐式标准化它们操作的字符串。操作结果不是语言和/或区域敏感的，除非另有说明。

注意：
设计这种方法的理由是使字符串的实现尽可能简单和高效。如果 ECMAScript 源文本采用规范化形式 C，字符串字面量也会被保证规范化，只要它们不包含任何 Unicode 转义序列。

在本规范中，短语 “A、B、...” 的字符串连接（每个参数是一个字符串值、代码单元或代码单元序列）表示一个字符串值，其代码单元序列是每个参数（按顺序）的代码单元（按顺序）的连接。

短语 “从 inclusiveStart 到 exclusiveEnd 的 S 的子字符串”（其中 S 是一个字符串值或代码单元序列，inclusiveStart 和 exclusiveEnd 是整数）表示一个字符串值，由从索引 inclusiveStart 开始到索引 exclusiveEnd 之前（当 inclusiveStart = exclusiveEnd 时是空字符串）的 S 的连续代码单元组成。如果省略了 “到” 后缀，则使用 S 的长度作为 exclusiveEnd 的值。

短语 “ASCII 单词字符” 表示以下字符串值，由 Unicode 基本拉丁语块中的每个字母和数字以及 U+005F（下划线）组成：
"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_".
由于历史原因，它对各种算法有意义。

#### 6.1.4.1 StringIndexOf（string, searchValue, fromIndex）

抽象操作 StringIndexOf 接受参数 string（一个字符串）、searchValue（一个字符串）和 fromIndex（一个非负整数），返回一个非负整数或 NOT-FOUND。当调用时执行以下步骤：

1. 令 len 为 string 的长度。
2. 如果 searchValue 是空字符串且 fromIndex ≤ len，则返回 fromIndex。
3. 令 searchLen 为 searchValue 的长度。
4. 对每个整数 i，使得 fromIndex ≤ i ≤ len - searchLen，按升序执行
   a. 令 candidate 为从 i 到 i + searchLen 的 string 的子字符串。
   b. 如果 candidate 是 searchValue，则返回 i。
5. 返回 NOT-FOUND。

注意 1：
如果 searchValue 是空字符串且 fromIndex ≤ string 的长度，则此算法返回 fromIndex。空字符串实际上在字符串中的每个位置都有效，包括最后一个代码单元之后。

注意 2：
如果 fromIndex + searchValue 的长度 > string 的长度，则此算法始终返回 NOT-FOUND。

#### 6.1.4.2 StringLastIndexOf（string, searchValue, fromIndex）

抽象操作 StringLastIndexOf 接受参数 string（一个字符串）、searchValue（一个字符串）和 fromIndex（一个非负整数），返回一个非负整数或 NOT-FOUND。当调用时执行以下步骤：

1. 令 len 为 string 的长度。
2. 令 searchLen 为 searchValue 的长度。
3. 断言：fromIndex + searchLen ≤ len。
4. 对每个整数 i，使得 0 ≤ i ≤ fromIndex，按降序执行
   a. 令 candidate 为从 i 到 i + searchLen 的 string 的子字符串。
   b. 如果 candidate 是 searchValue，则返回 i。
5. 返回 NOT-FOUND。

注意：
如果 searchValue 是空字符串，则此算法返回 fromIndex。空字符串实际上在字符串中的每个位置都有效，包括最后一个代码单元之后。

### 6.1.5 Symbol 类型

Symbol 类型是一组所有非字符串值，可以用作对象属性的键。

每个可能的 Symbol 值都是唯一且不可变的。

每个 Symbol 值不可变地持有一个关联值，称为 [[Description]]，它是 undefined 或字符串值。

#### 6.1.5.1 众所周知的符号

众所周知的符号是规范算法显式引用的内置 Symbol 值。它们通常用作属性的键，这些属性的值用作规范算法的扩展点。除非另有说明，否则众所周知的符号值在所有领域中共享（9.3）。

在本规范中，众所周知的符号用 @@name 形式的符号表示，其中 “name” 是表 1 中列出的值之一。

表 1：众所周知的符号

| 规范名称             | [[Description]]             | 值和用途                                                                                                                                                         |
|--------------------|---------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------|
| @@asyncIterator    | "Symbol.asyncIterator"    | 返回对象的默认 AsyncIterator 的方法。由 for-await-of 语句的语义调用。                                                                                                          |
| @@hasInstance      | "Symbol.hasInstance"      | 确定构造函数对象是否将对象识别为其实例的方法。由 instanceof 运算符的语义调用。                                                                                              |
| @@isConcatSpreadable | "Symbol.isConcatSpreadable" | 如果 true 表示对象应通过 Array.prototype.concat 扁平化为其数组元素的布尔值属性。                                                                                        |
| @@iterator         | "Symbol.iterator"         | 返回对象的默认 Iterator 的方法。由 for-of 语句的语义调用。                                                                                                              |
| @@match            | "Symbol.match"            | 将正则表达式与字符串匹配的正则表达式方法。由 String.prototype.match 方法调用。                                                                                               |
| @@matchAll         | "Symbol.matchAll"         | 返回一个迭代器的正则表达式方法，该迭代器生成正则表达式与字符串的匹配项。由 String.prototype.matchAll 方法调用。                                                                 |
| @@replace          | "Symbol.replace"          | 替换字符串中匹配子字符串的正则表达式方法。由 String.prototype.replace 方法调用。                                                                                              |
| @@search           | "Symbol.search"           | 返回字符串中与正| 规范名称             | [[Description]]             | 值和用途                                                                                                                                                         |
|--------------------|---------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------|
| @@search           | "Symbol.search"           | 返回与正则表达式匹配的字符串中的索引的正则表达式方法。由 String.prototype.search 方法调用。                                                                                             |
| @@species          | "Symbol.species"          | 一个函数值属性，是用于创建派生对象的构造函数函数。                                                                                                                             |
| @@split            | "Symbol.split"            | 按正则表达式匹配的索引拆分字符串的正则表达式方法。由 String.prototype.split 方法调用。                                                                                             |
| @@toPrimitive      | "Symbol.toPrimitive"      | 将对象转换为相应的原始值的方法。由 ToPrimitive 抽象操作调用。                                                                                                                 |
| @@toStringTag      | "Symbol.toStringTag"      | 用于创建对象默认字符串描述的字符串值属性。由内置方法 Object.prototype.toString 访问。                                                                                         |
| @@unscopables      | "Symbol.unscopables"      | 一个对象值属性，其自身和继承的属性名称是不包括在关联对象的 with 环境绑定中的属性名称。                                                                                                 |

### 6.1.6 数值类型

ECMAScript 具有两种内置数值类型：Number 和 BigInt。以下抽象操作是在这些数值类型上定义的。结果列显示返回类型，以及某些操作返回中断完成的可能性。

表 2：数值类型操作

| 操作                        | 示例源码             | 被以下语义调用的评估操作 | 结果                                              |
|-----------------------------|----------------------|-------------------------|---------------------------------------------------|
| Number::unaryMinus          | -x                   | 一元 - 运算符             | Number                                            |
| BigInt::unaryMinus          |                      |                         | BigInt                                            |
| Number::bitwiseNOT          | ~x                   | 按位 NOT 运算符 (~)       | Number                                            |
| BigInt::bitwiseNOT          |                      |                         | BigInt                                            |
| Number::exponentiate        | x ** y               | 指数运算符和 Math.pow     | Number                                            |
| BigInt::exponentiate        |                      |                         | 正常完成包含一个 BigInt 或中断完成                |
| Number::multiply            | x * y                | 乘法运算符               | Number                                            |
| BigInt::multiply            |                      |                         | BigInt                                            |
| Number::divide              | x / y                | 乘法运算符               | Number                                            |
| BigInt::divide              |                      |                         | 正常完成包含一个 BigInt 或中断完成                |
| Number::remainder           | x % y                | 乘法运算符               | Number                                            |
| BigInt::remainder           |                      |                         | 正常完成包含一个 BigInt 或中断完成                |
| Number::add                 | x ++ ++ x x + y      | 后缀递增运算符、前缀递增运算符和加法运算符 (+)    | Number                                            |
| BigInt::add                 |                      |                         | BigInt                                            |
| Number::subtract            | x -- -- x x - y      | 后缀递减运算符、前缀递减运算符和减法运算符 (-)    | Number                                            |
| BigInt::subtract            |                      |                         | BigInt                                            |
| Number::leftShift           | x << y               | 左移运算符 (<<)           | Number                                            |
| BigInt::leftShift           |                      |                         | BigInt                                            |
| Number::signedRightShift    | x >> y               | 有符号右移运算符 (>>)      | Number                                            |
| BigInt::signedRightShift    |                      |                         | BigInt                                            |
| Number::unsignedRightShift  | x >>> y              | 无符号右移运算符 (>>>)     | Number                                            |
| BigInt::unsignedRightShift  |                      |                         | 中断完成                                          |
| Number::lessThan            | x < y x > y x <= y x >= y | 关系运算符，通过 IsLessThan (x, y, LeftFirst) | Boolean 或 undefined（对于无序输入）                |
| BigInt::lessThan            |                      |                         | Boolean                                           |
| Number::equal               | x == y x != y x === y x !== y | 等值运算符，通过 IsStrictlyEqual (x, y) | Boolean                                           |
| BigInt::equal               |                      |                         | Boolean                                           |
| Number::sameValue           | Object.is(x, y)      | 对象内部方法，通过 SameValue (x, y) 来测试精确值相等性 | Boolean                                           |
| Number::sameValueZero       | [x].includes(y)      | 数组、Map 和 Set 方法，通过 SameValueZero (x, y) 来测试值相等性，忽略 +0𝔽 和 -0𝔽 的差异 | Boolean                                           |
| Number::bitwiseAND          | x & y                | 按位与运算符             | Number                                            |
| BigInt::bitwiseAND          |                      |                         | BigInt                                            |
| Number::bitwiseXOR          | x ^ y                | 按位异或运算符           | Number                                            |
| BigInt::bitwiseXOR          |                      |                         | BigInt                                            |
| Number::bitwiseOR           | x | y                | 按位或运算符             | Number                                            |
| BigInt::bitwiseOR           |                      |                         | BigInt                                            |
| Number::toString            | String(x)            | 许多表达式和内置函数，通过 ToString (argument) | String                                            |
| BigInt::toString            |                      |                         | String                                            |

由于数值类型通常不能在不损失精度或截断的情况下转换，ECMAScript 语言不提供这些类型之间的隐式转换。程序员必须显式调用 Number 和 BigInt 函数在需要调用另一种类型的函数时进行转换。

注意：
ECMAScript 的第一版及后续版本为某些运算符提供了可能丧失精度或截断的隐式数值转换。这些传统隐式转换为了向后兼容而保留，但不适用于 BigInt，以尽量减少程序员错误的可能性，并为将来的版本中泛化值类型提供选择。

#### 6.1.6.1 Number 类型

Number 类型有 18,437,736,874,454,810,627 个值，表示双精度浮点数 IEEE 754-2019 binary64 值，符合 IEEE 标准二进制浮点运算，除了 IEEE 标准的 9,007,199,254,740,990 个不同的 “非数值” 在 ECMAScript 中表示为单一的特殊 NaN 值（注意，NaN 值由程序表达式 NaN 产生）。在某些实现中，外部代码可能能够检测到不同的 NaN 值之间的差异，但这种行为是实现定义的；对 ECMAScript 代码来说，所有 NaN 值是不可区分的。

注意：
在 ArrayBuffer（见 25.1）或 SharedArrayBuffer（见 25.2）中存储 Number 值后，可能观察到的位模式不一定与 ECMAScript 实现中使用的 Number 值的内部表示相同。

还有两个特殊值，称为正无穷大和负无穷大。为了简洁，这些值分别用符号 +∞𝔽 和 -∞𝔽 表示。（注意，这两个无穷大的 Number 值由程序表达式 +Infinity（或简 simply Infinity）和 -Infinity 产生。）

其他 18,437,736,874,454,810,624 个值称为有限数值。它们中一半是正数，另一半是负数；对于每个有限正数 Number 值，都有一个具有相同大小的对应负数值。

注意，正零和负零都存在。为了简洁，这些值分别用符号 +0𝔽 和 -0𝔽 表示。（注意，这两个不同的零 Number 值由程序表达式 +0（或简 simply 0）和 -0 产生。）

18,437,736,874,454,810,622 个有限非零值有两种：

- 18,428,729,675,200,069,632 个（即 2**64 - 2**54）是归一化的，形式为
  s × m × 2**e
  其中 s 为 1 或 -1，m 是区间 [2**52, 2**53) 内的整数，e 是区间 [-1074, 971] 内的整数。

- 剩余的 9,007,199,254,740,990 个（即 2**53 - 2）值是非归一化的，形式为
  s × m × 2**e
  其中 s 为 1 或 -1，m 是区间 (0, 2**52) 内的整数，e 为 -1074。

注意，所有绝对值不大于 2**53 的正整数和负负整数在 Number 类型中都是可表示的。整数 0 在 Number 类型中有两种表示：+0𝔽 和 -0𝔽。

一个有限数值如果非零且其表达式中的整数 m 是奇数，则具有奇数有效数值。否则，它具有偶数有效数值。

在本规范中，短语 “x 的 Number 值” 表示代表精确实数数学量 x 的一个 Number 值（x 可能是一个无理数，如 π）。选择离 x 最近的 Number 类型的有限值集合中的成员（去掉 -0𝔽，并增加两个不可表示的值，即 2**1024（即 +1 × 2**53 × 2**971）和 -2**1024（即 -1 × 2**53 × 2**971））。如果两个集合值同样接近，则选择具有偶数有效数值的那个；为了这个目的，两个额外值 2**1024 和 -2**1024 被认为具有偶数有效数值。最后，如果选择了 2**1024，则将其替换为 +∞𝔽；如果选择了 -2**1024，则将其替换为 -∞𝔽；如果选择了 +0𝔽，且 x < 0，则将其替换为 -0𝔽；其他选择的值保持不变。结果是 x 的 Number 值。（此过程完全对应于 IEEE 754-2019 的 roundTiesToEven 模式的行为。）

+∞ 的 Number 值是 +∞𝔽，-∞ 的 Number 值是 -∞𝔽。

某些 ECMAScript 运算符仅处理特定范围内的整数，例如从 -2**31 到 2**31 - 1 的区间，或从 0 到 2**16 - 1 的区间。这些运算符接受任何 Number 类型的值，但首先将每个这样的值转换为预期范围内的整数值。有关数值转换操作的描述，请参见 7.1。

#### 6.1.6.1.1 Number::unaryMinus（x）

抽象操作 Number::unaryMinus 接受参数 x（一个 Number），返回一个 Number。当调用时执行以下步骤：

1. 如果 x 是 NaN，则返回 NaN。
2. 返回 x 的取反结果；即计算一个具有相同大小但符号相反的 Number。

#### 6.1.6.1.2 Number::bitwiseNOT（x）

抽象操作 Number::bitwiseNOT 接受参数 x（一个 Number），返回一个整数 Number。当调用时执行以下步骤：

1. 令 oldValue 为 ! ToInt32(x)。
2. 返回对 oldValue 应用按位补运算的结果。结果的数学值可以精确表示为 32 位二进制补码位串。

#### 6.1.6.1.3 Number::exponentiate（base, exponent）

抽象操作 Number::exponentiate 接受参数 base（一个 Number）和 exponent（一个 Number），返回一个 Number。它返回一个实现近似值，表示将 base 提升到 exponent 次幂的结果。当调用时执行以下步骤：

1. 如果 exponent 是 NaN，则返回 NaN。
2. 如果 exponent 是 +0𝔽 或 -0𝔽，则返回 1𝔽。
3. 如果 base 是 NaN，则返回 NaN。
4. 如果 base 是 +∞𝔽，则
   a. 如果 exponent > +0𝔽，则返回 +∞𝔽。否则，返回 +0𝔽。
5. 如果 base 是 -∞𝔽，则
   a. 如果 exponent > +0𝔽，则
      i. 如果 exponent 是奇整数，则返回 -∞𝔽。否则，返回 +∞𝔽。
   b. 否则，
      i. 如果 exponent 是奇整数，则返回 -0𝔽。否则，返回 +0𝔽。
6. 如果 base 是 +0𝔽，则
   a. 如果 exponent > +0𝔽，则返回 +0𝔽。否则，返回 +∞𝔽。
7. 如果 base 是 -0𝔽，则
   a. 如果 exponent > +0𝔽，则
      i. 如果 exponent 是奇整数，则返回 -0𝔽。否则，返回 +0𝔽。
   b. 否则，
      i. 如果 exponent 是奇整数，则返回 -∞𝔽。否则，返回 +∞𝔽。
8. 断言：base 是有限的，且不是 +0𝔽 也不是 -0𝔽。
9. 如果 exponent 是 +∞𝔽，则
   a. 如果 abs(ℝ(base)) > 1，则返回 +∞𝔽。
   b. 如果 abs(ℝ(base)) = 1，则返回 NaN。
   c. 如果 abs(ℝ(base)) < 1，则返回 +0𝔽。
10. 如果 exponent 是 -∞𝔽，则
    a. 如果 abs(ℝ(base)) > 1，则返回 +0𝔽。
    b. 如果 abs(ℝ(base)) = 1，则返回 NaN。
    c. 如果 abs(ℝ(base)) < 1，则返回 +∞𝔽。
11. 断言：exponent 是有限的，且不是 +0𝔽 也不是 -0𝔽。
12. 如果 base < -0𝔽 且 exponent 不是整数，则返回 NaN。
13. 返回一个实现近似的 Number 值，表示将 ℝ(base) 提升到 ℝ(exponent) 次幂的结果。

注意：
当 base 为 1𝔽 或 -1𝔽 且 exponent 为 +∞𝔽 或 -∞𝔽 时，或者当 base 为 1𝔽 且 exponent 为 NaN 时，base ** exponent 的结果与 IEEE 754-2019 不同。ECMAScript 的第一版为此操作指定了 NaN 的结果，而后来的 IEEE 754 版本指定了 1𝔽。为了兼容，保留了历史 ECMAScript 行为。

#### 6.1.6.1.4 Number::multiply（x, y）

抽象操作 Number::multiply 接受参数 x（一个 Number）和 y（一个 Number），返回一个 Number。它按照 IEEE 754-2019 二进制双精度算术的规则执行乘法运算，生成 x 和 y 的乘积。当调用时执行以下步骤：

1. 如果 x 是 NaN 或 y 是 NaN，则返回 NaN。
2. 如果 x 是 +∞𝔽 或 -∞𝔽，则
   a. 如果 y 是 +0𝔽 或 -0𝔽，则返回 NaN。
   b. 如果 y > +0𝔽，则返回 x。
   c. 返回 -x。
3. 如果 y 是 +∞𝔽 或 -∞𝔽，则
   a. 如果 x 是 +0𝔽 或 -0𝔽，则返回 NaN。
   b. 如果 x > +0𝔽，则返回 y。
   c. 返回 -y。
4. 如果 x 是 -0𝔽，则
   a. 如果 y 是 -0𝔽 或 y < -0𝔽，则返回 +0𝔽。
   b. 否则，返回 -0𝔽。
5. 如果 y 是 -0𝔽，则
   a. 如果 x < -0𝔽，则返回 +0𝔽。
   b. 否则，返回 -0𝔽。
6. 返回 𝔽(ℝ(x) × ℝ(y))。

注意：
有限精度乘法是交换的，但不总是结合的。

#### 6.1.6.1.5 Number::divide（x, y）

抽象操作 Number::divide 接受参数 x（一个 Number）和 y（一个 Number），返回一个 Number。它按照 IEEE 754-2019 二进制双精度算术的规则执行除法运算，生成 x（被除数）和 y（除数）的商。当调用时执行以下步骤：

1. 如果 x 是 NaN 或 y 是 NaN，则返回 NaN。
2. 如果 x 是 +∞𝔽 或 -∞𝔽，则
   a. 如果 y 是 +∞𝔽 或 -∞𝔽，则返回 NaN。
   b. 如果 y 是 +0𝔽 或 y > +0𝔽，则返回 x。
   c. 返回 -x。
3. 如果 y 是 +∞𝔽，则
   a. 如果 x 是 +0𝔽 或 x > +0𝔽，则返回 +0𝔽。否则，返回 -0𝔽。
4. 如果 y 是 -∞𝔽，则
   a. 如果 x 是 +0𝔽 或 x > +0𝔽，则返回 -0𝔽。否则，返回 +0𝔽。
5. 如果 x 是 +0𝔽 或 -0𝔽，则
   a. 如果 y 是 +0𝔽 或 -0𝔽，则返回 NaN。
   b. 如果 y > +0𝔽，则返回 x。
   c. 返回 -x。
6. 如果y 是 +0𝔽，则
   a. 如果 x > +0𝔽，则返回 +∞𝔽。否则，返回 -∞𝔽。
7. 如果 y 是 -0𝔽，则
   a. 如果 x > +0𝔽，则返回 -∞𝔽。否则，返回 +∞𝔽。
8. 返回 𝔽(ℝ(x) / ℝ(y))。

#### 6.1.6.1.6 Number::remainder（n, d）

抽象操作 Number::remainder 接受参数 n（一个 Number）和 d（一个 Number），返回一个 Number。它从其操作数的隐含除法中产生余数，其中 n 是被除数，d 是除数。当调用时执行以下步骤：

1. 如果 n 是 NaN 或 d 是 NaN，则返回 NaN。
2. 如果 n 是 +∞𝔽 或 -∞𝔽，则返回 NaN。
3. 如果 d 是 +∞𝔽 或 -∞𝔽，则返回 n。
4. 如果 d 是 +0𝔽 或 -0𝔽，则返回 NaN。
5. 如果 n 是 +0𝔽 或 -0𝔽，则返回 n。
6. 断言：n 和 d 是有限且非零的。
7. 令 quotient 为 ℝ(n) / ℝ(d)。
8. 令 q 为 truncate(quotient)。
9. 令 r 为 ℝ(n) - (ℝ(d) × q)。
10. 如果 r = 0 且 n < -0𝔽，则返回 -0𝔽。
11. 返回 𝔽(r)。

注意 1：
在 C 和 C++ 中，余数操作只接受整数操作数；在 ECMAScript 中，它也接受浮点数操作数。

注意 2：
浮点数余数操作的结果（由 % 运算符计算）与 IEEE 754-2019 定义的“余数”操作不同。IEEE 754-2019 的“余数”操作计算舍入除法的余数，而不是截断除法的余数，因此其行为不类似于通常的整数余数运算符。相反，ECMAScript 语言定义 % 运算符在浮点数操作上的行为类似于 Java 的整数余数运算符；这可以与 C 库函数 fmod 进行比较。

#### 6.1.6.1.7 Number::add（x, y）

抽象操作 Number::add 接受参数 x（一个 Number）和 y（一个 Number），返回一个 Number。它按照 IEEE 754-2019 二进制双精度算术的规则执行加法运算，产生其参数的和。当调用时执行以下步骤：

1. 如果 x 是 NaN 或 y 是 NaN，则返回 NaN。
2. 如果 x 是 +∞𝔽 且 y 是 -∞𝔽，则返回 NaN。
3. 如果 x 是 -∞𝔽 且 y 是 +∞𝔽，则返回 NaN。
4. 如果 x 是 +∞𝔽 或 -∞𝔽，则返回 x。
5. 如果 y 是 +∞𝔽 或 -∞𝔽，则返回 y。
6. 断言：x 和 y 都是有限的。
7. 如果 x 是 -0𝔽 且 y 是 -0𝔽，则返回 -0𝔽。
8. 返回 𝔽(ℝ(x) + ℝ(y))。

注意：
有限精度加法是交换的，但不总是结合的。

#### 6.1.6.1.8 Number::subtract（x, y）

抽象操作 Number::subtract 接受参数 x（一个 Number）和 y（一个 Number），返回一个 Number。它执行减法运算，产生其操作数的差；x 是被减数，y 是减数。当调用时执行以下步骤：

1. 返回 Number::add(x, Number::unaryMinus(y))。

注意：
x - y 的结果总是与 x + (-y) 的结果相同。

#### 6.1.6.1.9 Number::leftShift（x, y）

抽象操作 Number::leftShift 接受参数 x（一个 Number）和 y（一个 Number），返回一个整数 Number。当调用时执行以下步骤：

1. 令 lnum 为 ! ToInt32(x)。
2. 令 rnum 为 ! ToUint32(y)。
3. 令 shiftCount 为 ℝ(rnum) 取模 32。
4. 返回将 lnum 左移 shiftCount 位的结果。结果的数学值可以精确表示为 32 位二进制补码位串。

#### 6.1.6.1.10 Number::signedRightShift（x, y）

抽象操作 Number::signedRightShift 接受参数 x（一个 Number）和 y（一个 Number），返回一个整数 Number。当调用时执行以下步骤：

1. 令 lnum 为 ! ToInt32(x)。
2. 令 rnum 为 ! ToUint32(y)。
3. 令 shiftCount 为 ℝ(rnum) 取模 32。
4. 返回对 lnum 进行符号扩展右移 shiftCount 位的结果。最高有效位被传播。结果的数学值可以精确表示为 32 位二进制补码位串。

#### 6.1.6.1.11 Number::unsignedRightShift（x, y）

抽象操作 Number::unsignedRightShift 接受参数 x（一个 Number）和 y（一个 Number），返回一个整数 Number。当调用时执行以下步骤：

1. 令 lnum 为 ! ToUint32(x)。
2. 令 rnum 为 ! ToUint32(y)。
3. 令 shiftCount 为 ℝ(rnum) 取模 32。
4. 返回将 lnum 零填充右移 shiftCount 位的结果。空位用零填充。结果的数学值可以精确表示为 32 位无符号位串。

#### 6.1.6.1.12 Number::lessThan（x, y）

抽象操作 Number::lessThan 接受参数 x（一个 Number）和 y（一个 Number），返回一个 Boolean 或 undefined。当调用时执行以下步骤：

1. 如果 x 是 NaN，则返回 undefined。
2. 如果 y 是 NaN，则返回 undefined。
3. 如果 x 是 y，则返回 false。
4. 如果 x 是 +0𝔽 且 y 是 -0𝔽，则返回 false。
5. 如果 x 是 -0𝔽 且 y 是 +0𝔽，则返回 false。
6. 如果 x 是 +∞𝔽，则返回 false。
7. 如果 y 是 +∞𝔽，则返回 true。
8. 如果 y 是 -∞𝔽，则返回 false。
9. 如果 x 是 -∞𝔽，则返回 true。
10. 断言：x 和 y 都是有限的。
11. 如果 ℝ(x) < ℝ(y)，则返回 true。否则，返回 false。

#### 6.1.6.1.13 Number::equal（x, y）

抽象操作 Number::equal 接受参数 x（一个 Number）和 y（一个 Number），返回一个 Boolean。当调用时执行以下步骤：

1. 如果 x 是 NaN，则返回 false。
2. 如果 y 是 NaN，则返回 false。
3. 如果 x 是 y，则返回 true。
4. 如果 x 是 +0𝔽 且 y 是 -0𝔽，则返回 true。
5. 如果 x 是 -0𝔽 且 y 是 +0𝔽，则返回 true。
6. 返回 false。

#### 6.1.6.1.14 Number::sameValue（x, y）

抽象操作 Number::sameValue 接受参数 x（一个 Number）和 y（一个 Number），返回一个 Boolean。当调用时执行以下步骤：

1. 如果 x 是 NaN 且 y 是 NaN，则返回 true。
2. 如果 x 是 +0𝔽 且 y 是 -0𝔽，则返回 false。
3. 如果 x 是 -0𝔽 且 y 是 +0𝔽，则返回 false。
4. 如果 x 是 y，则返回 true。
5. 返回 false。

#### 6.1.6.1.15 Number::sameValueZero（x, y）

抽象操作 Number::sameValueZero 接受参数 x（一个 Number）和 y（一个 Number），返回一个 Boolean。当调用时执行以下步骤：

1. 如果 x 是 NaN 且 y 是 NaN，则返回 true。
2. 如果 x 是 +0𝔽 且 y 是 -0𝔽，则返回 true。
3. 如果 x 是 -0𝔽 且 y 是 +0𝔽，则返回 true。
4. 如果 x 是 y，则返回 true。
5. 返回 false。

#### 6.1.6.1.16 NumberBitwiseOp（op, x, y）

抽象操作 NumberBitwiseOp 接受参数 op（&、^ 或 |）、x（一个 Number）和 y（一个 Number），返回一个整数 Number。当调用时执行以下步骤：

1. 令 lnum 为 ! ToInt32(x)。
2. 令 rnum 为 ! ToInt32(y)。
3. 令 lbits 为表示 ℝ(lnum) 的 32 位二进制补码位串4. 令 rbits 为表示 ℝ(rnum) 的 32 位二进制补码位串。
5. 如果 op 是 &，则
   a. 令 result 为对 lbits 和 rbits 应用按位与操作的结果。
6. 否则，如果 op 是 ^，则
   a. 令 result 为对 lbits 和 rbits 应用按位异或操作的结果。
7. 否则，
   a. 断言：op 是 |。
   b. 令 result 为对 lbits 和 rbits 应用按位或操作的结果。
8. 返回表示结果的整数的 Number 值。

#### 6.1.6.1.17 Number::bitwiseAND（x, y）

抽象操作 Number::bitwiseAND 接受参数 x（一个 Number）和 y（一个 Number），返回一个整数 Number。当调用时执行以下步骤：

1. 返回 NumberBitwiseOp(&, x, y)。

#### 6.1.6.1.18 Number::bitwiseXOR（x, y）

抽象操作 Number::bitwiseXOR 接受参数 x（一个 Number）和 y（一个 Number），返回一个整数 Number。当调用时执行以下步骤：

1. 返回 NumberBitwiseOp(^, x, y)。

#### 6.1.6.1.19 Number::bitwiseOR（x, y）

抽象操作 Number::bitwiseOR 接受参数 x（一个 Number）和 y（一个 Number），返回一个整数 Number。当调用时执行以下步骤：

1. 返回 NumberBitwiseOp(|, x, y)。

#### 6.1.6.1.20 Number::toString（x, radix）

抽象操作 Number::toString 接受参数 x（一个 Number）和 radix（一个在 2 到 36（包括 2 和 36）之间的整数），返回一个字符串。它使用基数 radix 将 x 表示为字符串。在基数 r 的表示中使用的数字取自 "0123456789abcdefghijklmnopqrstuvwxyz" 的前 r 个代码单元。大于或等于 1𝔽 的数的表示中从不包含前导零。当调用时执行以下步骤：

1. 如果 x 是 NaN，则返回 "NaN"。
2. 如果 x 是 +0𝔽 或 -0𝔽，则返回 "0"。
3. 如果 x < -0𝔽，则返回字符串连接 "-" 和 Number::toString(-x, radix)。
4. 如果 x 是 +∞𝔽，则返回 "Infinity"。
5. 令 n、k 和 s 为整数，使得 k ≥ 1，radix**(k - 1) ≤ s < radix**k，𝔽(s × radix**(n - k)) 是 x，且 k 尽可能小。注意，k 是使用基数 radix 表示 s 的数字的数量，s 不可被 radix 整除，且 s 的最不重要数字不一定唯一确定。
6. 如果 radix ≠ 10 或 n 在 -5 到 21 的包括区间内，则
   a. 如果 n ≥ k，则
      i. 返回以下部分的字符串连接：
         - 使用基数 radix 表示的 s 的 k 个数字的代码单元
         - n - k 次代码单元 0x0030（数字零）
   b. 否则，如果 n > 0，则
      i. 返回以下部分的字符串连接：
         - 使用基数 radix 表示的 s 的 n 个最重要数字的代码单元
         - 代码单元 0x002E（句点）
         - 使用基数 radix 表示的 s 的剩余 k - n 个数字的代码单元
   c. 否则，
      i. 断言：n ≤ 0。
      ii. 返回以下部分的字符串连接：
         - 代码单元 0x0030（数字零）
         - 代码单元 0x002E（句点）
         - -n 次代码单元 0x0030（数字零）
         - 使用基数 radix 表示的 s 的 k 个数字的代码单元
7. 注意：在这种情况下，输入将使用科学 E 表示法表示，例如 1.2e+3。
8. 断言：radix 是 10。
9. 如果 n < 0，则
   a. 令 exponentSign 为代码单元 0x002D（减号）。
10. 否则，
    a. 令 exponentSign 为代码单元 0x002B（加号）。
11. 如果 k = 1，则
    a. 返回以下部分的字符串连接：
       - s 的单个数字的代码单元
       - 代码单元 0x0065（小写字母 e）
       - exponentSign
       - 表示 abs(n - 1) 的十进制表示的代码单元
12. 返回以下部分的字符串连接：
    - s 的十进制表示的最重要数字的代码单元
    - 代码单元 0x002E（句点）
    - s 的十进制表示的剩余 k - 1 个数字的代码单元
    - 代码单元 0x0065（小写字母 e）
    - exponentSign
    - 表示 abs(n - 1) 的十进制表示的代码单元

注意 1：
以下观察可能对实现有用，但不属于本标准的规范要求：

如果 x 是任何 Number 值，除了 -0𝔽，那么 ToNumber(ToString(x)) 是 x。
s 的最不重要数字并不总是唯一确定的。
注意 2：
对于提供比上述规则更准确转换的实现，建议使用以下替代版本的步骤 5 作为指导：

5. 令 n、k 和 s 为整数，使得 k ≥ 1，radix**(k - 1) ≤ s < radix**k，𝔽(s × radix**(n - k)) 是 x，且 k 尽可能小。如果 s 有多种可能的值，则选择 s × radix**(n - k) 最接近 ℝ(x) 的 s 值。如果有两种这样的可能值，则选择偶数的那个值。注意，k 是使用基数 radix 表示 s 的数字的数量，且 s 不可被 radix 整除。
注意 3：
ECMAScript 的实现者可能会发现 David M. Gay 关于浮点数的二进制到十进制和十进制到二进制转换的论文和代码有用：

Gay, David M. Correctly Rounded Binary-Decimal and Decimal-Binary Conversions. Numerical Analysis, Manuscript 90-10. AT&T Bell Laboratories (Murray Hill, New Jersey). 1990 年 11 月 30 日。可以通过以下网址获取：http://ampl.com/REFS/abstracts.html#rounding。相关代码可通过以下网址获取：http://netlib.sandia.gov/fp/dtoa.c 和 http://netlib.sandia.gov/fp/g_fmt.c，并且在各种 netlib 镜像站点上也可以找到。

### 6.1.6.2 BigInt 类型

BigInt 类型表示一个整数值。该值可以是任意大小，不受特定位宽的限制。一般来说，除非另有说明，否则操作旨在返回精确的数学基础答案。对于二元操作，BigInt 作为二进制补码字符串处理，负数被视为向左无限扩展的位。

#### 6.1.6.2.1 BigInt::unaryMinus（x）

抽象操作 BigInt::unaryMinus 接受参数 x（一个 BigInt），返回一个 BigInt。当调用时执行以下步骤：

1. 如果 x = 0ℤ，则返回 0ℤ。
2. 返回 -x。

#### 6.1.6.2.2 BigInt::bitwiseNOT（x）

抽象操作 BigInt::bitwiseNOT 接受参数 x（一个 BigInt），返回一个 BigInt。它返回 x 的按位取反结果。当调用时执行以下步骤：

1. 返回 -x - 1ℤ。

#### 6.1.6.2.3 BigInt::exponentiate（base, exponent）

抽象操作 BigInt::exponentiate 接受参数 base（一个 BigInt）和 exponent（一个 BigInt），返回一个正常完成包含一个 BigInt 或抛出完成。当调用时执行以下步骤：

1. 如果 exponent < 0ℤ，则抛出 RangeError 异常。
2. 如果 base = 0ℤ 且 exponent = 0ℤ，则返回 1ℤ。
3. 返回 base 提升到 exponent 次幂的结果。

#### 6.1.6.2.4 BigInt::multiply（x, y）

抽象操作 BigInt::multiply 接受参数 x（一个 BigInt）和 y（一个 BigInt），返回一个 BigInt。当调用时执行以下步骤：

1. 返回 x × y。

注意：
即使结果的位宽比输入大得多，也会给出精确的数学答案。

#### 6.1.6.2.5 BigInt::divide（x, y）

抽象操作 BigInt::divide 接受参数 x（一个 BigInt）和 y（一个 BigInt），返回一个正常完成包含一个 BigInt 或抛出完成。当调用时执行以下步骤：

1. 如果 y = 0ℤ，则抛出 RangeError 异常。
2. 令 quotient 为 ℝ(x) / ℝ(y)。
3. 返回 ℤ(truncate(quotient))。

#### 6.1.6.2.6 BigInt::remainder（n, d）

抽象操作 BigInt::remainder 接受参数 n（一个 BigInt）和 d（一个 BigInt），返回一个正常完成包含一个 BigInt 或抛出完成。当调用时执行以下步骤：

1. 如果 d = 0ℤ，则抛出 RangeError 异常。
2. 如果 n = 0ℤ，则返回 0ℤ。
3. 令 quotient 为 ℝ(n) / ℝ(d)。
4. 令 q 为 ℤ(truncate(quotient))。
5. 返回 n - (d × q)。

注意：
结果的符号与被除数的符号相同。

#### 6.1.6.2.7 BigInt::add（x, y）

抽象操作 BigInt::add 接受参数 x（一个 BigInt）和 y（一个 BigInt），返回一个 BigInt。当调用时执行以下步骤：

1. 返回 x + y。

#### 6.1.6.2.8 BigInt::subtract（x, y）

抽象操作 BigInt::subtract 接受参数 x（一个 BigInt）和 y（一个 BigInt），返回一个 BigInt。当调用时执行以下步骤：

1. 返回 x - y。

#### 6.1.6.2.9 BigInt::leftShift（x, y）

抽象操作 BigInt::leftShift 接受参数 x（一个 BigInt）和 y（一个 BigInt），返回一个 BigInt。当调用时执行以下步骤：

1. 如果 y < 0ℤ，则
   a. 返回 ℤ(floor(ℝ(x) / 2**(-ℝ(y))))。
2. 返回 x × 2ℤ**y。

注意：
这里的语义应当等同于按位移位，将 BigInt 视为无限长度的二进制补码数字串。

#### 6.1.6.2.10 BigInt::signedRightShift（x, y）

抽象操作 BigInt::signedRightShift 接受参数 x（一个 BigInt）和 y（一个 BigInt），返回一个 BigInt。当调用时执行以下步骤：

1. 返回 BigInt::leftShift(x, -y)。

#### 6.1.6.2.11 BigInt::unsignedRightShift（x, y）

抽象操作 BigInt::unsignedRightShift 接受参数 x（一个 BigInt）和 y（一个 BigInt），返回一个抛出完成。当调用时执行以下步骤：

1. 抛出 TypeError 异常。

#### 6.1.6.2.12 BigInt::lessThan（x, y）

抽象操作 BigInt::lessThan 接受参数 x（一个 BigInt）和 y（一个 BigInt），返回一个 Boolean。当调用时执行以下步骤：

1. 如果 ℝ(x) < ℝ(y)，则返回 true；否则返回 false。

#### 6.1.6.2.13 BigInt::equal（x, y）

抽象操作 BigInt::equal 接受参数 x（一个 BigInt）和 y（一个 BigInt），返回一个 Boolean。当调用时执行以下步骤：

1. 如果 ℝ(x) = ℝ(y)，则返回 true；否则返回 false。

#### 6.1.6.2.14 BinaryAnd（x, y）

抽象操作 BinaryAnd 接受参数 x（0 或 1）和 y（0 或 1），返回 0 或 1。当调用时执行以下步骤：

1. 如果 x = 1 且 y = 1，则返回 1。
2. 否则，返回 0。

#### 6.1.6.2.15 BinaryOr（x, y）

抽象操作 BinaryOr 接受参数 x（0 或 1）和 y（0 或 1），返回 0 或 1。当调用时执行以下步骤：

1. 如果 x = 1 或 y = 1，则返回 1。
2. 否则，返回 0。

#### 6.1.6.2.16 BinaryXor（x, y）

抽象操作 BinaryXor 接受参数 x（0 或 1）和 y（0 或 1），返回 0 或 1。当调用时执行以下步骤：

1. 如果 x = 1 且 y = 0，则返回 1。
2. 否则如果 x = 0 且 y = 1，则返回 1。
3. 否则，返回 0。

#### 6.1.6.2.17 BigIntBitwiseOp（op, x, y）

抽象操作 BigIntBitwiseOp 接受参数 op（&、^ 或 |）、x（一个 BigInt）和 y（一个 BigInt），返回一个 BigInt。当调用时执行以下步骤：

1. 将 x 设置为 ℝ(x)。
2. 将 y 设置为 ℝ(y)。
3. 令 result 为 0。
4. 令 shift 为 0。
5. 重复，直到 (x = 0 或 x = -1) 且 (y = 0 或 y = -1)，
   a. 令 xDigit 为 x 模 2。
   b. 令 yDigit 为 y 模 2。
   c. 如果 op 是 &，则
      i. 设置 result 为 result + 2**shift × BinaryAnd(xDigit, yDigit)。
   d. 否则如果 op 是 |，则
      i. 设置 result 为 result + 2**shift × BinaryOr(xDigit, yDigit)。
   e. 否则，
      i. 断言：op 是 ^。
      ii. 设置 result 为 result + 2**shift × BinaryXor(xDigit, yDigit)。
   f. 设置 shift 为 shift + 1。
   g. 设置 x 为 (x - xDigit) / 2。
   h. 设置 y 为 (y - yDigit) / 2。
6. 如果 op 是 &，则
   a. 令 tmp 为 BinaryAnd(x 模 2, y 模 2)。
7. 否则如果 op 是 |，则
   a. 令 tmp 为 BinaryOr(x 模 2, y 模 2)。
8. 否则，
   a. 断言：op 是 ^。
   b. 令 tmp 为 BinaryXor(x 模 2, y 模 2)。
9. 如果 tmp ≠ 0，则
   a. 设置 result 为 result - 2**shift。
   b. 注意：这扩展了符号。
10. 返回 result 的 BigInt 值。

#### 6.1.6.2.18 BigInt::bitwiseAND（x, y）

抽象操作 BigInt::bitwiseAND 接受参数 x（一个 BigInt）和 y（一个 BigInt），返回一个 BigInt。当调用时执行以下步骤：

1. 返回 BigIntBitwiseOp(&, x, y)。

#### 6.1.6.2.19 BigInt::bitwiseXOR（x, y）

抽象操作 BigInt::bitwiseXOR 接受参数 x（一个 BigInt）和 y（一个 BigInt），返回一个 BigInt。当调用时执行以下步骤：

1. 返回 BigIntBitwiseOp(^, x, y)。

#### 6.1.6.2.20 BigInt::bitwiseOR（x, y）

抽象操作 BigInt::bitwiseOR 接受参数 x（一个 BigInt）和 y（一个 BigInt），返回一个 BigInt。当调用时执行以下步骤：

1. 返回 BigIntBitwiseOp(|, x, y)。

#### 6.1.6.2.21 BigInt::toString（x, radix）

抽象操作 BigInt::toString 接受参数 x（一个 BigInt）和 radix（一个在 2 到 36（包括 2 和 36）之间的整数），返回一个字符串。它使用基数 radix 将 x 表示为字符串。在基数 r 的表示中使用的数字取自 "0123456789abcdefghijklmnopqrstuvwxyz" 的前 r 个代码单元。除了 0ℤ，BigInt 的表示中从不包含前导零。当调用时执行以下步骤：

1. 如果 x < 0ℤ，则返回字符串连接 "-" 和 BigInt::toString(-x, radix)。
2. 返回使用基数 radix 表示 x 的字符串值。

### 6.1.7 Object 类型

Object 类型的每个实例，也称为“对象”，表示属性的集合。每个属性要么是数据属性，要么是访问器属性：

- 数据属性将键值与 ECMAScript 语言值和一组布尔属性相关联。
- 访问器属性将键值与一个或两个访问器函数以及一组布尔属性相关联。访问器函数用于存储或检索与属性相关联的 ECMAScript 语言值。

对象的属性使用属性键唯一标识。属性键可以是字符串或符号。所有字符串和符号（包括空字符串）都是有效的属性键。属性名是属性键，是字符串。

整数索引是一个属性名 n，使得 CanonicalNumericIndexString(n) 返回一个在 +0𝔽 到 2**53 --1 之间的整数 Number。数组索引是一个整数索引 n，使得 CanonicalNumericIndexString(n) 返回一个在 +0𝔽 到 2**32 - 2 之间的整数 Number。

注意：
每个非负安全整数都有对应的整数索引。除了 2**32 - 1 之外的每个 32 位无符号整数都有对应的数组索引。“-0” 既不是整数索引也不是数组索引。

属性键用于访问属性及其值。属性的访问有两种：获取（get）和设置（set），分别对应于值的检索和赋值。通过 get 和 set 访问的属性包括对象的直接属性和通过属性继承关系从另一个关联对象继承的属性。继承的属性可以是关联对象的直接属性或继承属性。每个对象的直接属性的键值必须与该对象的其他直接属性的键值不同。

所有对象在逻辑上都是属性的集合，但存在多种不同形式的对象，它们在访问和操作其属性的语义上有所不同。请参阅 6.1.7.2 获取不同形式对象的定义。

此外，一些对象是可调用的；这些对象称为函数或函数对象，进一步描述如下。ECMAScript 中的所有函数都是 Object 类型的成员。

#### 6.1.7.1 属性属性

属性用于定义和解释 Object 属性的状态，如表 3 所述。除非明确指定，每个属性的初始值为其默认值。

表 3：Object 属性的属性

| 属性名       | 存在的属性类型  | 值域                | 默认值    | 描述                           |
| ------------ | --------------- | ------------------- | -------- | ------------------------------ |
| [[Value]]    | 数据属性        | 一个 ECMAScript 语言值 | undefined | 通过属性的 get 访问检索到的值。 |
| [[Writable]] | 数据属性        | 一个布尔值           | false    | 如果为 false，ECMAScript 代码尝试使用 [[Set]] 更改属性的 [[Value]] 属性将不会成功。 |
| [[Get]]      | 访问器属性      | 一个 Object 或 undefined | undefined | 如果值是一个 Object，则它必须是一个函数对象。函数的 [[Call]] 内部方法（表 5）在每次进行属性的 get 访问时使用空参数列表调用以检索属性值。 |
| [[Set]]      | 访问器属性      | 一个 Object 或 undefined | undefined | 如果值是一个 Object，则它必须是一个函数对象。函数的 [[Call]] 内部方法（表 5）在每次进行属性的 set 访问时使用包含所赋值的唯一参数的参数列表调用。属性的 [[Set]] 内部方法的效果可能会影响后续对属性的 [[Get]] 内部方法的调用返回的值，但这不是必须的。 |
| [[Enumerable]] | 数据属性或访问器属性 | 一个布尔值           | false    | 如果为 true，则属性将在 for-in 枚举中被枚举（见 14.7.5）。否则，属性称为不可枚举的。 |
| [[Configurable]] | 数据属性或访问器属性 | 一个布尔值           | false    | 如果为 false，尝试删除属性、将其从数据属性更改为访问器属性或从访问器属性更改为数据属性，或者对其属性进行任何更改（除了替换现有的 [[Value]] 或将 [[Writable]] 设置为 false）将失败。 |

#### 6.1.7.2 Object 内部方法和内部槽

在 ECMAScript 中，Object 的实际语义通过称为内部方法的算法指定。ECMAScript 引擎中的每个对象都与一组内部方法相关联，这些内部方法定义了其运行时行为。这些内部方法不是 ECMAScript 语言的一部分。它们纯粹是为了阐述目的而在本规范中定义的。然而，每个 ECMAScript 实现中的对象必须按照与其关联的内部方法指定的行为运行。具体实现的方式由实现决定。

内部方法名是多态的。这意味着不同的对象值在调用公共内部方法名时可能会执行不同的算法。内部方法调用的目标对象是“目标”。如果在运行时，算法的实现尝试使用对象不支持的内部方法，则抛出一个 TypeError 异常。

内部槽对应于与对象相关联的内部状态，并由各种 ECMAScript 规范算法使用。内部槽不是对象属性，不会被继承。根据具体的内部槽规范，这些状态可能包括任何 ECMAScript 语言类型的值或特定 ECMAScript 规范类型的值。除非另有明确规定，内部槽是在创建对象的过程中分配的，不能动态添加到对象中。除非另有规定，内部槽的初始值为 undefined。各种算法在本规范中创建具有内部槽的对象。然而，ECMAScript 语言没有提供将内部槽与对象关联的直接方法。

所有对象都有一个名为 [[PrivateElements]] 的内部槽，这是一个 PrivateElements 列表。此列表表示对象的私有字段、方法和访问器的值。初始状态为空列表。

内部方法和内部槽在本规范中使用双方括号 [[ ]] 标识。

表 4 总结了本规范使用的适用于所有由 ECMAScript 代码创建或操作的对象的基本内部方法。每个对象必须为所有基本内部方法提供算法。然而，所有对象不一定为这些方法使用相同的算法。

普通对象是满足以下所有条件的对象：

- 对于表 4 中列出的内部方法，对象使用 10.1 中定义的方法。
- 如果对象具有 [[Call]] 内部方法，则它使用 10.2.1 或 10.3.1 中定义的方法之一。
- 如果对象具有 [[Construct]] 内部方法，则它使用 10.2.2 或 10.3.2 中定义的方法之一。

特殊对象是指不属于普通对象的对象。

本规范通过这些对象的内部方法识别不同种类的特殊对象。行为上等同于某种特殊对象的对象（例如数组特殊对象或绑定函数特殊对象），但不具有为该种类指定的相同内部方法集合的对象，不被视为该种类的特殊对象。

表 4 和其他类似表格中的“签名”列描述了每个内部方法的调用模式。调用模式始终包括一个括号内的描述性参数名称列表。如果参数名称与 ECMAScript 类型名称相同，则该名称描述了参数值的所需类型。如果内部方法显式返回一个值，其参数列表后面跟随一个箭头（→）和返回值的类型名称。签名中使用的类型名称指的是第 6 节中定义的类型，辅以以下附加名称。“any” 表示该值可以是任何 ECMAScript 语言类型。

除了参数之外，内部方法始终可以访问作为方法调用目标的对象。

内部方法隐式返回一个完成记录（Completion Record），要么是包含该内部方法显示返回类型的正常完成记录，要么是抛出完成记录。

表 4：基本内部方法

| 内部方法          | 签名                       | 描述                                                 |
| ----------------- | -------------------------- | ---------------------------------------------------- |
| [[GetPrototypeOf]] | ( ) → Object \| Null        | 确定提供此对象继承属性的对象。null 值表示没有继承属性。 |
| [[SetPrototypeOf]] | (Object \| Null) → Boolean | 将此对象与另一个提供继承属性的对象关联。传递 null 表示没有继承属性。返回 true 表示操作成功，返回 false 表示操作不成功。 |
| [[IsExtensible]]  | ( ) → Boolean              | 确定是否允许向此对象添加额外属性。                   |
| [[PreventExtensions]] | ( ) → Boolean              | 控制是否允许向此对象添加新属性。返回 true 表示操作成功，返回 false 表示操作不成功。 |
| [[GetOwnProperty]] | (propertyKey) → Undefined \| Property Descriptor | 返回对象的直接属性 propertyKey 的属性描述符，或如果不存在此类属性则返回 undefined。 |
| [[DefineOwnProperty]] | (propertyKey, PropertyDescriptor) → Boolean | 创建或更改对象的直接属性 propertyKey，使其状态符合 PropertyDescriptor 的描述。返回 true 表示该属性已成功创建或更新，返回 false 表示属性不能被创建或更新。 |
| [[HasProperty]]   | (propertyKey) → Boolean    | 返回一个布尔值，指示此对象是否已具有一个键为 propertyKey 的直接或继承属性。 |
| [[Get]]           | (propertyKey, Receiver) → any | 从此对象中返回键为 propertyKey 的属性值。如果必须执行 ECMAScript 代码才能检索属性值，Receiver 在评估代码时用作 this 值。 |
| [[Set]]           | (propertyKey, value, Receiver) → Boolean | 将键为 propertyKey 的属性值设置为 value。如果必须执行 ECMAScript 代码才能设置属性值，Receiver 在评估代码时用作 this 值。返回 true 表示属性值已设置，返回 false 表示属性值不能被设置。 |
| [[Delete]]| [[Delete]]           | (propertyKey) → Boolean    | 移除对象的直接属性 propertyKey。如果属性未被删除且仍然存在，返回 false。如果属性已被删除或不存在，返回 true。                   |
| [[OwnPropertyKeys]]  | ( ) → List of property keys | 返回一个列表，其元素是对象的所有直接属性键。                                                             |

表 5 总结了支持可作为函数调用的对象的其他基本内部方法。函数对象是支持 [[Call]] 内部方法的对象。构造函数是支持 [[Construct]] 内部方法的对象。每个支持 [[Construct]] 的对象必须支持 [[Call]]；也就是说，每个构造函数必须是一个函数对象。因此，构造函数也可以称为构造函数对象或构造函数函数对象。

表 5：函数对象的附加基本内部方法

| 内部方法    | 签名                               | 描述                                                 |
| ----------- | ---------------------------------- | ---------------------------------------------------- |
| [[Call]]    | (any, a List of any) → any         | 执行与此对象相关联的代码。通过函数调用表达式调用。内部方法的参数是一个 this 值和一个包含调用表达式传递给函数的参数列表的列表。实现此内部方法的对象是可调用的。 |
| [[Construct]] | (a List of any, Object) → Object | 创建一个对象。通过 new 操作符或 super 调用调用。内部方法的第一个参数是一个列表，包含构造函数调用或 super 调用的参数。第二个参数是最初应用 new 操作符的对象。实现此内部方法的对象称为构造函数。函数对象不一定是构造函数，此类非构造函数函数对象没有 [[Construct]] 内部方法。 |

普通对象和标准特殊对象的基本内部方法的语义在第 10 节中指定。如果实现不支持特殊对象的内部方法的任何指定使用，则在尝试时必须抛出 TypeError 异常。

### 6.1.7.3 基本内部方法的约束

ECMAScript 引擎的对象的内部方法必须符合以下列出的约束。普通 ECMAScript 对象以及本规范中的所有标准特殊对象都保持这些约束。ECMAScript Proxy 对象通过对 [[ProxyHandler]] 对象上的陷阱调用结果进行运行时检查来保持这些约束。

实现提供的特殊对象也必须为这些对象保持这些约束。违反这些约束可能导致 ECMAScript 代码行为不可预测，并可能产生安全问题。然而，违反这些约束绝不能破坏实现的内存安全性。

实现不得允许通过提供实现基本内部方法功能的替代接口而不强制执行其约束的方式来规避这些约束。

定义：
- 内部方法的目标是调用内部方法的对象。
- 如果目标对象的 [[IsExtensible]] 内部方法返回 false，或者 [[PreventExtensions]] 内部方法返回 true，则该目标对象是不可扩展的。
- 不存在的属性是在不可扩展目标上不存在的直接属性。
- 所有对 SameValue 的引用均符合 SameValue 算法的定义。

返回值：
任何内部方法返回的值必须是一个完成记录，其 [[Type]] 字段值为 NORMAL，[[Target]] 字段值为 EMPTY，并且 [[Value]] 字段值为该内部方法的“正常返回类型”显示的值，或者 [[Type]] 字段值为 THROW，[[Target]] 字段值为 EMPTY，并且 [[Value]] 字段值为任何 ECMAScript 语言值。

注意：
内部方法不得返回继续完成、断开完成或返回完成。

[[GetPrototypeOf]]（）
正常返回类型为 Object 或 Null。
如果目标对象是不可扩展的，并且 [[GetPrototypeOf]] 返回一个值 V，则任何未来对 [[GetPrototypeOf]] 的调用都应返回与 V 相同的值。

注意：
对象的原型链应有有限长度（即，从任何对象开始，递归应用 [[GetPrototypeOf]] 内部方法到其结果应最终导致 null 值）。但是，如果原型链包含任何不使用普通对象 [[GetPrototypeOf]] 定义的特殊对象，则此要求在对象级别上不可强制执行。这样的循环原型链可能会在访问对象属性时导致无限循环。

[[SetPrototypeOf]]（V）
正常返回类型为 Boolean。
如果目标对象是不可扩展的，[[SetPrototypeOf]] 必须返回 false，除非 V 与目标对象的观察到的 [[GetPrototypeOf]] 值相同。

[[IsExtensible]]（）
正常返回类型为 Boolean。
如果 [[IsExtensible]] 返回 false，则所有未来对目标对象的 [[IsExtensible]] 调用必须返回 false。

[[PreventExtensions]]（）
正常返回类型为 Boolean。
如果 [[PreventExtensions]] 返回 true，则所有未来对目标对象的 [[IsExtensible]] 调用必须返回 false，且目标对象现在被视为不可扩展。

[[GetOwnProperty]]（P）
正常返回类型为 Property Descriptor 或 Undefined。
如果返回值的类型为 Property Descriptor，则返回值必须是一个完全填充的 Property Descriptor。
如果 P 被描述为一个不可配置、不可写的直接数据属性，则所有未来对 [[GetOwnProperty]]（P）的调用必须返回与 P 的 [[Value]] 属性相同的值。
如果 P 的除 [[Writable]] 和 [[Value]] 之外的属性可能随时间变化，或者该属性可能被删除，则 P 的 [[Configurable]] 属性必须为 true。
如果 [[Writable]] 属性可能从 false 更改为 true，则 [[Configurable]] 属性必须为 true。
如果目标对象是不可扩展的，并且 P 是不存在的，那么所有未来对目标对象的 [[GetOwnProperty]]（P）的调用必须将 P 描述为不存在的（即 [[GetOwnProperty]]（P）必须返回 undefined）。

注意：
因此，如果属性被描述为数据属性，并且其值可能随时间变化，那么即使没有通过其他基本内部方法公开的机制来更改值，那么 [[Writable]] 和 [[Configurable]] 属性之一或两者必须为 true。

[[DefineOwnProperty]]（P, Desc）
正常返回类型为 Boolean。
如果 P 先前被观察到是目标对象的不可配置的直接属性，[[DefineOwnProperty]] 必须返回 false，除非：
P 是一个可写的数据属性。不可配置的可写数据属性可以更改为不可配置的不可写数据属性。
Desc 的所有属性与 P 的属性相同。
如果目标对象是不可扩展的，并且 P 是不存在的直接属性，[[DefineOwnProperty]]（P, Desc）必须返回 false。也就是说，不可扩展的目标对象不能扩展新属性。

[[HasProperty]]（P）
正常返回类型为 Boolean。
如果 P 先前被观察到是目标对象的不可配置的直接数据或访问器属性，[[HasProperty]] 必须返回 true。

[[Get]]（P, Receiver）
正常返回类型为任何 ECMAScript 语言类型。
如果 P 先前被观察到是目标对象的不可配置的不可写直接数据属性，并且其值为 V，则 [[Get]] 必须返回与 V 相同的值。
如果 P 先前被观察到是目标对象的不可配置的直接访问器属性，并且其 [[Get]] 属性为 undefined，则 [[Get]] 操作必须返回 undefined。

[[Set]]（P, V, Receiver）
正常返回类型为 Boolean。
如果 P 先前被观察到是目标对象的不可配置的不可写直接数据属性，则 [[Set]] 必须返回 false，除非 V 与 P 的 [[Value]] 属性相同。
如果 P 先前被观察到是目标对象的不可配置的直接访问器属性，并且其 [[Set]] 属性为 undefined，则 [[Set]] 操作必须返回 false。

[[Delete]]（P）
正常返回类型为 Boolean。
如果 P 先前被观察到是目标对象的不可配置的直接数据或访问器属性，[[Delete]] 必须返回 false。

[[OwnPropertyKeys]]（）
正常返回类型为列表。
返回的列表不得包含任何重复项。
返回列表的每个元素的类型要么是 String 要么是 Symbol。
返回的列表必须至少包含所有先前被观察到的不可配置的直接属性的键。
如果目标对象是不可扩展的，则返回的列表必须仅包含目标对象的所有可通过 [[GetOwnProperty]] 观察到的直接属性的键。

[[Call]]（）
正常返回类型为任何 ECMAScript 语言类型。

[[Construct]]（）
正常返回类型为 Object。
目标对象还必须具有 [[Call]] 内部方法。

### 6.1.7.4 知名内置对象

知名内置对象是本规范的算法明确引用的内置对象，通常具有领域特定的标识。除非另有规定，每个内置对象实际上对应于一组相似的对象，每个领域一个。

在本规范中，类似 %name% 的引用表示与当前领域关联的内置对象，对应于名称。类似 %name.a.b% 的引用表示，正如在评估任何 ECMAScript 代码之前访问内置对象 %name% 的 "a" 属性的值的 "b" 属性一样。确定当前领域及其内置对象的方法在 9.4 中描述。知名内置对象如表 6 所示。

表 6：知名内置对象

| 内置名称                     | 全表 6：知名内置对象

| 内置名称                     | 全局名称                   | ECMAScript 语言关联           |
| --------------------------- | ------------------------- | ----------------------------- |
| %AggregateError%            | AggregateError            | AggregateError 构造函数 (20.5.7.1) |
| %Array%                     | Array                     | Array 构造函数 (23.1.1)       |
| %ArrayBuffer%               | ArrayBuffer               | ArrayBuffer 构造函数 (25.1.4) |
| %ArrayIteratorPrototype%    |                           | Array 迭代器对象的原型 (23.1.5) |
| %AsyncFromSyncIteratorPrototype% |                       | 同步转异步迭代器对象的原型 (27.1.4) |
| %AsyncFunction%             |                           | 异步函数对象的构造函数 (27.7.1) |
| %AsyncGeneratorFunction%    |                           | 异步生成器函数对象的构造函数 (27.4.1) |
| %AsyncGeneratorPrototype%   |                           | 异步生成器对象的原型 (27.6)  |
| %AsyncIteratorPrototype%    |                           | 所有标准内置异步迭代器对象的间接继承对象 |
| %Atomics%                   | Atomics                   | Atomics 对象 (25.4)           |
| %BigInt%                    | BigInt                    | BigInt 构造函数 (21.2.1)      |
| %BigInt64Array%             | BigInt64Array             | BigInt64Array 构造函数 (23.2) |
| %BigUint64Array%            | BigUint64Array            | BigUint64Array 构造函数 (23.2) |
| %Boolean%                   | Boolean                   | Boolean 构造函数 (20.3.1)     |
| %DataView%                  | DataView                  | DataView 构造函数 (25.3.2)    |
| %Date%                      | Date                      | Date 构造函数 (21.4.2)        |
| %decodeURI%                 | decodeURI                 | decodeURI 函数 (19.2.6.1)     |
| %decodeURIComponent%        | decodeURIComponent        | decodeURIComponent 函数 (19.2.6.2) |
| %encodeURI%                 | encodeURI                 | encodeURI 函数 (19.2.6.3)     |
| %encodeURIComponent%        | encodeURIComponent        | encodeURIComponent 函数 (19.2.6.4) |
| %Error%                     | Error                     | Error 构造函数 (20.5.1)       |
| %eval%                      | eval                      | eval 函数 (19.2.1)            |
| %EvalError%                 | EvalError                 | EvalError 构造函数 (20.5.5.1) |
| %FinalizationRegistry%      | FinalizationRegistry      | FinalizationRegistry 构造函数 (26.2.1) |
| %Float32Array%              | Float32Array              | Float32Array 构造函数 (23.2)  |
| %Float64Array%              | Float64Array              | Float64Array 构造函数 (23.2)  |
| %ForInIteratorPrototype%    |                           | For-In 迭代器对象的原型 (14.7.5.10) |
| %Function%                  | Function                  | Function 构造函数 (20.2.1)    |
| %GeneratorFunction%         |                           | 生成器函数对象的构造函数 (27.3.1) |
| %GeneratorPrototype%        |                           | 生成器对象的原型 (27.5)       |
| %Int8Array%                 | Int8Array                 | Int8Array 构造函数 (23.2)     |
| %Int16Array%                | Int16Array                | Int16Array 构造函数 (23.2)    |
| %Int32Array%                | Int32Array                | Int32Array 构造函数 (23.2)    |
| %isFinite%                  | isFinite                  | isFinite 函数 (19.2.2)        |
| %isNaN%                     | isNaN                     | isNaN 函数 (19.2.3)           |
| %IteratorPrototype%         |                           | 所有标准内置迭代器对象的间接继承对象 |
| %JSON%                      | JSON                      | JSON 对象 (25.5)              |
| %Map%                       | Map                       | Map 构造函数 (24.1.1)         |
| %MapIteratorPrototype%      |                           | Map 迭代器对象的原型 (24.1.5) |
| %Math%                      | Math                      | Math 对象 (21.3)              |
| %Number%                    | Number                    | Number 构造函数 (21.1.1)      |
| %Object%                    | Object                    | Object 构造函数 (20.1.1)      |
| %parseFloat%                | parseFloat                | parseFloat 函数 (19.2.4)      |
| %parseInt%                  | parseInt                  | parseInt 函数 (19.2.5)        |
| %Promise%                   | Promise                   | Promise 构造函数 (27.2.3)     |
| %Proxy%                     | Proxy                     | Proxy 构造函数 (28.2.1)       |
| %RangeError%                | RangeError                | RangeError 构造函数 (20.5.5.2) |
| %ReferenceError%            | ReferenceError            | ReferenceError 构造函数 (20.5.5.3) |
| %Reflect%                   | Reflect                   | Reflect 对象 (28.1)           |
| %RegExp%                    | RegExp                    | RegExp 构造函数 (22.2.4)      |
| %RegExpStringIteratorPrototype% |                      | RegExp String Iterator 对象的原型 (22.2.9) |
| %Set%                       | Set                       | Set 构造函数 (24.2.2)         |
| %SetIteratorPrototype%      |                           | Set 迭代器对象的原型 (24.2.6) |
| %SharedArrayBuffer%         | SharedArrayBuffer         | SharedArrayBuffer 构造函数 (25.2.3) |
| %String%                    | String                    | String 构造函数 (22.1.1)      |
| %StringIteratorPrototype%   |                           | String 迭代器对象的原型 (22.1.5) |
| %Symbol%                    | Symbol                    | Symbol 构造函数 (20.4.1)      |
| %SyntaxError%               | SyntaxError               | SyntaxError 构造函数 (20.5.5.4) |
| %ThrowTypeError%            |                           | 一个无条件抛出新的 %TypeError% 实例的函数对象 |
| %TypedArray%                |                           | 所有类型化数组构造函数的超类 (23.2.1) |
| %TypeError%                 | TypeError                 | TypeError 构造函数 (20.5.5.5) |
| %Uint8Array%                | Uint8Array                | Uint8Array 构造函数 (23.2)    |
| %Uint8ClampedArray%         | Uint8ClampedArray         | Uint8ClampedArray 构造函数 (23.2) |
| %Uint16Array%               | Uint16Array               | Uint16Array 构造函数 (23.2)   |
| %Uint32Array%               | Uint32Array               | Uint32Array 构造函数 (23.2)   |
| %URIError%                  | URIError                  | URIError 构造函数 (20.5.5.6)  |
| %WeakMap%                   | WeakMap                   | WeakMap 构造函数 (24.3.1)     |
| %WeakRef%                   | WeakRef                   | WeakRef 构造函数 (26.1.1)     |
| %WeakSet%                   | WeakSet                   | WeakSet 构造函数 (24.4.1)     |

注意：
表 97 中有更多条目。

### 6.2 ECMAScript 规范类型

规范类型对应于算法中用于描述 ECMAScript 语言构造和 ECMAScript 语言类型语义的元值。规范类型包括引用、列表、完成记录、属性描述符、环境记录、抽象闭包和数据块。规范类型的值是规范工件，不一定对应于 ECMAScript 实现中的任何具体实体。规范类型的值可以用于描述 ECMAScript 表达式求值的中间结果，但不能作为对象的属性或 ECMAScript 语言变量的值存储。

#### 6.2.1 Enum 规范类型

枚举值是内部使用的规范值，不能直接从 ECMAScript 代码中观察到。枚举值使用无衬线字体表示。例如，完成记录的 [[Type]] 字段取值为 NORMAL、RETURN 或 THROW。枚举值除了名称外没有其他特征。枚举值的名称唯一，用于区分其他枚举#### 6.2.1 Enum 规范类型

枚举值是内部使用的规范值，不能直接从 ECMAScript 代码中观察到。枚举值使用无衬线字体表示。例如，完成记录的 [[Type]] 字段取值为 NORMAL、RETURN 或 THROW。枚举值除了名称外没有其他特征。枚举值的名称唯一，用于区分其他枚举，并不暗示其在上下文中的用途或含义。

#### 6.2.2 List 和 Record 规范类型

List 类型用于解释新表达式、函数调用以及其他算法中参数列表的求值，在这些情况下需要一个简单的有序值列表。List 类型的值是包含单个值的有序序列。这些序列可以是任意长度的。列表的元素可以使用从 0 开始的索引随机访问。为了方便表示，可以使用类似数组的语法访问 List 元素。例如，arguments[2] 是表示 List 的第 3 个元素的简写。

当算法迭代 List 的元素而未指定顺序时，使用的顺序是 List 中元素的顺序。

在本规范中，可以使用字面量语法表示新的 List 值。例如，« 1, 2 » 表示一个包含两个元素的 List 值，每个元素都初始化为特定值。可以使用 « » 表示新的空 List。

在本规范中，短语“the list-concatenation of A, B, ...”（其中每个参数都是可能为空的 List）表示一个新的 List 值，其元素是每个参数的元素（按顺序）的连接。

对于字符串列表，“按字典顺序排序”一词的意思是按代码单元的数值顺序排序，最长的字符串排在最前，按照抽象操作 IsLessThan 描述的顺序进行排序。

Record 类型用于在本规范的算法中描述数据聚合。Record 类型的值由一个或多个命名字段组成。每个字段的值是 ECMAScript 语言值或规范值。字段名始终用双中括号括起来，例如 [[Value]]。

为了方便表示，可以使用类似对象字面量的语法表示 Record 值。例如，{ [[Field1]]: 42, [[Field2]]: false, [[Field3]]: EMPTY } 表示一个有三个字段的 Record 值，每个字段都初始化为特定值。字段名的顺序并不重要。未明确列出的任何字段都被视为缺失。

在规范文本和算法中，可以使用点表示法引用 Record 值的特定字段。例如，如果 R 是前一段中显示的 Record，那么 R.[[Field2]] 是“R 的 [[Field2]] 字段”的简写。

常用 Record 字段组合的架构可以命名，并且可以使用该名称作为字面量 Record 值的前缀，以标识描述的特定数据聚合类型。例如：PropertyDescriptor { [[Value]]: 42, [[Writable]]: false, [[Configurable]]: true }。

#### 6.2.3 Set 和 Relation 规范类型

Set 类型用于解释内存模型中的无序元素集合。它不同于 ECMAScript 中同名的集合类型。为了消除歧义，本规范中实例的 ECMAScript 集合始终称为“Set 对象”。Set 类型的值是简单的元素集合，其中没有元素出现多次。元素可以添加到 Set 中，也可以从 Set 中删除。Set 可以进行并集、交集或相减操作。

Relation 类型用于解释集合上的约束。Relation 类型的值是值域中的有序对的集合。例如，事件的 Relation 是事件的有序对集合。对于 Relation R 及其值域中的两个值 a 和 b，a R b 是“有序对 (a, b) 是 R 的成员”的简写。Relation 是满足某些条件的最小 Relation。

严格偏序是 Relation 值 R 满足以下条件：

对于 R 的域中的所有 a、b 和 c：

- 不存在 a R a，且
- 如果 a R b 且 b R c，则 a R c。

注意：
上述两个属性分别称为不自反性和传递性。

严格全序是 Relation 值 R 满足以下条件：

对于 R 的域中的所有 a、b 和 c：

- a 是 b 或 a R b 或 b R a，且
- 不存在 a R a，且
- 如果 a R b 且 b R c，则 a R c。

注意：
上述三个属性分别称为全域性、不自反性和传递性。

#### 6.2.4 Completion Record 规范类型

Completion Record 规范类型用于解释值的运行时传播和控制流，例如执行非局部控制转移的语句（break、continue、return 和 throw）的行为。

Completion Record 具有表 7 中定义的字段。

表 7：Completion Record 字段

| 字段名       | 值                              | 含义                      |
| ------------ | ------------------------------- | ------------------------- |
| [[Type]]     | NORMAL、BREAK、CONTINUE、RETURN 或 THROW | 发生的完成类型            |
| [[Value]]    | 除 Completion Record 以外的任何值 | 产生的值                  |
| [[Target]]   | 字符串或 EMPTY                  | 用于定向控制转移的目标标签 |

以下简写术语有时用于指代 Completion Record：

- normal completion（正常完成）指 [[Type]] 值为 NORMAL 的 Completion Record。
- break completion（中断完成）指 [[Type]] 值为 BREAK 的 Completion Record。
- continue completion（继续完成）指 [[Type]] 值为 CONTINUE 的 Completion Record。
- return completion（返回完成）指 [[Type]] 值为 RETURN 的 Completion Record。
- throw completion（抛出完成）指 [[Type]] 值为 THROW 的 Completion Record。
- abrupt completion（突然完成）指 [[Type]] 值不为 NORMAL 的 Completion Record。
- 包含某种类型值的正常完成指的是 [[Value]] 字段中包含该类型值的正常完成。

本规范中定义的可调用对象仅返回正常完成或抛出完成。返回任何其他类型的 Completion Record 被视为编辑错误。

实现定义的可调用对象必须返回正常完成或抛出完成。

##### 6.2.4.1 NormalCompletion ( value )

抽象操作 NormalCompletion 接受参数 value（除 Completion Record 以外的任何值）并返回正常完成。当被调用时执行以下步骤：

1. 返回 Completion Record { [[Type]]: NORMAL, [[Value]]: value, [[Target]]: EMPTY }。

##### 6.2.4.2 ThrowCompletion ( value )

抽象操作 ThrowCompletion 接受参数 value（ECMAScript 语言值）并返回抛出完成。当被调用时执行以下步骤：

1. 返回 Completion Record { [[Type]]: THROW, [[Value]]: value, [[Target]]: EMPTY }。

##### 6.2.4.3 UpdateEmpty ( completionRecord, value )

抽象操作 UpdateEmpty 接受参数 completionRecord（Completion Record）和 value（除 Completion Record 以外的任何值）并返回 Completion Record。当被调用时执行以下步骤：

1. 断言：如果 completionRecord 是返回完成或抛出完成，则 completionRecord.[[Value]] 不为 EMPTY。
2. 如果 completionRecord.[[Value]] 不为 EMPTY，则返回 completionRecord。
3. 返回 Completion Record { [[Type]]: completionRecord.[[Type]], [[Value]]: value, [[Target]]: completionRecord.[[Target]] }。

#### 6.2.5 Reference Record 规范类型

Reference Record 类型用于解释删除、typeof、赋值运算符、super 关键字及其他语言特性的行为。例如，赋值的左操作数应生成 Reference Record。

Reference Record 是已解析的名称或（可能尚未解析的）属性绑定；其字段由表 8 定义。

表 8：Reference Record 字段

| 字段名             | 值                                               | 含义                                                         |
| ------------------ | ------------------------------------------------ | ------------------------------------------------------------ |
| [[Base]]           | ECMAScript 语言值、环境记录或 UNRESOLVABLE       | 保存绑定的值或环境记录。UNRESOLVABLE 的 [[Base]] 表示绑定无法解析。 |
| [[ReferencedName]] | ECMAScript 语言值或私有名称                       | 绑定的名称。如果 [[Base]] 值是环境记录，则始终是字符串。否则，可能是 ECMAScript 语言值，直到执行 ToPropertyKey。 |
| [[Strict]]         | 布尔值                                           | 如果 Reference Record 起源于严格模式代码，则为 true，否则为 false。 |
| [[ThisValue]]      | ECMAScript 语言值或 EMPTY                        | 如果不是 EMPTY，则表示一个使用 super 关键字表示的属性绑定；称为 Super Reference Record，其 [[Base]] 值永远不会是环境记录。在这种情况下，[[ThisValue]] 字段保存创建 Reference Record 时的 this 值。 |

以下抽象操作用于本规范中操作 Reference Record：

##### 6.2.5.1 IsPropertyReference ( V )

抽象操作 IsPropertyReference 接受参数 V（Reference Record）并返回布尔值。当被调用时执行以下步骤：

1. 如果 V.[[Base]] 是 UNRESOLVABLE，返回 false。
2. 如果 V.[[Base]] 是环境记录，2. 如果 V.[[Base]] 是环境记录，返回 false；否则返回 true。

##### 6.2.5.2 IsUnresolvableReference ( V )

抽象操作 IsUnresolvableReference 接受参数 V（Reference Record）并返回布尔值。当被调用时执行以下步骤：

1. 如果 V.[[Base]] 是 UNRESOLVABLE，返回 true；否则返回 false。

##### 6.2.5.3 IsSuperReference ( V )

抽象操作 IsSuperReference 接受参数 V（Reference Record）并返回布尔值。当被调用时执行以下步骤：

1. 如果 V.[[ThisValue]] 不为 EMPTY，返回 true；否则返回 false。

##### 6.2.5.4 IsPrivateReference ( V )

抽象操作 IsPrivateReference 接受参数 V（Reference Record）并返回布尔值。当被调用时执行以下步骤：

1. 如果 V.[[ReferencedName]] 是私有名称，返回 true；否则返回 false。

##### 6.2.5.5 GetValue ( V )

抽象操作 GetValue 接受参数 V（Reference Record 或 ECMAScript 语言值）并返回一个正常完成包含 ECMAScript 语言值或一个突然完成。当被调用时执行以下步骤：

1. 如果 V 不是 Reference Record，返回 V。
2. 如果 IsUnresolvableReference(V) 为 true，抛出一个 ReferenceError 异常。
3. 如果 IsPropertyReference(V) 为 true，则
    a. 让 baseObj 为 ? ToObject(V.[[Base]])。
    b. 如果 IsPrivateReference(V) 为 true，则
        i. 返回 ? PrivateGet(baseObj, V.[[ReferencedName]])。
    c. 如果 V.[[ReferencedName]] 不是属性键，则
        i. 将 V.[[ReferencedName]] 设置为 ? ToPropertyKey(V.[[ReferencedName]])。
    d. 返回 ? baseObj.[[Get]](V.[[ReferencedName]], GetThisValue(V))。
4. 否则，
    a. 让 base 为 V.[[Base]]。
    b. 断言：base 是环境记录。
    c. 返回 ? base.GetBindingValue(V.[[ReferencedName]], V.[[Strict]])（见 9.1）。

注意：在步骤 3.a 中可能创建的对象在上述抽象操作和普通对象的 [[Get]] 内部方法之外不可访问。实现可以选择避免实际创建该对象。

##### 6.2.5.6 PutValue ( V, W )

抽象操作 PutValue 接受参数 V（Reference Record 或 ECMAScript 语言值）和 W（ECMAScript 语言值），并返回一个正常完成包含 UNUSED 或一个突然完成。当被调用时执行以下步骤：

1. 如果 V 不是 Reference Record，抛出一个 ReferenceError 异常。
2. 如果 IsUnresolvableReference(V) 为 true，则
    a. 如果 V.[[Strict]] 为 true，抛出一个 ReferenceError 异常。
    b. 让 globalObj 为 GetGlobalObject()。
    c. 执行 ? Set(globalObj, V.[[ReferencedName]], W, false)。
    d. 返回 UNUSED。
3. 如果 IsPropertyReference(V) 为 true，则
    a. 让 baseObj 为 ? ToObject(V.[[Base]])。
    b. 如果 IsPrivateReference(V) 为 true，则
        i. 返回 ? PrivateSet(baseObj, V.[[ReferencedName]], W)。
    c. 如果 V.[[ReferencedName]] 不是属性键，则
        i. 将 V.[[ReferencedName]] 设置为 ? ToPropertyKey(V.[[ReferencedName]])。
    d. 让 succeeded 为 ? baseObj.[[Set]](V.[[ReferencedName]], W, GetThisValue(V))。
    e. 如果 succeeded 为 false 且 V.[[Strict]] 为 true，抛出一个 TypeError 异常。
    f. 返回 UNUSED。
4. 否则，
    a. 让 base 为 V.[[Base]]。
    b. 断言：base 是环境记录。
    c. 返回 ? base.SetMutableBinding(V.[[ReferencedName]], W, V.[[Strict]])（见 9.1）。

注意：在步骤 3.a 中可能创建的对象在上述抽象操作和普通对象的 [[Set]] 内部方法之外不可访问。实现可以选择避免实际创建该对象。

##### 6.2.5.7 GetThisValue ( V )

抽象操作 GetThisValue 接受参数 V（Reference Record）并返回一个 ECMAScript 语言值。当被调用时执行以下步骤：

1. 断言：IsPropertyReference(V) 为 true。
2. 如果 IsSuperReference(V) 为 true，返回 V.[[ThisValue]]；否则返回 V.[[Base]]。

##### 6.2.5.8 InitializeReferencedBinding ( V, W )

抽象操作 InitializeReferencedBinding 接受参数 V（Reference Record）和 W（ECMAScript 语言值），并返回一个正常完成包含 UNUSED 或一个突然完成。当被调用时执行以下步骤：

1. 断言：IsUnresolvableReference(V) 为 false。
2. 让 base 为 V.[[Base]]。
3. 断言：base 是环境记录。
4. 返回 ? base.InitializeBinding(V.[[ReferencedName]], W)。

##### 6.2.5.9 MakePrivateReference ( baseValue, privateIdentifier )

抽象操作 MakePrivateReference 接受参数 baseValue（ECMAScript 语言值）和 privateIdentifier（字符串），并返回一个 Reference Record。当被调用时执行以下步骤：

1. 让 privEnv 为当前执行上下文的 PrivateEnvironment。
2. 断言：privEnv 不为 null。
3. 让 privateName 为 ResolvePrivateIdentifier(privEnv, privateIdentifier)。
4. 返回 Reference Record { [[Base]]: baseValue, [[ReferencedName]]: privateName, [[Strict]]: true, [[ThisValue]]: EMPTY }。

#### 6.2.6 属性描述符规范类型

属性描述符类型用于解释对象属性的操作和显化。属性描述符是具有零个或多个字段的记录，其中每个字段的名称是属性名，其值是表 3 中指定的相应属性值。属性描述符值可以进一步分类为数据属性描述符和访问器属性描述符，具体取决于某些字段的存在或使用。数据属性描述符是包含 [[Value]] 字段或 [[Writable]] 字段的属性描述符。访问器属性描述符是包含 [[Get]] 字段或 [[Set]] 字段的属性描述符。任何属性描述符都可以具有 [[Enumerable]] 和 [[Configurable]] 字段。一个属性描述符值不能同时是数据属性描述符和访问器属性描述符；然而，它可能是两者都不是（在这种情况下，它是一个通用属性描述符）。一个完全填充的属性描述符是一个包含所有对应字段定义的访问器属性描述符或数据属性描述符。

以下抽象操作用于本规范中操作属性描述符值：

##### 6.2.6.1 IsAccessorDescriptor ( Desc )

抽象操作 IsAccessorDescriptor 接受参数 Desc（属性描述符或未定义），并返回一个布尔值。当被调用时执行以下步骤：

1. 如果 Desc 是未定义，返回 false。
2. 如果 Desc 有 [[Get]] 字段，返回 true。
3. 如果 Desc 有 [[Set]] 字段，返回 true。
4. 返回 false。

##### 6.2.6.2 IsDataDescriptor ( Desc )

抽象操作 IsDataDescriptor 接受参数 Desc（属性描述符或未定义），并返回一个布尔值。当被调用时执行以下步骤：

1. 如果 Desc 是未定义，返回 false。
2. 如果 Desc 有 [[Value]] 字段，返回 true。
3. 如果 Desc 有 [[Writable]] 字段，返回 true。
4. 返回 false。

##### 6.2.6.3 IsGenericDescriptor ( Desc )

抽象操作 IsGenericDescriptor 接受参数 Desc（属性描述符或未定义），并返回一个布尔值。当被调用时执行以下步骤：

1. 如果 Desc 是未定义，返回 false。
2. 如果 IsAccessorDescriptor(Desc) 为 true，返回 false。
3. 如果 IsDataDescriptor(Desc) 为 true，返回 false。
4. 返回 true。

##### 6.2.6.4 FromPropertyDescriptor ( Desc )

抽象操作 FromPropertyDescriptor 接受参数 Desc（属性描述符或未定义），并返回一个对象或未定义。当被调用时执行以下步骤：

1. 如果 Desc 是未定义，返回未定义。
2. 让 obj 为 OrdinaryObjectCreate(%Object.prototype%)。
3. 断言：obj 是一个没有自有属性的可扩展普通对象。
4. 如果 Desc 有 [[Value]] 字段，则
    a. 执行 ! CreateDataPropertyOrThrow(obj, "value", Desc.[[Value]])。
5. 如果 Desc 有 [[Writable]] 字段，则
    a. 执行 ! CreateDataPropertyOrThrow(obj, "writable", Desc.[[Writable]])。
6. 如果 Desc 有 [[Get]] 字段，则
    a. 执行 ! CreateDataPropertyOrThrow(obj, "get", Desc.[[Get]])。
7. 如果 Desc 有 [[Set]] 字段，则
    a. 执行 ! CreateDataPropertyOrThrow(obj, "set", Desc.[[Set]])。
8. 如果 Desc 有 [[Enumerable]] 字段，则
    a.8. 如果 Desc 有 [[Enumerable]] 字段，则
    a. 执行 ! CreateDataPropertyOrThrow(obj, "enumerable", Desc.[[Enumerable]])。
9. 如果 Desc 有 [[Configurable]] 字段，则
    a. 执行 ! CreateDataPropertyOrThrow(obj, "configurable", Desc.[[Configurable]])。
10. 返回 obj。

##### 6.2.6.5 ToPropertyDescriptor ( Obj )

抽象操作 ToPropertyDescriptor 接受参数 Obj（ECMAScript 语言值），并返回一个正常完成包含属性描述符或一个突然完成。当被调用时执行以下步骤：

1. 如果 Obj 不是对象，抛出一个 TypeError 异常。
2. 让 desc 成为一个新的属性描述符，最初没有字段。
3. 让 hasEnumerable 为 ? HasProperty(Obj, "enumerable")。
4. 如果 hasEnumerable 为 true，则
    a. 让 enumerable 为 ToBoolean(? Get(Obj, "enumerable"))。
    b. 设置 desc.[[Enumerable]] 为 enumerable。
5. 让 hasConfigurable 为 ? HasProperty(Obj, "configurable")。
6. 如果 hasConfigurable 为 true，则
    a. 让 configurable 为 ToBoolean(? Get(Obj, "configurable"))。
    b. 设置 desc.[[Configurable]] 为 configurable。
7. 让 hasValue 为 ? HasProperty(Obj, "value")。
8. 如果 hasValue 为 true，则
    a. 让 value 为 ? Get(Obj, "value")。
    b. 设置 desc.[[Value]] 为 value。
9. 让 hasWritable 为 ? HasProperty(Obj, "writable")。
10. 如果 hasWritable 为 true，则
    a. 让 writable 为 ToBoolean(? Get(Obj, "writable"))。
    b. 设置 desc.[[Writable]] 为 writable。
11. 让 hasGet 为 ? HasProperty(Obj, "get")。
12. 如果 hasGet 为 true，则
    a. 让 getter 为 ? Get(Obj, "get")。
    b. 如果 IsCallable(getter) 为 false 且 getter 不是未定义，抛出一个 TypeError 异常。
    c. 设置 desc.[[Get]] 为 getter。
13. 让 hasSet 为 ? HasProperty(Obj, "set")。
14. 如果 hasSet 为 true，则
    a. 让 setter 为 ? Get(Obj, "set")。
    b. 如果 IsCallable(setter) 为 false 且 setter 不是未定义，抛出一个 TypeError 异常。
    c. 设置 desc.[[Set]] 为 setter。
15. 如果 desc 有 [[Get]] 字段或 desc 有 [[Set]] 字段，则
    a. 如果 desc 有 [[Value]] 字段或 desc 有 [[Writable]] 字段，抛出一个 TypeError 异常。
16. 返回 desc。

##### 6.2.6.6 CompletePropertyDescriptor ( Desc )

抽象操作 CompletePropertyDescriptor 接受参数 Desc（属性描述符），并返回 UNUSED。当被调用时执行以下步骤：

1. 让 like 成为记录 { [[Value]]: undefined, [[Writable]]: false, [[Get]]: undefined, [[Set]]: undefined, [[Enumerable]]: false, [[Configurable]]: false }。
2. 如果 IsGenericDescriptor(Desc) 为 true 或 IsDataDescriptor(Desc) 为 true，则
    a. 如果 Desc 没有 [[Value]] 字段，设置 Desc.[[Value]] 为 like.[[Value]]。
    b. 如果 Desc 没有 [[Writable]] 字段，设置 Desc.[[Writable]] 为 like.[[Writable]]。
3. 否则，
    a. 如果 Desc 没有 [[Get]] 字段，设置 Desc.[[Get]] 为 like.[[Get]]。
    b. 如果 Desc 没有 [[Set]] 字段，设置 Desc.[[Set]] 为 like.[[Set]]。
4. 如果 Desc 没有 [[Enumerable]] 字段，设置 Desc.[[Enumerable]] 为 like.[[Enumerable]]。
5. 如果 Desc 没有 [[Configurable]] 字段，设置 Desc.[[Configurable]] 为 like.[[Configurable]]。
6. 返回 UNUSED。

#### 6.2.7 环境记录规范类型

环境记录类型用于解释嵌套函数和块中名称解析的行为。该类型及其操作在 9.1 中定义。

#### 6.2.8 抽象闭包规范类型

抽象闭包规范类型用于引用算法步骤及其值集合。抽象闭包是元值，可以使用函数应用风格调用，如 closure(arg1, arg2)。与抽象操作类似，调用执行抽象闭包描述的算法步骤。

在创建抽象闭包的算法步骤中，使用动词“capture”后跟别名列表来捕获值。创建抽象闭包时，捕获与每个别名关联的值。在指定抽象闭包调用算法时，每个捕获的值通过用于捕获值的别名引用。

如果抽象闭包返回完成记录，则该完成记录必须是正常完成或抛出完成。

抽象闭包内联创建，作为其他算法的一部分，如下例所示。

1. 让 addend 为 41。
2. 让 closure 成为一个具有参数 (x) 的新抽象闭包，捕获 addend，并在调用时执行以下步骤：
    a. 返回 x + addend。
3. 让 val 为 closure(1)。
4. 断言：val 为 42。

#### 6.2.9 数据块

数据块规范类型用于描述一组独立的可变字节大小（8 位）数值序列。字节值是一个介于 0 到 255 之间的整数。数据块值创建时具有固定数量的字节，每个字节的初始值为 0。

为了方便表示，可以使用类似数组的语法访问数据块值的各个字节。这种表示法将数据块值呈现为 0 起始的整数索引字节序列。例如，如果 db 是一个 5 字节的数据块值，那么 db[2] 可以用来访问其第 3 个字节。

驻留在可以从多个代理同时引用的内存中的数据块被指定为共享数据块。共享数据块具有身份（用于等同性测试共享数据块值的身份），不与在任何进程中映射的虚拟地址绑定，而是与该数据块表示的内存位置集合绑定。两个数据块仅当它们包含的位置集合相等时才相等；否则它们不相等且它们包含的位置集合的交集为空。最后，共享数据块与数据块可以区分。

共享数据块的语义由内存模型使用共享数据块事件定义。以下抽象操作引入共享数据块事件，并作为评估语义和内存模型事件语义之间的接口。事件形成候选执行，内存模型作为过滤器。请参阅内存模型以获取完整语义。

共享数据块事件由内存模型定义的记录表示。

以下抽象操作用于本规范中操作数据块值：

##### 6.2.9.1 CreateByteDataBlock ( size )

抽象操作 CreateByteDataBlock 接受参数 size（非负整数），并返回一个正常完成包含数据块或一个突然完成。当被调用时执行以下步骤：

1. 如果 size > 2**53 - 1，抛出一个 RangeError 异常。
2. 让 db 成为一个包含 size 字节的新数据块值。如果无法创建此类数据块，抛出一个 RangeError 异常。
3. 将 db 的所有字节设置为 0。
4. 返回 db。

##### 6.2.9.2 CreateSharedByteDataBlock ( size )

抽象操作 CreateSharedByteDataBlock 接受参数 size（非负整数），并返回一个正常完成包含共享数据块或一个突然完成。当被调用时执行以下步骤：

1. 让 db 成为一个包含 size 字节的新共享数据块值。如果无法创建此类共享数据块，抛出一个 RangeError 异常。
2. 让 execution 为周围代理的代理记录的 [[CandidateExecution]] 字段。
3. 让 eventsRecord 为 execution.[[EventsRecords]] 中 [[AgentSignifier]] 是 AgentSignifier() 的代理事件记录。
4. 让 zero 为 « 0 »。
5. 对于 db 的每个索引 i，执行
    a. 将 WriteSharedMemory { [[Order]]: INIT, [[NoTear]]: true, [[Block]]: db, [[ByteIndex]]: i, [[ElementSize]]: 1, [[Payload]]: zero } 添加到 eventsRecord.[[EventList]]。
6. 返回 db。

##### 6.2.9.3 CopyDataBlockBytes ( toBlock, toIndex, fromBlock, fromIndex, count )

抽象操作 CopyDataBlockBytes 接受参数 toBlock（数据块或共享数据块）、toIndex（非负整数）、fromBlock（数据块或共享数据块）、fromIndex（非负整数）和 count（非负整数），并返回 UNUSED。当被调用时执行以下步骤：

1. 断言：fromBlock 和 toBlock 是不同的值。
2. 让 fromSize 为 fromBlock 中的字节数。
3. 断言：fromIndex + count ≤ fromSize。
44. 让 toSize 为 toBlock 中的字节数。
5. 断言：toIndex + count ≤ toSize。
6. 重复，直到 count > 0，
    a. 如果 fromBlock 是共享数据块，则
        i. 让 execution 为周围代理的代理记录的 [[CandidateExecution]] 字段。
        ii. 让 eventsRecord 为 execution.[[EventsRecords]] 中 [[AgentSignifier]] 是 AgentSignifier() 的代理事件记录。
        iii. 让 bytes 为一个列表，其中唯一的元素是一个非确定性选择的字节值。
        iv. 注意：在实现中，bytes 是底层硬件上的非原子读取指令的结果。非确定性是内存模型的语义规定，用于描述弱一致性硬件的可观察行为。
        v. 让 readEvent 为 ReadSharedMemory { [[Order]]: UNORDERED, [[NoTear]]: true, [[Block]]: fromBlock, [[ByteIndex]]: fromIndex, [[ElementSize]]: 1 }。
        vi. 将 readEvent 添加到 eventsRecord.[[EventList]]。
        vii. 将 Chosen Value Record { [[Event]]: readEvent, [[ChosenValue]]: bytes } 添加到 execution.[[ChosenValues]]。
        viii. 如果 toBlock 是共享数据块，则
            1. 将 WriteSharedMemory { [[Order]]: UNORDERED, [[NoTear]]: true, [[Block]]: toBlock, [[ByteIndex]]: toIndex, [[ElementSize]]: 1, [[Payload]]: bytes } 添加到 eventsRecord.[[EventList]]。
        ix. 否则，
            1. 设置 toBlock[toIndex] 为 bytes[0]。
    b. 否则，
        i. 断言：toBlock 不是共享数据块。
        ii. 设置 toBlock[toIndex] 为 fromBlock[fromIndex]。
    c. 设置 toIndex 为 toIndex + 1。
    d. 设置 fromIndex 为 fromIndex + 1。
    e. 设置 count 为 count - 1。
7. 返回 UNUSED。

#### 6.2.10 私有元素规范类型

私有元素类型是用于私有类字段、方法和访问器规范的记录。虽然属性描述符不用于私有元素，但私有字段的行为类似于不可配置、不可枚举、可写的数据属性，私有方法的行为类似于不可配置、不可枚举、不可写的数据属性，私有访问器的行为类似于不可配置、不可枚举的访问器属性。

私有元素类型的值是记录类型的值，其字段由表 9 定义。这些值称为私有元素。

表 9：私有元素字段
| 字段名称 | [[Kind]] 字段的值 | 值 | 含义 |
| --- | --- | --- | --- |
| [[Key]] | 所有 | 私有名称 | 字段、方法或访问器的名称 |
| [[Kind]] | 所有 | FIELD、METHOD 或 ACCESSOR | 元素的类型 |
| [[Value]] | FIELD 和 METHOD | ECMAScript 语言值 | 字段的值 |
| [[Get]] | ACCESSOR | 函数对象或未定义 | 私有访问器的 getter |
| [[Set]] | ACCESSOR | 函数对象或未定义 | 私有访问器的 setter |

#### 6.2.11 类字段定义记录规范类型

类字段定义类型是用于类字段规范的记录。

类字段定义类型的值是记录类型的值，其字段由表 10 定义。这些值称为类字段定义记录。

表 10：类字段定义记录字段
| 字段名称 | 值 | 含义 |
| --- | --- | --- |
| [[Name]] | 私有名称、字符串或符号 | 字段的名称 |
| [[Initializer]] | ECMAScript 函数对象或 EMPTY | 字段的初始化器（如果有） |

#### 6.2.12 私有名称

私有名称规范类型用于描述一个全局唯一值（一个与任何其他私有名称不同的值，即使它们在其他方面是不可区分的），表示私有类元素（字段、方法或访问器）的键。每个私有名称都有一个关联的不可变 [[Description]]，它是一个字符串值。可以使用 PrivateFieldAdd 或 PrivateMethodOrAccessorAdd 在任何 ECMAScript 对象上安装私有名称，然后使用 PrivateGet 和 PrivateSet 读取或写入。

#### 6.2.13 类静态块定义记录规范类型

类静态块定义记录是一种记录类型，用于封装类静态初始化块的可执行代码。

类静态块定义记录的字段如表 11 所示。

表 11：类静态块定义记录字段
| 字段名称 | 值 | 含义 |
| --- | --- | --- |
| [[BodyFunction]] | ECMAScript 函数对象 | 在类的静态初始化过程中调用的函数对象 |

