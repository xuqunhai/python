### 9 可执行代码和执行上下文

#### 9.1 环境记录
环境记录是一种规范类型，用于定义标识符与特定变量和函数的关联，基于 ECMAScript 代码的词法嵌套结构。通常，环境记录与 ECMAScript 代码的某些特定语法结构相关联，如 FunctionDeclaration、BlockStatement 或 TryStatement 的 Catch 子句。每次评估这些代码时，都会创建一个新的环境记录来记录由该代码创建的标识符绑定。

每个环境记录都有一个 [[OuterEnv]] 字段，它要么为 null，要么是对外部环境记录的引用。这用于模拟环境记录值的逻辑嵌套。内（inner）环境记录的外部引用是对逻辑上包围内环境记录的环境记录的引用。当然，外部环境记录也可以有它自己的外部环境记录。一个环境记录可以作为多个内环境记录的外部环境记录。例如，如果一个 FunctionDeclaration 包含两个嵌套的 FunctionDeclaration，那么每个嵌套函数的环境记录将拥有当前评估的外部函数的环境记录作为它们的外部环境记录。

环境记录纯粹是规范机制，不需要对应于 ECMAScript 实现的任何特定工件。ECMAScript 程序不可能直接访问或操作这些值。

#### 9.1.1 环境记录类型层次结构
可以认为环境记录存在于一个简单的面向对象层次结构中，其中环境记录是一个抽象类，具有三个具体子类：声明性环境记录、对象环境记录和全局环境记录。函数环境记录和模块环境记录是声明性环境记录的子类。

**环境记录 (抽象)**

声明性环境记录用于定义 ECMAScript 语言语法元素（如 FunctionDeclaration、VariableDeclaration 和 Catch 子句）的效果，这些元素直接将标识符绑定与 ECMAScript 语言值相关联。

函数环境记录对应于 ECMAScript 函数对象的调用，并包含该函数内的顶层声明绑定。它可能建立一个新的 this 绑定。它还捕获了支持 super 方法调用所需的状态。

模块环境记录包含模块的顶层声明绑定。它还包含模块显式导入的绑定。其 [[OuterEnv]] 是一个全局环境记录。

对象环境记录用于定义 ECMAScript 元素（如 WithStatement）的效果，这些元素将标识符绑定与某个对象的属性相关联。

全局环境记录用于脚本全局声明。它没有外部环境；其 [[OuterEnv]] 为 null。它可能预先填充有标识符绑定，并且包括一个关联的全局对象，其属性提供了一些全局环境的标识符绑定。随着 ECMAScript 代码的执行，可以向全局对象添加其他属性，并且可以修改初始属性。

环境记录抽象类包括表 16 中定义的抽象规范方法。这些抽象方法对每个具体子类都有不同的具体算法。

**表 16: 环境记录的抽象方法**

| 方法                   | 目的                                                                                             |
|------------------------|--------------------------------------------------------------------------------------------------|
| HasBinding(N)          | 确定环境记录是否有字符串值 N 的绑定。如果有，返回 true；否则返回 false。                           |
| CreateMutableBinding(N, D)  | 在环境记录中创建一个新的但未初始化的可变绑定。字符串值 N 是绑定名称的文本。如果布尔参数 D 为 true，则绑定可以随后被删除。  |
| CreateImmutableBinding(N, S)  | 在环境记录中创建一个新的但未初始化的不可变绑定。字符串值 N 是绑定名称的文本。如果 S 为 true，则在初始化后尝试设置它总是会抛出异常，无论引用该绑定的操作的严格模式设置如何。  |
| InitializeBinding(N, V)  | 设置环境记录中已经存在但未初始化的绑定的值。字符串值 N 是绑定名称的文本。V 是绑定的值，可以是任何 ECMAScript 语言类型的值。 |
| SetMutableBinding(N, V, S)  | 设置环境记录中已经存在的可变绑定的值。字符串值 N 是绑定名称的文本。V 是绑定的值，可以是任何 ECMAScript 语言类型的值。S 是一个布尔标志。如果 S 为 true 并且绑定不能被设置，则抛出一个 TypeError 异常。 |
| GetBindingValue(N, S)  | 从环境记录中返回已存在绑定的值。字符串值 N 是绑定名称的文本。S 用于标识来自严格模式代码或其他需要严格模式引用语义的引用。如果 S 为 true 并且绑定不存在，则抛出一个 ReferenceError 异常。如果绑定存在但未初始化，无论 S 的值如何，都会抛出一个 ReferenceError。 |
| DeleteBinding(N)  | 从环境记录中删除绑定。字符串值 N 是绑定名称的文本。如果存在 N 的绑定，删除绑定并返回 true。如果绑定存在但不能被删除，返回 false。如果绑定不存在，返回 true。 |
| HasThisBinding()  | 确定环境记录是否建立了一个 this 绑定。如果是，返回 true；否则返回 false。 |
| HasSuperBinding()  | 确定环境记录是否建立了一个 super 方法绑定。如果是，返回 true；否则返回 false。 |
| WithBaseObject()  | 如果此环境记录与一个 with 语句相关联，则返回 with 对象。否则，返回 undefined。 |

#### 9.1.1.1 声明性环境记录
每个声明性环境记录都与包含变量、常量、let、class、module、import 和/或函数声明的 ECMAScript 程序范围相关联。声明性环境记录绑定其范围内包含的声明定义的标识符集。

声明性环境记录的具体规范方法的行为由以下算法定义。

##### 9.1.1.1.1 HasBinding ( N )
声明性环境记录 envRec 的 HasBinding 具体方法接受参数 N（一个字符串）并返回包含一个布尔值的正常完成。它确定参数标识符是否是记录绑定的标识符之一。调用时执行以下步骤：

1. 如果 envRec 有 N 的绑定，返回 true。
2. 返回 false。

##### 9.1.1.1.2 CreateMutableBinding ( N, D )
声明性环境记录 envRec 的 CreateMutableBinding 具体方法接受参数 N（一个字符串）和 D（一个布尔值），并返回包含 UNUSED 的正常完成。它为名称 N 创建一个新的未初始化的可变绑定。在此环境记录中不应已有 N 的绑定。如果 D 为 true，则新绑定被标记为可以被随后删除。调用时执行以下步骤：

1. 断言：envRec 尚未有 N 的绑定。
2. 在 envRec 中创建一个 N 的可变绑定，并记录它是未初始化的。如果 D 为 true，则记录新创建的绑定可以被后续的 DeleteBinding 调用删除。
3. 返回 UNUSED。

##### 9.1.1.1.3 CreateImmutableBinding ( N, S )
声明性环境记录 envRec 的 CreateImmutableBinding 具体方法接受参数 N（一个字符串）和 S（一个布尔值），并返回包含 UNUSED 的正常完成。它为名称 N 创建一个新的未初始化的不可变绑定。在此环境记录中不应已有 N 的绑定。如果 S 为 true，则新绑定被标记为严格绑定。调用时执行以下步骤：

1. 断言：envRec 尚未有 N 的绑定。
2. 在 envRec 中创建一个 N 的不可变绑定，并记录它是未初始化的。如果 S 为 true，则记录新创建的绑定是严格绑定。
3. 返回 UNUSED。

##### 9.1.1.1.4 InitializeBinding ( N, V )
声明性环境记录 envRec 的 InitializeBinding 具体方法接受参数 N（一个字符串）和 V（一个 ECMAScript 语言值），并返回包含 UNUSED 的正常完成。它用于将名称为 N 的标识符当前绑定的值设置为 V。必须已存在一个未初始化的 N 的绑定。调用时执行以下步骤：

1. 断言：envRec 必须有一个未初始化的 N 的绑定。
2. 将 envRec 中 N 的绑定值设置为 V。
3. 记录 envRec 中 N 的绑定已被初始化。
4. 返回 UNUSED。

##### 9.1.1.1.5 SetMutableBinding ( N, V, S )
声明性环境记录 envRec 的 SetMutableBinding 具体方法接受参数 N（一个字符串）、V（一个 ECMAScript 语言值）和 S（一个布尔值），并返回包含 UNUSED 或一个抛出完成。它试图将名称为 N 的标识符当前绑定的值更改为 V。通常已经存在一个 N 的绑定，但在少数情况下可能没有。如果绑定是不可变绑定，并且 S 为 true，则抛出 TypeError。如果调用时执行以下步骤：

1. 如果 envRec 没有 N 的绑定，
  a. 如果 S 为 true，则抛出一个 ReferenceError 异常。
  b. 执行 ! envRec.CreateMutableBinding(N, true)。
  c. 执行 ! envRec.InitializeBinding(N, V)。
  d. 返回 UNUSED。
2. 如果 envRec 中 N 的绑定是一个严格绑定，则将 S 设置为true。
3. 如果 envRec 中 N 的绑定尚未初始化，
  a. 抛出一个 ReferenceError 异常。
4. 否则，如果 envRec 中 N 的绑定是一个可变绑定，
  a. 将其绑定值更改为 V。
5. 否则，
  a. 断言：这是试图更改不可变绑定的值。
  b. 如果 S 为 true，抛出一个 TypeError 异常。
6. 返回 UNUSED。

##### 9.1.1.1.6 GetBindingValue ( N, S )
声明性环境记录 envRec 的 GetBindingValue 具体方法接受参数 N（一个字符串）和 S（一个布尔值），并返回包含一个 ECMAScript 语言值的正常完成或一个抛出完成。它返回名称为 N 的绑定标识符的值。如果绑定存在但未初始化，则抛出 ReferenceError 异常，无论 S 的值如何。调用时执行以下步骤：

1. 断言：envRec 有 N 的绑定。
2. 如果 envRec 中 N 的绑定是一个未初始化的绑定，抛出一个 ReferenceError 异常。
3. 返回当前绑定到 envRec 中 N 的值。

##### 9.1.1.1.7 DeleteBinding ( N )
声明性环境记录 envRec 的 DeleteBinding 具体方法接受参数 N（一个字符串），并返回包含一个布尔值的正常完成。它只能删除明确指定为可删除的绑定。调用时执行以下步骤：

1. 断言：envRec 有 N 的绑定。
2. 如果 envRec 中 N 的绑定不能被删除，返回 false。
3. 从 envRec 中移除 N 的绑定。
4. 返回 true。

##### 9.1.1.1.8 HasThisBinding ( )
声明性环境记录 envRec 的 HasThisBinding 具体方法不接受参数并返回 false。调用时执行以下步骤：

1. 返回 false。

注意：常规声明性环境记录（即既不是函数环境记录也不是模块环境记录）不提供 this 绑定。

##### 9.1.1.1.9 HasSuperBinding ( )
声明性环境记录 envRec 的 HasSuperBinding 具体方法不接受参数并返回 false。调用时执行以下步骤：

1. 返回 false。

注意：常规声明性环境记录（即既不是函数环境记录也不是模块环境记录）不提供 super 绑定。

##### 9.1.1.1.10 WithBaseObject ( )
声明性环境记录 envRec 的 WithBaseObject 具体方法不接受参数并返回 undefined。调用时执行以下步骤：

1. 返回 undefined。

#### 9.1.1.2 对象环境记录
每个对象环境记录都与一个称为绑定对象的对象相关联。对象环境记录绑定的字符串标识符名称集合直接对应于其绑定对象的属性名称。非字符串形式的属性键不包括在绑定的标识符集合中。无论 [[Enumerable]] 属性的设置如何，既包括自己的属性，也包括继承的属性。由于可以动态添加和删除对象的属性，因此对象环境记录绑定的标识符集合可能会随任何添加或删除属性的操作而改变。由于这种副作用创建的任何绑定即使对应属性的 Writable 属性为 false，也被视为可变绑定。对象环境记录中不存在不可变绑定。

为 with 语句（14.11）创建的对象环境记录可以将其绑定对象作为隐式的 this 值用于函数调用。此功能由一个布尔 [[IsWithEnvironment]] 字段控制。

对象环境记录具有表 17 中列出的附加状态字段。

**表 17: 对象环境记录的附加字段**

| 字段名称                 | 值         | 含义                              |
|-------------------------|------------|----------------------------------|
| [[BindingObject]]       | 一个对象    | 此环境记录的绑定对象。             |
| [[IsWithEnvironment]]   | 一个布尔值  | 表示此环境记录是否为 with 语句创建。 |

对象环境记录的具体规范方法的行为由以下算法定义。

##### 9.1.1.2.1 HasBinding ( N )
对象环境记录 envRec 的 HasBinding 具体方法接受参数 N（一个字符串）并返回包含一个布尔值的正常完成或一个抛出完成。它确定其关联的绑定对象是否具有名称为 N 的属性。调用时执行以下步骤：

1. 令 bindingObject 为 envRec.[[BindingObject]]。
2. 令 foundBinding 为 ? HasProperty(bindingObject, N)。
3. 如果 foundBinding 为 false，返回 false。
4. 如果 envRec.[[IsWithEnvironment]] 为 false，返回 true。
5. 令 unscopables 为 ? Get(bindingObject, @@unscopables)。
6. 如果 unscopables 是一个对象，
  a. 令 blocked 为 ToBoolean(? Get(unscopables, N))。
  b. 如果 blocked 为 true，返回 false。
7. 返回 true。

##### 9.1.1.2.2 CreateMutableBinding ( N, D )
对象环境记录 envRec 的 CreateMutableBinding 具体方法接受参数 N（一个字符串）和 D（一个布尔值），并返回包含 UNUSED 的正常完成或一个抛出完成。它在环境记录的关联绑定对象中创建一个名称为 N 的属性，并将其初始化为 undefined。如果 D 为 true，则新属性的 [[Configurable]] 属性设置为 true；否则设置为 false。调用时执行以下步骤：

1. 令 bindingObject 为 envRec.[[BindingObject]]。
2. 执行 ? DefinePropertyOrThrow(bindingObject, N, PropertyDescriptor { [[Value]]: undefined, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: D })。
3. 返回 UNUSED。

注意：通常 envRec 不会有 N 的绑定，但如果有，DefinePropertyOrThrow 的语义可能会导致现有绑定被替换或遮蔽，或导致返回一个抛出完成。

##### 9.1.1.2.3 CreateImmutableBinding ( N, S )
对象环境记录的 CreateImmutableBinding 具体方法在本规范中从未使用。

##### 9.1.1.2.4 InitializeBinding ( N, V )
对象环境记录 envRec 的 InitializeBinding 具体方法接受参数 N（一个字符串）和 V（一个 ECMAScript 语言值），并返回包含 UNUSED 的正常完成或一个抛出完成。它用于将名称为 N 的标识符当前绑定的值设置为 V。调用时执行以下步骤：

1. 执行 ? envRec.SetMutableBinding(N, V, false)。
2. 返回 UNUSED。

注意：在本规范中，所有为对象环境记录使用的 CreateMutableBinding 都会紧接着调用 InitializeBinding，因此本规范不会显式跟踪对象环境记录中的绑定初始化状态。

##### 9.1.1.2.5 SetMutableBinding ( N, V, S )
对象环境记录 envRec 的 SetMutableBinding 具体方法接受参数 N（一个字符串）、V（一个 ECMAScript 语言值）和 S（一个布尔值），并返回包含 UNUSED 的正常完成或一个抛出完成。它尝试将环境记录的关联绑定对象的名称为 N 的属性的值设置为 V。通常已经存在一个名称为 N 的属性，但如果不存在或当前不可写，错误处理由 S 决定。调用时执行以下步骤：

1. 令 bindingObject 为 envRec.[[BindingObject]]。
2. 令 stillExists 为 ? HasProperty(bindingObject, N)。
3. 如果 stillExists 为 false 且 S 为 true，抛出一个 ReferenceError 异常。
4. 执行 ? Set(bindingObject, N, V, S)。
5. 返回 UNUSED。

##### 9.1.1.2.6 GetBindingValue ( N, S )
对象环境记录 envRec 的 GetBindingValue 具体方法接受参数 N（一个字符串）和 S（一个布尔值），并返回包含一个 ECMAScript 语言值的正常完成或一个抛出完成。它返回其关联绑定对象的名称为 N 的属性的值。属性应该已经存在，但如果不存在，结果取决于 S。调用时执行以下步骤：

1. 令 bindingObject 为 envRec.[[BindingObject]]。
2. 令 value 为 ? HasProperty(bindingObject, N)。
3. 如果 value 为 false，
  a. 如果 S 为 false，返回 undefined；否则抛出一个 ReferenceError 异常。
4. 返回 ? Get(bindingObject, N)。

##### 9.1.1.2.7 DeleteBinding ( N )
对象环境记录 envRec 的 DeleteBinding 具体方法接受参数 N（一个字符串），并返回包含一个布尔值的正常完成或一个抛出完成。它只能删除对应于环境对象属性且其 [[Configurable]] 属性为 true 的绑定。调用时执行以下步骤：

1. 令 bindingObject 为 envRec.[[BindingObject]]。
2. 返回 ? bindingObject.[[Delete]](N)。

##### 9.1.1.2.8 HasThisBinding ( )
对象环境记录 envRec 的 HasThisBinding 具体方法不接受参数并返回 false。调用时执行以下步骤：

1. 返回 false。

注意：对象环境记录不提供 this 绑定。

##### 9.1.1.2.9 HasSuperBinding ( )
对象环境记录 envRec 的 HasSuperBinding 
具体方法不接受参数并返回 false。调用时执行以下步骤：

1. 返回 false。

注意：对象环境记录不提供 super 绑定。

##### 9.1.1.2.10 WithBaseObject ( )
对象环境记录 envRec 的 WithBaseObject 具体方法不接受参数，并返回一个对象或 undefined。调用时执行以下步骤：

1. 如果 envRec.[[IsWithEnvironment]] 为 true，返回 envRec.[[BindingObject]]。
2. 否则，返回 undefined。

#### 9.1.1.3 函数环境记录
函数环境记录是一个声明性环境记录，用于表示函数的顶级作用域，并且如果该函数不是箭头函数，还提供一个 this 绑定。如果一个函数不是箭头函数并且引用了 super，那么它的函数环境记录还包含用于在函数内部执行 super 方法调用的状态。

函数环境记录具有表 18 中列出的附加状态字段。

**表 18: 函数环境记录的附加字段**

| 字段名称              | 值                           | 含义                                     |
|----------------------|------------------------------|----------------------------------------|
| [[ThisValue]]        | 一个 ECMAScript 语言值       | 此函数调用中使用的 this 值。               |
| [[ThisBindingStatus]]| LEXICAL, INITIALIZED, UNINITIALIZED | 如果值为 LEXICAL，则这是一个箭头函数，没有本地的 this 值。 |
| [[FunctionObject]]   | 一个 ECMAScript 函数对象      | 导致创建此环境记录的函数对象。              |
| [[NewTarget]]        | 一个对象或 undefined          | 如果此环境记录是由 [[Construct]] 内部方法创建的，[[NewTarget]] 是 [[Construct]] newTarget 参数的值。否则，其值为 undefined。 |

函数环境记录支持表 16 中列出的所有声明性环境记录方法，并且除了 HasThisBinding 和 HasSuperBinding 方法外，所有这些方法的规范都相同。此外，函数环境记录还支持表 19 中列出的方法：

**表 19: 函数环境记录的附加方法**

| 方法              | 目的                                                                 |
|------------------|----------------------------------------------------------------------|
| BindThisValue(V) | 设置 [[ThisValue]] 并记录它已被初始化。                                |
| GetThisBinding() | 返回此环境记录的 this 绑定的值。如果 this 绑定尚未初始化，则抛出 ReferenceError 异常。 |
| GetSuperBase()   | 返回在此环境记录中绑定的 super 属性访问的基础对象。值为 undefined 表示这种访问将产生运行时错误。 |

函数环境记录附加的具体规范方法的行为由以下算法定义：

##### 9.1.1.3.1 BindThisValue ( V )
函数环境记录 envRec 的 BindThisValue 具体方法接受参数 V（一个 ECMAScript 语言值），并返回包含一个 ECMAScript 语言值的正常完成或一个抛出完成。调用时执行以下步骤：

1. 断言：envRec.[[ThisBindingStatus]] 不是 LEXICAL。
2. 如果 envRec.[[ThisBindingStatus]] 是 INITIALIZED，抛出一个 ReferenceError 异常。
3. 将 envRec.[[ThisValue]] 设置为 V。
4. 将 envRec.[[ThisBindingStatus]] 设置为 INITIALIZED。
5. 返回 V。

##### 9.1.1.3.2 HasThisBinding ( )
函数环境记录 envRec 的 HasThisBinding 具体方法不接受参数并返回一个布尔值。调用时执行以下步骤：

1. 如果 envRec.[[ThisBindingStatus]] 是 LEXICAL，返回 false；否则，返回 true。

##### 9.1.1.3.3 HasSuperBinding ( )
函数环境记录 envRec 的 HasSuperBinding 具体方法不接受参数并返回一个布尔值。调用时执行以下步骤：

1. 如果 envRec.[[ThisBindingStatus]] 是 LEXICAL，返回 false。
2. 如果 envRec.[[FunctionObject]].[[HomeObject]] 是 undefined，返回 false；否则，返回 true。

##### 9.1.1.3.4 GetThisBinding ( )
函数环境记录 envRec 的 GetThisBinding 具体方法不接受参数并返回包含一个 ECMAScript 语言值的正常完成或一个抛出完成。调用时执行以下步骤：

1. 断言：envRec.[[ThisBindingStatus]] 不是 LEXICAL。
2. 如果 envRec.[[ThisBindingStatus]] 是 UNINITIALIZED，抛出一个 ReferenceError 异常。
3. 返回 envRec.[[ThisValue]]。

##### 9.1.1.3.5 GetSuperBase ( )
函数环境记录 envRec 的 GetSuperBase 具体方法不接受参数并返回包含一个对象、null 或 undefined 的正常完成或一个抛出完成。调用时执行以下步骤：

1. 令 home 为 envRec.[[FunctionObject]].[[HomeObject]]。
2. 如果 home 是 undefined，返回 undefined。
3. 断言：home 是一个对象。
4. 返回 ? home.[[GetPrototypeOf]]()。

#### 9.1.1.4 全局环境记录
全局环境记录用于表示所有在同一领域中处理的 ECMAScript 脚本元素共享的最外层作用域。全局环境记录提供内建全局（第 19 章）、全局对象的属性和所有在全局代码中出现的顶级声明（8.2.9，8.2.11）的绑定。

全局环境记录逻辑上是一个单独的记录，但它被指定为一个复合体，封装了一个对象环境记录和一个声明性环境记录。对象环境记录的基础对象是关联领域记录的全局对象。这个全局对象是全局环境记录的 GetThisBinding 具体方法返回的值。全局环境记录的对象环境记录部分包含所有内建全局（第 19 章）和在全局代码中包含的 FunctionDeclaration、GeneratorDeclaration、AsyncFunctionDeclaration、AsyncGeneratorDeclaration 或 VariableStatement 的绑定。所有其他 ECMAScript 声明在全局代码中的绑定包含在全局环境记录的声明性环境记录部分中。

可以直接在全局对象上创建属性。因此，全局环境记录的对象环境记录部分可能包含显式由 FunctionDeclaration、GeneratorDeclaration、AsyncFunctionDeclaration、AsyncGeneratorDeclaration 或 VariableDeclaration 声明创建的绑定，也可能包含隐式作为全局对象的属性创建的绑定。为了识别哪些绑定是使用声明显式创建的，全局环境记录维护一个名称列表，用于记录其 CreateGlobalVarBinding 和 CreateGlobalFunctionBinding 具体方法绑定的名称。

全局环境记录具有表 20 中列出的附加字段和表 21 中列出的附加方法。

**表 20: 全局环境记录的附加字段**

| 字段名称            | 值                     | 含义                                                                                               |
|--------------------|------------------------|--------------------------------------------------------------------------------------------------|
| [[ObjectRecord]]   | 一个对象环境记录        | 绑定对象是全局对象。它包含全局内建绑定以及在关联领域的全局代码中的 FunctionDeclaration、GeneratorDeclaration、AsyncFunctionDeclaration、AsyncGeneratorDeclaration 和 VariableDeclaration 绑定。 |
| [[GlobalThisValue]]| 一个对象               | 在全局作用域中由 this 返回的值。宿主可以提供任何 ECMAScript 对象值。                                                 |
| [[DeclarativeRecord]] | 一个声明性环境记录    | 包含关联领域的全局代码中除 FunctionDeclaration、GeneratorDeclaration、AsyncFunctionDeclaration、AsyncGeneratorDeclaration 和 VariableDeclaration 绑定之外的所有声明绑定。 |
| [[VarNames]]       | 一个字符串列表          | 由 FunctionDeclaration、GeneratorDeclaration、AsyncFunctionDeclaration、AsyncGeneratorDeclaration 和 VariableDeclaration 声明在全局代码中绑定的字符串名称。 |

**表 21: 全局环境记录的附加方法**

| 方法                      | 目的                                                                                                                                                                                                                                                                   |
|---------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| GetThisBinding()          | 返回此环境记录的 this 绑定的值。                                                                                                                                                                                                                                         |
| HasVarDeclaration(N)      | 确定参数标识符是否在此环境记录中具有由 VariableDeclaration、FunctionDeclaration、GeneratorDeclaration、AsyncFunctionDeclaration 或 AsyncGeneratorDeclaration 创建的绑定。                                                                                               |
| HasLexicalDeclaration(N)  | 确定参数标识符是否在此环境记录中具有由词法声明（如 LexicalDeclaration 或 ClassDeclaration）创建的绑定。                                                                                                                                                                 |
| HasRestrictedGlobalProperty(N) | 确定参数是否是全局对象属性的名称，这些属性不能被全局词法绑定所遮蔽。                                                                                                                                                                                                  |
| CanDeclareGlobalVar(N)    | 确定如果为相同参数 N 调用相应的 CreateGlobalVarBinding 调用是否会成功。允许冗余的 var 声明和预先存在的全局对象属性的 var 声明。                                                                                                                                              |
| CanDeclareGlobalFunction(N)| 确定如果为相同参数 N 调用相应的 CreateGlobalFunctionBinding 调用是否会成功。                                                                                                                                                                                              |
| CreateGlobalVarBinding(N, D)| 在 [[ObjectRecord]] 组件的全局环境记录中创建并初始化为 undefined 的全局 var 绑定。绑定将是一个可变绑定。对应的全局对象属性将具有适合 var 的属性值。字符串值 N 是绑定名称。如果 D 为 true，则绑定可以被删除。逻辑上等同于 CreateMutableBinding 之后跟随 SetMutableBinding，但它允许 var 声明获得特殊处理。|
| CreateGlobalFunctionBinding(N, V, D) | 在 [[ObjectRecord]] 组件的全局环境记录中创建并初始化一个全局函数绑定。绑定将是一个可变绑定。对应的全局对象属性将具有适合函数的属性值。字符串值 N 是绑定名称。V 是初始化值。如果布尔参数 D 为 true，则绑定可以被删除。逻辑上等同于 CreateMutableBinding 之后跟随 SetMutableBinding，但它允许函数声明获得特殊处理。|

全局环境记录的具体规范方法的行为由以下算法定义。

##### 9.1.1.4.1 HasBinding ( N )
全局环境记录 envRec 的 HasBinding 具体方法接受参数 N（一个字符串）并返回包含一个布尔值的正常完成或一个抛出完成。它确定参数标识符是否是记录绑定的标识符之一。调用时执行以下步骤：

1. 令 DclRec 为 envRec.[[DeclarativeRecord]]。
2. 如果 ! DclRec.HasBinding(N) 为 true，返回 true。
3. 令 ObjRec 为 envRec.[[ObjectRecord]]。
4. 返回 ? ObjRec.HasBinding(N)。

##### 9.1.1.4.2 CreateMutableBinding ( N, D )
全局环境记录 envRec 的 CreateMutableBinding 具体方法接受参数 N（一个字符串）和 D（一个布尔值），并返回包含 UNUSED 的正常完成或一个抛出完成。它为名称 N 创建一个新的未初始化的可变绑定。绑定在关联的 DeclarativeRecord 中创建。此 DeclarativeRecord 中不应已有 N 的绑定。如果 D 为 true，则新绑定被标记为可以被删除。调用时执行以下步骤：

1. 令 DclRec 为 envRec.[[DeclarativeRecord]]。
2. 如果 ! DclRec.HasBinding(N) 为 true，抛出一个 TypeError 异常。
3. 返回 ! DclRec.CreateMutableBinding(N, D)。

##### 9.1.1.4.3 CreateImmutableBinding ( N, S )
全局环境记录 envRec 的 CreateImmutableBinding 具体方法接受参数 N（一个字符串）和 S（一个布尔值），并返回包含 UNUSED 的正常完成或一个抛出完成。它为名称 N 创建一个新的未初始化的不可变绑定。在此环境记录中不应已有 N 的绑定。如果 S 为 true，则新绑定被标记为严格绑定。调用时执行以下步骤：

1. 令 DclRec 为 envRec.[[DeclarativeRecord]]。
2. 如果 ! DclRec.HasBinding(N) 为 true，抛出一个 TypeError 异常。
3. 返回 ! DclRec.CreateImmutableBinding(N, S)。

##### 9.1.1.4.4 InitializeBinding ( N, V )
全局环境记录 envRec 的 InitializeBinding 具体方法接受参数 N（一个字符串）和 V（一个 ECMAScript 语言值），并返回包含 UNUSED 的正常完成或一个抛出完成。它用于将名称为 N 的标识符当前绑定的值设置为 V。必须已存在一个未初始化的 N 的绑定。调用时执行以下步骤：

1. 令 DclRec 为 envRec.[[DeclarativeRecord]]。
2. 如果 ! DclRec.HasBinding(N) 为 true，
  a. 返回 ! DclRec.InitializeBinding(N, V)。
3. 断言：如果绑定存在，它必须在对象环境记录中。
4. 令 ObjRec 为 envRec.[[ObjectRecord]]。
5. 返回 ? ObjRec.InitializeBinding(N, V)。

##### 9.1.1.4.5 SetMutableBinding ( N, V, S )
全局环境记录 envRec 的 SetMutableBinding 具体方法接受参数 N（一个字符串）、V（一个 ECMAScript 语言值）和 S（一个布尔值），并返回包含 UNUSED 的正常完成或一个抛出完成。它尝试将名称为 N 的标识符当前绑定的值更改为 V。如果绑定是不可变绑定并且 S 为 true，则抛出 TypeError。调用时执行以下步骤：

1. 令 DclRec 为 envRec.[[DeclarativeRecord]]。
2. 如果 ! DclRec.HasBinding(N) 为 true，
  a. 返回 ? DclRec.SetMutableBinding(N, V, S)。
3. 令 ObjRec 为 envRec.[[ObjectRecord]]。
4. 返回 ? ObjRec.SetMutableBinding(N, V, S)。

##### 9.1.1.4.6 GetBindingValue ( N, S )
全局环境记录 envRec 的 GetBindingValue 具体方法接受参数 N（一个字符串）和 S（一个布尔值），并返回包含一个 ECMAScript 语言值的正常完成或一个抛出完成。它返回名称为 N 的绑定标识符的值。如果绑定是未初始化的绑定，则抛出 ReferenceError 异常。调用时执行以下步骤：

1. 令 DclRec 为 envRec.[[DeclarativeRecord]]。
2. 如果 ! DclRec.HasBinding(N) 为 true，
  a. 返回 ? DclRec.GetBindingValue(N, S)。
3. 令 ObjRec 为 envRec.[[ObjectRecord]]。
4. 返回 ? ObjRec.GetBindingValue(N, S)。

##### 9.1.1.4.7 DeleteBinding ( N )
全局环境记录 envRec 的 DeleteBinding 具体方法接受参数 N（一个字符串），并返回包含一个布尔值的正常完成或一个抛出完成。它只能删除明确指定为可删除的绑定。调用时执行以下步骤：

1. 令 DclRec 为 envRec.[[DeclarativeRecord]]。
2. 如果 ! DclRec.HasBinding(N) 为 true，
  a. 返回 ! DclRec.DeleteBinding(N)。
3. 令 ObjRec 为 envRec.[[ObjectRecord]]。
4. 令 globalObject 为 ObjRec.[[BindingObject]]。
5. 令 existingProp 为 ? HasOwnProperty(globalObject, N)。
6. 如果 existingProp 为 true，
  a. 令 status 为 ? ObjRec.DeleteBinding(N)。
  b. 如果 status 为 true 且 envRec.[[VarNames]] 包含 N，
    i. 从 envRec.[[VarNames]] 中移除 N。
  c. 返回 status。
7. 返回 true。

##### 9.1.1.4.8 HasThisBinding ( )
全局环境记录 envRec 的 HasThisBinding 具体方法不接受参数并返回 true。调用时执行以下步骤：

1. 返回 true。

注意：全局环境记录始终提供 this 绑定。

##### 9.1.1.4.9 HasSuperBinding ( )
全局环境记录 envRec 的 HasSuperBinding 具体方法不接受参数并返回 false。调用时执行以下步骤：

1. 返回 false。

注意：全局环境记录不提供 super 绑定。

##### 9.1.1.4.10 WithBaseObject ( )
全局环境记录 envRec 的 WithBaseObject 具体方法不接受参数并返回 undefined。调用时执行以下步骤：

1. 返回 undefined。

##### 9.1.1.4.11 GetThisBinding ( )
全局环境记录 envRec 的 GetThisBinding 具体方法不接受参数并返回一个对象的正常完成。调用时执行以下步骤：

1. 返回 envRec.[[GlobalThisValue]]。

##### 9.1.1.4.12 HasVarDeclaration ( N )
全局环境记录 envRec 的 HasVarDeclaration 具体方法接受参数 N（一个字符串）并返回一个布尔值。它确定参数标识符是否在此记录中具有由 VariableDeclaration、FunctionDeclaration、GeneratorDeclaration、AsyncFunctionDeclaration 或 AsyncGeneratorDeclaration 创建的绑定。调用时执行以下步骤：

1. 令 varDeclaredNames 为 envRec.[[VarNames]]。
2. 如果 varDeclaredNames 包含 N，返回 true。
3. 返回 false。

##### 9.1.1.4.13 HasLexicalDeclaration ( N )
全局环境记录 envRec 的 HasLexicalDeclaration 具体方法接受参数 N（一个字符串）并返回一个布尔值。它确定参数标识符是否在此记录中具有由词法声明（如 LexicalDeclaration 或 ClassDeclaration）创建的绑定。调用时执行以下步骤：

1. 令 DclRec 为 envRec.[[DeclarativeRecord]]。
2. 返回 ! DclRec.HasBinding(N)。

##### 9.1.1.4.14 HasRestrictedGlobalProperty ( N )
全局环境记录 envRec 的 HasRestrictedGlobalProperty 具体方法接受参数 N（一个字符串）并返回包含一个布尔值的正常完成或一个抛出完成。它确定参数标识符是否是全局对象的属性名称，这些属性不能被全局词法绑定所遮蔽。调用时执行以下步骤：

1. 令 ObjRec 为 envRec.[[ObjectRecord]]。
2. 令 globalObject 为 ObjRec.[[BindingObject]]。
3. 令 existingProp 为 ? globalObject.[[GetOwnProperty]](N)。
4. 如果 existingProp 为 undefined，返回 false。
5. 如果 existingProp.[[Configurable]] 为 true，返回 false。
6. 返回 true。

注意：属性可能直接在全局对象上创建，而不是通过 var 或 function 声明创建。不能创建与全局对象不可配置属性同名的全局词法绑定。“undefined” 就是这种属性的一个例子。

##### 9.1.1.4.15 CanDeclareGlobalVar ( N )
全局环境记录 envRec 的 CanDeclareGlobalVar 具体方法接受参数 N（一个字符串），并返回包含一个布尔值的正常完成或一个抛出完成。它确定如果为相同参数 N 调用相应的 CreateGlobalVarBinding 是否会成功。允许冗余的 var 声明和已有的全局对象属性的 var 声明。调用时执行以下步骤：

1. 令 ObjRec 为 envRec.[[ObjectRecord]]。
2. 令 globalObject 为 ObjRec.[[BindingObject]]。
3. 令 hasProperty 为 ? HasOwnProperty(globalObject, N)。
4. 如果 hasProperty 为 true，返回 true。
5. 返回 ? IsExtensible(globalObject)。

##### 9.1.1.4.16 CanDeclareGlobalFunction ( N )
全局环境记录 envRec 的 CanDeclareGlobalFunction 具体方法接受参数 N（一个字符串），并返回包含一个布尔值的正常完成或一个抛出完成。它确定如果为相同参数 N 调用相应的 CreateGlobalFunctionBinding 是否会成功。调用时执行以下步骤：

1. 令 ObjRec 为 envRec.[[ObjectRecord]]。
2. 令 globalObject 为 ObjRec.[[BindingObject]]。
3. 令 existingProp 为 ? globalObject.[[GetOwnProperty]](N)。
4. 如果 existingProp 为 undefined，返回 ? IsExtensible(globalObject)。
5. 如果 existingProp.[[Configurable]] 为 true，返回 true。
6. 如果 IsDataDescriptor(existingProp) 为 true 且 existingProp 的属性值为 { [[Writable]]: true, [[Enumerable]]: true }，返回 true。
7. 返回 false。

##### 9.1.1.4.17 CreateGlobalVarBinding ( N, D )
全局环境记录 envRec 的 CreateGlobalVarBinding 具体方法接受参数 N（一个字符串）和 D（一个布尔值），并返回包含 UNUSED 的正常完成或一个抛出完成。它在关联的对象环境记录中创建并初始化一个全局 var 绑定，并在关联的 [[VarNames]] 列表中记录绑定名称。如果已存在绑定，则重用它并假设它已初始化。调用时执行以下步骤：

1. 令 ObjRec 为 envRec.[[ObjectRecord]]。
2. 令 globalObject 为 ObjRec.[[BindingObject]]。
3. 令 hasProperty 为 ? HasOwnProperty(globalObject, N)。
4. 令 extensible 为 ? IsExtensible(globalObject)。
5. 如果 hasProperty 为 false 且 extensible 为 true，
  a. 执行 ? ObjRec.CreateMutableBinding(N, D)。
  b. 执行 ? ObjRec.InitializeBinding(N, undefined)。
6. 如果 envRec.[[VarNames]] 不包含 N，
  a. 将 N 添加到 envRec.[[VarNames]] 中。
7. 返回 UNUSED。

##### 9.1.1.4.18 CreateGlobalFunctionBinding ( N, V, D )
全局环境记录 envRec 的 CreateGlobalFunctionBinding 具体方法接受参数 N（一个字符串）、V（一个 ECMAScript 语言值）和 D（一个布尔值），并返回包含 UNUSED 的正常完成或一个抛出完成。它在关联的对象环境记录中创建并初始化一个全局函数绑定，并在关联的 [[VarNames]] 列表中记录绑定名称。如果已存在绑定，则替换它。调用时执行以下步骤：

1. 令 ObjRec 为 envRec.[[ObjectRecord]]。
2. 令 globalObject 为 ObjRec.[[BindingObject]]。
3. 令 existingProp 为 ? globalObject.[[GetOwnProperty]](N)。
4. 如果 existingProp 为 undefined 或 existingProp.[[Configurable]] 为 true，
  a. 令 desc 为 PropertyDescriptor { [[Value]]: V, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: D }。
5. 否则，
  a. 令 desc 为 PropertyDescriptor { [[Value]]: V }。
6. 执行 ? DefinePropertyOrThrow(globalObject, N, desc)。
7. 执行 ? Set(globalObject, N, V, false)。
8. 如果 envRec.[[VarNames]] 不包含 N，
  a. 将 N 添加到 envRec.[[VarNames]] 中。
9. 返回 UNUSED。

注意：全局函数声明始终表示为全局对象的自有属性。如果可能，现有的自有属性将被重新配置以具有一组标准属性值。第 7 步等同于调用 InitializeBinding 具体方法所做的，并且如果 globalObject 是一个代理，将产生相同的代理陷阱调用序列。

##### 9.1.1.5 模块环境记录
模块环境记录是一个声明性环境记录，用于表示 ECMAScript 模块的外部作用域。除了常规的可变和不可变绑定外，模块环境记录还提供不可变的导入绑定，这些绑定提供对另一个环境记录中存在的目标绑定的间接访问。

模块环境记录支持表 16 中列出的所有声明性环境记录方法，并且除了 GetBindingValue、DeleteBinding、HasThisBinding 和 GetThisBinding 之外，所有这些方法的规范都相同。此外，模块环境记录还支持表 22 中列出的方法：

**表 22: 模块环境记录的附加方法**

| 方法                     | 目的                                                                                       |
|-------------------------|------------------------------------------------------------------------------------------|
| CreateImportBinding(N, M, N2) | 在模块环境记录中创建一个不可变的间接绑定。字符串值 N 是绑定名称的文本。M 是一个模块记录，N2 是 M 的模块环境记录中存在的绑定。   |
| GetThisBinding()        | 返回此环境记录的 this 绑定的值。                                                           |

模块环境记录附加的具体规范方法的行为由以下算法定义：

##### 9.1.1.5.1 GetBindingValue ( N, S )
模块环境记录 envRec 的 GetBindingValue 具体方法接受参数 N（一个字符串）和 S（一个布尔值），并返回包含一个 ECMAScript 语言值的正常完成或一个抛出完成。它返回名称为 N 的绑定标识符的值。但是，如果绑定是一个间接绑定，则返回目标绑定的值。如果绑定存在但未初始化，则抛出 ReferenceError 异常。调用时执行以下步骤：

1. 断言：S 为 true。
2. 断言：envRec 有 N 的绑定。
3. 如果 N 的绑定是一个间接绑定，
  a. 令 M 和 N2 为创建此 N 绑定时提供的间接值。
  b. 令 targetEnv 为 M.[[Environment]]。
  c. 如果 targetEnv 是 EMPTY，抛出一个 ReferenceError 异常。
  d. 返回 ? targetEnv.GetBindingValue(N2, true)。
4. 如果 envRec 中 N 的绑定是一个未初始化的绑定，抛出一个 ReferenceError 异常。
5. 返回当前绑定到 N 的值在 envRec 中。

注意：S 始终为 true，因为模块始终是严格模式代码。

##### 9.1.1.5.2 DeleteBinding ( N )
模块环境记录的 DeleteBinding 具体方法在本规范中从未使用。

注意：模块环境记录仅在严格代码中使用，并且一个早期错误规则阻止在严格代码中对解析为模块环境记录绑定的引用记录应用 delete 操作符。见 13.5.1.1。

##### 9.1.1.5.3 HasThisBinding ( )
模块环境记录 envRec 的 HasThisBinding 具体方法不接受参数并返回 true。调用时执行以下步骤：

1. 返回 true。

注意：模块环境记录始终提供 this 绑定。

##### 9.1.1.5.4 GetThisBinding ( )
模块环境记录 envRec 的 GetThisBinding 具体方法不接受参数并返回一个包含 undefined 的正常完成。调用时执行以下步骤：

1. 返回 undefined。

##### 9.1.1.5.5 CreateImportBinding ( N, M, N2 )
模块环境记录 envRec 的 CreateImportBinding 具体方法接受参数 N（一个字符串）、M（一个模块记录）和 N2（一个字符串），并返回 UNUSED。它为名称 N 创建一个新的已初始化的不可变间接绑定。在此环境记录中不应已有 N 的绑定。N2 是 M 的模块环境记录中存在的绑定名称。对新绑定值的访问将间接访问目标绑定的值。调用时执行以下步骤：

1. 断言：envRec 尚未有 N 的绑定。
2. 断言：当 M.[[Environment]] 实例化时，它将有一个对 N2 的直接绑定。
3. 在 envRec 中为 N 创建一个不可变的间接绑定，该绑定引用 M 和 N2 作为其目标绑定，并记录该绑定已初始化。
4. 返回 UNUSED。

#### 9.1.2 环境记录操作
本规范中使用以下抽象操作来操作环境记录：

##### 9.1.2.1 GetIdentifierReference ( env, name, strict )
抽象操作 GetIdentifierReference接受参数 env（一个环境记录或 null）、name（一个字符串）和 strict（一个布尔值），并返回包含一个引用记录的正常完成或一个抛出完成。调用时执行以下步骤：

1. 如果 env 为 null，
  a. 返回引用记录 { [[Base]]: UNRESOLVABLE, [[ReferencedName]]: name, [[Strict]]: strict, [[ThisValue]]: EMPTY }。
2. 令 exists 为 ? env.HasBinding(name)。
3. 如果 exists 为 true，
  a. 返回引用记录 { [[Base]]: env, [[ReferencedName]]: name, [[Strict]]: strict, [[ThisValue]]: EMPTY }。
4. 否则，
  a. 令 outer 为 env.[[OuterEnv]]。
  b. 返回 ? GetIdentifierReference(outer, name, strict)。

##### 9.1.2.2 NewDeclarativeEnvironment ( E )
抽象操作 NewDeclarativeEnvironment 接受参数 E（一个环境记录或 null），并返回一个声明性环境记录。调用时执行以下步骤：

1. 令 env 为一个新的声明性环境记录，不包含任何绑定。
2. 将 env.[[OuterEnv]] 设置为 E。
3. 返回 env。

##### 9.1.2.3 NewObjectEnvironment ( O, W, E )
抽象操作 NewObjectEnvironment 接受参数 O（一个对象）、W（一个布尔值）和 E（一个环境记录或 null），并返回一个对象环境记录。调用时执行以下步骤：

1. 令 env 为一个新的对象环境记录。
2. 将 env.[[BindingObject]] 设置为 O。
3. 将 env.[[IsWithEnvironment]] 设置为 W。
4. 将 env.[[OuterEnv]] 设置为 E。
5. 返回 env。

##### 9.1.2.4 NewFunctionEnvironment ( F, newTarget )
抽象操作 NewFunctionEnvironment 接受参数 F（一个 ECMAScript 函数对象）和 newTarget（一个对象或 undefined），并返回一个函数环境记录。调用时执行以下步骤：

1. 令 env 为一个新的函数环境记录，不包含任何绑定。
2. 将 env.[[FunctionObject]] 设置为 F。
3. 如果 F.[[ThisMode]] 为 LEXICAL，将 env.[[ThisBindingStatus]] 设置为 LEXICAL。
4. 否则，将 env.[[ThisBindingStatus]] 设置为 UNINITIALIZED。
5. 将 env.[[NewTarget]] 设置为 newTarget。
6. 将 env.[[OuterEnv]] 设置为 F.[[Environment]]。
7. 返回 env。

##### 9.1.2.5 NewGlobalEnvironment ( G, thisValue )
抽象操作 NewGlobalEnvironment 接受参数 G（一个对象）和 thisValue（一个对象），并返回一个全局环境记录。调用时执行以下步骤：

1. 令 objRec 为 NewObjectEnvironment(G, false, null)。
2. 令 dclRec 为 NewDeclarativeEnvironment(null)。
3. 令 env 为一个新的全局环境记录。
4. 将 env.[[ObjectRecord]] 设置为 objRec。
5. 将 env.[[GlobalThisValue]] 设置为 thisValue。
6. 将 env.[[DeclarativeRecord]] 设置为 dclRec。
7. 将 env.[[VarNames]] 设置为一个新的空列表。
8. 将 env.[[OuterEnv]] 设置为 null。
9. 返回 env。

##### 9.1.2.6 NewModuleEnvironment ( E )
抽象操作 NewModuleEnvironment 接受参数 E（一个环境记录），并返回一个模块环境记录。调用时执行以下步骤：

1. 令 env 为一个新的模块环境记录，不包含任何绑定。
2. 将 env.[[OuterEnv]] 设置为 E。
3. 返回 env。

### 9.2 私有环境记录

私有环境记录是一种规范机制，用于根据 ECMAScript 代码中的类声明（ClassDeclarations）和类表达式（ClassExpressions）的词法嵌套结构来跟踪私有名称（Private Names）。它们类似于环境记录，但有所不同。每个私有环境记录与一个类声明或类表达式相关联。每次评估这样的类时，都会创建一个新的私有环境记录，以记录该类声明的私有名称。

每个私有环境记录都有表 23 中定义的字段。

#### 表 23: 私有环境记录字段

| 字段名称                  | 值类型                          | 含义                                                  |
| ----------------------- | ---------------------------- | --------------------------------------------------- |
| [[OuterPrivateEnvironment]] | 私有环境记录或 null              | 最近的包含类的私有环境记录。如果该私有环境记录关联的类不包含在任何其他类中，则为 null。 |
| [[Names]]                 | 私有名称列表                    | 该类声明的私有名称。                                        |

#### 9.2.1 私有环境记录操作

在本规范中使用以下抽象操作来操作私有环境记录：

##### 9.2.1.1 NewPrivateEnvironment ( outerPrivEnv )
抽象操作 NewPrivateEnvironment 接受参数 outerPrivEnv（一个私有环境记录或 null），并返回一个私有环境记录。调用时执行以下步骤：

1. 令 names 为一个新的空列表。
2. 返回私有环境记录 { [[OuterPrivateEnvironment]]: outerPrivEnv, [[Names]]: names }。

##### 9.2.1.2 ResolvePrivateIdentifier ( privEnv, identifier )
抽象操作 ResolvePrivateIdentifier 接受参数 privEnv（一个私有环境记录）和 identifier（一个字符串），并返回一个私有名称。调用时执行以下步骤：

1. 令 names 为 privEnv.[[Names]]。
2. 对于 names 中的每个私有名称 pn，执行
   a. 如果 pn.[[Description]] 为 identifier，则
      i. 返回 pn。
3. 令 outerPrivEnv 为 privEnv.[[OuterPrivateEnvironment]]。
4. 断言：outerPrivEnv 不是 null。
5. 返回 ResolvePrivateIdentifier(outerPrivEnv, identifier)。

### 9.3 范围（Realms）

在评估之前，所有 ECMAScript 代码必须与一个范围相关联。从概念上讲，一个范围由一组内在对象、一个 ECMAScript 全局环境、在该全局环境范围内加载的所有 ECMAScript 代码以及其他相关状态和资源组成。

在本规范中，一个范围表示为一个范围记录（Realm Record），其字段在表 24 中规定：

#### 表 24: 范围记录字段

| 字段名称             | 值                             | 含义                                                        |
| ----------------- | --------------------------- | --------------------------------------------------------- |
| [[AgentSignifier]] | 一个代理标识符                  | 拥有该范围的代理                                            |
| [[Intrinsics]]     | 一个记录，其字段名称为内在键，其值为对象 | 与该范围相关的代码使用的内在值                                  |
| [[GlobalObject]]   | 一个对象或 undefined         | 该范围的全局对象                                              |
| [[GlobalEnv]]      | 一个全局环境记录                | 该范围的全局环境                                              |
| [[TemplateMap]]    | 一个记录列表，字段 [[Site]]（一个模板文字解析节点）和 [[Array]]（一个数组） | 模板对象分别为每个范围使用其范围记录的 [[TemplateMap]] 进行规范化。每个 [[Site]] 值是一个模板文字解析节点。关联的 [[Array]] 值是传递给标签函数的相应模板对象。 |
| [[LoadedModules]]  | 一个记录列表，字段 [[Specifier]]（一个字符串）和 [[Module]]（一个模块记录） | 从此范围导入的说明符字符串到已解析模块记录的映射。列表中不包含具有相同 [[Specifier]] 的两个不同记录。    |
| [[HostDefined]]    | 任意值（默认值为 undefined）   | 保留供需要与范围记录关联其他信息的主机使用的字段。                          |

#### 9.3.1 InitializeHostDefinedRealm ( )
抽象操作 InitializeHostDefinedRealm 不接受任何参数，返回包含 UNUSED 的正常完成或抛出完成。调用时执行以下步骤：

1. 令 realm 为一个新的范围记录。
2. 执行 CreateIntrinsics(realm)。
3. 将 realm.[[AgentSignifier]] 设置为 AgentSignifier()。
4. 将 realm.[[GlobalObject]] 设置为 undefined。
5. 将 realm.[[GlobalEnv]] 设置为 undefined。
6. 将 realm.[[TemplateMap]] 设置为一个新的空列表。
7. 令 newContext 为一个新的执行上下文。
8. 将 newContext 的 Function 设置为 null。
9. 将 newContext 的 Realm 设置为 realm。
10. 将 newContext 的 ScriptOrModule 设置为 null。
11. 将 newContext 推入执行上下文栈；newContext 现在是正在运行的执行上下文。
12. 如果主机需要使用一个异质对象作为 realm 的全局对象，
   a. 令 global 为以主机定义的方式创建的这样的对象。
13. 否则，
   a. 令 global 为 OrdinaryObjectCreate(realm.[[Intrinsics]].[[%Object.prototype%]])。
14. 如果主机需要 realm 的全局范围内的 this 绑定返回全局对象以外的对象，
   a. 令 thisValue 为以主机定义的方式创建的这样的对象。
15. 否则，
   a. 令 thisValue 为 global。
16. 将 realm.[[GlobalObject]] 设置为 global。
17. 将 realm.[[GlobalEnv]] 设置为 NewGlobalEnvironment(global, thisValue)。
18. 执行 ? SetDefaultGlobalBindings(realm)。
19. 在 global 上创建任何主机定义的全局对象属性。
20. 返回 UNUSED。

#### 9.3.2 CreateIntrinsics ( realmRec )
抽象操作 CreateIntrinsics 接受参数 realmRec（一个范围记录），并返回 UNUSED。调用时执行以下步骤：

1. 将 realmRec.[[Intrinsics]] 设置为一个新的记录。
2. 使用表 6 中列出的值设置 realmRec.[[Intrinsics]] 的字段。字段名称是表第一列中列出的名称。每个字段的值是一个新的对象值，完全且递归地填充了该对象在第 19 到 28 节中定义的属性值。所有对象属性值都是新创建的对象值。所有内置函数对象的值都是通过执行 CreateBuiltinFunction(steps, length, name, slots, realmRec, prototype) 创建的，其中 steps 是本规范提供的该函数的定义，name 是该函数 "name" 属性的初始值，length 是该函数 "length" 属性的初始值，slots 是函数指定的内部插槽的名称列表（如果有），prototype 是函数的 [[Prototype]] 内部插槽的指定值。内在对象及其属性的创建顺序必须避免对尚未创建的对象的依赖。
3. 执行 AddRestrictedFunctionProperties(realmRec.[[Intrinsics]].[[%Function.prototype%]], realmRec)。
4. 返回 UNUSED。

#### 9.3.3 SetDefaultGlobalBindings ( realmRec )
抽象操作 SetDefaultGlobalBindings 接受参数 realmRec（一个范围记录），并返回包含 UNUSED 的正常完成或抛出完成。调用时执行以下步骤：

1. 令 global 为 realmRec.[[GlobalObject]]。
2. 对于第 19 节中指定的全局对象的每个属性，执行
   a. 令 name 为属性名称的字符串值。
   b. 令 desc 为该属性的完全填充的数据属性描述符，包含该属性的指定属性。对于 19.2、19.3 或 19.4 中列出的属性，[[Value]] 属性的值是 realmRec 中相应的内在对象。
   c. 执行 ? DefinePropertyOrThrow(global, name, desc)。
3. 返回 UNUSED。

### 9.4 执行上下文

执行上下文是一个规范设备，用于跟踪 ECMAScript 实现代码的运行时评估。在任何时候，每个代理最多只有一个实际执行代码的执行上下文。这被称为代理的运行执行上下文。本规范中所有对运行执行上下文的引用均表示周围代理的运行执行上下文。

执行上下文栈用于跟踪执行上下文。运行执行上下文始终是该栈的顶元素。每当控制从当前运行执行上下文关联的可执行代码转移到与该上下文不关联的可执行代码时，都会创建一个新的执行上下文。新创建的执行上下文被推入栈中并成为运行执行上下文。

执行上下文包含跟踪其关联代码的执行进度所需的任何实现特定状态。每个执行上下文至少包含表 25 中列出的状态组件。

#### 表 25: 所有执行上下文的状态组件

| 组件                      | 目的                                                                 |
| ----------------------- | ------------------------------------------------------------------ |
| 代码评估状态               | 执行与此执行上下文关联的代码所需的任何状态，包括暂停和恢复评估。                               |
| 函| 组件            | 目的                                                                 |
| ------------- | ------------------------------------------------------------------ |
| 函数            | 如果此执行上下文正在评估一个函数对象的代码，那么该组件的值是该函数对象。如果上下文正在评估一个脚本或模块的代码，该值为 null。 |
| Realm         | 该上下文所关联代码访问 ECMAScript 资源的范围记录。                                |
| ScriptOrModule| 该上下文所关联代码的模块记录或脚本记录。如果没有关联的脚本或模块，例如在 InitializeHostDefinedRealm 创建的初始执行上下文的情况，该值为 null。 |

通过运行执行上下文的代码评估可以在本规范定义的各种点暂停。一旦运行执行上下文被暂停，另一个执行上下文可能成为运行执行上下文并开始评估其代码。在稍后的某个时间，已暂停的执行上下文可能再次成为运行执行上下文并从先前暂停的点继续评估其代码。运行执行上下文状态在执行上下文之间的转换通常以堆栈的后进先出方式进行。然而，一些 ECMAScript 特性需要非 LIFO 的运行执行上下文转换。

运行执行上下文的 Realm 组件的值也称为当前范围记录。运行执行上下文的函数组件的值也称为活动函数对象。

ECMAScript 代码执行上下文有表 26 中列出的其他状态组件。

#### 表 26: ECMAScript 代码执行上下文的其他状态组件

| 组件               | 目的                                                                      |
| ---------------- | ----------------------------------------------------------------------- |
| 词法环境（LexicalEnvironment） | 标识用于在此执行上下文中解析标识符引用的环境记录。                                       |
| 变量环境（VariableEnvironment） | 标识在此执行上下文中由 VariableStatements 创建的绑定的环境记录。                        |
| 私有环境（PrivateEnvironment）  | 标识由最近包含的类中的 ClassElements 创建的私有名称的私有环境记录。如果没有包含类，则为 null。 |

词法环境和变量环境组件始终是环境记录。

代表生成器评估的执行上下文有表 27 中列出的其他状态组件。

#### 表 27: 生成器执行上下文的其他状态组件

| 组件       | 目的                                      |
| -------- | --------------------------------------- |
| 生成器       | 此执行上下文正在评估的生成器。                         |

在大多数情况下，只有运行执行上下文（执行上下文栈的顶部）由本规范中的算法直接操作。因此，当术语“词法环境”和“变量环境”不加修饰地使用时，它们是指运行执行上下文的这些组件。

执行上下文纯粹是一个规范机制，不必对应于 ECMAScript 实现的任何特定工件。ECMAScript 代码无法直接访问或观察执行上下文。

#### 9.4.1 GetActiveScriptOrModule ( )
抽象操作 GetActiveScriptOrModule 不接受任何参数，返回一个脚本记录、模块记录或 null。它用于根据运行执行上下文确定正在运行的脚本或模块。调用时执行以下步骤：

1. 如果执行上下文栈为空，返回 null。
2. 令 ec 为执行上下文栈中顶层的 ScriptOrModule 组件不为 null 的执行上下文。
3. 如果不存在这样的执行上下文，返回 null。否则，返回 ec 的 ScriptOrModule。

#### 9.4.2 ResolveBinding ( name [ , env ] )
抽象操作 ResolveBinding 接受参数 name（一个字符串）和可选参数 env（一个环境记录或 undefined），返回一个包含参考记录的正常完成或抛出完成。它用于确定 name 的绑定。env 可用于显式提供要搜索绑定的环境记录。调用时执行以下步骤：

1. 如果未提供 env 或 env 为 undefined，
   a. 将 env 设置为运行执行上下文的词法环境。
2. 断言：env 是一个环境记录。
3. 令 strict 为正在评估的语法生成的 IsStrict。
4. 返回 ? GetIdentifierReference(env, name, strict)。

注意：ResolveBinding 的结果始终是一个其 [[ReferencedName]] 字段为 name 的参考记录。

#### 9.4.3 GetThisEnvironment ( )
抽象操作 GetThisEnvironment 不接受任何参数，返回一个环境记录。它查找当前提供 this 绑定的环境记录。调用时执行以下步骤：

1. 令 env 为运行执行上下文的词法环境。
2. 重复，
   a. 令 exists 为 env.HasThisBinding()。
   b. 如果 exists 为 true，返回 env。
   c. 令 outer 为 env.[[OuterEnv]]。
   d. 断言：outer 不是 null。
   e. 将 env 设置为 outer。

注意：步骤 2 中的循环总会终止，因为环境列表总是以提供 this 绑定的全局环境结束。

#### 9.4.4 ResolveThisBinding ( )
抽象操作 ResolveThisBinding 不接受任何参数，返回一个包含 ECMAScript 语言值的正常完成或抛出完成。它使用运行执行上下文的词法环境确定 this 的绑定。调用时执行以下步骤：

1. 令 envRec 为 GetThisEnvironment()。
2. 返回 ? envRec.GetThisBinding()。

#### 9.4.5 GetNewTarget ( )
抽象操作 GetNewTarget 不接受任何参数，返回一个对象或 undefined。它使用运行执行上下文的词法环境确定 NewTarget 的值。调用时执行以下步骤：

1. 令 envRec 为 GetThisEnvironment()。
2. 断言：envRec 具有 [[NewTarget]] 字段。
3. 返回 envRec.[[NewTarget]]。

#### 9.4.6 GetGlobalObject ( )
抽象操作 GetGlobalObject 不接受任何参数，返回一个对象。它返回当前运行执行上下文使用的全局对象。调用时执行以下步骤：

1. 令 currentRealm 为当前范围记录。
2. 返回 currentRealm.[[GlobalObject]]。


### 9.5 任务和主机操作来安排任务

任务是一个没有参数的抽象闭包，当没有其他 ECMAScript 计算正在进行时启动一个 ECMAScript 计算。

ECMAScript 主机环境在特定代理中安排任务执行。本规范描述了用于安排任务的主机钩子 `HostEnqueueGenericJob`、`HostEnqueueFinalizationRegistryCleanupJob`、`HostEnqueuePromiseJob` 和 `HostEnqueueTimeoutJob`。本规范中的主机钩子根据对任务安排施加的额外约束进行组织。主机可以定义其他安排任务的抽象操作。这些操作接受一个任务抽象闭包和一个 realm（一个 Realm 记录或 null）作为参数。如果提供了 Realm 记录，这些操作会安排在提供的 Realm 中在其拥有的代理上执行任务。如果提供的是 null，那么任务不会评估 ECMAScript 代码。它们的实现必须符合以下要求：

在将来的某个时间点，当任务安排的代理中没有运行上下文且该代理的执行上下文堆栈为空时，实施必须：
1. 执行任何主机定义的准备步骤。
2. 调用任务抽象闭包。
3. 执行任何主机定义的清理步骤，之后执行上下文堆栈必须为空。
4. 在任何时间点，一个代理中只能有一个任务在进行评估。
5. 一旦任务评估开始，必须在评估任何其他任务之前完成。
6. 抽象闭包必须返回正常完成，自己处理错误。

**注意 1**：主机环境不需要统一对待任务安排。例如，Web 浏览器和 Node.js 将 Promise 处理任务视为比其他工作更高的优先级；未来的特性可能会添加不被如此优先对待的任务。

在特定时间点，如果以下所有条件为真，则 scriptOrModule（一个脚本记录、一个模块记录或 null）是活动的脚本或模块：
1. `GetActiveScriptOrModule()` 是 scriptOrModule。
2. 如果 scriptOrModule 是一个脚本记录或模块记录，则令 ec 为执行上下文堆栈中顶层的执行上下文，其 ScriptOrModule 组件为 scriptOrModule。ec 的 Realm 组件是 scriptOrModule.[[Realm]]。

在特定时间点，如果以下所有条件为真，则一个执行准备评估 ECMAScript 代码：
1. 执行上下文堆栈不为空。
2. 执行上下文堆栈顶层的执行上下文的 Realm 组件是一个 Realm 记录。

**注意 2**：主机环境可以通过将执行上下文推送到执行上下文堆栈来准备评估代码。具体步骤由实现定义。

特定的 Realm 选择由主机环境决定。这个初始执行上下文和 Realm 仅在任何回调函数被调用之前使用。当与任务相关的回调函数（如 Promise 处理程序）被调用时，调用会推送其自身的执行上下文和 Realm。

特定类型的任务有额外的合规要求。

### 9.5.1 JobCallback 记录

JobCallback 记录是一个用于存储函数对象和主机定义值的记录值。通过主机安排的任务调用的函数对象可能有额外的主机定义上下文。为了传递状态，任务抽象闭包不应直接捕获和调用函数对象。相反，使用 `HostMakeJobCallback` 和 `HostCallJobCallback`。

**注意**：例如，WHATWG HTML 规范（<https://html.spec.whatwg.org/>）使用主机定义值来传递 Promise 回调的现有设置对象。

JobCallback 记录有表 28 中列出的字段。

#### 表 28: JobCallback 记录字段

| 字段名         | 值                 | 含义                         |
| ------------- | ------------------ | -------------------------- |
| [[Callback]]  | 一个函数对象       | 当任务被调用时调用的函数。      |
| [[HostDefined]] | 任意值（默认值为空） | 预留给主机使用的字段。          |

### 9.5.2 HostMakeJobCallback ( callback )

主机定义的抽象操作 `HostMakeJobCallback` 接受参数 callback（一个函数对象）并返回一个 JobCallback 记录。

`HostMakeJobCallback` 的实现必须符合以下要求：
1. 它必须返回一个 JobCallback 记录，其 [[Callback]] 字段是 callback。

默认的 `HostMakeJobCallback` 实现执行以下步骤：

1. 返回 JobCallback 记录 { [[Callback]]: callback, [[HostDefined]]: EMPTY }。

非 Web 浏览器的 ECMAScript 主机必须使用默认的 `HostMakeJobCallback` 实现。

**注意**：在将回调传递给负责最终安排和运行的函数时调用此操作。例如，`promise.then(thenAction)` 在调用 `Promise.prototype.then` 时对 thenAction 调用 `MakeJobCallback`，而不是在安排反应任务时。

### 9.5.3 HostCallJobCallback ( jobCallback, V, argumentsList )

主机定义的抽象操作 `HostCallJobCallback` 接受参数 jobCallback（一个 JobCallback 记录）、V（一个 ECMAScript 语言值）和 argumentsList（一个 ECMAScript 语言值的列表），返回一个包含 ECMAScript 语言值的正常完成或抛出完成。

`HostCallJobCallback` 的实现必须符合以下要求：
1. 它必须执行并返回 `Call(jobCallback.[[Callback]], V, argumentsList)` 的结果。

**注意**：此要求意味着主机不能更改本规范中定义的函数对象的 [[Call]] 行为。

默认的 `HostCallJobCallback` 实现执行以下步骤：

1. 断言：`IsCallable(jobCallback.[[Callback]])` 为 true。
2. 返回 `? Call(jobCallback.[[Callback]], V, argumentsList)`。

非 Web 浏览器的 ECMAScript 主机必须使用默认的 `HostCallJobCallback` 实现。

### 9.5.4 HostEnqueueGenericJob ( job, realm )

主机定义的抽象操作 `HostEnqueueGenericJob` 接受参数 job（一个任务抽象闭包）和 realm（一个 Realm 记录）并返回 UNUSED。它在 realm 代表的代理中安排在某个未来时间执行任务。与此算法一起使用的抽象闭包旨在安排而没有额外的约束，例如优先级和排序。

`HostEnqueueGenericJob` 的实现必须符合 9.5 中的要求。

### 9.5.5 HostEnqueuePromiseJob ( job, realm )

主机定义的抽象操作 `HostEnqueuePromiseJob` 接受参数 job（一个任务抽象闭包）和 realm（一个 Realm 记录或 null）并返回 UNUSED。它安排任务在某个未来时间执行。与此算法一起使用的抽象闭包旨在与 Promise 处理操作相关或以与 Promise 处理操作相等的优先级安排。

`HostEnqueuePromiseJob` 的实现必须符合 9.5 中的要求以及以下要求：

1. 如果 realm 不是 null，每次调用 job 时，实施必须执行实现定义的步骤，以便在调用 job 时准备好评估 ECMAScript 代码。
2. 令 scriptOrModule 为调用 `HostEnqueuePromiseJob` 时的 `GetActiveScriptOrModule()`。如果 realm 不是 null，每次调用 job 时，实施必须执行实现定义的步骤，以便在调用 job 时 scriptOrModule 是活动的脚本或模块。
3. 任务必须按照安排它们的 `HostEnqueuePromiseJob` 调用的顺序运行。

**注意**：`NewPromiseResolveThenableJob` 返回的任务的 realm 通常是调用 then 函数对象上的 `GetFunctionRealm` 的结果。`NewPromiseReactionJob` 返回的任务的 realm 通常是调用处理程序（如果处理程序不是 undefined）上的 `GetFunctionRealm` 的结果。如果处理程序是 undefined，realm 为 null。对于这两种任务，当 `GetFunctionRealm` 异常完成时（例如，在被撤销的 Proxy 上调用），realm 是 `GetFunctionRealm` 调用时的当前 Realm 记录。当 realm 为 null 时，不会评估用户 ECMAScript 代码，也不会创建新的 ECMAScript 对象（例如错误对象）。例如，WHATWG HTML 规范（<https://html.spec.whatwg.org/>）使用 realm 检查运行脚本的能力和入口概念。

### 9.5.6 HostEnqueueTimeoutJob ( timeoutJob, realm, milliseconds )

主机定义的抽象操作 `HostEnqueueTimeoutJob` 接受参数 timeoutJob（一个任务抽象闭包）、realm（一个 Realm 记录）和 milliseconds（一个非负有限数字）并返回 UNUSED。它在 realm 代表的代理中安排在至少 milliseconds 毫秒后执行任务。

`HostEnqueueTimeoutJob` 的实现必须符合 9.5 中的要求。

### 9.6 代理

代理包括一组 ECMAScript 执行上下文、一个执行上下文堆栈、一个运行执行上下文、一个代理记录和一个执行线程。除了执行线程，代理的组成部分专属于该代理。

代理的执行线程独立于其他代理执行### 代理的执行上下文，除非某个代理共享的执行线程具有多个代理，并且没有代理记录的 [[CanBlock]] 字段为 true。

**注意 1**：例如，一些 Web 浏览器在多个不相关的浏览器窗口选项卡之间共享单个执行线程。

当代理的执行线程正在执行算法步骤时，该代理是这些步骤的周围代理。这些步骤使用周围代理访问代理内持有的规范级执行对象：运行执行上下文、执行上下文堆栈和代理记录的字段。

代理标识符是一个全局唯一的、不透明的值，用于标识一个代理。

#### 表 29：代理记录字段

| 字段名            | 值                | 含义                                                                 |
| ----------------- | ----------------- | -------------------------------------------------------------------- |
| [[LittleEndian]]  | 布尔值            | 当算法 GetValueFromBuffer 和 SetValueInBuffer 需要时计算的 isLittleEndian 参数的默认值。选择是实现定义的，应选择对实现最有效的替代方案。一旦观察到该值，它就不能更改。       |
| [[CanBlock]]      | 布尔值            | 确定代理是否可以阻塞。                                               |
| [[Signifier]]     | 代理标识符        | 唯一标识代理集群中的代理。                                           |
| [[IsLockFree1]]   | 布尔值            | 如果对一个字节值的原子操作是无锁的，则为 true，否则为 false。         |
| [[IsLockFree2]]   | 布尔值            | 如果对两个字节值的原子操作是无锁的，则为 true，否则为 false。         |
| [[IsLockFree8]]   | 布尔值            | 如果对八个字节值的原子操作是无锁的，则为 true，否则为 false。         |
| [[CandidateExecution]] | 候选执行记录  | 参见内存模型。                                                      |
| [[KeptAlive]]     | 对象或符号的列表 | 最初是一个新的空列表，表示直到当前任务结束为止要保持活跃的对象和/或符号的列表。 |

一旦集群中的任何代理观察到 [[Signifier]]、[[IsLockFree1]] 和 [[IsLockFree2]] 的值，它们就不能更改。

**注意 2**：[[IsLockFree1]] 和 [[IsLockFree2]] 的值不一定由硬件决定，还可能反映实现选择，这些选择可能会随时间和 ECMAScript 实现而有所不同。

没有 [[IsLockFree4]] 字段：4 字节的原子操作始终是无锁的。

实际上，如果原子操作使用任何类型的锁，该操作就不是无锁的。无锁不意味着无等待：没有上限，说明完成无锁原子操作可能需要多少机器步骤。

原子访问大小 n 的无锁性并不暗示非原子访问大小 n 的（感知的）原子性，具体来说，非原子访问可能仍作为多个独立的内存访问序列执行。有关详细信息，请参阅 ReadSharedMemory 和 WriteSharedMemory。

**注意 3**：代理是一个规范机制，不必对应于任何特定的 ECMAScript 实现工件。

### 9.6.1 AgentSignifier ( )

抽象操作 AgentSignifier 不接受参数并返回一个代理标识符。它在调用时执行以下步骤：

1. 令 AR 为周围代理的代理记录。
2. 返回 AR.[[Signifier]]。

### 9.6.2 AgentCanSuspend ( )

抽象操作 AgentCanSuspend 不接受参数并返回一个布尔值。它在调用时执行以下步骤：

1. 令 AR 为周围代理的代理记录。
2. 返回 AR.[[CanBlock]]。

**注意**：在某些环境中，某个代理可能无法合理地挂起。例如，在 Web 浏览器环境中，可能不允许挂起文档的主事件处理线程，而允许挂起工人的事件处理线程。

### 9.7 代理集群

代理集群是可以通过操作共享内存进行通信的代理的最大集合。

**注意 1**：不同代理中的程序可能通过未指定的方法共享内存。最小化，共享数组缓冲区的底层内存可以在集群中的代理之间共享。

可能有一些代理可以通过消息传递进行通信，但不能共享内存；它们永远不会在同一个代理集群中。

每个代理正好属于一个代理集群。

**注意 2**：集群中的代理不必在特定时间点全部活跃。如果代理 A 创建了另一个代理 B，随后 A 终止且 B 创建了代理 C，则这三个代理处于同一个集群中，如果 A 可以与 B 共享一些内存且 B 可以与 C 共享一些内存。

集群中的所有代理必须在各自代理记录的 [[LittleEndian]] 字段中具有相同的值。

**注意 3**：如果代理集群中的不同代理具有不同的 [[LittleEndian]] 值，共享内存进行多字节数据处理会变得困难。

集群中的所有代理必须在各自代理记录的 [[IsLockFree1]] 字段中具有相同的值；类似地，对于 [[IsLockFree2]] 字段。

集群中的所有代理必须在各自代理记录的 [[Signifier]] 字段中具有不同的值。

嵌入可以在不通知或配合代理的情况下停用（停止前进进程）或激活（恢复前进进程）代理。如果嵌入这样做，它不得无限期地让集群中的某些代理保持活跃而让其他代理停用。

**注意 4**：上述限制的目的是避免代理死锁或饿死的情况。例如，如果一个 HTML 共享工人的生命周期独立于任何窗口中的文档，并且允许它与此类独立文档的专用工人共享内存，而文档及其专用工人停用时（例如，文档被推入其窗口的历史中），如果专用工人持有锁并且共享工人尝试获取锁，则共享工人将被阻塞，直到专用工人再次激活（如果有的话）。与此同时，尝试从其他窗口访问共享工人的其他工人将饿死。

上述限制意味着，无法在嵌入中共享内存的代理之间共享内存。

嵌入可以在没有集群其他代理事先通知或配合的情况下终止代理。如果代理不是通过其自身或集群中其他代理的程序动作终止，而是通过集群外部的力量终止，则嵌入必须选择两种策略之一：要么终止集群中的所有代理，要么提供可靠的 API，使集群中的代理能够协调，以便至少一个剩余成员能够检测到终止，终止数据包含足够的信息来识别被终止的代理。

**注意 5**：这种类型终止的示例包括：操作系统或用户终止运行在单独进程中的代理；当每代理资源计数指示代理失控时，嵌入本身终止与其他代理在同一进程中运行的代理。

以下每个规范值及其传递可达的值正好属于一个代理集群：

- 候选执行记录
- 共享数据块
- 等待者列表记录

在集群中的任何代理评估任何 ECMAScript 代码之前，所有代理的代理记录中的 [[CandidateExecution]] 字段设置为初始候选执行。初始候选执行是一个空候选执行，其 [[EventsRecords]] 字段是一个包含每个代理的代理事件记录的列表，每个代理事件记录的 [[AgentSignifier]] 字段是该代理的代理标识符，其 [[EventList]] 和 [[AgentSynchronizesWith]] 字段为空列表。

**注意 6**：集群中的所有代理在其代理记录的 [[CandidateExecution]] 字段中共享相同的候选执行。候选执行是内存模型使用的规范机制。

**注意 7**：代理集群是一个规范机制，不必对应于任何特定的 ECMAScript 实现工件。

### 9.8 前进进度

代理进行前进进度是指其根据本规范执行评估步骤。

当代理的运行执行上下文同步且无限期地等待外部事件时，该代理被阻塞。只有代理记录的 [[CanBlock]] 字段为 true 的代理才能以这种方式被阻塞。未阻塞的代理是未被阻塞的代理。

实施必须确保：

- 每个具有专用执行线程的未阻塞代理最终进行前进进度
- 在共享执行线程的一组代理中，一个代理最终进行前进进度
- 除非通过显式 API 提供阻塞，否则代理不会导致另一个代理被阻塞

**注意**：这与内存模型中的活性保证一起，确保所有 SEQ-CST 写入最终对所有代理可观察。

### 9.9 弱引用和终结注册表目标的处理模型

#### 9.9.1 目标

本规范不保证任何对象或符号将被垃圾回收。非活动对象或符号可能在长时间后释放，也可能永远不会释放。因此，本规范在描述由垃圾回收触发的行为时使用了“可能”一词。

弱引用和终结注册表的语义基于在特定时间点发生的两个操作：

1. 当调用 `WeakRef.prototype.deref` 时，引用对象（如果未返回 undefined）将保持活跃，以便后续同步访问也返回相同的值。当通过 `ClearKeptObjects` 抽象操作进行同步工作时，此列表将被重置。
2. 当一个对象或符号与一个终结注册表关联变得不可访问时，可能会在同步 ECMAScript 执行完成后最终调用终结注册表的清理回调。终结注册表清理通过 `CleanupFinalizationRegistry` 抽象操作进行。

这些操作（`ClearKeptObjects` 或 `CleanupFinalizationRegistry`）都不得中断同步 ECMAScript 执行。由于主机可以组合更长的同步 ECMAScript 执行运行，本规范将 `ClearKeptObjects` 和 `CleanupFinalizationRegistry` 的调度推迟到主机环境。

一些 ECMAScript 实现包括在后台运行的垃圾收集器，包括 ECMAScript 空闲时运行的垃圾收集器。让主机环境调度 `CleanupFinalizationRegistry` 允许它恢复 ECMAScript 执行以运行终结器工作，这可能释放持有的值，减少整体内存使用。

#### 9.9.2 活跃性

对于对象和/或符号集 S，一个假设的弱引用无关的执行（相对于 S）是一个执行，其中 `WeakRefDeref` 对一个弱引用，其引用对象是 S 的元素，总是返回 undefined。

**注意 1**：弱引用无关性与活跃性捕捉了两个概念。首先，弱引用本身不会保持其引用对象活跃。其次，活跃性中的循环并不意味着值是活跃的。具体来说，如果确定 v 的活跃性依赖于确定弱引用引用对象 r 的活跃性，r 的活跃性不能假设 v 的活跃性，否则将是循环推理。

**注意 2**：弱引用无关性是针对对象或符号集而不是单个值定义的，以处理循环。如果定义在单个值上，则在循环中的弱引用引用对象将被视为活跃，即使它的身份仅通过循环中的其他弱引用引用对象观察到。

**注意 3**：通俗地说，如果包含某个值的每个集合都是活跃的，则我们说该单个对象或符号是活跃的。

在评估期间的任何时候，如果对象和/或符号集 S 满足以下任一条件，则 S 被认为是活跃的：

- S 中的任何元素包含在任何代理的 `[[KeptAlive]]` 列表中。
- 存在一个有效的未来假设弱引用无关的执行，相对于 S，该执行观察到 S 中任何值的身份。

**注意 4**：上述第二个条件旨在捕捉这样一种直觉，即如果一个值的身份通过非弱引用手段可观察，则该值是活跃的。通过观察严格相等比较或观察将该值用作 Map 的键，可以观察到一个值的身份。

**注意 5**：值在字段、内部插槽或属性中的存在并不意味着该值是活跃的。例如，如果该值从未传递回程序，则无法观察到它。这是弱映射中的键、弱集合的成员以及终结注册表单元记录的 `[[WeakRefTarget]]` 和 `[[UnregisterToken]]` 字段的情况。

上述定义意味着，如果弱映射中的键不是活跃的，则其对应的值也不一定是活跃的。

**注意 6**：活跃性是保证哪些弱引用引擎不得清空的下限。此处定义的活跃性是不可判定的。实际上，引擎使用保守的近似，如可达性。预计会有显著的实现余地。

#### 9.9.3 执行

在任何时候，如果对象和/或符号集 S 不是活跃的，则 ECMAScript 实现可能原子地执行以下步骤：

1. 对于 S 的每个元素值，执行以下步骤：
   a. 对于每个弱引用 ref，使 ref.[[WeakRefTarget]] 为 value，执行以下步骤：
      i. 将 ref.[[WeakRefTarget]] 设置为 EMPTY。
   b. 对于每个终结注册表 fg，使 fg.[[Cells]] 包含记录 cell，其 [[WeakRefTarget]] 为 value，执行以下步骤：
      i. 将 cell.[[WeakRefTarget]] 设置为 EMPTY。
      ii. 可选地，执行 `HostEnqueueFinalizationRegistryCleanupJob(fg)`。
   c. 对于每个弱映射 map，使 map.[[WeakMapData]] 包含记录 r，其 [[Key]] 为 value，执行以下步骤：
      i. 将 r.[[Key]] 设置为 EMPTY。
      ii. 将 r.[[Value]] 设置为 EMPTY。
   d. 对于每个弱集合 set，使 set.[[WeakSetData]] 包含 value，执行以下步骤：
      i. 将 set.[[WeakSetData]] 中值为 value 的元素替换为值为 EMPTY 的元素。

**注意 1**：结合活跃性的定义，此条款规定了实现可以应用的关于弱引用的优化。

可以访问对象而不观察其身份。对非逃逸对象的属性进行标量替换和死变量消除等优化是允许的，这些优化因此允许可观察地清空指向这些对象的弱引用。

另一方面，如果对象的身份是可观察的，并且该对象位于弱引用的 `[[WeakRefTarget]]` 内部插槽中，则禁止可观察地清空该弱引用的优化，如重新物化。

由于调用 `HostEnqueueFinalizationRegistryCleanupJob` 是可选的，注册在终结注册表中的对象不会必然保持该终结注册表活跃。实现可以由于任何原因省略终结注册表回调，例如，如果终结注册表本身变为非活动，或如果应用程序正在关闭。

**注意 2**：实现没有义务为非活跃对象或符号的最大集合清空弱引用。

如果实现选择了一个非活跃的集合 S 以清空弱引用，此定义要求它同时清空 S 中所有值的弱引用。换句话说，实现不可符合规范地仅清空指向值 v 的弱引用，而不清空其他可能导致观察到 v 值的弱引用。

#### 9.9.4 主机钩子

##### 9.9.4.1 HostEnqueueFinalizationRegistryCleanupJob ( finalizationRegistry )

主机定义的抽象操作 `HostEnqueueFinalizationRegistryCleanupJob` 接受参数 finalizationRegistry（一个终结注册表）并返回 UNUSED。

令 cleanupJob 为一个没有参数的新任务抽象闭包，该闭包捕获 finalizationRegistry 并在调用时执行以下步骤：

1. 令 cleanupResult 为 `Completion(CleanupFinalizationRegistry(finalizationRegistry))`。
2. 如果 cleanupResult 是一个异常完成，则执行任何主机定义的错误报告步骤。
3. 返回 UNUSED。

`HostEnqueueFinalizationRegistryCleanupJob` 的实现安排 cleanupJob 在某个将来的时间执行（如果可能）。它还必须符合 9.5 中的要求。

### 9.10 ClearKeptObjects ( )

抽象操作 `ClearKeptObjects` 不接受参数并返回 UNUSED。预期 ECMAScript 实现会在同步 ECMAScript 执行序列完成时调用 `ClearKeptObjects`。它在调用时执行以下步骤：

1. 令 agentRecord 为周围代理的代理记录。
2. 将 agentRecord.[[KeptAlive]] 设置为一个新的空列表。
3. 返回 UNUSED。

### 9.11 AddToKeptObjects ( value )

抽象操作 `AddToKeptObjects` 接受参数 value（一个对象或符号）并返回 UNUSED。它在调用时执行以下步骤：

1. 令 agentRecord 为周围代理的代理记录。
2. 将 value 附加到 agentRecord.[[KeptAlive]]。
3. 返回 UNUSED。

**注意**：当抽象操作 `AddToKeptObjects` 被调用并传递一个目标对象或符号时，它将目标添加到一个列表中，该列表在调用 `ClearKeptObjects` 之前将强烈指向目标。

### 9.12 CleanupFinalizationRegistry ( finalizationRegistry )

抽象操作 `CleanupFinalizationRegistry` 接受参数 finalizationRegistry（一个终结注册表）并返回包含 UNUSED 的正常完成或抛出完成。它在调用时执行以下步骤：

1. 断言：finalizationRegistry 有 `[[Cells]]` 和 `[[CleanupCallback]]` 内部插槽。
2. 令 callback 为 finalizationRegistry.[[CleanupCallback]]。
3. 当 finalizationRegistry.[[Cells]] 包含一个记录 cell 且 cell.[[WeakRefTarget]] 为 EMPTY 时，实现可以执行以下步骤：
   a. 选择任何此类 cell。
   b. 从 finalizationRegistry.[[Cells]] 中移除 cell。
   c. 执行 `?HostCallJobCallback(callback, undefined, « cell.[[HeldValue]] »)`。
4. 返回 UNUSED。

### 9.13 CanBeHeldWeakly ( v )

抽象操作 `CanBeHeldWeakly` 接受参数 v（一个 ECMAScript 语言值）并返回一个布尔值。它在调用时执行以下步骤：

1. 如果 v 是一个对象，返回 true。
2. 如果 v 是一个符号且 `KeyForSymbol(v)` 为 undefined，返回 true。
3. 返回 false。

**注意**：没有语言身份的语言值无法被引用，且不适合作为弱引用。例如，Symbol 值是通过 `Symbol.for` 生成的，与其他 Symbol 值不同，没有语言身份且不适合作为弱引用。众所周知的符号可能永远不会被回收，但仍然被视为适合作为弱引用，因为它们数量有限，可以通过多种实现方法进行管理。然而，任何关联到活跃弱映射中的众所周知符号的值都不太可能被回收，并可能在实现中“泄漏”内存资源。

### 10. 普通对象和异变对象的行为

### 10.1 普通对象的内部方法和内部槽

所有普通对象都有一个名为 `[[Prototype]]` 的内部槽。该内部槽的值要么是 `null` 要么是一个对象，用于实现继承。假设普通对象 O 缺少名为 P 的属性，但其 `[[Prototype]]` 对象上存在 P 属性。如果 P 是 `[[Prototype]]` 对象上的数据属性，则 O 继承它的获取访问行为，使得 P 看起来像是 O 的属性。如果 P 是 `[[Prototype]]` 对象上的可写数据属性，则在 O 上设置 P 会创建一个名为 P 的新数据属性。如果 P 是 `[[Prototype]]` 对象上的不可写数据属性，则在 O 上设置 P 会失败。如果 P 是 `[[Prototype]]` 对象上的访问器属性，则 O 会继承该访问器的获取和设置访问。

每个普通对象都有一个布尔值的 `[[Extensible]]` 内部槽，用于满足 6.1.7.3 中指定的与扩展性相关的内部方法不变量。即，一旦对象的 `[[Extensible]]` 内部槽的值被设置为 `false`，就无法再向该对象添加属性、修改该对象的 `[[Prototype]]` 内部槽的值或将 `[[Extensible]]` 的值更改为 `true`。

在以下算法描述中，假设 O 是一个普通对象，P 是一个属性键值，V 是任何 ECMAScript 语言值，Desc 是一个属性描述符记录。

每个普通对象的内部方法都委托给一个类似命名的抽象操作。如果这样的抽象操作依赖于另一个内部方法，则在 O 上调用内部方法，而不是直接调用类似命名的抽象操作。这些语义确保当普通对象内部方法应用于异变对象时，异变对象的重载内部方法会被调用。

#### 10.1.1 `[[GetPrototypeOf]] ( )`
普通对象 O 的 `[[GetPrototypeOf]]` 内部方法不接受参数，返回一个包含对象或 `null` 的正常完成。调用时执行以下步骤：

1. 返回 `OrdinaryGetPrototypeOf(O)`。

#### 10.1.1.1 `OrdinaryGetPrototypeOf ( O )`
抽象操作 `OrdinaryGetPrototypeOf` 接受参数 O（一个对象），返回一个对象或 `null`。调用时执行以下步骤：

1. 返回 O.`[[Prototype]]`。

#### 10.1.2 `[[SetPrototypeOf]] ( V )`
普通对象 O 的 `[[SetPrototypeOf]]` 内部方法接受参数 V（一个对象或 `null`），返回一个包含布尔值的正常完成。调用时执行以下步骤：

1. 返回 `OrdinarySetPrototypeOf(O, V)`。

#### 10.1.2.1 `OrdinarySetPrototypeOf ( O, V )`
抽象操作 `OrdinarySetPrototypeOf` 接受参数 O（一个对象）和 V（一个对象或 `null`），返回一个布尔值。调用时执行以下步骤：

1. 令 current 为 O.`[[Prototype]]`。
2. 如果 `SameValue(V, current)` 为 `true`，返回 `true`。
3. 令 extensible 为 O.`[[Extensible]]`。
4. 如果 extensible 为 `false`，返回 `false`。
5. 令 p 为 V。
6. 令 done 为 `false`。
7. 重复，直到 done 为 `false`，
   a. 如果 p 为 `null`，则
      i. 令 done 为 `true`。
   b. 否则如果 `SameValue(p, O)` 为 `true`，则
      i. 返回 `false`。
   c. 否则，
      i. 如果 p.`[[GetPrototypeOf]]` 不是 10.1.1 中定义的普通对象内部方法，令 done 为 `true`。
      ii. 否则，令 p 为 p.`[[Prototype]]`。
8. 将 O.`[[Prototype]]` 设置为 V。
9. 返回 `true`。

**注意**：第 7 步中的循环保证了任何仅包含使用普通对象定义 `[[GetPrototypeOf]]` 和 `[[SetPrototypeOf]]` 的对象的原型链中不会有循环。

#### 10.1.3 `[[IsExtensible]] ( )`
普通对象 O 的 `[[IsExtensible]]` 内部方法不接受参数，返回一个包含布尔值的正常完成。调用时执行以下步骤：

1. 返回 `OrdinaryIsExtensible(O)`。

#### 10.1.3.1 `OrdinaryIsExtensible ( O )`
抽象操作 `OrdinaryIsExtensible` 接受参数 O（一个对象），返回一个布尔值。调用时执行以下步骤：

1. 返回 O.`[[Extensible]]`。

#### 10.1.4 `[[PreventExtensions]] ( )`
普通对象 O 的 `[[PreventExtensions]]` 内部方法不接受参数，返回一个包含 `true` 的正常完成。调用时执行以下步骤：

1. 返回 `OrdinaryPreventExtensions(O)`。

#### 10.1.4.1 `OrdinaryPreventExtensions ( O )`
抽象操作 `OrdinaryPreventExtensions` 接受参数 O（一个对象），返回 `true`。调用时执行以下步骤：

1. 将 O.`[[Extensible]]` 设置为 `false`。
2. 返回 `true`。

#### 10.1.5 `[[GetOwnProperty]] ( P )`
普通对象 O 的 `[[GetOwnProperty]]` 内部方法接受参数 P（一个属性键），返回一个包含属性描述符或未定义的正常完成。调用时执行以下步骤：

1. 返回 `OrdinaryGetOwnProperty(O, P)`。

#### 10.1.5.1 `OrdinaryGetOwnProperty ( O, P )`
抽象操作 `OrdinaryGetOwnProperty` 接受参数 O（一个对象）和 P（一个属性键），返回一个属性描述符或未定义。调用时执行以下步骤：

1. 如果 O 没有键值为 P 的自有属性，返回未定义。
2. 令 D 为一个新创建的没有字段的属性描述符。
3. 令 X 为 O 的键值为 P 的自有属性。
4. 如果 X 是一个数据属性，则
   a. 将 D.`[[Value]]` 设置为 X 的 `[[Value]]` 属性的值。
   b. 将 D.`[[Writable]]` 设置为 X 的 `[[Writable]]` 属性的值。
5. 否则，
   a. 断言：X 是一个访问器属性。
   b. 将 D.`[[Get]]` 设置为 X 的 `[[Get]]` 属性的值。
   c. 将 D.`[[Set]]` 设置为 X 的 `[[Set]]` 属性的值。
6. 将 D.`[[Enumerable]]` 设置为 X 的 `[[Enumerable]]` 属性的值。
7. 将 D.`[[Configurable]]` 设置为 X 的 `[[Configurable]]` 属性的值。
8. 返回 D。

#### 10.1.6 `[[DefineOwnProperty]] ( P, Desc )`
普通对象 O 的 `[[DefineOwnProperty]]` 内部方法接受参数 P（一个属性键）和 Desc（一个属性描述符），返回一个包含布尔值的正常完成或一个抛出完成。调用时执行以下步骤：

1. 返回 `? OrdinaryDefineOwnProperty(O, P, Desc)`。

#### 10.1.6.1 `OrdinaryDefineOwnProperty ( O, P, Desc )`
抽象操作 `OrdinaryDefineOwnProperty` 接受参数 O（一个对象），P（一个属性键）和 Desc（一个属性描述符），返回一个包含布尔值的正常完成或一个抛出完成。调用时执行以下步骤：

1. 令 current 为 `? O.[[GetOwnProperty]](P)`。
2. 令 extensible 为 `? IsExtensible(O)`。
3. 返回 `ValidateAndApplyPropertyDescriptor(O, P, extensible, Desc, current)`。

#### 10.1.6.2 `IsCompatiblePropertyDescriptor ( Extensible, Desc, Current )`
抽象操作 `IsCompatiblePropertyDescriptor` 接受参数 Extensible（一个布尔值），Desc（一个属性描述符）和 Current（一个属性描述符或未定义），返回一个布尔值。调用时执行以下步骤：

1. 返回 `ValidateAndApplyPropertyDescriptor(undefined, "", Extensible, Desc, Current)`。

#### 10.1.6.3 `ValidateAndApplyPropertyDescriptor ( O, P, extensible, Desc, current )`
抽象操作 `ValidateAndApplyPropertyDescriptor` 接受参数 O（一个对象或未定义），P（一个属性键），extensible（一个布尔值），Desc（一个属性描述符）和 current（一个属性描述符或未定义），返回一个布尔值。当且仅当 Desc 可以在保持不变量的情况下作为具有指定扩展性和当前属性 current 的对象的属性应用时，返回 `true`。当这种应用可能且 O 不为未定义时，它会为名为 P 的属性执行（如果需要的话创建该属性）。调用时执行以下步骤：

1. 断言：P 是一个属性键1. 断言：P 是一个属性键。
2. 如果 current 为 undefined，则
   a. 如果 extensible 为 false，返回 false。
   b. 如果 O 为 undefined，返回 true。
   c. 如果 IsAccessorDescriptor(Desc) 为 true，则
      i. 创建对象 O 的名为 P 的自有访问器属性，其 `[[Get]]`、`[[Set]]`、`[[Enumerable]]` 和 `[[Configurable]]` 属性设置为 Desc 中相应字段的值，如果 Desc 没有该字段，则设置为属性的默认值。
   d. 否则，
      i. 创建对象 O 的名为 P 的自有数据属性，其 `[[Value]]`、`[[Writable]]`、`[[Enumerable]]` 和 `[[Configurable]]` 属性设置为 Desc 中相应字段的值，如果 Desc 没有该字段，则设置为属性的默认值。
   e. 返回 true。
3. 断言：current 是一个完全填充的属性描述符。
4. 如果 Desc 没有任何字段，返回 true。
5. 如果 current.`[[Configurable]]` 为 false，则
   a. 如果 Desc 有 `[[Configurable]]` 字段且 Desc.`[[Configurable]]` 为 true，返回 false。
   b. 如果 Desc 有 `[[Enumerable]]` 字段且 Desc.`[[Enumerable]]` 不等于 current.`[[Enumerable]]`，返回 false。
   c. 如果 IsGenericDescriptor(Desc) 为 false 且 IsAccessorDescriptor(Desc) 不等于 IsAccessorDescriptor(current)，返回 false。
   d. 如果 IsAccessorDescriptor(current) 为 true，则
      i. 如果 Desc 有 `[[Get]]` 字段且 `SameValue(Desc.[[Get]], current.[[Get]])` 为 false，返回 false。
      ii. 如果 Desc 有 `[[Set]]` 字段且 `SameValue(Desc.[[Set]], current.[[Set]])` 为 false，返回 false。
   e. 否则，如果 current.`[[Writable]]` 为 false，则
      i. 如果 Desc 有 `[[Writable]]` 字段且 Desc.`[[Writable]]` 为 true，返回 false。
      ii. 如果 Desc 有 `[[Value]]` 字段且 `SameValue(Desc.[[Value]], current.[[Value]])` 为 false，返回 false。
6. 如果 O 不为 undefined，则
   a. 如果 IsDataDescriptor(current) 为 true 且 IsAccessorDescriptor(Desc) 为 true，则
      i. 如果 Desc 有 `[[Configurable]]` 字段，令 configurable 为 Desc.`[[Configurable]]`；否则令 configurable 为 current.`[[Configurable]]`。
      ii. 如果 Desc 有 `[[Enumerable]]` 字段，令 enumerable 为 Desc.`[[Enumerable]]`；否则令 enumerable 为 current.`[[Enumerable]]`。
      iii. 用一个访问器属性替换对象 O 的名为 P 的属性，其 `[[Configurable]]` 和 `[[Enumerable]]` 属性设置为 configurable 和 enumerable，且其 `[[Get]]` 和 `[[Set]]` 属性设置为 Desc 中相应字段的值，如果 Desc 没有该字段，则设置为属性的默认值。
   b. 否则如果 IsAccessorDescriptor(current) 为 true 且 IsDataDescriptor(Desc) 为 true，则
      i. 如果 Desc 有 `[[Configurable]]` 字段，令 configurable 为 Desc.`[[Configurable]]`；否则令 configurable 为 current.`[[Configurable]]`。
      ii. 如果 Desc 有 `[[Enumerable]]` 字段，令 enumerable 为 Desc.`[[Enumerable]]`；否则令 enumerable 为 current.`[[Enumerable]]`。
      iii. 用一个数据属性替换对象 O 的名为 P 的属性，其 `[[Configurable]]` 和 `[[Enumerable]]` 属性设置为 configurable 和 enumerable，且其 `[[Value]]` 和 `[[Writable]]` 属性设置为 Desc 中相应字段的值，如果 Desc 没有该字段，则设置为属性的默认值。
   c. 否则，
      i. 对于 Desc 的每个字段，将对象 O 的名为 P 的属性的相应属性设置为该字段的值。
7. 返回 true。

#### 10.1.7 `[[HasProperty]] ( P )`
普通对象 O 的 `[[HasProperty]]` 内部方法接受参数 P（一个属性键），返回一个包含布尔值的正常完成或一个抛出完成。调用时执行以下步骤：

1. 返回 `? OrdinaryHasProperty(O, P)`。

#### 10.1.7.1 `OrdinaryHasProperty ( O, P )`
抽象操作 `OrdinaryHasProperty` 接受参数 O（一个对象）和 P（一个属性键），返回一个包含布尔值的正常完成或一个抛出完成。调用时执行以下步骤：

1. 令 hasOwn 为 `? O.[[GetOwnProperty]](P)`。
2. 如果 hasOwn 不为 undefined，返回 true。
3. 令 parent 为 `? O.[[GetPrototypeOf]]()`。
4. 如果 parent 不为 null，则
   a. 返回 `? parent.[[HasProperty]](P)`。
5. 返回 false。

#### 10.1.8 `[[Get]] ( P, Receiver )`
普通对象 O 的 `[[Get]]` 内部方法接受参数 P（一个属性键）和 Receiver（一个 ECMAScript 语言值），返回一个包含 ECMAScript 语言值的正常完成或一个抛出完成。调用时执行以下步骤：

1. 返回 `? OrdinaryGet(O, P, Receiver)`。

#### 10.1.8.1 `OrdinaryGet ( O, P, Receiver )`
抽象操作 `OrdinaryGet` 接受参数 O（一个对象）、P（一个属性键）和 Receiver（一个 ECMAScript 语言值），返回一个包含 ECMAScript 语言值的正常完成或一个抛出完成。调用时执行以下步骤：

1. 令 desc 为 `? O.[[GetOwnProperty]](P)`。
2. 如果 desc 为 undefined，则
   a. 令 parent 为 `? O.[[GetPrototypeOf]]()`。
   b. 如果 parent 为 null，返回 undefined。
   c. 返回 `? parent.[[Get]](P, Receiver)`。
3. 如果 IsDataDescriptor(desc) 为 true，返回 desc.`[[Value]]`。
4. 断言：IsAccessorDescriptor(desc) 为 true。
5. 令 getter 为 desc.`[[Get]]`。
6. 如果 getter 为 undefined，返回 undefined。
7. 返回 `? Call(getter, Receiver)`。

#### 10.1.9 `[[Set]] ( P, V, Receiver )`
普通对象 O 的 `[[Set]]` 内部方法接受参数 P（一个属性键）、V（一个 ECMAScript 语言值）和 Receiver（一个 ECMAScript 语言值），返回一个包含布尔值的正常完成或一个抛出完成。调用时执行以下步骤：

1. 返回 `? OrdinarySet(O, P, V, Receiver)`。

#### 10.1.9.1 `OrdinarySet ( O, P, V, Receiver )`
抽象操作 `OrdinarySet` 接受参数 O（一个对象）、P（一个属性键）、V（一个 ECMAScript 语言值）和 Receiver（一个 ECMAScript 语言值），返回一个包含布尔值的正常完成或一个抛出完成。调用时执行以下步骤：

1. 令 ownDesc 为 `? O.[[GetOwnProperty]](P)`。
2. 返回 `? OrdinarySetWithOwnDescriptor(O, P, V, Receiver, ownDesc)`。

#### 10.1.9.2 `OrdinarySetWithOwnDescriptor ( O, P, V, Receiver, ownDesc )`
抽象操作 `OrdinarySetWithOwnDescriptor` 接受参数 O（一个对象）、P（一个属性键）、V（一个 ECMAScript 语言值）、Receiver（一个 ECMAScript 语言值）和 ownDesc（一个属性描述符或未定义），返回一个包含布尔值的正常完成或一个抛出完成。调用时执行以下步骤：

1. 如果 ownDesc 为 undefined，则
   a. 令 parent 为 `? O.[[GetPrototypeOf]]()`。
   b. 如果 parent 不为 null，则
      i. 返回 `? parent.[[Set]](P, V, Receiver)`。
   c. 否则，
      i. 将 ownDesc 设置为属性描述符 `{ [[Value]]: undefined, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true }`。
2. 如果 IsDataDescriptor(ownDesc) 为 true，则
   a. 如果 ownDesc.`[[Writable]]` 为 false，返回 false。
   b. 如果 Receiver 不是一个对象，返回 false。
   c. 令 existingDescriptor 为 `? Receiver.[[GetOwnProperty]](P)`。
   d. 如果 existingDescriptor 不为 undefined，则
      i. 如果 IsAccessorDescriptor(existingDescriptor) 为 true，返回 false。
      ii. 如果 existingDescriptor.`[[Writable]]` 为 false，返回 false。
      iii. 令 valueDesc 为属性描述符 `{ [[Value]]: V }`。
      iv. 返回 `? Receiver.[[DefineOwnProperty]](P, valueDesc)`。
   e. 否则，
      i. 断言：Receiver 当前没有属性 P。
      ii. 返回 `? CreateDataProperty(Receiver, P, V)`。
3. 断断言：IsAccessorDescriptor(ownDesc) 为 true。
4. 令 setter 为 ownDesc.`[[Set]]`。
5. 如果 setter 为 undefined，返回 false。
6. 执行 `? Call(setter, Receiver, « V »)`。
7. 返回 true。

#### 10.1.10 `[[Delete]] ( P )`
普通对象 O 的 `[[Delete]]` 内部方法接受参数 P（一个属性键），返回一个包含布尔值的正常完成或一个抛出完成。调用时执行以下步骤：

1. 返回 `? OrdinaryDelete(O, P)`。

#### 10.1.10.1 `OrdinaryDelete ( O, P )`
抽象操作 `OrdinaryDelete` 接受参数 O（一个对象）和 P（一个属性键），返回一个包含布尔值的正常完成或一个抛出完成。调用时执行以下步骤：

1. 令 desc 为 `? O.[[GetOwnProperty]](P)`。
2. 如果 desc 为 undefined，返回 true。
3. 如果 desc.`[[Configurable]]` 为 true，则
   a. 从 O 中移除键名为 P 的自有属性。
   b. 返回 true。
4. 返回 false。

#### 10.1.11 `[[OwnPropertyKeys]] ( )`
普通对象 O 的 `[[OwnPropertyKeys]]` 内部方法不接受参数，返回一个包含属性键列表的正常完成。调用时执行以下步骤：

1. 返回 `OrdinaryOwnPropertyKeys(O)`。

#### 10.1.11.1 `OrdinaryOwnPropertyKeys ( O )`
抽象操作 `OrdinaryOwnPropertyKeys` 接受参数 O（一个对象），返回一个属性键列表。调用时执行以下步骤：

1. 令 keys 为一个新的空列表。
2. 对于 O 的每个键名为 P 的自有属性，按数组索引递增顺序，
   a. 将 P 添加到 keys。
3. 对于 O 的每个键名为 P 的字符串属性，按属性创建的时间顺序，
   a. 将 P 添加到 keys。
4. 对于 O 的每个键名为 P 的符号属性，按属性创建的时间顺序，
   a. 将 P 添加到 keys。
5. 返回 keys。

#### 10.1.12 `OrdinaryObjectCreate ( proto [ , additionalInternalSlotsList ] )`
抽象操作 `OrdinaryObjectCreate` 接受参数 proto（一个对象或 `null`）和可选参数 additionalInternalSlotsList（一个内部槽名称列表），返回一个对象。它用于指定创建新普通对象的运行时过程。additionalInternalSlotsList 包含对象必须定义的额外内部槽的名称，除了 `[[Prototype]]` 和 `[[Extensible]]`。如果没有提供 additionalInternalSlotsList，则使用一个新的空列表。调用时执行以下步骤：

1. 令 internalSlotsList 为 « `[[Prototype]]`, `[[Extensible]]` »。
2. 如果提供了 additionalInternalSlotsList，将 internalSlotsList 设置为 internalSlotsList 和 additionalInternalSlotsList 的列表连接。
3. 令 O 为 `MakeBasicObject(internalSlotsList)`。
4. 将 O.`[[Prototype]]` 设置为 proto。
5. 返回 O。

**注意**：尽管 `OrdinaryObjectCreate` 做的只是调用 `MakeBasicObject`，其使用传达了创建普通对象而非异变对象的意图。因此，在本规范中，它不被任何随后修改对象内部方法以使结果变为非普通对象的算法调用。创建异变对象的操作直接调用 `MakeBasicObject`。

#### 10.1.13 `OrdinaryCreateFromConstructor ( constructor, intrinsicDefaultProto [ , internalSlotsList ] )`
抽象操作 `OrdinaryCreateFromConstructor` 接受参数 constructor（一个构造函数）和 intrinsicDefaultProto（一个字符串），以及可选参数 internalSlotsList（内部槽名称列表），返回一个包含对象的正常完成或一个抛出完成。它创建一个普通对象，其 `[[Prototype]]` 值从构造函数的 "prototype" 属性中获取（如果存在）。否则，使用 intrinsicDefaultProto 指定的内在对象作为 `[[Prototype]]`。internalSlotsList 包含必须作为对象一部分定义的额外内部槽的名称。如果没有提供 internalSlotsList，则使用一个新的空列表。调用时执行以下步骤：

1. 断言：intrinsicDefaultProto 是本规范中一个内在对象的名称。相应的对象必须是用于作为对象的 `[[Prototype]]` 值的内在对象。
2. 令 proto 为 `? GetPrototypeFromConstructor(constructor, intrinsicDefaultProto)`。
3. 如果提供了 internalSlotsList，令 slotsList 为 internalSlotsList。
4. 否则，令 slotsList 为一个新的空列表。
5. 返回 `OrdinaryObjectCreate(proto, slotsList)`。

#### 10.1.14 `GetPrototypeFromConstructor ( constructor, intrinsicDefaultProto )`
抽象操作 `GetPrototypeFromConstructor` 接受参数 constructor（一个函数对象）和 intrinsicDefaultProto（一个字符串），返回一个包含对象的正常完成或一个抛出完成。它确定应当用于创建与特定构造函数对应的对象的 `[[Prototype]]` 值。该值从构造函数的 "prototype" 属性中获取（如果存在）。否则，使用 intrinsicDefaultProto 指定的内在对象作为 `[[Prototype]]`。调用时执行以下步骤：

1. 断言：intrinsicDefaultProto 是本规范中一个内在对象的名称。相应的对象必须是用于作为对象的 `[[Prototype]]` 值的内在对象。
2. 令 proto 为 `? Get(constructor, "prototype")`。
3. 如果 proto 不是一个对象，则
   a. 令 realm 为 `? GetFunctionRealm(constructor)`。
   b. 将 proto 设置为 realm 的名为 intrinsicDefaultProto 的内在对象。
4. 返回 proto。

**注意**：如果构造函数未提供 `[[Prototype]]` 值，使用的默认值是从构造函数函数的 realm 获取的，而不是从运行执行上下文获取的。

#### 10.1.15 `RequireInternalSlot ( O, internalSlot )`
抽象操作 `RequireInternalSlot` 接受参数 O（一个 ECMAScript 语言值）和 internalSlot（一个内部槽名称），返回一个包含 UNUSED 的正常完成或一个抛出完成。除非 O 是一个对象并且有给定的内部槽，否则它会抛出异常。调用时执行以下步骤：

1. 如果 O 不是一个对象，抛出一个 TypeError 异常。
2. 如果 O 没有 internalSlot 内部槽，抛出一个 TypeError 异常。
3. 返回 UNUSED。

### 10.3 内置函数对象

内置函数对象是一个普通对象；它必须满足 10.1 中规定的普通对象的要求。

除了每个普通对象所需的内部槽（参见 10.1）之外，内置函数对象还必须具有以下内部槽：

- `[[Realm]]`，表示创建函数的领域的领域记录。
- `[[InitialName]]`，一个字符串，是函数的初始名称。它在 20.2.3.5 中使用。

除非另有说明，内置函数对象的 `[[Prototype]]` 内部槽的初始值为 %Function.prototype%。

内置函数对象必须有一个符合 10.3.1 中定义的 `[[Call]]` 内部方法。

只有当一个内置函数对象被描述为“构造函数”或者本规范中的某些算法明确设置了其 `[[Construct]]` 内部方法时，该对象才具有 `[[Construct]]` 内部方法。这样的 `[[Construct]]` 内部方法必须符合 10.3.2 中的定义。

实现可以提供本规范中未定义的额外内置函数对象。

#### 10.3.1 `[[Call]] ( thisArgument, argumentsList )`
内置函数对象 F 的 `[[Call]]` 内部方法接受参数 `thisArgument`（一个 ECMAScript 语言值）和 `argumentsList`（一个 ECMAScript 语言值的列表），并返回一个包含 ECMAScript 语言值的正常完成或一个抛出完成。调用时执行以下步骤：

1. 返回 `? BuiltinCallOrConstruct(F, thisArgument, argumentsList, undefined)`。

#### 10.3.2 `[[Construct]] ( argumentsList, newTarget )`
内置函数对象 F 的 `[[Construct]]` 内部方法（当该方法存在时）接受参数 `argumentsList`（一个 ECMAScript 语言值的列表）和 `newTarget`（一个构造函数），并返回一个包含对象的正常完成或一个抛出完成。调用时执行以下步骤：

1. 返回 `? BuiltinCallOrConstruct(F, UNINITIALIZED, argumentsList, newTarget)`。

#### 10.3.3 `BuiltinCallOrConstruct ( F, thisArgument, argumentsList, newTarget )`
抽象操作 `BuiltinCallOrConstruct` 接受参数 F（一个内置函数对象），`thisArgument`（一个 ECMAScript 语言值或 UNINITIALIZED），`argumentsList`（一个 ECMAScript 语言值的列表），以及 `newTarget`（一个构造函数或 undefined），并返回一个包含 ECMAScript 语言值的正常完成或一个抛出完成。调用时执行以下步骤：

1. 令 `callerContext` 为正在运行的执行上下文。
2. 如果 `callerContext` 尚未被挂起，则挂起 `callerContext`。
3. 令 `calleeContext` 为一个新的执行上下文。
4. 将 `calleeContext` 的函数设置为 F。
5. 令 `calleeRealm` 为 F 的 `[[Realm]]`。
6. 将 `calleeContext` 的领域设置为 `calleeRealm`。
7. 将 `calleeContext` 的 `ScriptOrModule` 设置为 null。
8. 执行任何必要的实现定义的 `calleeContext` 初始化。
9. 将 `calleeContext` 压入执行上下文栈；`calleeContext` 现在是正在运行的执行上下文。
10. 令 `result` 为评估 F 的结果的完成记录，结果应当符合 F 的规范。如果 `thisArgument` 为 UNINITIALIZED，则 `this` 值未初始化；否则，`thisArgument` 提供 `this` 值。`argumentsList` 提供命名参数。`newTarget` 提供 `NewTarget` 值。
11. **注意**：如果 F 在本文档中定义，“F 的规范”是通过算法步骤或其他方式为其指定的行为。
12. 从执行上下文栈中移除 `calleeContext` 并恢复 `callerContext` 作为正在运行的执行上下文。
13. 返回 `? result`。

**注意**：当 `calleeContext` 从执行上下文栈中移除时，如果它已经被挂起并由一个可访问的生成器保留以供稍后恢复，则不能销毁它。

#### 10.3.4 `CreateBuiltinFunction ( behaviour, length, name, additionalInternalSlotsList [ , realm [ , prototype [ , prefix ] ] ] )`
抽象操作 `CreateBuiltinFunction` 接受参数 `behaviour`（一个抽象闭包、一组算法步骤或本规范中提供的其他函数行为定义）、`length`（一个非负整数或 +∞）、`name`（一个属性键或私有名称）和 `additionalInternalSlotsList`（一个内部槽名称列表），以及可选参数 `realm`（一个领域记录）、`prototype`（一个对象或 null）和 `prefix`（一个字符串），并返回一个函数对象。`additionalInternalSlotsList` 包含必须定义为对象一部分的额外内部槽的名称。此操作创建一个内置函数对象。调用时执行以下步骤：

1. 如果未提供 `realm`，将 `realm` 设置为当前领域记录。
2. 如果未提供 `prototype`，将 `prototype` 设置为 `realm.[[Intrinsics]].[[%Function.prototype%]]`。
3. 令 `internalSlotsList` 为一个包含即将创建的内置函数对象的所有内部槽名称的列表。
4. 将 `additionalInternalSlotsList` 的元素追加到 `internalSlotsList`。
5. 令 `func` 为一个新的内置函数对象，当被调用时，它使用 `behaviour` 描述的行为并使用提供的参数作为 `behaviour` 指定的对应参数的值。新函数对象具有内部槽，其名称是 `internalSlotsList` 的元素，以及一个 `[[InitialName]]` 内部槽。
6. 将 `func.[[Prototype]]` 设置为 `prototype`。
7. 将 `func.[[Extensible]]` 设置为 true。
8. 将 `func.[[Realm]]` 设置为 `realm`。
9. 将 `func.[[InitialName]]` 设置为 null。
10. 执行 `SetFunctionLength(func, length)`。
11. 如果未提供 `prefix`，则
    a. 执行 `SetFunctionName(func, name)`。
12. 否则，
    a. 执行 `SetFunctionName(func, name, prefix)`。
13. 返回 `func`。

本规范中定义的每个内置函数都是通过调用 `CreateBuiltinFunction` 抽象操作创建的。

### 10.4 内置异变对象的内部方法和槽
本规范定义了几种内置异变对象。这些对象通常在大多数情况下行为类似于普通对象，除了某些特定情况。以下异变对象使用普通对象的内部方法，除非下面明确规定了例外情况：

#### 10.4.1 绑定函数异变对象
绑定函数异变对象是包装另一个函数对象的异变对象。绑定函数异变对象是可调用的（它具有 `[[Call]]` 内部方法，并且可能具有 `[[Construct]]` 内部方法）。调用绑定函数异变对象通常会调用其包装的函数。

如果一个对象的 `[[Call]]` 方法和（如果适用）`[[Construct]]` 方法使用以下实现，并且其其他基本内部方法使用 10.1 中的定义，则该对象是一个绑定函数异变对象。这些方法是在 `BoundFunctionCreate` 中安装的。

绑定函数异变对象没有表 30 中列出的 ECMAScript 函数对象的内部槽。相反，它们具有表 31 中列出的内部槽，除了 `[[Prototype]]` 和 `[[Extensible]]`。

表 31：绑定函数异变对象的内部槽
| 内部槽 | 类型 | 描述 |
| --- | --- | --- |
| `[[BoundTargetFunction]]` | 一个可调用的对象 | 包装的函数对象。 |
| `[[BoundThis]]` | 一个 ECMAScript 语言值 | 调用包装函数时始终传递的 `this` 值。 |
| `[[BoundArguments]]` | 一个 ECMAScript 语言值的列表 | 用作调用包装函数的第一个参数的值列表。 |

##### 10.4.1.1 `[[Call]] ( thisArgument, argumentsList )`
绑定函数异变对象 F 的 `[[Call]]` 内部方法接受参数 `thisArgument`（一个 ECMAScript 语言值）和 `argumentsList`（一个 ECMAScript 语言值的列表），并返回一个包含 ECMAScript 语言值的正常完成或一个抛出完成。调用时执行以下步骤：

1. 令 `target` 为 F 的 `[[BoundTargetFunction]]`。
2. 令 `boundThis` 为 F 的 `[[BoundThis]]`。
3. 令 `boundArgs` 为 F 的 `[[BoundArguments]]`。
4. 令 `args` 为 `boundArgs` 和 `argumentsList` 的列表连接。
5. 返回 `? Call(target, boundThis, args)`。

##### 10.4.1.2 `[[Construct]] ( argumentsList, newTarget )`
绑定函数异变对象 F 的 `[[Construct]]` 内方法接受参数 `argumentsList`（一个 ECMAScript 语言值的列表）和 `newTarget`（一个构造函数），并返回一个包含对象的正常完成或一个抛出完成。调用时执行以下步骤：

1. 令 `target` 为 F 的 `[[BoundTargetFunction]]`。
2. 断言：`IsConstructor(target)` 为 true。
3. 令 `boundArgs` 为 F 的 `[[BoundArguments]]`。
4. 令 `args` 为 `boundArgs` 和 `argumentsList` 的列表连接。
5. 如果 `SameValue(F, newTarget)` 为 true，则将 `newTarget` 设置为 `target`。
6. 返回 `? Construct(target, args, newTarget)`。

##### 10.4.1.3 `BoundFunctionCreate ( targetFunction, boundThis, boundArgs )`
抽象操作 `BoundFunctionCreate` 接受参数 `targetFunction`（一个函数对象）、`boundThis`（一个 ECMAScript 语言值）和 `boundArgs`（一个 ECMAScript 语言值的列表），并返回一个包含函数对象的正常完成或一个抛出完成。此操作用于指定创建新的绑定函数异变对象。调用时执行以下步骤：

1. 令 `proto` 为 `? targetFunction.[[GetPrototypeOf]]()`。
2. 令 `internalSlotsList` 为 `« [[Prototype]], [[Extensible]] »` 和表 31 中列出的内部槽的列表连接。
3. 令 `obj` 为 `MakeBasicObject(internalSlotsList)`。
4. 将 `obj.[[Prototype]]` 设置为 `proto`。
5. 按照 10.4.1.1 中的描述设置 `obj.[[Call]]`。
6. 如果 `IsConstructor(targetFunction)` 为 true，则
   a. 按照 10.4.1.2 中的描述设置 `obj.[[Construct]]`。
7. 将 `obj.[[BoundTargetFunction]]` 设置为 `targetFunction`。
8. 将 `obj.[[BoundThis]]` 设置为 `boundThis`。
9. 将 `obj.[[BoundArguments]]` 设置为 `boundArgs`。
10. 返回 `obj`。

#### 10.4.2 数组异变对象
数组是一种对数组索引属性键（见 6.1.7）进行特殊处理的异变对象。属性名为数组索引的属性也称为元素。每个数组都有一个不可配置的“length”属性，其值始终是小于 2**32 的非负整数。数组的“length”属性值在数学上大于每个自身属性的数组索引名；每当创建或更改数组的自身属性时，其他属性会相应调整以保持此不变量。具体来说，每当添加一个名为数组索引的自身属性时，“length”属性的值如果有必要将变为比该数组索引大一；每当更改“length”属性的值时，所有名为数组索引且值不小于新长度的自身属性将被删除。此约束仅适用于数组的自身属性，并且不受从其原型继承的“length”或数组索引属性的影响。

如果一个对象的 `[[DefineOwnProperty]]` 内部方法使用以下实现，并且其其他基本内部方法使用 10.1 中的定义，则该对象是一个数组异变对象（或简称数组）。这些方法是在 `ArrayCreate` 中安装的。

##### 10.4.2.1 `[[DefineOwnProperty]] ( P, Desc )`
数组异变对象 A 的 `[[DefineOwnProperty]]` 内部方法接受参数 P（一个属性键）和 Desc（一个属性描述符），并返回一个包含布尔值的正常完成或一个抛出完成。调用时执行以下步骤：

1. 如果 P 是 "length"，则
   a. 返回 `? ArraySetLength(A, Desc)`。
2. 否则如果 P 是数组索引，则
   a. 令 `lengthDesc` 为 `OrdinaryGetOwnProperty(A, "length")`。
   b. 断言：`IsDataDescriptor(lengthDesc)` 为 true。
   c. 断言：`lengthDesc.[[Configurable]]` 为 false。
   d. 令 `length` 为 `lengthDesc.[[Value]]`。
   e. 断言：`length` 是一个非负整数。
   f. 令 `index` 为 `! ToUint32(P)`。
   g. 如果 `index ≥ length` 并且 `lengthDesc.[[Writable]]` 为 false，则返回 false。
   h. 令 `succeeded` 为 `! OrdinaryDefineOwnProperty(A, P, Desc)`。
   i. 如果 `succeeded` 为 false，则返回 false。
   j. 如果 `index ≥ length`，则
      i. 将 `lengthDesc.[[Value]]` 设置为 `index + 1𝔽`。
      ii. 将 `succeeded` 设置为 `! OrdinaryDefineOwnProperty(A, "length", lengthDesc)`。
      iii. 断言：`succeeded` 为 true。
   k. 返回 true。
3. 返回 `? OrdinaryDefineOwnProperty(A, P, Desc)`。

##### 10.4.2.2 `ArrayCreate ( length [ , proto ] )`
抽象操作 `ArrayCreate` 接受参数 `length`（一个非负整数）和可选参数 `proto`（一个对象），并返回一个包含数组异变对象的正常完成或一个抛出完成。此操作用于指定创建新的数组。调用时执行以下步骤：

1. 如果 `length > 2**32 - 1`，则抛出一个 `RangeError` 异常。
2. 如果未提供 `proto`，则将 `proto` 设置为 `%Array.prototype%`。
3. 令 `A` 为 `MakeBasicObject(« [[Prototype]], [[Extensible]] »)`。
4. 将 `A.[[Prototype]]` 设置为 `proto`。
5. 按照 10.4.2.1 中的描述设置 `A.[[DefineOwnProperty]]`。
6. 执行 `! OrdinaryDefineOwnProperty(A, "length", PropertyDescriptor { [[Value]]: 𝔽(length), [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false })`。
7. 返回 `A`。

##### 10.4.2.3 `ArraySpeciesCreate ( originalArray, length )`
抽象操作 `ArraySpeciesCreate` 接受参数 `originalArray`（一个对象）和 `length`（一个非负整数），并返回一个包含对象的正常完成或一个抛出完成。此操作用于指定使用从 `originalArray` 派生的构造函数创建新的数组或类似对象。它不强制构造函数返回一个数组。调用时执行以下步骤：

1. 令 `isArray` 为 `? IsArray(originalArray)`。
2. 如果 `isArray` 为 false，则返回 `? ArrayCreate(length)`。
3. 令 `C` 为 `? Get(originalArray, "constructor")`。
4. 如果 `IsConstructor(C)` 为 true，则
   a. 令 `thisRealm` 为当前的领域记录。
   b. 令 `realmC` 为 `? GetFunctionRealm(C)`。
   c. 如果 `thisRealm` 和 `realmC` 不是同一个领域记录，则
      i. 如果 `SameValue(C, realmC.[[Intrinsics]].[[%Array%]])` 为 true，则将 `C` 设置为 undefined。
5. 如果 `C` 是一个对象，则
   a. 将 `C` 设置为 `? Get(C, @@species)`。
   b. 如果 `C` 为 null，则将 `C` 设置为 undefined。
6. 如果 `C` 为 undefined，则返回 `? ArrayCreate(length)`。
7. 如果 `IsConstructor(C)` 为 false，则抛出一个 `TypeError` 异常。
8. 返回 `? Construct(C, « 𝔽(length) »)`。

**注意**：如果 `originalArray` 是使用标准内置数组构造函数创建的，并且其领域不是正在运行的执行上下文的领域，则使用正在运行的执行上下文的领域创建一个新的数组。这保持了与过去 Web 浏览器的兼容性，这些浏览器历史上对现在使用 `ArraySpeciesCreate` 定义的 `Array.prototype` 方法具有这种行为。

##### 10.4.2.4 `ArraySetLength ( A, Desc )`
抽象操作 `ArraySetLength` 接受参数 `A`（一个数组）和 `Desc`（一个属性描述符），并返回一个包含布尔值的正常完成或一个抛出完成。调用时执行以下步骤：

1. 如果 `Desc` 没有 `[[Value]]` 字段，则
   a. 返回 `! OrdinaryDefineOwnProperty(A, "length", Desc)`。
2. 令 `newLenDesc` 为 `Desc` 的副本。
3. 令 `newLen` 为 `? ToUint32(Desc.[[Value]])`。
4. 令 `numberLen` 为 `? ToNumber(Desc.[[Value]])`。
5. 如果 `SameValueZero(newLen, numberLen)` 为 false，则抛出一个 `RangeError` 异常。
6. 将`newLenDesc.[[Value]]` 设置为 `newLen`。
7. 令 `oldLenDesc` 为 `OrdinaryGetOwnProperty(A, "length")`。
8. 断言：`IsDataDescriptor(oldLenDesc)` 为 true。
9. 断言：`oldLenDesc.[[Configurable]]` 为 false。
10. 令 `oldLen` 为 `oldLenDesc.[[Value]]`。
11. 如果 `newLen ≥ oldLen`，则
    a. 返回 `! OrdinaryDefineOwnProperty(A, "length", newLenDesc)`。
12. 如果 `oldLenDesc.[[Writable]]` 为 false，则返回 false。
13. 如果 `newLenDesc` 没有 `[[Writable]]` 字段或 `newLenDesc.[[Writable]]` 为 true，则
    a. 令 `newWritable` 为 true。
14. 否则，
    a. **注意**：将 `[[Writable]]` 属性设置为 false 被延后，以防某些元素无法删除。
    b. 令 `newWritable` 为 false。
    c. 将 `newLenDesc.[[Writable]]` 设置为 true。
15. 令 `succeeded` 为 `! OrdinaryDefineOwnProperty(A, "length", newLenDesc)`。
16. 如果 `succeeded` 为 false，则返回 false。
17. 对于 `A` 的每个自身属性键 `P`，如果 `P` 是数组索引并且 `! ToUint32(P) ≥ newLen`，按降序数值索引顺序执行以下步骤：
    a. 令 `deleteSucceeded` 为 `! A.[[Delete]](P)`。
    b. 如果 `deleteSucceeded` 为 false，则
        i. 将 `newLenDesc.[[Value]]` 设置为 `! ToUint32(P) + 1𝔽`。
        ii. 如果 `newWritable` 为 false，则将 `newLenDesc.[[Writable]]` 设置为 false。
        iii. 执行 `! OrdinaryDefineOwnProperty(A, "length", newLenDesc)`。
        iv. 返回 false。
18. 如果 `newWritable` 为 false，则
    a. 令 `succeeded` 为 `! OrdinaryDefineOwnProperty(A, "length", PropertyDescriptor { [[Writable]]: false })`。
    b. 断言：`succeeded` 为 true。
19. 返回 true。

**注意**：在步骤 3 和 4 中，如果 `Desc.[[Value]]` 是一个对象，则其 `valueOf` 方法会被调用两次。这是从本规范第 2 版开始指定的具有此效果的遗留行为。

#### 10.4.3 字符串异变对象
字符串对象是一种封装字符串值并暴露与字符串值的各个代码单元元素相对应的虚拟整数索引数据属性的异变对象。字符串异变对象始终具有名为“length”的数据属性，其值为所封装的字符串值的长度。代码单元数据属性和“length”属性都是不可写和不可配置的。

如果一个对象的 `[[GetOwnProperty]]`、`[[DefineOwnProperty]]` 和 `[[OwnPropertyKeys]]` 内部方法使用以下实现，并且其其他基本内部方法使用 10.1 中的定义，则该对象是一个字符串异变对象（或简称字符串对象）。这些方法是在 `StringCreate` 中安装的。

字符串异变对象具有与普通对象相同的内部槽。它们还具有一个 `[[StringData]]` 内部槽。

##### 10.4.3.1 `[[GetOwnProperty]] ( P )`
字符串异变对象 S 的 `[[GetOwnProperty]]` 内部方法接受参数 P（一个属性键），并返回一个包含属性描述符或 undefined 的正常完成。调用时执行以下步骤：

1. 令 `desc` 为 `OrdinaryGetOwnProperty(S, P)`。
2. 如果 `desc` 不为 undefined，则返回 `desc`。
3. 返回 `StringGetOwnProperty(S, P)`。

##### 10.4.3.2 `[[DefineOwnProperty]] ( P, Desc )`
字符串异变对象 S 的 `[[DefineOwnProperty]]` 内部方法接受参数 P（一个属性键）和 Desc（一个属性描述符），并返回一个包含布尔值的正常完成。调用时执行以下步骤：

1. 令 `stringDesc` 为 `StringGetOwnProperty(S, P)`。
2. 如果 `stringDesc` 不为 undefined，则
    a. 令 `extensible` 为 `S.[[Extensible]]`。
    b. 返回 `IsCompatiblePropertyDescriptor(extensible, Desc, stringDesc)`。
3. 返回 `! OrdinaryDefineOwnProperty(S, P, Desc)`。

##### 10.4.3.3 `[[OwnPropertyKeys]] ( )`
字符串异变对象 O 的 `[[OwnPropertyKeys]]` 内部方法不接受任何参数，返回一个包含属性键列表的正常完成。调用时执行以下步骤：

1. 令 `keys` 为一个新的空列表。
2. 令 `str` 为 `O.[[StringData]]`。
3. 断言：`str` 是一个字符串。
4. 令 `len` 为 `str` 的长度。
5. 对于每个整数 `i`，如果 `0 ≤ i < len`，按升序执行以下步骤：
    a. 将 `! ToString(𝔽(i))` 追加到 `keys`。
6. 对于 `O` 的每个自身属性键 `P`，如果 `P` 是数组索引并且 `! ToIntegerOrInfinity(P) ≥ len`，按升序数值索引顺序执行以下步骤：
    a. 将 `P` 追加到 `keys`。
7. 对于 `O` 的每个自身属性键 `P`，如果 `P` 是字符串并且 `P` 不是数组索引，按属性创建的时间顺序升序执行以下步骤：
    a. 将 `P` 追加到 `keys`。
8. 对于 `O` 的每个自身属性键 `P`，如果 `P` 是符号，按属性创建的时间顺序升序执行以下步骤：
    a. 将 `P` 追加到 `keys`。
9. 返回 `keys`。

##### 10.4.3.4 `StringCreate ( value, prototype )`
抽象操作 `StringCreate` 接受参数 `value`（一个字符串）和 `prototype`（一个对象），并返回一个字符串异变对象。此操作用于指定创建新的字符串异变对象。调用时执行以下步骤：

1. 令 `S` 为 `MakeBasicObject(« [[Prototype]], [[Extensible]], [[StringData]] »)`。
2. 将 `S.[[Prototype]]` 设置为 `prototype`。
3. 将 `S.[[StringData]]` 设置为 `value`。
4. 按照 10.4.3.1 中的描述设置 `S.[[GetOwnProperty]]`。
5. 按照 10.4.3.2 中的描述设置 `S.[[DefineOwnProperty]]`。
6. 按照 10.4.3.3 中的描述设置 `S.[[OwnPropertyKeys]]`。
7. 令 `length` 为 `value` 的长度。
8. 执行 `! DefinePropertyOrThrow(S, "length", PropertyDescriptor { [[Value]]: 𝔽(length), [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false })`。
9. 返回 `S`。

##### 10.4.3.5 `StringGetOwnProperty ( S, P )`
抽象操作 `StringGetOwnProperty` 接受参数 `S`（一个具有 `[[StringData]]` 内部槽的对象）和 `P`（一个属性键），并返回一个属性描述符或 undefined。调用时执行以下步骤：

1. 如果 `P` 不是字符串，则返回 undefined。
2. 令 `index` 为 `CanonicalNumericIndexString(P)`。
3. 如果 `index` 为 undefined，则返回 undefined。
4. 如果 `index` 不是整数，则返回 undefined。
5. 如果 `index` 为 -0𝔽，则返回 undefined。
6. 令 `str` 为 `S.[[StringData]]`。
7. 断言：`str` 是一个字符串。
8. 令 `len` 为 `str` 的长度。
9. 如果 ℝ(index) < 0 或 `len ≤ ℝ(index)`，则返回 undefined。
10. 令 `resultStr` 为从 ℝ(index) 到 ℝ(index) + 1 的 `str` 子字符串。
11. 返回属性描述符 `{ [[Value]]: resultStr, [[Writable]]: false, [[Enumerable]]: true, [[Configurable]]: false }`。

好的，我会继续翻译以下的章节内容。

### 10.4.4 参数异变对象
大多数 ECMAScript 函数都会为其代码提供一个 `arguments` 对象。根据函数定义的特性，其 `arguments` 对象要么是普通对象，要么是参数异变对象。参数异变对象是一种异变对象，其数组索引属性键映射到与其关联的 ECMAScript 函数调用的形式参数绑定。

如果一个对象的内部方法使用以下实现，则该对象是参数异变对象，而未指定的方法则使用 10.1 中的定义。这些方法是在 `CreateMappedArgumentsObject` 中安装的。

**注意 1**：尽管 `CreateUnmappedArgumentsObject` 归类在此条款中，它创建的是普通对象，而不是参数异变对象。

参数异变对象具有与普通对象相同的内部槽。它们还具有一个 `[[ParameterMap]]` 内部槽。普通的 `arguments` 对象也具有一个 `[[ParameterMap]]` 内部槽，其值始终为 `undefined`。对于普通的 `arguments` 对象，`[[ParameterMap]]` 内部槽仅用于 `Object.prototype.toString`（20.1.3.6）以标识它们。

**注意 2**：参数异变对象的整数索引数据属性，其数值名称值小于对应函数对象的形式参数数量，最初与函数的执行上下文中的相应参数绑定共享其值。这意味着更改属性会更改相应参数绑定的值，反之亦然。如果删除此类属性然后重新定义，或将其更改为访问器属性，则这种对应关系将被打破。如果 `arguments` 对象是普通对象，则其属性值只是传递给函数的参数的副本，并且属性值与形式参数值之间没有动态链接。

**注意 3**：`ParameterMap` 对象及其属性值用于指定 `arguments` 对象与参数绑定的对应关系。`ParameterMap` 对象及其属性值并不会从 ECMAScript 代码中直接可观察到。ECMAScript 实现不需要实际创建或使用此类对象来实现指定的语义。

**注意 4**：普通 `arguments` 对象定义了一个名为 `callee` 的不可配置访问器属性，在访问时会抛出 `TypeError` 异常。对于参数异变对象，该属性的定义仅适用于某些非严格模式的函数。普通变体中的 `callee` 属性的定义存在是为了确保符合 ECMAScript 实现不会以任何其他方式定义它。

**注意 5**：ECMAScript 实现的参数异变对象历史上包含一个名为 `caller` 的访问器属性。在 ECMAScript 2017 之前，本规范包括了对普通 `arguments` 对象上的 `caller` 属性的抛出定义。由于实现不再包含此扩展，因此 ECMAScript 2017 删除了对抛出 `caller` 访问器的要求。

#### 10.4.4.1 `[[GetOwnProperty]] ( P )`
参数异变对象 `args` 的 `[[GetOwnProperty]]` 内部方法接受参数 `P`（一个属性键），并返回一个包含属性描述符或 `undefined` 的正常完成。调用时执行以下步骤：

1. 令 `desc` 为 `OrdinaryGetOwnProperty(args, P)`。
2. 如果 `desc` 为 `undefined`，则返回 `undefined`。
3. 令 `map` 为 `args.[[ParameterMap]]`。
4. 令 `isMapped` 为 `! HasOwnProperty(map, P)`。
5. 如果 `isMapped` 为 true，则
    a. 将 `desc.[[Value]]` 设置为 `! Get(map, P)`。
6. 返回 `desc`。

#### 10.4.4.2 `[[DefineOwnProperty]] ( P, Desc )`
参数异变对象 `args` 的 `[[DefineOwnProperty]]` 内部方法接受参数 `P`（一个属性键）和 `Desc`（一个属性描述符），并返回一个包含布尔值的正常完成。调用时执行以下步骤：

1. 令 `map` 为 `args.[[ParameterMap]]`。
2. 令 `isMapped` 为 `! HasOwnProperty(map, P)`。
3. 令 `newArgDesc` 为 `Desc`。
4. 如果 `isMapped` 为 true 并且 `IsDataDescriptor(Desc)` 为 true，则
    a. 如果 `Desc` 没有 `[[Value]]` 字段、`Desc` 具有 `[[Writable]]` 字段且 `Desc.[[Writable]]` 为 false，则
        i. 将 `newArgDesc` 设置为 `Desc` 的副本。
        ii. 将 `newArgDesc.[[Value]]` 设置为 `! Get(map, P)`。
5. 令 `allowed` 为 `! OrdinaryDefineOwnProperty(args, P, newArgDesc)`。
6. 如果 `allowed` 为 false，则返回 false。
7. 如果 `isMapped` 为 true，则
    a. 如果 `Desc` 是访问器描述符，则
        i. 执行 `! map.[[Delete]](P)`。
    b. 否则，
        i. 如果 `Desc` 具有 `[[Value]]` 字段，则
            1. 断言：由于参数异变对象映射的形式参数始终是可写的，因此以下 `Set` 将成功。
            2. 执行 `! Set(map, P, Desc.[[Value]], false)`。
        ii. 如果 `Desc` 具有 `[[Writable]]` 字段且 `Desc.[[Writable]]` 为 false，则
            1. 执行 `! map.[[Delete]](P)`。
8. 返回 true。

#### 10.4.4.3 `[[Get]] ( P, Receiver )`
参数异变对象 `args` 的 `[[Get]]` 内部方法接受参数 `P`（一个属性键）和 `Receiver`（一个 ECMAScript 语言值），并返回一个包含 ECMAScript 语言值或抛出完成的正常完成。调用时执行以下步骤：

1. 令 `map` 为 `args.[[ParameterMap]]`。
2. 令 `isMapped` 为 `! HasOwnProperty(map, P)`。
3. 如果 `isMapped` 为 false，则
    a. 返回 `? OrdinaryGet(args, P, Receiver)`。
4. 否则，
    a. 断言：`map` 包含 `P` 的形式参数映射。
    b. 返回 `! Get(map, P)`。

#### 10.4.4.4 `[[Set]] ( P, V, Receiver )`
参数异变对象 `args` 的 `[[Set]]` 内部方法接受参数 `P`（一个属性键）、`V`（一个 ECMAScript 语言值）和 `Receiver`（一个 ECMAScript 语言值），并返回一个包含布尔值或抛出完成的正常完成。调用时执行以下步骤：

1. 如果 `SameValue(args, Receiver)` 为 false，则
    a. 令 `isMapped` 为 false。
2. 否则，
    a. 令 `map` 为 `args.[[ParameterMap]]`。
    b. 令 `isMapped` 为 `! HasOwnProperty(map, P)`。
3. 如果 `isMapped` 为 true，则
    a. 断言：由于参数异变对象映射的形式参数始终是可写的，因此以下 `Set` 将成功。
    b. 执行 `! Set(map, P, V, false)`。
4. 返回 `? OrdinarySet(args, P, V, Receiver)`。

#### 10.4.4.5 `[[Delete]] ( P )`
参数异变对象 `args` 的 `[[Delete]]` 内部方法接受参数 `P`（一个属性键），并返回一个包含布尔值或抛出完成的正常完成。调用时执行以下步骤：

1. 令 `map` 为 `args.[[ParameterMap]]`。
2. 令 `isMapped` 为 `! HasOwnProperty(map, P)`。
3. 令 `result` 为 `? OrdinaryDelete(args, P)`。
4. 如果 `result` 为 true 并且 `isMapped` 为 true，则
    a. 执行 `! map.[[Delete]](P)`。
5. 返回 `result`。

#### 10.4.4.6 `CreateUnmappedArgumentsObject ( argumentsList )`
抽象操作 `CreateUnmappedArgumentsObject` 接受参数 `argumentsList`（一个 ECMAScript 语言值列表），并返回一个普通对象。调用时执行以下步骤：

1. 令 `len` 为 `argumentsList` 中元素的数量。
2. 令 `obj` 为 `OrdinaryObjectCreate(%Object.prototype%, « [[ParameterMap]] »)`。
3. 将 `obj.[[ParameterMap]]` 设置为 `undefined`。
4. 执行 `! DefinePropertyOrThrow(obj, "length", PropertyDescriptor { [[Value]]: 𝔽(len), [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true })`。
5. 令 `index` 为 0。
6. 重复好的，继续翻译：

6. 重复执行以下步骤，直到 `index` 等于 `len`:
    a. 令 `val` 为 `argumentsList[index]`。
    b. 执行 `! CreateDataPropertyOrThrow(obj, ! ToString(𝔽(index)), val)`。
    c. 将 `index` 增加 1。

7. 执行 `! DefinePropertyOrThrow(obj, @@iterator, PropertyDescriptor { [[Value]]: %Array.prototype.values%, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true })`。
8. 执行 `! DefinePropertyOrThrow(obj, "callee", PropertyDescriptor { [[Get]]: %ThrowTypeError%, [[Set]]: %ThrowTypeError%, [[Enumerable]]: false, [[Configurable]]: false })`。
9. 返回 `obj`。

#### 10.4.4.7 `CreateMappedArgumentsObject ( func, formals, argumentsList, env )`
抽象操作 `CreateMappedArgumentsObject` 接受参数 `func`（一个对象）、`formals`（一个解析节点）、`argumentsList`（一个 ECMAScript 语言值列表）和 `env`（一个环境记录），并返回一个参数异变对象。调用时执行以下步骤：

1. 断言：`formals` 不包含剩余参数、任何绑定模式或任何初始化器。它可能包含重复的标识符。
2. 令 `len` 为 `argumentsList` 中元素的数量。
3. 令 `obj` 为 `MakeBasicObject(« [[Prototype]], [[Extensible]], [[ParameterMap]] »)`。
4. 设置 `obj.[[GetOwnProperty]]` 为 10.4.4.1 中的规范。
5. 设置 `obj.[[DefineOwnProperty]]` 为 10.4.4.2 中的规范。
6. 设置 `obj.[[Get]]` 为 10.4.4.3 中的规范。
7. 设置 `obj.[[Set]]` 为 10.4.4.4 中的规范。
8. 设置 `obj.[[Delete]]` 为 10.4.4.5 中的规范。
9. 设置 `obj.[[Prototype]]` 为 `%Object.prototype%`。
10. 令 `map` 为 `OrdinaryObjectCreate(null)`。
11. 将 `obj.[[ParameterMap]]` 设置为 `map`。
12. 令 `parameterNames` 为 `formals` 的绑定名称。
13. 令 `numberOfParameters` 为 `parameterNames` 中元素的数量。
14. 令 `index` 为 0。
15. 重复执行以下步骤，直到 `index` 等于 `len`:
    a. 令 `val` 为 `argumentsList[index]`。
    b. 执行 `! CreateDataPropertyOrThrow(obj, ! ToString(𝔽(index)), val)`。
    c. 将 `index` 增加 1。

16. 执行 `! DefinePropertyOrThrow(obj, "length", PropertyDescriptor { [[Value]]: 𝔽(len), [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true })`。
17. 令 `mappedNames` 为一个新的空列表。
18. 将 `index` 设置为 `numberOfParameters - 1`。
19. 重复执行以下步骤，直到 `index` 小于 0:
    a. 令 `name` 为 `parameterNames[index]`。
    b. 如果 `mappedNames` 不包含 `name`，则
        i. 将 `name` 附加到 `mappedNames`。
        ii. 如果 `index` 小于 `len`，则
            1. 令 `g` 为 `MakeArgGetter(name, env)`。
            2. 令 `p` 为 `MakeArgSetter(name, env)`。
            3. 执行 `! map.[[DefineOwnProperty]](! ToString(𝔽(index)), PropertyDescriptor { [[Set]]: p, [[Get]]: g, [[Enumerable]]: false, [[Configurable]]: true })`。
    c. 将 `index` 减少 1。

20. 执行 `! DefinePropertyOrThrow(obj, @@iterator, PropertyDescriptor { [[Value]]: %Array.prototype.values%, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true })`。
21. 执行 `! DefinePropertyOrThrow(obj, "callee", PropertyDescriptor { [[Value]]: func, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true })`。
22. 返回 `obj`。

##### 10.4.4.7.1 `MakeArgGetter ( name, env )`
抽象操作 `MakeArgGetter` 接受参数 `name`（一个字符串）和 `env`（一个环境记录），并返回一个函数对象。它创建了一个内置函数对象，该函数执行时返回在 `env` 中绑定的 `name` 的值。调用时执行以下步骤：

1. 令 `getterClosure` 为一个新的抽象闭包，没有参数，捕获 `name` 和 `env`，并在调用时执行以下步骤：
    a. 返回 `env.GetBindingValue(name, false)`。

2. 令 `getter` 为 `CreateBuiltinFunction(getterClosure, 0, "", « »)`。
3. **注意**：`getter` 不会直接暴露给 ECMAScript 代码。
4. 返回 `getter`。

##### 10.4.4.7.2 `MakeArgSetter ( name, env )`
抽象操作 `MakeArgSetter` 接受参数 `name`（一个字符串）和 `env`（一个环境记录），并返回一个函数对象。它创建了一个内置函数对象，该函数执行时在 `env` 中设置 `name` 的值。调用时执行以下步骤：

1. 令 `setterClosure` 为一个新的抽象闭包，参数为 `(value)`，捕获 `name` 和 `env`，并在调用时执行以下步骤：
    a. 返回 `! env.SetMutableBinding(name, value, false)`。

2. 令 `setter` 为 `CreateBuiltinFunction(setterClosure, 1, "", « »)`。
3. **注意**：`setter` 不会直接暴露给 ECMAScript 代码。
4. 返回 `setter`。

#### 10.4.5 类型化数组异变对象
类型化数组是一种对整数索引属性键进行特殊处理的异变对象。

类型化数组具有与普通对象相同的内部槽，另外还包括 `[[ViewedArrayBuffer]]`、`[[ArrayLength]]`、`[[ByteOffset]]`、`[[ContentType]]` 和 `[[TypedArrayName]]` 内部槽。

如果一个对象的 `[[GetOwnProperty]]`、`[[HasProperty]]`、`[[DefineOwnProperty]]`、`[[Get]]`、`[[Set]]`、`[[Delete]]` 和 `[[OwnPropertyKeys]]` 内部方法使用本节中的定义，并且其其他基本内部方法使用 10.1 中的定义，则该对象是类型化数组。这些方法是在 `TypedArrayCreate` 中安装的。

##### 10.4.5.1 `[[GetOwnProperty]] ( P )`
类型化数组 `O` 的 `[[GetOwnProperty]]` 内部方法接受参数 `P`（一个属性键），并返回一个包含属性描述符或 `undefined` 的正常完成。调用时执行以下步骤：

1. 如果 `P` 是字符串，则
    a. 令 `numericIndex` 为 `CanonicalNumericIndexString(P)`。
    b. 如果 `numericIndex` 不为 `undefined`，则
        i. 令 `value` 为 `TypedArrayGetElement(O, numericIndex)`。
        ii. 如果 `value` 为 `undefined`，则返回 `undefined`。
        iii. 返回属性描述符 `{ [[Value]]: value, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true }`。

2. 返回 `OrdinaryGetOwnProperty(O, P)`。

##### 10.4.5.2 `[[HasProperty]] ( P )`
类型化数组 `O` 的 `[[HasProperty]]` 内部方法接受参数 `P`（一个属性键），并返回一个包含布尔值的正常完成。调用时执行以下步骤：

1. 如果 `P` 是字符串，则
    a. 令 `numericIndex` 为 `CanonicalNumericIndexString(P)`。
    b. 如果 `numericIndex` 不为 `undefined`，返回 `IsValidIntegerIndex(O, numericIndex)`。

2. 返回 `? OrdinaryHasProperty(O, P)`。

##### 10.4.5.3 `[[DefineOwnProperty]] ( P, Desc )`
类型化数组 `O` 的 `[[DefineOwnProperty]]` 内部方法接受参数 `P`（一个属性键）和 `Desc`（一个属性描述符），并返回一个包含布尔值的正常完成。调用时执行以下步骤：

1. 如果 `P` 是字符串，则
    a. 令 `numericIndex` 为 `CanonicalNumericIndexString(P)`。
    b. 如果 `numericIndex` 不为 `undefined`，则
        i. 如果 `IsValidIntegerIndex(O, numericIndex)` 为 false，返回 false。
       

 ii. 如果 `Desc` 具有 `[[Configurable]]` 字段且 `Desc.[[Configurable]]` 为 false，返回 false。
        iii. 如果 `Desc` 具有 `[[Enumerable]]` 字段且 `Desc.[[Enumerable]]` 为 false，返回 false。
        iv. 如果 `IsAccessorDescriptor(Desc)` 为 true，返回 false。
        v. 如果 `Desc` 具有 `[[Writable]]` 字段且 `Desc.[[Writable]]` 为 false，返回 false。
        vi. 如果 `Desc` 具有 `[[Value]]` 字段，执行 `? TypedArraySetElement(O, numericIndex, Desc.[[Value]])`。
        vii. 返回 true。

2. 返回 `! OrdinaryDefineOwnProperty(O, P, Desc)`。

##### 10.4.5.4 `[[Get]] ( P, Receiver )`
类型化数组 `O` 的 `[[Get]]` 内部方法接受参数 `P`（一个属性键）和 `Receiver`（一个 ECMAScript 语言值），并返回一个包含 ECMAScript 语言值或抛出完成的正常完成。调用时执行以下步骤：

1. 如果 `P` 是字符串，则
    a. 令 `numericIndex` 为 `CanonicalNumericIndexString(P)`。
    b. 如果 `numericIndex` 不为 `undefined`，则
        i. 返回 `TypedArrayGetElement(O, numericIndex)`。

2. 返回 `? OrdinaryGet(O, P, Receiver)`。

##### 10.4.5.5 `[[Set]] ( P, V, Receiver )`
类型化数组 `O` 的 `[[Set]]` 内部方法接受参数 `P`（一个属性键）、`V`（一个 ECMAScript 语言值）和 `Receiver`（一个 ECMAScript 语言值），并返回一个包含布尔值或抛出完成的正常完成。调用时执行以下步骤：

1. 如果 `P` 是字符串，则
    a. 令 `numericIndex` 为 `CanonicalNumericIndexString(P)`。
    b. 如果 `numericIndex` 不为 `undefined`，则
        i. 如果 `SameValue(O, Receiver)` 为 true，则
            1. 执行 `? TypedArraySetElement(O, numericIndex, V)`。
            2. 返回 true。
        ii. 如果 `IsValidIntegerIndex(O, numericIndex)` 为 false，返回 true。

2. 返回 `? OrdinarySet(O, P, V, Receiver)`。

##### 10.4.5.6 `[[Delete]] ( P )`
类型化数组 `O` 的 `[[Delete]]` 内部方法接受参数 `P`（一个属性键），并返回一个包含布尔值的正常完成。调用时执行以下步骤：

1. 如果 `P` 是字符串，则
    a. 令 `numericIndex` 为 `CanonicalNumericIndexString(P)`。
    b. 如果 `numericIndex` 不为 `undefined`，则
        i. 如果 `IsValidIntegerIndex(O, numericIndex)` 为 false，返回 true；否则返回 false。

2. 返回 `! OrdinaryDelete(O, P)`。

##### 10.4.5.7 `[[OwnPropertyKeys]] ( )`
类型化数组 `O` 的 `[[OwnPropertyKeys]]` 内部方法不接受参数，并返回一个包含属性键列表的正常完成。调用时执行以下步骤：

1. 令 `taRecord` 为 `MakeTypedArrayWithBufferWitnessRecord(O, SEQ-CST)`。
2. 令 `keys` 为一个新的空列表。
3. 如果 `IsTypedArrayOutOfBounds(taRecord)` 为 false，则
    a. 令 `length` 为 `TypedArrayLength(taRecord)`。
    b. 对于每个整数 `i`，使 0 ≤ i < length，以升序顺序执行以下步骤：
        i. 将 `! ToString(𝔽(i))` 附加到 `keys`。

4. 对于 `O` 的每个自己的属性键 `P`，如果 `P` 是字符串且 `P` 不是整数索引，则按属性创建的时间顺序升序执行以下步骤：
    a. 将 `P` 附加到 `keys`。

5. 对于 `O` 的每个自己的属性键 `P`，如果 `P` 是符号，则按属性创建的时间顺序升序执行以下步骤：
    a. 将 `P` 附加到 `keys`。

6. 返回 `keys`。

##### 10.4.5.8 `TypedArray With Buffer Witness Records`
`TypedArray With Buffer Witness Record` 是一种记录值，用于封装一个类型化数组以及视图缓冲区的缓存字节长度。当视图缓冲区是可增长的 `SharedArrayBuffer` 时，它有助于确保单个共享内存读取事件的数据块字节长度。

`TypedArray With Buffer Witness Records` 具有表 32 中列出的字段。

**表 32：TypedArray With Buffer Witness Record 字段**

| 字段名                | 值               | 含义                                                |
| -------------------- | --------------- | -------------------------------------------------- |
| `[[Object]]`         | 一个类型化数组   | 加载其缓冲区字节长度的类型化数组。                  |
| `[[CachedBufferByteLength]]` | 非负整数或 `DETACHED` | 创建记录时对象的 `[[ViewedArrayBuffer]]` 的字节长度。|

##### 10.4.5.9 `MakeTypedArrayWithBufferWitnessRecord ( obj, order )`
抽象操作 `MakeTypedArrayWithBufferWitnessRecord` 接受参数 `obj`（一个类型化数组）和 `order`（SEQ-CST 或 UNORDERED），并返回一个 `TypedArray With Buffer Witness Record`。调用时执行以下步骤：

1. 令 `buffer` 为 `obj.[[ViewedArrayBuffer]]`。
2. 如果 `IsDetachedBuffer(buffer)` 为 true，则
    a. 将 `byteLength` 设置为 `DETACHED`。
3. 否则，
    a. 将 `byteLength` 设置为 `ArrayBufferByteLength(buffer, order)`。

4. 返回 `TypedArray With Buffer Witness Record { [[Object]]: obj, [[CachedBufferByteLength]]: byteLength }`。

##### 10.4.5.10 `TypedArrayCreate ( prototype )`
抽象操作 `TypedArrayCreate` 接受参数 `prototype`（一个对象），并返回一个类型化数组。调用时执行以下步骤：

1. 令 `internalSlotsList` 为 `« [[Prototype]], [[Extensible]], [[ViewedArrayBuffer]], [[TypedArrayName]], [[ContentType]], [[ByteLength]], [[ByteOffset]], [[ArrayLength]] »`。
2. 令 `A` 为 `MakeBasicObject(internalSlotsList)`。
3. 设置 `A.[[GetOwnProperty]]` 为 10.4.5.1 中的规范。
4. 设置 `A.[[HasProperty]]` 为 10.4.5.2 中的规范。
5. 设置 `A.[[DefineOwnProperty]]` 为 10.4.5.3 中的规范。
6. 设置 `A.[[Get]]` 为 10.4.5.4 中的规范。
7. 设置 `A.[[Set]]` 为 10.4.5.5 中的规范。
8. 设置 `A.[[Delete]]` 为 10.4.5.6 中的规范。
9. 设置 `A.[[OwnPropertyKeys]]` 为 10.4.5.7 中的规范。
10. 设置 `A.[[Prototype]]` 为 `prototype`。
11. 返回 `A`。

##### 10.4.5.11 `TypedArrayByteLength ( taRecord )`
抽象操作 `TypedArrayByteLength` 接受参数 `taRecord`（一个 `TypedArray With Buffer Witness Record`），并返回一个非负整数。调用时执行以下步骤：

1. 如果 `IsTypedArrayOutOfBounds(taRecord)` 为 true，返回 0。
2. 令 `length` 为 `TypedArrayLength(taRecord)`。
3. 如果 `length` 等于 0，返回 0。
4. 令 `O` 为 `taRecord.[[Object]]`。
5. 如果 `O.[[ByteLength]]` 不是 `AUTO`，返回 `O.[[ByteLength]]`。
6. 令 `elementSize` 为 `TypedArrayElementSize(O)`。
7. 返回 `length × elementSize`。

##### 10.4.5.12 `TypedArrayLength ( taRecord )`
抽象操作 `TypedArrayLength` 接受参数 `taRecord`（一个 `TypedArray With Buffer Witness Record`），并返回一个非负整数。调用时执行以下步骤：

1. 断言：`IsTypedArrayOutOfBounds(taRecord)` 为 false。
2. 令 `O` 为 `taRecord.[[Object]]`。
3. 如果 `O.[[ArrayLength]]` 不是 `AUTO`，返回 `O.[[ArrayLength]]`。
4. 断言：`IsFixedLengthArrayBuffer(O.[[ViewedArrayBuffer]])` 为 false。
5. 令 `byteOffset` 为 `O.[[ByteOffset]]`。
6. 令 `elementSize` 为 `TypedArrayElementSize(O)`。
7. 令 `byteLength` 为 `taRecord.[[CachedBufferByteLength]]`

。
8. 断言：`byteLength` 不是 `DETACHED`。
9. 返回 `floor((byteLength - byteOffset) / elementSize)`。

##### 10.4.5.13 `IsTypedArrayOutOfBounds ( taRecord )`
抽象操作 `IsTypedArrayOutOfBounds` 接受参数 `taRecord`（一个 `TypedArray With Buffer Witness Record`），并返回一个布尔值。它检查对象的任何数字属性是否引用了不包含在底层缓冲区范围内的索引值。调用时执行以下步骤：

1. 令 `O` 为 `taRecord.[[Object]]`。
2. 令 `bufferByteLength` 为 `taRecord.[[CachedBufferByteLength]]`。
3. 断言：如果 `IsDetachedBuffer(O.[[ViewedArrayBuffer]])` 为 true，则 `bufferByteLength` 为 `DETACHED`。
4. 如果 `bufferByteLength` 为 `DETACHED`，返回 true。
5. 令 `byteOffsetStart` 为 `O.[[ByteOffset]]`。
6. 如果 `O.[[ArrayLength]]` 为 `AUTO`，则
    a. 令 `byteOffsetEnd` 为 `bufferByteLength`。
7. 否则，
    a. 令 `elementSize` 为 `TypedArrayElementSize(O)`。
    b. 令 `byteOffsetEnd` 为 `byteOffsetStart + O.[[ArrayLength]] × elementSize`。

8. 如果 `byteOffsetStart > bufferByteLength` 或 `byteOffsetEnd > bufferByteLength`，返回 true。
9. **注意**：长度为 0 的类型化数组不被认为是越界的。
10. 返回 false。

##### 10.4.5.14 `IsValidIntegerIndex ( O, index )`
抽象操作 `IsValidIntegerIndex` 接受参数 `O`（一个类型化数组）和 `index`（一个数字），并返回一个布尔值。调用时执行以下步骤：

1. 如果 `IsDetachedBuffer(O.[[ViewedArrayBuffer]])` 为 true，返回 false。
2. 如果 `index` 不是整数数字，返回 false。
3. 如果 `index` 为 -0𝔽，返回 false。
4. 令 `taRecord` 为 `MakeTypedArrayWithBufferWitnessRecord(O, UNORDERED)`。
5. **注意**：当 `O` 的后备缓冲区是可增长的 `SharedArrayBuffer` 时，边界检查不是同步操作。
6. 如果 `IsTypedArrayOutOfBounds(taRecord)` 为 true，返回 false。
7. 令 `length` 为 `TypedArrayLength(taRecord)`。
8. 如果 ℝ(index) < 0 或 ℝ(index) ≥ length，返回 false。
9. 返回 true。

##### 10.4.5.15 `TypedArrayGetElement ( O, index )`
抽象操作 `TypedArrayGetElement` 接受参数 `O`（一个类型化数组）和 `index`（一个数字），并返回一个数字、BigInt 或 `undefined`。调用时执行以下步骤：

1. 如果 `IsValidIntegerIndex(O, index)` 为 false，返回 `undefined`。
2. 令 `offset` 为 `O.[[ByteOffset]]`。
3. 令 `elementSize` 为 `TypedArrayElementSize(O)`。
4. 令 `byteIndexInBuffer` 为 `(ℝ(index) × elementSize) + offset`。
5. 令 `elementType` 为 `TypedArrayElementType(O)`。
6. 返回 `GetValueFromBuffer(O.[[ViewedArrayBuffer]], byteIndexInBuffer, elementType, true, UNORDERED)`。

##### 10.4.5.16 `TypedArraySetElement ( O, index, value )`
抽象操作 `TypedArraySetElement` 接受参数 `O`（一个类型化数组）、`index`（一个数字）和 `value`（一个 ECMAScript 语言值），并返回一个包含 `UNUSED` 或抛出完成的正常完成。调用时执行以下步骤：

1. 如果 `O.[[ContentType]]` 为 `BIGINT`，令 `numValue` 为 `? ToBigInt(value)`。
2. 否则，令 `numValue` 为 `? ToNumber(value)`。
3. 如果 `IsValidIntegerIndex(O, index)` 为 true，则
    a. 令 `offset` 为 `O.[[ByteOffset]]`。
    b. 令 `elementSize` 为 `TypedArrayElementSize(O)`。
    c. 令 `byteIndexInBuffer` 为 `(ℝ(index) × elementSize) + offset`。
    d. 令 `elementType` 为 `TypedArrayElementType(O)`。
    e. 执行 `SetValueInBuffer(O.[[ViewedArrayBuffer]], byteIndexInBuffer, elementType, numValue, true, UNORDERED)`。

4. 返回 `UNUSED`。

**注意**：此操作总是看似成功，但尝试写入类型化数组末尾之后或写入由分离的 `ArrayBuffer` 支持的类型化数组时无效。

##### 10.4.5.17 `IsArrayBufferViewOutOfBounds ( O )`
抽象操作 `IsArrayBufferViewOutOfBounds` 接受参数 `O`（一个类型化数组或 `DataView`），并返回一个布尔值。它检查类型化数组的任何数字属性或 `DataView` 对象的方法是否可以引用底层数据块边界之外的值。此抽象操作存在作为上游规范的便利。调用时执行以下步骤：

1. 如果 `O` 具有 `[[DataView]]` 内部槽，则
    a. 令 `viewRecord` 为 `MakeDataViewWithBufferWitnessRecord(O, SEQ-CST)`。
    b. 返回 `IsViewOutOfBounds(viewRecord)`。

2. 令 `taRecord` 为 `MakeTypedArrayWithBufferWitnessRecord(O, SEQ-CST)`。
3. 返回 `IsTypedArrayOutOfBounds(taRecord)`。

#### 10.4.6 模块命名空间异变对象
模块命名空间异变对象是一种异变对象，用于公开从 ECMAScript 模块导出的绑定（参见 16.2.3）。模块命名空间异变对象的字符串键自己的属性与模块导出的绑定名称一一对应。导出的绑定包括使用 `export *` 导出项间接导出的任何绑定。每个字符串值自己的属性键是对应导出绑定名称的 `StringValue`。这些是模块命名空间异变对象的唯一字符串键属性。每个这样的属性具有 `{ [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: false }` 属性。模块命名空间异变对象不可扩展。

如果一个对象的 `[[GetPrototypeOf]]`、`[[SetPrototypeOf]]`、`[[IsExtensible]]`、`[[PreventExtensions]]`、`[[GetOwnProperty]]`、`[[DefineOwnProperty]]`、`[[HasProperty]]`、`[[Get]]`、`[[Set]]`、`[[Delete]]` 和 `[[OwnPropertyKeys]]` 内部方法使用本节中的定义，并且其其他基本内部方法使用 10.1 中的定义，则该对象是模块命名空间异变对象。这些方法是在 `ModuleNamespaceCreate` 中安装的。

模块命名空间异变对象具有表 33 中定义的内部槽。

**表 33：模块命名空间异变对象的内部槽**

| 内部槽      | 类型            | 描述                                     |
| ---------- | --------------- | --------------------------------------- |
| `[[Module]]` | 一个模块记录     | 该模块记录，其导出此命名空间公开。       |
| `[[Exports]]` | 一个字符串列表   | 元素是作为此对象自己的属性公开的导出名称的字符串值的列表。列表按字典代码单元顺序排序。 |

##### 10.4.6.1 `[[GetPrototypeOf]] ( )`
模块命名空间异变对象的 `[[GetPrototypeOf]]` 内部方法不接受参数，并返回一个包含 `null` 的正常完成。调用时执行以下步骤：

1. 返回 `null`。

##### 10.4.6.2 `[[SetPrototypeOf]] ( V )`
模块命名空间异变对象 `O` 的 `[[SetPrototypeOf]]` 内部方法接受参数 `V`（一个对象或 `null`），并返回一个包含布尔值的正常完成。调用时执行以下步骤：

1. 返回 `! SetImmutablePrototype(O, V)`。

##### 10.4.6.3 `[[IsExtensible]] ( )`
模块命名空间异变对象的 `[[IsExtensible]]` 内部方法不接受参数，并返回一个包含 `false` 的正常完成。调用时执行以下步骤：

1. 返回 `false`。

##### 10.4.6.4 `[[PreventExtensions]] ( )`
模块命名空间异变对象的 `[[PreventExtensions]]` 内部方法不接受参数，并返回一个包含 `true` 的正常完成。调用时执行以下步骤：

1. 返回 `true`。

##### 10.4.6.5 `[[GetOwnProperty]] ( P )`
模块命名空间异变对象 `O` 的 `[[GetOwnProperty]]` 内部方法接受

参数 `P`（一个属性键），并返回一个包含属性描述符或 `undefined` 的正常完成或抛出完成。调用时执行以下步骤：

1. 如果 `P` 是符号，返回 `OrdinaryGetOwnProperty(O, P)`。
2. 令 `exports` 为 `O.[[Exports]]`。
3. 如果 `exports` 不包含 `P`，返回 `undefined`。
4. 令 `value` 为 `? O.[[Get]](P, O)`。
5. 返回属性描述符 `{ [[Value]]: value, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: false }`。

##### 10.4.6.6 `[[DefineOwnProperty]] ( P, Desc )`
模块命名空间异变对象 `O` 的 `[[DefineOwnProperty]]` 内部方法接受参数 `P`（一个属性键）和 `Desc`（一个属性描述符），并返回一个包含布尔值的正常完成或抛出完成。调用时执行以下步骤：

1. 如果 `P` 是符号，返回 `! OrdinaryDefineOwnProperty(O, P, Desc)`。
2. 令 `current` 为 `? O.[[GetOwnProperty]](P)`。
3. 如果 `current` 为 `undefined`，返回 false。
4. 如果 `Desc` 具有 `[[Configurable]]` 字段且 `Desc.[[Configurable]]` 为 true，返回 false。
5. 如果 `Desc` 具有 `[[Enumerable]]` 字段且 `Desc.[[Enumerable]]` 为 false，返回 false。
6. 如果 `IsAccessorDescriptor(Desc)` 为 true，返回 false。
7. 如果 `Desc` 具有 `[[Writable]]` 字段且 `Desc.[[Writable]]` 为 false，返回 false。
8. 如果 `Desc` 具有 `[[Value]]` 字段，返回 `SameValue(Desc.[[Value]], current.[[Value]])`。
9. 返回 true。

##### 10.4.6.7 `[[HasProperty]] ( P )`
模块命名空间异变对象 `O` 的 `[[HasProperty]]` 内部方法接受参数 `P`（一个属性键），并返回一个包含布尔值的正常完成。调用时执行以下步骤：

1. 如果 `P` 是符号，返回 `! OrdinaryHasProperty(O, P)`。
2. 令 `exports` 为 `O.[[Exports]]`。
3. 如果 `exports` 包含 `P`，返回 true。
4. 返回 false。

##### 10.4.6.8 `[[Get]] ( P, Receiver )`
模块命名空间异变对象 `O` 的 `[[Get]]` 内部方法接受参数 `P`（一个属性键）和 `Receiver`（一个 ECMAScript 语言值），并返回一个包含 ECMAScript 语言值或抛出完成的正常完成。调用时执行以下步骤：

1. 如果 `P` 是符号，则
    a. 返回 `! OrdinaryGet(O, P, Receiver)`。

2. 令 `exports` 为 `O.[[Exports]]`。
3. 如果 `exports` 不包含 `P`，返回 `undefined`。
4. 令 `m` 为 `O.[[Module]]`。
5. 令 `binding` 为 `m.ResolveExport(P)`。
6. 断言：`binding` 是一个已解析的绑定记录。
7. 令 `targetModule` 为 `binding.[[Module]]`。
8. 断言：`targetModule` 不为 `undefined`。
9. 如果 `binding.[[BindingName]]` 为 `NAMESPACE`，则
    a. 返回 `GetModuleNamespace(targetModule)`。

10. 令 `targetEnv` 为 `targetModule.[[Environment]]`。
11. 如果 `targetEnv` 为 `EMPTY`，抛出 `ReferenceError` 异常。
12. 返回 `? targetEnv.GetBindingValue(binding.[[BindingName]], true)`。

**注意**：`ResolveExport` 无副作用。每次使用特定的 `exportName` 和 `resolveSet` 参数调用此操作时，它必须返回相同的结果。实现可能选择预先计算或缓存 `ResolveExport` 对模块命名空间异变对象的 `[[Exports]]` 的结果。

##### 10.4.6.9 `[[Set]] ( P, V, Receiver )`
模块命名空间异变对象的 `[[Set]]` 内部方法接受参数 `P`（一个属性键）、`V`（一个 ECMAScript 语言值）和 `Receiver`（一个 ECMAScript 语言值），并返回一个包含 `false` 的正常完成。调用时执行以下步骤：

1. 返回 false。

##### 10.4.6.10 `[[Delete]] ( P )`
模块命名空间异变对象 `O` 的 `[[Delete]]` 内部方法接受参数 `P`（一个属性键），并返回一个包含布尔值的正常完成。调用时执行以下步骤：

1. 如果 `P` 是符号，则
    a. 返回 `! OrdinaryDelete(O, P)`。

2. 令 `exports` 为 `O.[[Exports]]`。
3. 如果 `exports` 包含 `P`，返回 false。
4. 返回 true。

##### 10.4.6.11 `[[OwnPropertyKeys]] ( )`
模块命名空间异变对象 `O` 的 `[[OwnPropertyKeys]]` 内部方法不接受参数，并返回一个包含属性键列表的正常完成。调用时执行以下步骤：

1. 令 `exports` 为 `O.[[Exports]]`。
2. 令 `symbolKeys` 为 `OrdinaryOwnPropertyKeys(O)`。
3. 返回 `exports` 和 `symbolKeys` 的列表连接。

##### 10.4.6.12 `ModuleNamespaceCreate ( module, exports )`
抽象操作 `ModuleNamespaceCreate` 接受参数 `module`（一个模块记录）和 `exports`（一个字符串列表），并返回一个模块命名空间异变对象。调用时执行以下步骤：

1. 断言：`module.[[Namespace]]` 为空。
2. 令 `internalSlotsList` 为表 33 中列出的内部槽。
3. 令 `M` 为 `MakeBasicObject(internalSlotsList)`。
4. 将 `M` 的基本内部方法设置为 10.4.6 中指定的定义。
5. 将 `M.[[Module]]` 设置为 `module`。
6. 令 `sortedExports` 为一个列表，其元素是按字典代码单元顺序排序的 `exports` 的元素。
7. 将 `M.[[Exports]]` 设置为 `sortedExports`。
8. 创建与 28.3 中的定义相对应的 `M` 的自己的属性。
9. 将 `module.[[Namespace]]` 设置为 `M`。
10. 返回 `M`。

#### 10.4.7 不可变原型异变对象
不可变原型异变对象是一种异变对象，其 `[[Prototype]]` 内部槽在初始化后不会更改。

如果一个对象的 `[[SetPrototypeOf]]` 内部方法使用以下实现（其其他基本内部方法可能使用任何实现，取决于具体的不可变原型异变对象），则该对象是不可变原型异变对象。

**注意**：与其他异变对象不同，不可变原型异变对象没有提供专用的创建抽象操作。这是因为它们仅用于 `%Object.prototype%` 和主机环境，在主机环境中，相关对象可能以其他方式是异变的，因此需要专用的创建操作。

##### 10.4.7.1 `[[SetPrototypeOf]] ( V )`
不可变原型异变对象 `O` 的 `[[SetPrototypeOf]]` 内部方法接受参数 `V`（一个对象或 `null`），并返回一个包含布尔值或抛出完成的正常完成。调用时执行以下步骤：

1. 返回 `? SetImmutablePrototype(O, V)`。

##### 10.4.7.2 `SetImmutablePrototype ( O, V )`
抽象操作 `SetImmutablePrototype` 接受参数 `O`（一个对象）和 `V`（一个对象或 `null`），并返回一个包含布尔值或抛出完成的正常完成。调用时执行以下步骤：

1. 令 `current` 为 `? O.[[GetPrototypeOf]]()`。
2. 如果 `SameValue(V, current)` 为 true，返回 true。
3. 返回 false。

### 10.5 代理对象的内部方法和内部槽

代理对象是一种特殊的对象，其基本内部方法部分由 ECMAScript 代码实现。每个代理对象都有一个名为 `[[ProxyHandler]]` 的内部槽。`[[ProxyHandler]]` 的值是一个对象，称为代理的处理程序对象，或者为 null。处理程序对象的方法（见表 34）可用于增强一个或多个代理对象的内部方法的实现。每个代理对象还有一个名为 `[[ProxyTarget]]` 的内部槽，其值要么是一个对象，要么是 null 值。这个对象被称为代理的目标对象。

如果一个对象的基本内部方法（包括 `[[Call]]` 和 `[[Construct]]`，如果适用）使用本节中的定义，则该对象是一个代理特殊对象。这些内部方法在 `ProxyCreate` 中被安装。

**表 34：代理处理程序方法**

| 内部方法                     | 处理程序方法              |
|-----------------------------|---------------------------|
| `[[GetPrototypeOf]]`        | getPrototypeOf            |
| `[[SetPrototypeOf]]`        | setPrototypeOf            |
| `[[IsExtensible]]`          | isExtensible              |
| `[[PreventExtensions]]`     | preventExtensions         |
| `[[GetOwnProperty]]`        | getOwnPropertyDescriptor  |
| `[[DefineOwnProperty]]`     | defineProperty            |
| `[[HasProperty]]`           | has                       |
| `[[Get]]`                   | get                       |
| `[[Set]]`                   | set                       |
| `[[Delete]]`                | deleteProperty            |
| `[[OwnPropertyKeys]]`       | ownKeys                   |
| `[[Call]]`                  | apply                     |
| `[[Construct]]`             | construct                 |

当调用处理程序方法来实现代理对象的内部方法时，处理程序方法会将代理的目标对象作为参数传递。代理的处理程序对象不一定具有对应于每个基本内部方法的方法。如果处理程序对象没有与内部陷阱对应的方法，则在代理上调用内部方法会调用代理目标对象上的相应内部方法。

代理对象的 `[[ProxyHandler]]` 和 `[[ProxyTarget]]` 内部槽在对象创建时总是被初始化，并且通常不允许修改。某些代理对象的创建方式允许它们在创建后被撤销。当代理被撤销时，其 `[[ProxyHandler]]` 和 `[[ProxyTarget]]` 内部槽被设置为 null，导致随后在该代理对象上调用内部方法时抛出 TypeError 异常。

由于代理对象允许通过任意 ECMAScript 代码来实现内部方法，因此可以定义一个其处理程序方法违反 6.1.7.3 中定义的不变量的代理对象。6.1.7.3 中定义的一些内部方法不变量是基本完整性不变量。这些不变量由本节中指定的代理对象内部方法明确执行。ECMAScript 实现必须能够在所有可能的不变量违反情况下保持健壮。

在以下算法描述中，假定 `O` 是一个 ECMAScript 代理对象，`P` 是一个属性键值，`V` 是任何 ECMAScript 语言值，`Desc` 是一个属性描述符记录。

#### 10.5.1 `[[GetPrototypeOf]] ( )`
代理特殊对象 `O` 的 `[[GetPrototypeOf]]` 内部方法不接受参数，并返回一个包含一个对象或 null 的正常完成，或者返回一个抛出完成。调用时执行以下步骤：

1. 执行 `? ValidateNonRevokedProxy(O)`。
2. 令 `target` 为 `O.[[ProxyTarget]]`。
3. 令 `handler` 为 `O.[[ProxyHandler]]`。
4. 断言：`handler` 是一个对象。
5. 令 `trap` 为 `? GetMethod(handler, "getPrototypeOf")`。
6. 如果 `trap` 是 undefined，
    a. 返回 `? target.[[GetPrototypeOf]]()`。
7. 令 `handlerProto` 为 `? Call(trap, handler, « target »)`。
8. 如果 `handlerProto` 不是一个对象且 `handlerProto` 不是 null，抛出 TypeError 异常。
9. 令 `extensibleTarget` 为 `? IsExtensible(target)`。
10. 如果 `extensibleTarget` 为 true，返回 `handlerProto`。
11. 令 `targetProto` 为 `? target.[[GetPrototypeOf]]()`。
12. 如果 `SameValue(handlerProto, targetProto)` 为 false，抛出 TypeError 异常。
13. 返回 `handlerProto`。

**注意** `[[GetPrototypeOf]]` 对代理对象执行以下不变量：

- `[[GetPrototypeOf]]` 的结果必须是一个对象或 null。
- 如果目标对象不可扩展，则对代理对象应用 `[[GetPrototypeOf]]` 必须返回与对代理对象的目标对象应用 `[[GetPrototypeOf]]` 相同的值。

#### 10.5.2 `[[SetPrototypeOf]] ( V )`
代理特殊对象 `O` 的 `[[SetPrototypeOf]]` 内部方法接受参数 `V`（一个对象或 null），并返回一个包含布尔值的正常完成，或者返回一个抛出完成。调用时执行以下步骤：

1. 执行 `? ValidateNonRevokedProxy(O)`。
2. 令 `target` 为 `O.[[ProxyTarget]]`。
3. 令 `handler` 为 `O.[[ProxyHandler]]`。
4. 断言：`handler` 是一个对象。
5. 令 `trap` 为 `? GetMethod(handler, "setPrototypeOf")`。
6. 如果 `trap` 是 undefined，
    a. 返回 `? target.[[SetPrototypeOf]](V)`。
7. 令 `booleanTrapResult` 为 `ToBoolean(? Call(trap, handler, « target, V »))`。
8. 如果 `booleanTrapResult` 为 false，返回 false。
9. 令 `extensibleTarget` 为 `? IsExtensible(target)`。
10. 如果 `extensibleTarget` 为 true，返回 true。
11. 令 `targetProto` 为 `? target.[[GetPrototypeOf]]()`。
12. 如果 `SameValue(V, targetProto)` 为 false，抛出 TypeError 异常。
13. 返回 true。

**注意** `[[SetPrototypeOf]]` 对代理对象执行以下不变量：

- `[[SetPrototypeOf]]` 的结果是一个布尔值。
- 如果目标对象不可扩展，参数值必须与应用于目标对象的 `[[GetPrototypeOf]]` 的结果相同。

#### 10.5.3 `[[IsExtensible]] ( )`
代理特殊对象 `O` 的 `[[IsExtensible]]` 内部方法不接受参数，并返回一个包含布尔值的正常完成，或者返回一个抛出完成。调用时执行以下步骤：

1. 执行 `? ValidateNonRevokedProxy(O)`。
2. 令 `target` 为 `O.[[ProxyTarget]]`。
3. 令 `handler` 为 `O.[[ProxyHandler]]`。
4. 断言：`handler` 是一个对象。
5. 令 `trap` 为 `? GetMethod(handler, "isExtensible")`。
6. 如果 `trap` 是 undefined，
    a. 返回 `? IsExtensible(target)`。
7. 令 `booleanTrapResult` 为 `ToBoolean(? Call(trap, handler, « target »))`。
8. 令 `targetResult` 为 `? IsExtensible(target)`。
9. 如果 `booleanTrapResult` 不等于 `targetResult`，抛出 TypeError 异常。
10. 返回 `booleanTrapResult`。

**注意** `[[IsExtensible]]` 对代理对象执行以下不变量：

- `[[IsExtensible]]` 的结果是一个布尔值。
- 对代理对象应用 `[[IsExtensible]]` 必须返回与对代理对象的目标对象应用 `[[IsExtensible]]` 相同的值。

#### 10.5.4 `[[PreventExtensions]] ( )`
代理特殊对象 `O` 的 `[[PreventExtensions]]` 内部方法不接受参数，并返回一个包含布尔值的正常完成，或者返回一个抛出完成。调用时执行以下步骤：

1. 执行 `? ValidateNonRevokedProxy(O)`。
2. 令 `target` 为 `O.[[ProxyTarget]]`。
3. 令 `handler` 为 `O.[[ProxyHandler]]`。
4. 断言：`handler` 是一个对象。
5. 令 `trap` 为 `? GetMethod(handler, "preventExtensions")`。
6. 如果 `trap` 是 undefined，
    a. 返回 `? target.[[PreventExtensions]]()`。
7. 令 `booleanTrapResult` 为 `ToBoolean(? Call(trap, handler, « target »))`。
8. 如果 `booleanTrapResult` 为 true，
    a. 令 `extensibleTarget` 为 `? IsExtensible(target)`。
    b. 如果 `extensibleTarget` 为 true，抛出 TypeError 异常。
9. 返回 `booleanTrapResult`。

**注意** `[[PreventExtensions]]` 对代理对象执行以下不变量：

- `[[PreventExtensions]]` 的结果

是一个布尔值。
- 只有当对代理对象的目标对象应用 `[[IsExtensible]]` 为 false 时，才会对代理对象应用 `[[PreventExtensions]]` 返回 true。

#### 10.5.5 `[[GetOwnProperty]] ( P )`
代理特殊对象 `O` 的 `[[GetOwnProperty]]` 内部方法接受参数 `P`（一个属性键），并返回一个包含一个属性描述符或 undefined 的正常完成，或者返回一个抛出完成。调用时执行以下步骤：

1. 执行 `? ValidateNonRevokedProxy(O)`。
2. 令 `target` 为 `O.[[ProxyTarget]]`。
3. 令 `handler` 为 `O.[[ProxyHandler]]`。
4. 断言：`handler` 是一个对象。
5. 令 `trap` 为 `? GetMethod(handler, "getOwnPropertyDescriptor")`。
6. 如果 `trap` 是 undefined，
    a. 返回 `? target.[[GetOwnProperty]](P)`。
7. 令 `trapResultObj` 为 `? Call(trap, handler, « target, P »)`。
8. 如果 `trapResultObj` 不是一个对象且 `trapResultObj` 不是 undefined，抛出 TypeError 异常。
9. 令 `targetDesc` 为 `? target.[[GetOwnProperty]](P)`。
10. 如果 `trapResultObj` 是 undefined，
    a. 如果 `targetDesc` 是 undefined，返回 undefined。
    b. 如果 `targetDesc.[[Configurable]]` 为 false，抛出 TypeError 异常。
    c. 令 `extensibleTarget` 为 `? IsExtensible(target)`。
    d. 如果 `extensibleTarget` 为 false，抛出 TypeError 异常。
    e. 返回 undefined。
11. 令 `extensibleTarget` 为 `? IsExtensible(target)`。
12. 令 `resultDesc` 为 `? ToPropertyDescriptor(trapResultObj)`。
13. 执行 `CompletePropertyDescriptor(resultDesc)`。
14. 令 `valid` 为 `IsCompatiblePropertyDescriptor(extensibleTarget, resultDesc, targetDesc)`。
15. 如果 `valid` 为 false，抛出 TypeError 异常。
16. 如果 `resultDesc.[[Configurable]]` 为 false，
    a. 如果 `targetDesc` 是 undefined 或 `targetDesc.[[Configurable]]` 为 true，则
        i. 抛出 TypeError 异常。
    b. 如果 `resultDesc` 有 `[[Writable]]` 字段且 `resultDesc.[[Writable]]` 为 false，则
        i. 断言：`targetDesc` 有 `[[Writable]]` 字段。
        ii. 如果 `targetDesc.[[Writable]]` 为 true，抛出 TypeError 异常。
17. 返回 `resultDesc`。

**注意** `[[GetOwnProperty]]` 对代理对象执行以下不变量：

- `[[GetOwnProperty]]` 的结果必须是一个对象或 undefined。
- 如果目标对象的一个属性是不可配置的自有属性，则该属性不能被报告为不存在。
- 如果目标对象不可扩展，则一个属性不能被报告为不存在，除非它不存在于目标对象的自有属性中。
- 一个属性不能被报告为不可配置，除非它存在于目标对象的不可配置的自有属性中。
- 一个属性不能被报告为既不可配置又不可写，除非它存在于目标对象的既不可配置又不可写的自有属性中。

### 注解
Proxy对象的[[GetOwnProperty]]强制执行以下不变量：

1. [[GetOwnProperty]]的结果必须是一个对象或未定义（undefined）。
2. 如果目标对象（target object）存在一个不可配置的自有属性，则该属性不能被报告为不存在。
3. 如果目标对象不可扩展且存在一个自有属性，则该属性不能被报告为不存在。
4. 如果目标对象不存在一个自有属性且目标对象不可扩展，则该属性不能被报告为存在。
5. 除非目标对象存在一个不可配置的自有属性，否则该属性不能被报告为不可配置。
6. 除非目标对象存在一个不可配置且不可写的自有属性，否则该属性不能被报告为既不可配置又不可写。

### 10.5.6 [[DefineOwnProperty]] ( P, Desc )
Proxy特殊对象O的[[DefineOwnProperty]]内部方法接受参数P（属性键）和Desc（属性描述符），并返回一个包含布尔值的正常完成或一个抛出完成。它在调用时执行以下步骤：

1. 执行 ? ValidateNonRevokedProxy(O)。
2. 令target为O.[[ProxyTarget]]。
3. 令handler为O.[[ProxyHandler]]。
4. 断言：handler是一个对象。
5. 令trap为 ? GetMethod(handler, "defineProperty")。
6. 如果trap是未定义的，则
    a. 返回 ? target.[[DefineOwnProperty]](P, Desc)。
7. 令descObj为FromPropertyDescriptor(Desc)。
8. 令booleanTrapResult为ToBoolean(? Call(trap, handler, « target, P, descObj »))。
9. 如果booleanTrapResult为false，返回false。
10. 令targetDesc为 ? target.[[GetOwnProperty]](P)。
11. 令extensibleTarget为 ? IsExtensible(target)。
12. 如果Desc有一个[[Configurable]]字段且Desc.[[Configurable]]为false，则
    a. 令settingConfigFalse为true。
13. 否则，
    a. 令settingConfigFalse为false。
14. 如果targetDesc为未定义，则
    a. 如果extensibleTarget为false，抛出一个TypeError异常。
    b. 如果settingConfigFalse为true，抛出一个TypeError异常。
15. 否则，
    a. 如果IsCompatiblePropertyDescriptor(extensibleTarget, Desc, targetDesc)为false，抛出一个TypeError异常。
    b. 如果settingConfigFalse为true且targetDesc.[[Configurable]]为true，抛出一个TypeError异常。
    c. 如果IsDataDescriptor(targetDesc)为true，targetDesc.[[Configurable]]为false，且targetDesc.[[Writable]]为true，则
        i. 如果Desc有一个[[Writable]]字段且Desc.[[Writable]]为false，抛出一个TypeError异常。
16. 返回true。

### 注解
Proxy对象的[[DefineOwnProperty]]强制执行以下不变量：

1. [[DefineOwnProperty]]的结果是一个布尔值。
2. 如果目标对象不可扩展，则不能添加属性。
3. 除非存在对应的不可配置自有属性，否则属性不能为不可配置。
4. 除非存在对应的不可配置且不可写的自有属性，否则不可配置的属性不能为不可写。
5. 如果属性有对应的目标对象属性，则使用[[DefineOwnProperty]]将该属性的属性描述符应用于目标对象不会抛出异常。

### 10.5.7 [[HasProperty]] ( P )
Proxy特殊对象O的[[HasProperty]]内部方法接受参数P（属性键），并返回一个包含布尔值的正常完成或一个抛出完成。它在调用时执行以下步骤：

1. 执行 ? ValidateNonRevokedProxy(O)。
2. 令target为O.[[ProxyTarget]]。
3. 令handler为O.[[ProxyHandler]]。
4. 断言：handler是一个对象。
5. 令trap为 ? GetMethod(handler, "has")。
6. 如果trap是未定义的，则
    a. 返回 ? target.[[HasProperty]](P)。
7. 令booleanTrapResult为ToBoolean(? Call(trap, handler, « target, P »))。
8. 如果booleanTrapResult为false，则
    a. 令targetDesc为 ? target.[[GetOwnProperty]](P)。
    b. 如果targetDesc不是未定义的，则
        i. 如果targetDesc.[[Configurable]]为false，抛出一个TypeError异常。
        ii. 令extensibleTarget为 ? IsExtensible(target)。
        iii. 如果extensibleTarget为false，抛出一个TypeError异常。
9. 返回booleanTrapResult。

### 注解
Proxy对象的[[HasProperty]]强制执行以下不变量：

1. [[HasProperty]]的结果是一个布尔值。
2. 如果目标对象存在一个不可配置的自有属性，则该属性不能被报告为不存在。
3. 如果目标对象不可扩展且存在一个自有属性，则该属性不能被报告为不存在。

### 10.5.8 [[Get]] ( P, Receiver )

Proxy特殊对象O的[[Get]]内部方法接受参数P（属性键）和Receiver（一个ECMAScript语言值），并返回一个包含ECMAScript语言值的正常完成或一个抛出完成。调用时执行以下步骤：

1. 执行 ? ValidateNonRevokedProxy(O)。
2. 令target为O.[[ProxyTarget]]。
3. 令handler为O.[[ProxyHandler]]。
4. 断言：handler是一个对象。
5. 令trap为 ? GetMethod(handler, "get")。
6. 如果trap是未定义的，
    a. 返回 ? target.[[Get]](P, Receiver)。
7. 令trapResult为 ? Call(trap, handler, « target, P, Receiver »)。
8. 令targetDesc为 ? target.[[GetOwnProperty]](P)。
9. 如果targetDesc不是未定义且targetDesc.[[Configurable]]为false，
    a. 如果IsDataDescriptor(targetDesc)为true且targetDesc.[[Writable]]为false，
        i. 如果SameValue(trapResult, targetDesc.[[Value]])为false，抛出一个TypeError异常。
    b. 如果IsAccessorDescriptor(targetDesc)为true且targetDesc.[[Get]]是未定义，
        i. 如果trapResult不是未定义，抛出一个TypeError异常。
10. 返回trapResult。

### 注解
Proxy对象的[[Get]]强制执行以下不变量：

1. 如果目标对象的属性是一个不可写的、不可配置的自有数据属性，则报告的属性值必须与该属性值相同。
2. 如果目标对象的属性是一个不可配置的自有访问器属性，并且其[[Get]]属性是未定义，则报告的属性值必须是未定义。

### 10.5.9 [[Set]] ( P, V, Receiver )

Proxy特殊对象O的[[Set]]内部方法接受参数P（属性键）、V（一个ECMAScript语言值）和Receiver（一个ECMAScript语言值），并返回一个包含布尔值的正常完成或一个抛出完成。调用时执行以下步骤：

1. 执行 ? ValidateNonRevokedProxy(O)。
2. 令target为O.[[ProxyTarget]]。
3. 令handler为O.[[ProxyHandler]]。
4. 断言：handler是一个对象。
5. 令trap为 ? GetMethod(handler, "set")。
6. 如果trap是未定义的，
    a. 返回 ? target.[[Set]](P, V, Receiver)。
7. 令booleanTrapResult为ToBoolean(? Call(trap, handler, « target, P, V, Receiver »))。
8. 如果booleanTrapResult为false，返回false。
9. 令targetDesc为 ? target.[[GetOwnProperty]](P)。
10. 如果targetDesc不是未定义且targetDesc.[[Configurable]]为false，
    a. 如果IsDataDescriptor(targetDesc)为true且targetDesc.[[Writable]]为false，
        i. 如果SameValue(V, targetDesc.[[Value]])为false，抛出一个TypeError异常。
    b. 如果IsAccessorDescriptor(targetDesc)为true，
        i. 如果targetDesc.[[Set]]是未定义，抛出一个TypeError异常。
11. 返回true。

### 注解
Proxy对象的[[Set]]强制执行以下不变量：

1. [[Set]]的结果是一个布尔值。
2. 如果对应的目标对象属性是一个不可写的、不可配置的自有数据属性，则不能将属性值更改为与该属性值不同。
3. 如果对应的目标对象属性是一个不可配置的自有访问器属性，并且其[[Set]]属性是未定义，则不能设置属性值。

### 10.5.10 [[Delete]] ( P )

Proxy特殊对象O的[[Delete]]内部方法接受参数P（属性键），并返回一个包含布尔值的正常完成或一个抛出完成。调用时执行以下步骤：

1. 执行 ? ValidateNonRevokedProxy(O)。
2. 令target为O.[[ProxyTarget]]。
3. 令handler为O.[[ProxyHandler]]。
4. 断言：handler是一个对象。
5. 令trap为 ? GetMethod(handler, "deleteProperty")。
6. 如果trap是未定义的，
    a. 返回 ? target.[[Delete]](P)。
7. 令booleanTrapResult为ToBoolean(? Call(trap, handler, « target, P »))。
8. 如果booleanTrapResult为false，返回false。
9. 令targetDesc为 ? target.[[GetOwnProperty]](P)。
10. 如果targetDesc是未定义的，返回true。
11. 如果targetDesc.[[Configurable]]为false，抛出一个TypeError异常。
12. 令extensibleTarget为 ? IsExtensible(target)。
13. 如果extensibleTarget为false，抛出一个TypeError异常。
14. 返回true。

### 注解
Proxy对象的[[Delete]]强制执行以下不变量：

1. [[Delete]]的结果是一个布尔值。
2. 如果目标对象存在一个不可配置的自有属性，则该属性不能被报告为已删除。
3. 如果目标对象不可扩展且存在一个自有属性，则该属性不能被报告为已删除。

### 10.5.11 [[OwnPropertyKeys]] ( )

Proxy特殊对象O的[[OwnPropertyKeys]]内部方法不接受任何参数，并返回一个包含属性键列表的正常完成或一个抛出完成。调用时执行以下步骤：

1. 执行 ? ValidateNonRevokedProxy(O)。
2. 令target为O.[[ProxyTarget]]。
3. 令handler为O.[[ProxyHandler]]。
4. 断言：handler是一个对象。
5. 令trap为 ? GetMethod(handler, "ownKeys")。
6. 如果trap是未定义的，
    a. 返回 ? target.[[OwnPropertyKeys]]()。
7. 令trapResultArray为 ? Call(trap, handler, « target »)。
8. 令trapResult为 ? CreateListFromArrayLike(trapResultArray, « String, Symbol »)。
9. 如果trapResult包含任何重复条目，抛出一个TypeError异常。
10. 令extensibleTarget为 ? IsExtensible(target)。
11. 令targetKeys为 ? target.[[OwnPropertyKeys]]()。
12. 断言：targetKeys是一个属性键列表。
13. 断言：targetKeys不包含重复条目。
14. 令targetConfigurableKeys为一个新的空列表。
15. 令targetNonconfigurableKeys为一个新的空列表。
16. 对于targetKeys的每个元素key，执行
    a. 令desc为 ? target.[[GetOwnProperty]](key)。
    b. 如果desc不是未定义且desc.[[Configurable]]为false，
        i. 将key添加到targetNonconfigurableKeys。
    c. 否则，
        i. 将key添加到targetConfigurableKeys。
17. 如果extensibleTarget为true且targetNonconfigurableKeys为空，
    a. 返回trapResult。
18. 令uncheckedResultKeys为一个列表，其元素为trapResult的元素。
19. 对于targetNonconfigurableKeys的每个元素key，执行
    a. 如果uncheckedResultKeys不包含key，抛出一个TypeError异常。
    b. 从uncheckedResultKeys中移除key。
20. 如果extensibleTarget为true，返回trapResult。
21. 对于targetConfigurableKeys的每个元素key，执行
    a. 如果uncheckedResultKeys不包含key，抛出一个TypeError异常。
    b. 从uncheckedResultKeys中移除key。
22. 如果uncheckedResultKeys不为空，抛出一个TypeError异常。
23. 返回trapResult。

### 注解
Proxy对象的[[OwnPropertyKeys]]强制执行以下不变量：

1. [[OwnPropertyKeys]]的结果是一个列表。
2. 返回的列表不包含重复条目。
3. 每个结果列表元素的类型是String或Symbol。
4. 结果列表必须包含目标对象所有不可配置的自有属性的键。
5. 如果目标对象不可扩展，则结果列表必须包含目标对象所有自有属性的键且不包含其他值。

### 10.5.12 [[Call]] ( thisArgument, argumentsList )

Proxy特殊对象O的[[Call]]内部方法接受参数thisArgument（一个ECMAScript语言值）和argumentsList（一个ECMAScript语言值的列表），并返回一个包含ECMAScript语言值的正常完成或一个抛出完成。调用时执行以下步骤：

1. 执行 ? ValidateNonRevokedProxy(O)。
2. 令target为O.[[ProxyTarget]]。
3. 令handler为O.[[ProxyHandler]]。
4. 断言：handler是一个对象。
5. 令trap为 ? GetMethod(handler, "apply")。
6. 如果trap是未定义的，
    a. 返回 ? Call(target, thisArgument, argumentsList)。
7. 令argArray为CreateArrayFromList(argumentsList)。
8. 返回 ? Call(trap, handler, « target, thisArgument, argArray »)。

### 注解
只有当其[[ProxyTarget]]内部槽的初始值是一个具有[[Call]]内部方法的对象时，Proxy特殊对象才具有[[Call]]内部方法。

### 10.5.13 [[Construct]] ( argumentsList, newTarget )

Proxy特殊对象O的[[Construct]]内部方法接受参数argumentsList（一个ECMAScript语言值的列表）和newTarget（一个构造函数），并返回一个包含对象的正常完成或一个抛出完成。调用时执行以下步骤：

1. 执行 ? ValidateNonRevokedProxy(O)。
2. 令target为O.[[ProxyTarget]]。
3. 断言：IsConstructor(target)为true。
4. 令handler为O.[[ProxyHandler]]。
5. 断言：handler是一个对象。
6. 令trap为 ? GetMethod(handler, "construct")。
7. 如果trap是未定义的，
    a. 返回 ? Construct(target, argumentsList, newTarget)。
8. 令argArray为CreateArrayFromList(argumentsList)。
9. 令newObj为 ? Call(trap, handler, « target, argArray, newTarget »)。
10. 如果newObj不是一个对象，抛出一个TypeError异常。
11. 返回newObj。

### 注解1
只有当其[[ProxyTarget]]内部槽的初始值是一个具有[[Construct]]内部方法的对象时，Proxy特殊对象才具有[[Construct]]内部方法。

### 注解2
Proxy对象的[[Construct]]强制执行以下不变量：

1. [[Construct]]的结果必须是一个对象。

### 10.5.14 ValidateNonRevokedProxy ( proxy )

抽象操作ValidateNonRevokedProxy接受参数proxy（一个Proxy特殊对象），并返回一个包含UNUSED的正常完成或一个抛出完成。如果proxy已被撤销，则抛出一个TypeError异常。调用时执行以下步骤：

1. 如果proxy.[[ProxyTarget]]为null，抛出一个TypeError异常。
2. 断言：proxy.[[ProxyHandler]]不是null。
3. 返回UNUSED。

### 10.5.15 ProxyCreate ( target, handler )

抽象操作ProxyCreate接受参数target（一个ECMAScript语言值）和handler（一个ECMAScript语言值），并返回一个包含Proxy特殊对象的正常完成或一个抛出完成。它用于指定新Proxy对象的创建。调用时执行以下步骤：

1. 如果target不是一个对象，抛出一个TypeError异常。
2. 如果handler不是一个对象，抛出一个TypeError异常。
3. 令P为MakeBasicObject(« [[ProxyHandler]], [[ProxyTarget]] »)。
4. 将P的基本内部方法（除[[Call]]和[[Construct]]外）设置为10.5中指定的定义。
5. 如果IsCallable(target)为true，
    a. 设置P.[[Call]]如10.5.12中指定的。
    b. 如果IsConstructor(target)为true，
        i. 设置P.[[Construct]]如10.5.13中指定的。
6. 将P.[[ProxyTarget]]设置为target。
7. 将P.[[ProxyHandler]]设置为handler。
8. 返回P。

### 11 ECMAScript语言：源文本
### 11.1 源文本
#### 语法
SourceCharacter ::
任意Unicode码点

ECMAScript源文本是Unicode码点的序列。从U+0000到U+10FFFF的所有Unicode码点值，包括代理码点，均可出现在ECMAScript源文本中，只要符合ECMAScript语法。用于存储和交换ECMAScript源文本的实际编码与本规范无关。不论外部源文本编码如何，符合规范的ECMAScript实现都将源文本处理为等效的SourceCharacter值序列，每个SourceCharacter都是一个Unicode码点。符合规范的ECMAScript实现不需要对源文本进行任何规范化处理，或者表现得好像它们在对源文本进行规范化处理。

组合字符序列的组成部分被视为单独的Unicode码点，即使用户可能将整个序列视为一个单一字符。

#### 注解
在字符串字面量、正则表达式字面量、模板字面量和标识符中，任何Unicode码点也可以使用显式表达码点数值的Unicode转义序列表示。在注释中，这样的转义序列实际上被忽略，作为注释的一部分。

ECMAScript与Java编程语言在Unicode转义序列的行为上有所不同。在Java程序中，如果Unicode转义序列\u000A出现在单行注释中，它被解释为行终止符（Unicode码点U+000A是换行符（LF）），因此下一个码点不属于注释。同样地，如果Unicode转义序列\u000A出现在Java程序中的字符串字面量中，它同样被解释为行终止符，这在字符串字面量中是不允许的——必须写为\n才能使换行符（LF）成为字符串字面量的字符串值的一部分。在ECMAScript程序中，出现在注释中的Unicode转义序列从不被解释，因此不会导致注释终止。同样地，出现在ECMAScript程序中的字符串字面量中的Unicode转义序列始终构成字面量的一部分，从不被解释为行终止符或可能终止字符串字面量的码点。

### 11.1.1 静态语义：UTF16EncodeCodePoint（cp）
抽象操作UTF16EncodeCodePoint接受参数cp（一个Unicode码点）并返回一个字符串。调用时执行以下步骤：

1. 断言：0 ≤ cp ≤ 0x10FFFF。
2. 如果cp ≤ 0xFFFF，返回由数值为cp的码元组成的字符串值。
3. 令cu1为数值为floor((cp - 0x10000) / 0x400) + 0xD800的码元。
4. 令cu2为数值为((cp - 0x10000) modulo 0x400) + 0xDC00的码元。
5. 返回cu1和cu2的字符串连接。

### 11.1.2 静态语义：CodePointsToString（text）
抽象操作CodePointsToString接受参数text（一个Unicode码点序列）并返回一个字符串。它将text转换为一个字符串值，如6.1.4所述。调用时执行以下步骤：

1. 令result为空字符串。
2. 对于text中的每个码点cp，执行
   a. 将result设置为result和UTF16EncodeCodePoint(cp)的字符串连接。
3. 返回result。

### 11.1.3 静态语义：UTF16SurrogatePairToCodePoint（lead，trail）
抽象操作UTF16SurrogatePairToCodePoint接受参数lead（一个码元）和trail（一个码元）并返回一个码点。将形成UTF-16代理对的两个码元转换为一个码点。调用时执行以下步骤：

1. 断言：lead是前导代理，trail是后续代理。
2. 令cp为(lead - 0xD800) × 0x400 + (trail - 0xDC00) + 0x10000。
3. 返回码点cp。

### 11.1.4 静态语义：CodePointAt（string，position）
抽象操作CodePointAt接受参数string（一个字符串）和position（一个非负整数）并返回一个包含字段[[CodePoint]]（一个码点）、[[CodeUnitCount]]（一个正整数）和[[IsUnpairedSurrogate]]（一个布尔值）的记录。它将string解释为UTF-16编码的码点序列，如6.1.4所述，并从索引位置position开始读取一个码点。调用时执行以下步骤：

1. 令size为string的长度。
2. 断言：position ≥ 0且position < size。
3. 令first为string中索引位置为position的码元。
4. 令cp为数值等于first数值的码点。
5. 如果first既不是前导代理也不是后续代理，则
   a. 返回记录{ [[CodePoint]]: cp, [[CodeUnitCount]]: 1, [[IsUnpairedSurrogate]]: false }。
6. 如果first是后续代理或position + 1 = size，则
   a. 返回记录{ [[CodePoint]]: cp, [[CodeUnitCount]]: 1, [[IsUnpairedSurrogate]]: true }。
7. 令second为string中索引位置为position + 1的码元。
8. 如果second不是后续代理，则
   a. 返回记录{ [[CodePoint]]: cp, [[CodeUnitCount]]: 1, [[IsUnpairedSurrogate]]: true }。
9. 将cp设置为UTF16SurrogatePairToCodePoint(first, second)。
10. 返回记录{ [[CodePoint]]: cp, [[CodeUnitCount]]: 2, [[IsUnpairedSurrogate]]: false }。

### 11.1.5 静态语义：StringToCodePoints（string）
抽象操作StringToCodePoints接受参数string（一个字符串）并返回一个码点列表。它返回将string解释为UTF-16编码的Unicode文本所得到的Unicode码点序列，如6.1.4所述。调用时执行以下步骤：

1. 令codePoints为一个新的空列表。
2. 令size为string的长度。
3. 令position为0。
4. 重复，直到position < size，
   a. 令cp为CodePointAt(string, position)。
   b. 将cp.[[CodePoint]]追加到codePoints。
   c. 将position设置为position + cp.[[CodeUnitCount]]。
5. 返回codePoints。

### 11.1.6 静态语义：ParseText（sourceText，goalSymbol）
抽象操作ParseText接受参数sourceText（一个字符串或Unicode码点序列）和goalSymbol（ECMAScript语法中的一个非终结符）并返回一个解析节点或一个非空的SyntaxError对象列表。调用时执行以下步骤：

1. 如果sourceText是一个字符串，将sourceText设置为StringToCodePoints(sourceText)。
2. 尝试使用goalSymbol作为目标符号解析sourceText，并分析解析结果中的任何早期错误条件。解析和早期错误检测可以以实现定义的方式交错进行。
3. 如果解析成功且未发现早期错误，则返回解析树根部的解析节点（goalSymbol的一个实例）。
4. 否则，返回一个或多个SyntaxError对象列表，表示解析错误和/或早期错误。如果存在多个解析错误或早期错误，则列表中错误对象的数量和顺序是实现定义的，但至少要有一个。

### 注解1
考虑一个文本在特定点有一个早期错误，并且在后续点有一个语法错误。一个先解析后检测早期错误的实现可能报告语法错误，而不进行早期错误检测。一个交错进行这两种活动的实现可能报告早期错误，而不继续发现语法错误。第三种实现可能报告这两种错误。所有这些行为都是符合规范的。

### 注解2
另见第17条款。

### 11.2 源代码的类型
ECMAScript代码有四种类型：

- 全局代码是作为ECMAScript脚本处理的源文本。特定脚本的全局代码不包括作为FunctionDeclaration、FunctionExpression、GeneratorDeclaration、GeneratorExpression、AsyncFunctionDeclaration、AsyncFunctionExpression、AsyncGeneratorDeclaration、AsyncGeneratorExpression、MethodDefinition、ArrowFunction、AsyncArrowFunction、ClassDeclaration或ClassExpression一部分解析的任何源文本。
- Eval代码是提供给内置eval函数的源文本。更准确地说，如果内置eval函数的参数是一个字符串，则其被视为ECMAScript脚本。特定eval调用的eval代码是该脚本的全局代码部分。
- 函数代码是解析以提供ECMAScript函数对象的[[ECMAScriptCode]]和[[FormalParameters]]内部槽（见10.2）的值的源文本。特定ECMAScript函数的函数代码不包括作为嵌套的FunctionDeclaration、FunctionExpression、GeneratorDeclaration、GeneratorExpression、AsyncFunctionDeclaration、AsyncFunctionExpression、AsyncGeneratorDeclaration、AsyncGeneratorExpression、MethodDefinition、ArrowFunction、AsyncArrowFunction、ClassDeclaration或ClassExpression的函数代码解析的任何源文本。

此外，如果上述源文本被解析为：
- FunctionDeclaration或FunctionExpression的FormalParameters和FunctionBody，
- GeneratorDeclaration或GeneratorExpression的FormalParameters和GeneratorBody，
- AsyncFunctionDeclaration或AsyncFunctionExpression的FormalParameters和AsyncFunctionBody，或
- AsyncGeneratorDeclaration或AsyncGeneratorExpression的FormalParameters和AsyncGeneratorBody，

那么与该声明或表达式的BindingIdentifier（如果有）匹配的源文本也包括在相应函数的函数代码中。

- 模块代码是提供为ModuleBody的源文本。它是模块初始化时直接评估的代码。特定模块的模块代码不包括作为嵌套的FunctionDeclaration、FunctionExpression、GeneratorDeclaration、GeneratorExpression、AsyncFunctionDeclaration、AsyncFunctionExpression、AsyncGeneratorDeclaration、AsyncGeneratorExpression、MethodDefinition、ArrowFunction、AsyncArrowFunction、ClassDeclaration或ClassExpression一部分解析的任何源文本。

#### 注解1
函数代码通常作为函数定义（15.2）、箭头函数定义（15.3）、方法定义（15.4）、生成器函数定义（15.5）、异步函数定义（15.8）、异步生成器函数定义（15.6）和异步箭头函数（15.9）的主体提供。函数代码也源自Function构造函数（20.2.1.1）、GeneratorFunction构造函数（27.3.1.1）和AsyncFunction构造函数（27.7.1.1）的参数。

#### 注解2
将BindingIdentifier包括在函数代码中的实际效果是，即使周围代码不是严格模式代码，严格模式代码的早期错误也适用于包含“use strict”指令的函数名为BindingIdentifier的代码。

### 11.2.1 指令序列和使用严格指令
指令序列是FunctionBody、ScriptBody或ModuleBody的初始StatementListItems或ModuleItems中出现的最长的ExpressionStatements序列，并且序列中的每个ExpressionStatement完全由StringLiteral标记和分号组成。分号可以显式出现，也可以通过自动分号插入（12.10）插入。指令序列可以是一个空序列。

使用严格指令是指令序列中的一个ExpressionStatement，其StringLiteral是“use strict”或'use strict'的确切码点序列。使用严格指令不得包含EscapeSequence或LineContinuation。

指令序列可能包含多个使用严格指令。但是，如果出现这种情况，实现可能会发出警告。

#### 注解
在包含生成的评估过程中，指令序列的ExpressionStatements通常被正常评估。实现可能会为不是使用严格指令且出现在指令序列中的ExpressionStatements定义实现特定的含义。如果存在适当的通知机制，遇到不是使用严格指令且没有由实现定义含义的ExpressionStatement时，实现应发出警告。

### 11.2.2 严格模式代码
ECMAScript语法单元可以使用无限制或严格模式语法和语义（4.3.2）进行处理。在以下情况下，代码被解释为严格模式代码：

- 如果全局代码以包含使用严格指令的指令序列开始，则全局代码是严格模式代码。
- 模块代码始终是严格模式代码。
- ClassDeclaration或ClassExpression的所有部分都是严格模式代码。
- 如果eval代码以包含使用严格指令的指令序列开始，或调用eval的直接eval包含在严格模式代码中，则eval代码是严格模式代码。
- 如果相关的FunctionDeclaration、FunctionExpression、GeneratorDeclaration、GeneratorExpression、AsyncFunctionDeclaration、AsyncFunctionExpression、AsyncGeneratorDeclaration、AsyncGeneratorExpression、MethodDefinition、ArrowFunction或AsyncArrowFunction包含在严格模式代码中，或生成函数[[ECMAScriptCode]]内部槽值的代码以包含使用严格指令的指令序列开始，则函数代码是严格模式代码。
- 如果提供给内置Function、Generator、AsyncFunction和AsyncGenerator构造函数的参数是一个字符串，当处理时是以包含使用严格指令的指令序列开始的FunctionBody，则函数代码是严格模式代码。

非严格模式代码称为非严格代码。

### 11.2.2.1 静态语义：IsStrict（node）
抽象操作IsStrict接受参数node（一个解析节点）并返回一个布尔值。调用时执行以下步骤：

1. 如果node匹配的源文本是严格模式代码，返回true；否则返回false。

### 11.2.3 非ECMAScript函数
ECMAScript实现可能支持评估其评估行为以某种主机定义的可执行代码形式（非ECMAScript源文本）表示的函数特殊对象。从ECMAScript代码调用或被这种函数对象调用的角度来看，函数对象是ECMAScript代码中定义的还是内置函数是不可观察的。

### 12 ECMAScript语言：词法语法
ECMAScript脚本或模块的源文本首先被转换为输入元素序列，这些元素是标记、行终止符、注释或空白。源文本从左到右扫描，反复将最长可能的码点序列作为下一个输入元素。

在某些情况下，词法输入元素的识别对消耗输入元素的语法上下文是敏感的。这需要多个词法语法的目标符号。InputElementHashbangOrRegExp目标用于脚本或模块的开始。InputElementRegExpOrTemplateTail目标用于允许RegularExpressionLiteral、TemplateMiddle或TemplateTail的语法上下文。InputElementRegExp目标符号用于所有允许RegularExpressionLiteral但不允许TemplateMiddle或TemplateTail的语法上下文。InputElementTemplateTail目标用于所有允许TemplateMiddle或TemplateTail但不允许RegularExpressionLiteral的语法上下文。在所有其他上下文中，InputElementDiv作为词法目标符号使用。

#### 注解
使用多个词法目标确保没有影响自动分号插入的词法歧义。例如，没有语法上下文允许同时存在前导除法或除法赋值和前导RegularExpressionLiteral。这不受分号插入影响（见12.10）；在以下示例中：

```javascript
a = b
/hi/g.exec(c).map(d);
```

其中第一个非空白、非注释码点在LineTerminator之后是U+002F（SOLIDUS），且语法上下文允许除法或除法赋值，在LineTerminator处不插入分号。即，上述示例解释为：

```javascript
a = b / hi / g.exec(c).map(d);
```

#### 语法
```plaintext
InputElementDiv ::
  WhiteSpace
  LineTerminator
  Comment
  CommonToken
  DivPunctuator
  RightBracePunctuator

InputElementRegExp ::
  WhiteSpace
  LineTerminator
  Comment
  CommonToken
  RightBracePunctuator
  RegularExpressionLiteral

InputElementRegExpOrTemplateTail ::
  WhiteSpace
  LineTerminator
  Comment
  CommonToken
  RegularExpressionLiteral
  TemplateSubstitutionTail

InputElementTemplateTail ::
  WhiteSpace
  LineTerminator
  Comment
  CommonToken
  DivPunctuator
  TemplateSubstitutionTail

InputElementHashbangOrRegExp ::
  WhiteSpace
  LineTerminator
  Comment
  CommonToken
  HashbangComment
  RegularExpressionLiteral
```

### 12.1 Unicode格式控制字符
Unicode格式控制字符（即Unicode字符数据库中类别为“Cf”的字符，如LEFT-TO-RIGHT MARK或RIGHT-TO-LEFT MARK）是用于在没有更高级别协议（如标记语言）的情况下控制一段文本格式的控制代码。

允许在源文本中使用格式控制字符以方便编辑和显示是有用的。所有格式控制字符可以在注释、字符串字面量、模板字面量和正则表达式字面量中使用。

U+FEFF（零宽度不换行空格）是主要用于文本开头的格式控制字符，用于标记文本为Unicode并允许检测文本的编码和字节顺序。用于此目的的<ZWNBSP>字符有时也会在文本开头之后出现，例如由于文件连接的结果。在ECMAScript源文本中，<ZWNBSP>码点在注释、字符串字面量、模板字面量和正则表达式字面量之外被视为空白字符（见12.2）。

### 12.2 空白
空白码点用于提高源文本的可读性并将标记（不可分割的词法单位）彼此分隔开，但除此之外没有其他意义。空白码点可以出现在任何两个标记之间以及输入的开头或结尾。空白码点可以出现在StringLiteral、RegularExpressionLiteral、Template或TemplateSubstitutionTail中，在这些地方它们被视为组成字面量值一部分的有效码点。它们也可以出现在注释中，但不能出现在任何其他种类的标记中。

ECMAScript的空白码点列于表35中。

#### 表35：空白码点
| 码点     | 名称                  | 缩写      |
|----------|----------------------|-----------|
| U+0009   | 字符制表符           | <TAB>     |
| U+000B   | 行制表符             | <VT>      |
| U+000C   | 进纸符（FF）         | <FF>      |
| U+FEFF   | 零宽度不换行空格     | <ZWNBSP>  |
| 任何一般类别为“Space_Separator”的码点 | <USP> |

#### 注解1
U+0020（空格）和U+00A0（不换行空格）码点是<USP>的一部分。

#### 注解2
除了表35中列出的码点外，ECMAScript空白有意排除所有具有Unicode“White_Space”属性但不属于一般类别“Space_Separator”（“Zs”）的码点。

#### 语法
```plaintext
WhiteSpace ::
  <TAB>
  <VT>
  <FF>
  <ZWNBSP>
  <USP>
```

### 12.3 行终止符
像空白码点一样，行终止符码点用于提高源文本的可读性并将标记（不可分割的词法单位）彼此分隔开。然而，与空白码点不同，行终止符对语法的行为有一些影响。一般来说，行终止符可以出现在任何两个标记之间，但在某些地方语法禁止它们出现。行终止符还影响自动分号插入过程（见12.10）。行终止符不能出现在任何标记中，除了StringLiteral、Template或TemplateSubstitutionTail。<LF>和<CR>行终止符不能出现在StringLiteral标记中，除非作为LineContinuation的一部分。

行终止符可以出现在多行注释中，但不能出现在单行注释中。

### 12.3 行终止符（续）
行终止符包含在正则表达式中的\s类匹配的空白字符集合中。

ECMAScript的行终止符码点列于表36中。

#### 表36：行终止符码点
| 码点   | Unicode名称      | 缩写  |
|--------|------------------|-------|
| U+000A | 换行符（LF）     | <LF>  |
| U+000D | 回车符（CR）     | <CR>  |
| U+2028 | 行分隔符         | <LS>  |
| U+2029 | 段落分隔符       | <PS>  |

只有表36中的Unicode码点被视为行终止符。其他新的行或换行Unicode码点不被视为行终止符，但如果它们符合表35中的要求，则被视为空白字符。<CR><LF>序列通常用作行终止符。为了报告行号的目的，它应被视为单个SourceCharacter。

#### 语法
```plaintext
LineTerminator ::
  <LF>
  <CR>
  <LS>
  <PS>

LineTerminatorSequence ::
  <LF>
  <CR> [lookahead ≠ <LF>]
  <LS>
  <PS>
  <CR> <LF>
```

### 12.4 注释
注释可以是单行或多行。多行注释不能嵌套。

由于单行注释可以包含任何Unicode码点，除了行终止符码点，并且根据一般规则，标记总是尽可能长，因此单行注释总是由//标记到行尾的所有码点组成。然而，行尾的行终止符不被视为单行注释的一部分；它由词法语法单独识别并成为语法语法输入元素流的一部分。这一点非常重要，因为它意味着单行注释的存在与否不会影响自动分号插入过程（见12.10）。

注释的行为类似于空白字符，被丢弃，但如果多行注释包含行终止符码点，则整个注释在语法解析时被视为一个行终止符。

#### 语法
```plaintext
Comment ::
  MultiLineComment
  SingleLineComment

MultiLineComment ::
  /* MultiLineCommentCharsopt */

MultiLineCommentChars ::
  MultiLineNotAsteriskChar MultiLineCommentCharsopt
  * PostAsteriskCommentCharsopt

PostAsteriskCommentChars ::
  MultiLineNotForwardSlashOrAsteriskChar MultiLineCommentCharsopt
  * PostAsteriskCommentCharsopt

MultiLineNotAsteriskChar ::
  SourceCharacter but not *

MultiLineNotForwardSlashOrAsteriskChar ::
  SourceCharacter but not one of / or *

SingleLineComment ::
  // SingleLineCommentCharsopt

SingleLineCommentChars ::
  SingleLineCommentChar SingleLineCommentCharsopt

SingleLineCommentChar ::
  SourceCharacter but not LineTerminator
```

本节中的一些产生式在B.1.1节中有替代定义。

### 12.5 哈希符注释
哈希符注释是位置敏感的，并且像其他类型的注释一样从语法语法的输入元素流中丢弃。

#### 语法
```plaintext
HashbangComment ::
  #! SingleLineCommentCharsopt
```

### 12.6 标记
#### 语法
```plaintext
CommonToken ::
  IdentifierName
  PrivateIdentifier
  Punctuator
  NumericLiteral
  StringLiteral
  Template
```

注：DivPunctuator、RegularExpressionLiteral、RightBracePunctuator和TemplateSubstitutionTail产生额外的标记，不包括在CommonToken产生式中。

### 12.7 名称和关键字
IdentifierName和ReservedWord是根据Unicode标准附件#31《标识符和模式语法》中的默认标识符语法解释的标记，但有一些小的修改。ReservedWord是IdentifierName的枚举子集。语法语法将Identifier定义为不是ReservedWord的IdentifierName。Unicode标识符语法基于Unicode标准指定的字符属性。所有符合规范的ECMAScript实现必须将最新版本的Unicode标准中指定类别的Unicode码点视为那些类别。ECMAScript实现可以识别在后续版本的Unicode标准中定义的标识符码点。

#### 注解1
本标准指定了特定的码点补充：U+0024（美元符号）和U+005F（下划线）在IdentifierName中的任何位置都是允许的。

#### 语法
```plaintext
PrivateIdentifier ::
  # IdentifierName

IdentifierName ::
  IdentifierStart
  IdentifierName IdentifierPart

IdentifierStart ::
  IdentifierStartChar
  \ UnicodeEscapeSequence

IdentifierPart ::
  IdentifierPartChar
  \ UnicodeEscapeSequence

IdentifierStartChar ::
  UnicodeIDStart
  $
  _

IdentifierPartChar ::
  UnicodeIDContinue
  $
  AsciiLetter :: one of
    a b c d e f g h i j k l m n o p q r s t u v w x y z A B C D E F G H I J K L M N O P Q R S T U V W X Y Z

UnicodeIDStart ::
  any Unicode code point with the Unicode property “ID_Start”

UnicodeIDContinue ::
  any Unicode code point with the Unicode property “ID_Continue”
```

非终结符UnicodeEscapeSequence的定义见12.9.4。

#### 注解2
非终结符IdentifierPart通过UnicodeIDContinue派生出_。

#### 注解3
具有Unicode属性“ID_Start”和“ID_Continue”的码点集合分别包括具有Unicode属性“Other_ID_Start”和“Other_ID_Continue”的码点。

### 12.7.1 标识符名称
Unicode转义序列在IdentifierName中是允许的，它们贡献一个等于UnicodeEscapeSequence的IdentifierCodePoint的单一Unicode码点。UnicodeEscapeSequence之前的\不贡献任何码点。UnicodeEscapeSequence不能用于贡献给IdentifierName一个否则无效的码点。换句话说，如果将\ UnicodeEscapeSequence序列替换为它贡献的SourceCharacter，结果仍必须是一个有效的IdentifierName，其SourceCharacter元素的顺序与原始IdentifierName完全相同。此规范中的所有IdentifierName解释基于它们的实际码点，无论是否使用转义序列贡献了任何特定码点。

根据Unicode标准，两个规范等效的IdentifierName在被替换每个UnicodeEscapeSequence后，除非它们由完全相同的码点序列表示，否则不相等。

#### 12.7.1.1 静态语义：早期错误
IdentifierStart :: \ UnicodeEscapeSequence
如果UnicodeEscapeSequence的IdentifierCodePoint不是由IdentifierStartChar词法语法产生式匹配的某个Unicode码点，则这是一个语法错误。

IdentifierPart :: \ UnicodeEscapeSequence
如果UnicodeEscapeSequence的IdentifierCodePoint不是由IdentifierPartChar词法语法产生式匹配的某个Unicode码点，则这是一个语法错误。

#### 12.7.1.2 静态语义：IdentifierCodePoints
语法导向操作IdentifierCodePoints不接受参数，返回一个码点列表。它在以下产生式上逐段定义：

```plaintext
IdentifierName :: IdentifierStart
  1. 令cp为IdentifierStart的IdentifierCodePoint。
  2. 返回« cp »。

IdentifierName :: IdentifierName IdentifierPart
  1. 令cps为派生的IdentifierName的IdentifierCodePoints。
  2. 令cp为IdentifierPart的IdentifierCodePoint。
  3. 返回cps和« cp »的列表连接。
```

#### 12.7.1.3 静态语义：IdentifierCodePoint
语法导向操作IdentifierCodePoint不接受参数，返回一个码点。它在以下产生式上逐段定义：

```plaintext
IdentifierStart :: IdentifierStartChar
  1. 返回由IdentifierStartChar匹配的码点。

IdentifierPart :: IdentifierPartChar
  1. 返回由IdentifierPartChar匹配的码点。

UnicodeEscapeSequence :: u Hex4Digits
  1. 返回数值等于Hex4Digits的MV的码点。

UnicodeEscapeSequence :: u{ CodePoint }
  1. 返回数值等于CodePoint的MV的码点。
```

### 12.7.2 关键字和保留字

关键字是与IdentifierName匹配但也有语法用途的标记；即，它以固定宽度字体出现在某些语法产生式中。ECMAScript的关键字包括if、while、async、await等。

保留字是不能用作标识符的IdentifierName。许多关键字是保留字，但有些不是，有些仅在某些上下文中是保留字。if和while是保留字。await仅在异步函数和模块中保留。async不是保留字；它可以毫无限制地用作变量名或语句标签。

本规范使用语法产生式和早期错误规则的组合来指定哪些名称是有效标识符，哪些是保留字。以下保留字列表中的所有标记，除了await和yield，都是无条件保留的。对于await和yield的例外情况，见13.1，通过参数化的语法产生式。最后，若干早期错误规则限制了有效标识符的集合。见13.1.1、14.3.1.1、14.7.5.1和15.7.1。总之，标识符名称有五类：

1. 始终允许作为标识符且不是关键字的，如Math、window、toString和_。
2. 从不允许作为标识符的，即下列保留字列表中的标记，除await和yield外。
3. 上下文允许作为标识符的，即await和yield。
4. 上下文不允许作为标识符的，在严格模式代码中：let、static、implements、interface、package、private、protected和public。
5. 始终允许作为标识符，但在某些语法产生式中也作为关键字，在这些地方Identifier是不允许的：as、async、from、get、meta、of、set和target。

有时使用条件关键字或上下文关键字一词来指代落入后三类的关键字，因此在某些上下文中可以用作标识符，在其他上下文中则用作关键字。

#### 语法
```plaintext
ReservedWord :: one of
  await break case catch class const continue debugger default delete do else enum export extends false finally for function if import in instanceof new null return super switch this throw true try typeof var void while with yield
```

#### 注解1
根据5.1.5，语法中的关键字匹配特定SourceCharacter元素的字面序列。关键字中的码点不能通过\ UnicodeEscapeSequence表示。

IdentifierName可以包含\ UnicodeEscapeSequences，但不能通过拼写els\u{65}声明一个名为"else"的变量。13.1.1中的早期错误规则排除了与保留字同样StringValue的标识符。

#### 注解2
enum目前在本规范中不作为关键字使用。它是一个未来保留字，预留用于未来的语言扩展。

类似地，implements、interface、package、private、protected和public是严格模式代码中的未来保留字。

#### 注解3
名称arguments和eval不是关键字，但在严格模式代码中有一些限制。见13.1.1、8.6.4、15.2.1、15.5.1、15.6.1和15.8.1。

### 12.8 标点符号

#### 语法
```plaintext
Punctuator ::
  OptionalChainingPunctuator
  OtherPunctuator

OptionalChainingPunctuator ::
  ?. [lookahead ∉ DecimalDigit]

OtherPunctuator :: one of
  { ( ) [ ] . ... ; , < > <= >= == != === !== + - * % ** ++ -- << >> >>> & | ^ ! ~ && || ?? ? : = += -= *= %= **= <<= >>= >>>= &= |= ^= &&= ||= ??= =>

DivPunctuator ::
  / /=

RightBracePunctuator ::
  }
```

### 12.9 字面量
#### 12.9.1 空字面量

#### 语法
```plaintext
NullLiteral ::
  null
```

#### 12.9.2 布尔字面量

#### 语法
```plaintext
BooleanLiteral ::
  true
  false
```

#### 12.9.3 数字字面量

#### 语法
```plaintext
NumericLiteralSeparator ::
  _

NumericLiteral ::
  DecimalLiteral
  DecimalBigIntegerLiteral
  NonDecimalIntegerLiteral[+Sep]
  NonDecimalIntegerLiteral[+Sep] BigIntLiteralSuffix
  LegacyOctalIntegerLiteral

DecimalBigIntegerLiteral ::
  0 BigIntLiteralSuffix
  NonZeroDigit DecimalDigits[+Sep]opt BigIntLiteralSuffix
  NonZeroDigit NumericLiteralSeparator DecimalDigits[+Sep] BigIntLiteralSuffix

NonDecimalIntegerLiteral[Sep] ::
  BinaryIntegerLiteral[?Sep]
  OctalIntegerLiteral[?Sep]
  HexIntegerLiteral[?Sep]

BigIntLiteralSuffix ::
  n

DecimalLiteral ::
  DecimalIntegerLiteral . DecimalDigits[+Sep]opt ExponentPart[+Sep]opt
  . DecimalDigits[+Sep] ExponentPart[+Sep]opt
  DecimalIntegerLiteral ExponentPart[+Sep]opt

DecimalIntegerLiteral ::
  0
  NonZeroDigit
  NonZeroDigit NumericLiteralSeparatoropt DecimalDigits[+Sep]
  NonOctalDecimalIntegerLiteral

DecimalDigits[Sep] ::
  DecimalDigit
  DecimalDigits[?Sep] DecimalDigit
  [+Sep] DecimalDigits[+Sep] NumericLiteralSeparator DecimalDigit

DecimalDigit :: one of
  0 1 2 3 4 5 6 7 8 9

NonZeroDigit :: one of
  1 2 3 4 5 6 7 8 9

ExponentPart[Sep] ::
  ExponentIndicator SignedInteger[?Sep]

ExponentIndicator :: one of
  e E

SignedInteger[Sep] ::
  DecimalDigits[?Sep]
  + DecimalDigits[?Sep]
  - DecimalDigits[?Sep]

BinaryIntegerLiteral[Sep] ::
  0b BinaryDigits[?Sep]
  0B BinaryDigits[?Sep]

BinaryDigits[Sep] ::
  BinaryDigit
  BinaryDigits[?Sep] BinaryDigit
  [+Sep] BinaryDigits[+Sep] NumericLiteralSeparator BinaryDigit

BinaryDigit :: one of
  0 1

OctalIntegerLiteral[Sep] ::
  0o OctalDigits[?Sep]
  0O OctalDigits[?Sep]

OctalDigits[Sep] ::
  OctalDigit
  OctalDigits[?Sep] OctalDigit
  [+Sep] OctalDigits[+Sep] NumericLiteralSeparator OctalDigit

LegacyOctalIntegerLiteral ::
  0 OctalDigit
  LegacyOctalIntegerLiteral OctalDigit

NonOctalDecimalIntegerLiteral ::
  0 NonOctalDigit
  LegacyOctalLikeDecimalIntegerLiteral NonOctalDigit
  NonOctalDecimalIntegerLiteral DecimalDigit

LegacyOctalLikeDecimalIntegerLiteral ::
  0 OctalDigit
  LegacyOctalLikeDecimalIntegerLiteral OctalDigit

OctalDigit :: one of
  0 1 2 3 4 5 6 7

NonOctalDigit :: one of
  8 9

HexIntegerLiteral[Sep] ::
  0x HexDigits[?Sep]
  0X HexDigits[?Sep]

HexDigits[Sep] ::
  HexDigit
  HexDigits[?Sep] HexDigit
  [+Sep] HexDigits[+Sep] NumericLiteralSeparator HexDigit

HexDigit :: one of
  0 1 2 3 4 5 6 7 8 9 a b c d e f A B C D E F
```

NumericLiteral后面的SourceCharacter不能是IdentifierStart或DecimalDigit。

#### 注解
例如：3in是错误的，而不是两个输入元素3和in。

### 12.9.3.1 静态语义：早期错误

#### 语法
```plaintext
NumericLiteral :: LegacyOctalIntegerLiteral
DecimalIntegerLiteral :: NonOctalDecimalIntegerLiteral
```

如果IsStrict(this production)为true，这是一个语法错误。

#### 注解
在非严格代码中，此语法是遗留的。

### 12.9.3.2 静态语义：MV
数字字面量代表Number类型或BigInt类型的值。

- DecimalLiteral :: DecimalIntegerLiteral . DecimalDigits 的 MV 是 DecimalIntegerLiteral 的 MV 加上 (DecimalDigits 的 MV × 10**-n)，其中 n 是 DecimalDigits 中的码点数，不包括所有出现的 NumericLiteralSeparator。
- DecimalLiteral :: DecimalIntegerLiteral . ExponentPart 的 MV 是 DecimalIntegerLiteral 的 MV × 10**e，其中 e 是 ExponentPart 的 MV。
- DecimalLiteral :: DecimalIntegerLiteral . DecimalDigits ExponentPart 的 MV 是 (DecimalIntegerLiteral 的 MV 加上 (DecimalDigits 的 MV × 10**-n)) × 10**e，其中 n 是 DecimalDigits 中的码点数，不包括所有出现的 NumericLiteralSeparator，e 是 ExponentPart 的 MV。
- DecimalLiteral :: . DecimalDigits 的 MV 是 DecimalDigits 的 MV × 10**-n，其中 n 是 DecimalDigits 中的码点数，不包括所有出现的 NumericLiteralSeparator。
- DecimalLiteral :: . DecimalDigits ExponentPart 的 MV 是 DecimalDigits 的 MV × 10**(e - n)，其中 n 是 DecimalDigits 中的码点数，不包括所有出现的 NumericLiteralSeparator，e 是 ExponentPart 的 MV。
- DecimalLiteral :: DecimalIntegerLiteral ExponentPart 的 MV 是 DecimalIntegerLiteral 的 MV × 10**e，其中 e 是 ExponentPart 的 MV。
- DecimalIntegerLiteral :: 0 的 MV 是 0。
- DecimalIntegerLiteral :: NonZeroDigit NumericLiteralSeparatoropt DecimalDigits 的 MV 是 (NonZeroDigit 的 MV × 10**n) 加上 DecimalDigits 的 MV，其中 n 是 DecimalDigits 中的码点数，不包括所有出现的 NumericLiteralSeparator。
- DecimalDigits :: DecimalDigits DecimalDigit 的 MV 是 (DecimalDigits 的 MV × 10) 加上 DecimalDigit 的 MV。
- DecimalDigits :: DecimalDigits NumericLiteralSeparator DecimalDigit 的 MV 是 (DecimalDigits 的 MV × 10) 加上 DecimalDigit 的 MV。
- ExponentPart :: ExponentIndicator SignedInteger 的 MV 是 SignedInteger 的 MV。
- SignedInteger :: - DecimalDigits 的 MV 是 DecimalDigits 的 MV 的负值。
- DecimalDigit :: 0 或 HexDigit :: 0 或 OctalDigit :: 0 或 LegacyOctalEscapeSequence :: 0 或 BinaryDigit :: 0 的 MV 是 0。
- DecimalDigit :: 1 或 NonZeroDigit :: 1 或 HexDigit :: 1 或 OctalDigit :: 1 或 BinaryDigit :: 1 的 MV 是 1。
- DecimalDigit :: 2 或 NonZeroDigit :: 2 或 HexDigit :: 2 或 OctalDigit :: 2 的 MV 是 2。
- DecimalDigit :: 3 或 NonZeroDigit :: 3 或 HexDigit :: 3 或 OctalDigit :: 3 的 MV 是 3。
- DecimalDigit :: 4 或 NonZeroDigit :: 4 或 HexDigit :: 4 或 OctalDigit :: 4 的 MV 是 4。
- DecimalDigit :: 5 或 NonZeroDigit :: 5 或 HexDigit :: 5 或 OctalDigit :: 5 的 MV 是 5。
- DecimalDigit :: 6 或 NonZeroDigit :: 6 或 HexDigit :: 6 或 OctalDigit :: 6 的 MV 是 6。
- DecimalDigit :: 7 或 NonZeroDigit :: 7 或 HexDigit :: 7 或 OctalDigit :: 7 的 MV 是 7。
- DecimalDigit :: 8 或 NonZeroDigit :: 8 或 NonOctalDigit :: 8 或 HexDigit :: 8 的 MV 是 8。
- DecimalDigit :: 9 或 NonZeroDigit :: 9 或 NonOctalDigit :: 9 或 HexDigit :: 9 的 MV 是 9。
- HexDigit :: a 或 HexDigit :: A 的 MV 是 10。
- HexDigit :: b 或 HexDigit :: B 的 MV 是 11。
- HexDigit :: c 或 HexDigit :: C 的 MV 是 12。
- HexDigit :: d 或 HexDigit :: D 的 MV 是 13。
- HexDigit :: e 或 HexDigit :: E 的 MV 是 14。
- HexDigit :: f 或 HexDigit :: F 的 MV 是 15。
- BinaryDigits :: BinaryDigits BinaryDigit 的 MV 是 (BinaryDigits 的 MV × 2) 加上 BinaryDigit 的 MV。
- BinaryDigits :: BinaryDigits NumericLiteralSeparator BinaryDigit 的 MV 是 (BinaryDigits 的 MV × 2) 加上 BinaryDigit 的 MV。
- OctalDigits :: OctalDigits OctalDigit 的 MV 是 (OctalDigits 的 MV × 8) 加上 OctalDigit 的 MV。
- OctalDigits :: OctalDigits NumericLiteralSeparator OctalDigit 的 MV 是 (OctalDigits 的 MV × 8) 加上 OctalDigit 的 MV。
- LegacyOctalIntegerLiteral :: LegacyOctalIntegerLiteral OctalDigit 的 MV 是 (LegacyOctalIntegerLiteral 的 MV × 8) 加上 OctalDigit 的 MV。
- NonOctalDecimalIntegerLiteral :: LegacyOctalLikeDecimalIntegerLiteral NonOctalDigit 的 MV 是 (LegacyOctalLikeDecimalIntegerLiteral 的 MV × 10) 加上 NonOctalDigit 的 MV。
- NonOctalDecimalIntegerLiteral :: NonOctalDecimalIntegerLiteral DecimalDigit 的 MV 是 (NonOctalDecimalIntegerLiteral 的 MV × 10) 加上 DecimalDigit 的 MV。
- LegacyOctalLikeDecimalIntegerLiteral :: LegacyOctalLikeDecimalIntegerLiteral OctalDigit 的 MV 是 (LegacyOctalLikeDecimalIntegerLiteral 的 MV × 10) 加上 OctalDigit 的 MV。
- HexDigits :: HexDigits HexDigit 的 MV 是 (HexDigits 的 MV × 16) 加上 HexDigit 的 MV。
- HexDigits :: HexDigits NumericLiteralSeparator HexDigit 的 MV 是 (HexDigits 的 MV × 16) 加上 HexDigit 的 MV。

### 12.9.3.3 静态语义：NumericValue

语法导向操作NumericValue不接受参数，返回一个Number或BigInt。它在以下产生式上逐段定义：

- NumericLiteral :: DecimalLiteral
  1. 返回RoundMVResult(DecimalLiteral的MV)。
- NumericLiteral :: NonDecimalIntegerLiteral
  1. 返回𝔽(NonDecimalIntegerLiteral的MV)。
- NumericLiteral :: LegacyOctalIntegerLiteral
  1. 返回𝔽(LegacyOctalIntegerLiteral的MV)。
- NumericLiteral :: NonDecimalIntegerLiteral BigIntLiteralSuffix
  1. 返回NonDecimalIntegerLiteral的MV的BigInt值。
- DecimalBigIntegerLiteral :: 0 BigIntLiteralSuffix
  1. 返回0ℤ。
- DecimalBigIntegerLiteral :: NonZeroDigit BigIntLiteralSuffix
  1. 返回NonZeroDigit的MV的BigInt值。
- DecimalBigIntegerLiteral ::
  NonZeroDigit DecimalDigits BigIntLiteralSuffix
  NonZeroDigit NumericLiteralSeparator DecimalDigits BigIntLiteralSuffix
  1. 令n为DecimalDigits中的码点数，不包括所有出现的NumericLiteralSeparator。
  2. 令mv为(NonZeroDigit的MV × 10**n)加上DecimalDigits的MV。
  3. 返回ℤ(mv)。

### 12.9.4 字符串字面量

#### 注解1

字符串字面量是用单引号或双引号括起来的0或多个Unicode码点。Unicode码点也可以用转义序列表示。所有码点在字符串字面量中都可以出现，除了闭合引号码点、U+005C（反斜杠）、U+000D（回车符）和U+000A（换行符）。任何码点都可以以转义序列的形式出现。字符串字面量评估为ECMAScript字符串值。在生成这些字符串值时，Unicode码点按11.1.1中定义的UTF-16编码。属于基本多语言平面的码点编码为字符串的单个代码单元元素。所有其他码点编码为字符串的两个代码单元元素。

#### 语法

```plaintext
StringLiteral ::
  " DoubleStringCharactersopt "
  ' SingleStringCharactersopt '

DoubleStringCharacters ::
  DoubleStringCharacter DoubleStringCharactersopt

SingleStringCharacters ::
  SingleStringCharacter SingleStringCharactersopt

DoubleStringCharacter ::
  SourceCharacter but not one of " or \ or LineTerminator
  <LS>
  <PS>
  \ EscapeSequence
  LineContinuation

SingleStringCharacter ::
  SourceCharacter but not one of ' or \ or LineTerminator
  <LS>
  <PS>
  \ EscapeSequence
  LineContinuation

LineContinuation ::
  \ LineTerminatorSequence

EscapeSequence ::
  CharacterEscapeSequence
  0 [lookahead ∉ DecimalDigit]
  LegacyOctalEscapeSequence
  NonOctalDecimalEscapeSequence
  HexEscapeSequence
  UnicodeEscapeSequence

CharacterEscapeSequence ::
  SingleEscapeCharacter
  NonEscapeCharacter

SingleEscapeCharacter :: one of
  ' " \ b f n r t v

NonEscapeCharacter ::
  SourceCharacter but not one of EscapeCharacter or LineTerminator

EscapeCharacter ::
  SingleEscapeCharacter
  DecimalDigit
  x
  u

LegacyOctalEscapeSequence ::
  0 [lookahead ∈ { 8, 9 }]
  NonZeroOctalDigit [lookahead ∉ OctalDigit]
  ZeroToThree OctalDigit [lookahead ∉ OctalDigit]
  FourToSeven OctalDigit
  ZeroToThree OctalDigit OctalDigit

NonZeroOctalDigit ::
  OctalDigit but not 0

ZeroToThree :: one of
  0 1 2 3

FourToSeven :: one of
  4 5 6 7

NonOctalDecimalEscapeSequence :: one of
  8 9

HexEscapeSequence ::
  x HexDigit HexDigit

UnicodeEscapeSequence ::
  u Hex4Digits
  u{ CodePoint }

Hex4Digits ::
  HexDigit HexDigit HexDigit HexDigit
```

非终结符HexDigit的定义见12.9.3。SourceCharacter定义在11.1中。

#### 注解2

<LF>和<CR>不能出现在字符串字面量中，除非作为LineContinuation的一部分以产生空码点序列。在字符串字面量的String值中包含它们的正确方法是使用转义序列，如\n或\u000A。

### 12.9.4.1 静态语义：早期错误

```plaintext
EscapeSequence ::
  LegacyOctalEscapeSequence
  NonOctalDecimalEscapeSequence
```

如果IsStrict(this production)为true，这是一个语法错误。

#### 注解1

在非严格代码中，此语法是遗留的。

#### 注解2

字符串字面量可能出现在放置封闭代码为严格模式的Use Strict Directive之前，实施必须注意强制执行上述规则。例如，以下源文本包含语法错误：

```plaintext
function invalid() { "\7"; "use strict"; }
```

### 12.9.4.2 静态语义：SV

语法导向操作SV不接受参数，返回一个字符串。

字符串字面量代表String类型的值。SV通过递归应用于字符串字面量的各个部分来生成字符串值。在此过程中，字符串字面量中的某些Unicode码点被解释为具有数学值，如下所述或在12.9.3中描述。

- StringLiteral :: " " 的 SV 是空字符串。
- StringLiteral :: ' ' 的 SV 是空字符串。
- DoubleStringCharacters :: DoubleStringCharacter DoubleStringCharacters 的 SV 是 DoubleStringCharacter 的 SV 和 DoubleStringCharacters 的 SV 的字符串连接。
- SingleStringCharacters :: SingleStringCharacter SingleStringCharacters 的 SV 是 SingleStringCharacter 的 SV 和 SingleStringCharacters 的 SV 的字符串连接。
- DoubleStringCharacter :: SourceCharacter but not one of " or \ or LineTerminator 的 SV 是对SourceCharacter匹配的码点执行UTF16EncodeCodePoint的结果。
- DoubleStringCharacter :: <LS> 的 SV 是由代码单元0x2028（行分隔符）组成的字符串值。
- DoubleStringCharacter :: <PS> 的 SV 是由代码单元0x2029（段落分隔符）组成的字符串值。
- DoubleStringCharacter :: LineContinuation 的 SV 是空字符串。
- SingleStringCharacter :: SourceCharacter but not one of ' or \ or LineTerminator 的 SV 是对SourceCharacter匹配的码点执行UTF16EncodeCodePoint的结果。
- SingleStringCharacter :: <LS> 的 SV 是由代码单元0x2028（行分隔符）组成的字符串值。
- SingleStringCharacter :: <PS> 的 SV 是由代码单元0x2029（段落分隔符）组成的字符串值。
- SingleStringCharacter :: LineContinuation 的 SV 是空字符串。
- EscapeSequence :: 0 的 SV 是由代码单元0x0000（NULL）组成的字符串值。
- CharacterEscapeSequence :: SingleEscapeCharacter 的 SV 是由单一转义字符的数值决定的代码单元组成的字符串值，见表37。

#### 表37：字符串单字符转义序列

| 转义序列 | 代码单元值 | Unicode字符名称 | 符号  |
|----------|------------|------------------|-------|
| \b       | 0x0008     | 退格符           | <BS>  |
| \t       | 0x0009     | 制表符           | <HT>  |
| \n       | 0x000A     | 换行符           | <LF>  |
| \v       | 0x000B     | 行制表符         | <VT>  |
| \f       | 0x000C     | 换页符           | <FF>  |
| \r       | 0x000D     | 回车符           | <CR>  |
| \"       | 0x0022     | 引号             | "     |
| \'       | 0x0027     | 撇号             | '     |
| \\       | 0x005C     | 反斜杠           | \     |

- NonEscapeCharacter :: SourceCharacter but not one of EscapeCharacter or LineTerminator 的 SV 是对SourceCharacter匹配的码点执行UTF16EncodeCodePoint的结果。
- EscapeSequence :: LegacyOctalEscapeSequence 的 SV 是由LegacyOctalEscapeSequence的MV组成的代码单元的字符串值。
- NonOctalDecimalEscapeSequence :: 8 的 SV 是由代码单元0x0038（数字8）组成的字符串值。
- NonOctalDecimalEscapeSequence :: 9 的 SV 是由代码单元0x0039（数字9）组成的字符串值。
- HexEscapeSequence :: x HexDigit HexDigit 的 SV 是由数值等于HexEscapeSequence的MV的代码单元组成的字符串值。
- Hex4Digits :: HexDigit HexDigit HexDigit HexDigit 的 SV 是由数值等于Hex4Digits的MV的代码单元组成的字符串值。
- UnicodeEscapeSequence :: u{ CodePoint } 的 SV 是对 CodePoint 的 MV 执行 UTF16EncodeCodePoint 的结果。
- TemplateEscapeSequence :: 0 的 SV 是由代码单元 0x0000（NULL）组成的字符串值。

### 12.9.4.3 静态语义：MV

- LegacyOctalEscapeSequence :: ZeroToThree OctalDigit 的 MV 是 (8 × ZeroToThree 的 MV) 加上 OctalDigit 的 MV。
- LegacyOctalEscapeSequence :: FourToSeven OctalDigit 的 MV 是 (8 × FourToSeven 的 MV) 加上 OctalDigit 的 MV。
- LegacyOctalEscapeSequence :: ZeroToThree OctalDigit OctalDigit 的 MV 是 (64，即 8**2，× ZeroToThree 的 MV) 加上 (8 × 第一个 OctalDigit 的 MV) 加上第二个 OctalDigit 的 MV。
- ZeroToThree :: 0 的 MV 是 0。
- ZeroToThree :: 1 的 MV 是 1。
- ZeroToThree :: 2 的 MV 是 2。
- ZeroToThree :: 3 的 MV 是 3。
- FourToSeven :: 4 的 MV 是 4。
- FourToSeven :: 5 的 MV 是 5。
- FourToSeven :: 6 的 MV 是 6。
- FourToSeven :: 7 的 MV 是 7。
- HexEscapeSequence :: x HexDigit HexDigit 的 MV 是 (16 × 第一个 HexDigit 的 MV) 加上第二个 HexDigit 的 MV。
- Hex4Digits :: HexDigit HexDigit HexDigit HexDigit 的 MV 是 (0x1000 × 第一个 HexDigit 的 MV) 加上 (0x100 × 第二个 HexDigit 的 MV) 加上 (0x10 × 第三个 HexDigit 的 MV) 加上第四个 HexDigit 的 MV。

### 12.9.5 正则表达式字面量

#### 注释1

正则表达式字面量是一个输入元素，每次对该字面量进行求值时都会转换为一个RegExp对象（见22.2）。即使程序中的两个正则表达式字面量内容相同，它们求值后的正则表达式对象也不会在 === 比较中相等。可以在运行时通过 new RegExp 或调用 RegExp 构造函数作为函数（见22.2.4）来创建 RegExp 对象。

下列产生式描述了正则表达式字面量的语法，输入元素扫描器使用它们来找到正则表达式字面量的结束。由 RegularExpressionBody 和 RegularExpressionFlags 组成的源文本随后使用更严格的 ECMAScript 正则表达式语法（22.2.1）再次解析。

实现可以扩展22.2.1中定义的ECMAScript正则表达式语法，但不能扩展下列定义的 RegularExpressionBody 和 RegularExpressionFlags 产生式或这些产生式使用的产生式。

#### 语法

```plaintext
RegularExpressionLiteral ::
  / RegularExpressionBody / RegularExpressionFlags

RegularExpressionBody ::
  RegularExpressionFirstChar RegularExpressionChars

RegularExpressionChars ::
  [empty]
  RegularExpressionChars RegularExpressionChar

RegularExpressionFirstChar ::
  RegularExpressionNonTerminator but not one of * or \ or / or [
  RegularExpressionBackslashSequence
  RegularExpressionClass

RegularExpressionChar ::
  RegularExpressionNonTerminator but not one of \ or / or [
  RegularExpressionBackslashSequence
  RegularExpressionClass

RegularExpressionBackslashSequence ::
  \ RegularExpressionNonTerminator

RegularExpressionNonTerminator ::
  SourceCharacter but not LineTerminator

RegularExpressionClass ::
  [ RegularExpressionClassChars ]

RegularExpressionClassChars ::
  [empty]
  RegularExpressionClassChars RegularExpressionClassChar

RegularExpressionClassChar ::
  RegularExpressionNonTerminator but not one of ] or \
  RegularExpressionBackslashSequence

RegularExpressionFlags ::
  [empty]
  RegularExpressionFlags IdentifierPartChar
```

#### 注释2

正则表达式字面量不能为空；如果输入序列 // 出现，它表示一个单行注释，而不是一个空的正则表达式字面量。要表示一个空的正则表达式，请使用：/ (?:) /。

### 12.9.5.1 静态语义：BodyText

语法导向操作 BodyText 不接受参数，返回源文本。它在以下产生式上逐段定义：

```plaintext
RegularExpressionLiteral :: / RegularExpressionBody / RegularExpressionFlags
  1. 返回被识别为 RegularExpressionBody 的源文本。
```

### 12.9.5.2 静态语义：FlagText

语法导向操作 FlagText 不接受参数，返回源文本。它在以下产生式上逐段定义：

```plaintext
RegularExpressionLiteral :: / RegularExpressionBody / RegularExpressionFlags
  1. 返回被识别为 RegularExpressionFlags 的源文本。
```

### 12.9.6 模板字面量词法组件

#### 语法

```plaintext
Template ::
  NoSubstitutionTemplate
  TemplateHead

NoSubstitutionTemplate ::
  ` TemplateCharactersopt `

TemplateHead ::
  ` TemplateCharactersopt ${

TemplateSubstitutionTail ::
  TemplateMiddle
  TemplateTail

TemplateMiddle ::
  } TemplateCharactersopt ${

TemplateTail ::
  } TemplateCharactersopt `

TemplateCharacters ::
  TemplateCharacter TemplateCharactersopt

TemplateCharacter ::
  $ [lookahead ≠ {]
  \ TemplateEscapeSequence
  \ NotEscapeSequence
  LineContinuation
  LineTerminatorSequence
  SourceCharacter but not one of ` or \ or $ or LineTerminator

TemplateEscapeSequence ::
  CharacterEscapeSequence
  0 [lookahead ∉ DecimalDigit]
  HexEscapeSequence
  UnicodeEscapeSequence

NotEscapeSequence ::
  0 DecimalDigit
  DecimalDigit but not 0
  x [lookahead ∉ HexDigit]
  x HexDigit [lookahead ∉ HexDigit]
  u [lookahead ∉ HexDigit] [lookahead ≠ {]
  u HexDigit [lookahead ∉ HexDigit]
  u HexDigit HexDigit [lookahead ∉ HexDigit]
  u HexDigit HexDigit HexDigit [lookahead ∉ HexDigit]
  u { [lookahead ∉ HexDigit]
  u { NotCodePoint [lookahead ∉ HexDigit]
  u { CodePoint [lookahead ∉ HexDigit] [lookahead ≠ }]

NotCodePoint ::
  HexDigits[~Sep] but only if the MV of HexDigits > 0x10FFFF

CodePoint ::
  HexDigits[~Sep] but only if the MV of HexDigits ≤ 0x10FFFF
```

#### 注释
TemplateSubstitutionTail 由 InputElementTemplateTail 替代词法目标使用。

### 12.9.6.1 静态语义：TV

语法导向操作 TV 不接受参数，返回一个字符串或未定义。模板字面量组件由 TV 解释为字符串类型的值。TV 用于构建模板对象的索引组件（俗称模板值）。在 TV 中，转义序列由转义序列表示的 Unicode 代码点的 UTF-16 代码单元替换。

- NoSubstitutionTemplate :: ` ` 的 TV 是空字符串。
- TemplateHead :: ` ${ 的 TV 是空字符串。
- TemplateMiddle :: } ${ 的 TV 是空字符串。
- TemplateTail :: } ` 的 TV 是空字符串。
- TemplateCharacters :: TemplateCharacter TemplateCharacters 的 TV 是 undefined，如果 TemplateCharacter 的 TV 是 undefined 或 TemplateCharacters 的 TV 是 undefined。否则，它是 TemplateCharacter 的 TV 和 TemplateCharacters 的 TV 的字符串连接。
- TemplateCharacter :: SourceCharacter but not one of ` or \ or $ or LineTerminator 的 TV 是对 SourceCharacter 匹配的代码点执行 UTF16EncodeCodePoint 的结果。
- TemplateCharacter :: $ 的 TV 是由代码单元 0x0024（美元符号）组成的字符串值。
- TemplateCharacter :: \ TemplateEscapeSequence 的 TV 是 TemplateEscapeSequence 的 SV。
- TemplateCharacter :: \ NotEscapeSequence 的 TV 是 undefined。
- TemplateCharacter :: LineTerminatorSequence 的 TV 是 LineTerminatorSequence 的 TRV。
- LineContinuation :: \ LineTerminatorSequence 的 TV 是空字符串。

### 12.9.6.2 静态语义：TRV

语法导向操作 TRV 不接受参数，返回一个字符串。模板字面量组件由 TRV 解释为字符串类型的值。TRV 用于构建模板对象的原始组件（俗称模板原始值）。TRV 类似于 TV，区别在于 TRV 中，转义序列按照它们在字面量中出现的形式解释。

- NoSubstitutionTemplate :: ` ` 的 TRV 是空字符串。
- TemplateHead :: ` ${ 的 TRV 是空字符串。
- TemplateMiddle :: } ${ 的 TRV 是空字符串。
- TemplateTail :: } ` 的 TRV 是空字符串。
- TemplateCharacters :: TemplateCharacter TemplateCharacters 的 TRV 是 TemplateCharacter 的 TRV 和 TemplateCharacters 的 TRV 的字符串连接。
- TemplateCharacter :: SourceCharacter but not one of ` or \ or $ or LineTerminator 的 TRV 是对 SourceCharacter 匹配的代码点执行 UTF16EncodeCodePoint 的结果。
- TemplateCharacter :: $ 的 TRV 是由代码单元 0x0024（美元符号）组成的字符串值。
- TemplateCharacter :: \ TemplateEscapeSequence 的 TRV 是代码单元 0x005C（反斜杠）和 TemplateEscapeSequence 的 TRV 的字符串连接。
- TemplateCharacter :: \ NotEscapeSequence 的 TRV 是代码单元 0x005C（反斜杠）和 NotEscapeSequence 的 TRV 的字符串连接。
- TemplateEscapeSequence :: 0 的 TRV 是由代码单元 0x0030（数字零）组成的字符串值。
- NotEscapeSequence :: 0 DecimalDigit 的 TRV 是代码单元 0x0030（数字零）和 DecimalDigit 的 TRV 的字符串连接。
- NotEscapeSequence :: x [lookahead ∉ HexDigit] 的 TRV 是由代码单元 0x0078（拉丁小写字母x）组成的字符串值。
- NotEscapeSequence :: x HexDigit [lookahead ∉ HexDigit] 的 TRV 是代码单元 0x0078（拉丁小写字母x）和 HexDigit 的 TRV 的字符串连接。
- NotEscapeSequence :: u [lookahead ∉ HexDigit] [lookahead ≠ {] 的 TRV 是由代码单元 0x0075（拉丁小写字母u）组成的字符串值。
- NotEscapeSequence :: u HexDigit [lookahead ∉ HexDigit] 的 TRV 是代码单元 0x0075（拉丁小写字母u）和 HexDigit 的 TRV 的字符串连接。
- NotEscapeSequence :: u HexDigit HexDigit [lookahead ∉ HexDigit] 的 TRV 是代码单元 0x0075（拉丁小写字母u）、第一个 HexDigit 的 TRV 和第二个 HexDigit 的 TRV 的字符串连接。
- NotEscapeSequence :: u HexDigit HexDigit HexDigit [lookahead ∉ HexDigit] 的 TRV 是代码单元 0x0075（拉丁小写字母u）、第一个 HexDigit 的 TRV、第二个 HexDigit 的 TRV 和第三个 HexDigit 的 TRV 的字符串连接。
- NotEscapeSequence :: u { [lookahead ∉ HexDigit] 的 TRV 是代码单元 0x0075（拉丁小写字母u）和代码单元 0x007B（左花括号）的字符串连接。
- NotEscapeSequence :: u { NotCodePoint [lookahead ∉ HexDigit] 的 TRV 是代码单元 0x0075（拉丁小写字母u）、代码单元 0x007B（左花括号）和 NotCodePoint 的 TRV 的字符串连接。
- NotEscapeSequence :: u { CodePoint [lookahead ∉ HexDigit] [lookahead ≠ }] 的 TRV 是代码单元 0x0075（拉丁小写字母u）、代码单元 0x007B（左花括号）和 CodePoint 的 TRV 的字符串连接。
- DecimalDigit :: 0 1 2 3 4 5 6 7 8 9 的 TRV 是对该产生式匹配的单个代码点执行 UTF16EncodeCodePoint 的结果。
- CharacterEscapeSequence :: NonEscapeCharacter 的 TRV 是 NonEscapeCharacter 的 SV。
- SingleEscapeCharacter :: ' " \ b f n r t v 的 TRV 是对该产生式匹配的单个代码点执行 UTF16EncodeCodePoint 的结果。
- HexEscapeSequence :: x HexDigit HexDigit 的 TRV 是代码单元 0x0078（拉丁小写字母x）、第一个 HexDigit 的 TRV 和第二个 HexDigit 的 TRV 的字符串连接。
- UnicodeEscapeSequence :: u Hex4Digits 的 TRV 是代码单元 0x0075（拉丁小写字母u）和 Hex4Digits 的 TRV 的字符串连接。
- UnicodeEscapeSequence :: u{ CodePoint } 的 TRV 是代码单元 0x0075（拉丁小写字母u）、代码单元 0x007B（左花括号）、CodePoint 的 TRV 和代码单元 0x007D（右花括号）的字符串连接。
- Hex4Digits :: HexDigit HexDigit HexDigit HexDigit 的 TRV 是第一个 HexDigit 的 TRV、第二个 HexDigit 的 TRV、第三个 HexDigit 的 TRV 和第四个 HexDigit 的 TRV 的字符串连接。
- HexDigits :: HexDigits HexDigit 的 TRV 是 HexDigits 的 TRV 和 HexDigit 的 TRV 的字符串连接。
- HexDigit :: 0 1 2 3 4 5 6 7 8 9 a b c d e f A B C D E F 的 TRV 是对该产生式匹配的单个代码点执行 UTF16EncodeCodePoint 的结果。
- LineContinuation :: \ LineTerminatorSequence 的 TRV 是代码单元 0x005C（反斜杠）和 LineTerminatorSequence 的 TRV 的字符串连接
- LineContinuation（行续接）:: \ LineTerminatorSequence 的 TRV 是由代码单元 0x005C（反斜杠）和 LineTerminatorSequence 的 TRV 字符串连接而成。
- LineTerminatorSequence（行终止符序列）:: <LF> 的 TRV 是由代码单元 0x000A（换行符）组成的字符串值。
- LineTerminatorSequence（行终止符序列）:: <CR> 的 TRV 是由代码单元 0x000A（换行符）组成的字符串值。
- LineTerminatorSequence（行终止符序列）:: <LS> 的 TRV 是由代码单元 0x2028（行分隔符）组成的字符串值。
- LineTerminatorSequence（行终止符序列）:: <PS> 的 TRV 是由代码单元 0x2029（段落分隔符）组成的字符串值。
- LineTerminatorSequence（行终止符序列）:: <CR> <LF> 的 TRV 是由代码单元 0x000A（换行符）组成的字符串值。

注：
TV（模板值）排除了行续接的代码单元，而 TRV（模板原始值）包括了它们。<CR><LF> 和 <CR> 行终止符序列在 TV 和 TRV 中都被规范化为 <LF>。要包括 <CR> 或 <CR><LF> 序列，需要显式的 TemplateEscapeSequence（模板转义序列）。

### 12.10 自动分号插入

大多数 ECMAScript 语句和声明必须以分号结束。这些分号可以明确出现在源文本中。然而，为了方便，某些情况下可以省略这些分号。这些情况通过说明在这些情况下分号自动插入到源代码标记流中来描述。

#### 12.10.1 自动分号插入规则

在以下规则中，“标记”指的是使用当前词法目标符号识别的实际词法标记，如第 12 节所述。

分号插入的三个基本规则是：

1. 当从左到右解析源文本时，遇到一个不被语法的任何生成式允许的标记（称为违规标记）时，如果以下条件之一成立，则在违规标记之前自动插入一个分号：
   - 违规标记与前一个标记之间至少隔一个行终止符。
   - 违规标记是 `}`。
   - 前一个标记是 `)`，并且插入的分号将被解析为 `do-while` 语句（14.7.2）的结束分号。

2. 当从左到右解析源文本时，遇到标记流的末尾且解析器无法将输入标记流解析为目标非终结符的单个实例时，则在输入流末尾自动插入一个分号。

3. 当从左到右解析源文本时，遇到一个语法生成式允许的标记，但该生成式是受限生成式，并且该标记将是紧跟在 `[no LineTerminator here]` 注释之后的终结符或非终结符的第一个标记（因此该标记称为受限标记），并且受限标记与前一个标记之间至少隔一个行终止符，则在受限标记之前自动插入一个分号。

但是，以上规则有一个附加的优先条件：如果自动插入的分号将被解析为空语句，或者该分号将成为 `for` 语句（见 14.7.4）头部的两个分号之一，则不会自动插入分号。

**注**：
以下是语法中唯一的受限生成式：

- UpdateExpression[Yield, Await] :
  - LeftHandSideExpression[?Yield, ?Await] [no LineTerminator here] ++
  - LeftHandSideExpression[?Yield, ?Await] [no LineTerminator here] --
  
- ContinueStatement[Yield, Await] :
  - continue ;
  - continue [no LineTerminator here] LabelIdentifier[?Yield, ?Await] ;
  
- BreakStatement[Yield, Await] :
  - break ;
  - break [no LineTerminator here] LabelIdentifier[?Yield, ?Await] ;
  
- ReturnStatement[Yield, Await] :
  - return ;
  - return [no LineTerminator here] Expression[+In, ?Yield, ?Await] ;
  
- ThrowStatement[Yield, Await] :
  - throw [no LineTerminator here] Expression[+In, ?Yield, ?Await] ;
  
- YieldExpression[In, Await] :
  - yield
  - yield [no LineTerminator here] AssignmentExpression[?In, +Yield, ?Await]
  - yield [no LineTerminator here] * AssignmentExpression[?In, +Yield, ?Await]
  
- ArrowFunction[In, Yield, Await] :
  - ArrowParameters[?Yield, ?Await] [no LineTerminator here] => ConciseBody[?In]
  
- AsyncFunctionDeclaration[Yield, Await, Default] :
  - async [no LineTerminator here] function BindingIdentifier[?Yield, ?Await] ( FormalParameters[~Yield, +Await] ) { AsyncFunctionBody }
  - [+Default] async [no LineTerminator here] function ( FormalParameters[~Yield, +Await] ) { AsyncFunctionBody }
  
- AsyncFunctionExpression :
  - async [no LineTerminator here] function BindingIdentifier[~Yield, +Await]opt ( FormalParameters[~Yield, +Await] ) { AsyncFunctionBody }
  
- AsyncMethod[Yield, Await] :
  - async [no LineTerminator here] ClassElementName[?Yield, ?Await] ( UniqueFormalParameters[~Yield, +Await] ) { AsyncFunctionBody }
  
- AsyncGeneratorDeclaration[Yield, Await, Default] :
  - async [no LineTerminator here] function * BindingIdentifier[?Yield, ?Await] ( FormalParameters[+Yield, +Await] ) { AsyncGeneratorBody }
  - [+Default] async [no LineTerminator here] function * ( FormalParameters[+Yield, +Await] ) { AsyncGeneratorBody }
  
- AsyncGeneratorExpression :
  - async [no LineTerminator here] function * BindingIdentifier[+Yield, +Await]opt ( FormalParameters[+Yield, +Await] ) { AsyncGeneratorBody }
  
- AsyncGeneratorMethod[Yield, Await] :
  - async [no LineTerminator here] * ClassElementName[?Yield, ?Await] ( UniqueFormalParameters[+Yield, +Await] ) { AsyncGeneratorBody }
  
- AsyncArrowFunction[In, Yield, Await] :
  - async [no LineTerminator here] AsyncArrowBindingIdentifier[?Yield] [no LineTerminator here] => AsyncConciseBody[?In]
  - CoverCallExpressionAndAsyncArrowHead[?Yield, ?Await] [no LineTerminator here] => AsyncConciseBody[?In]
  
- AsyncArrowHead :
  - async [no LineTerminator here] ArrowFormalParameters[~Yield, +Await]

这些受限生成式的实际效果如下：

- 当解析器将 `++` 或 `--` 标记视为后缀运算符，并且在前一个标记与 `++` 或 `--` 标记之间至少有一个行终止符时，则在 `++` 或 `--` 标记之前自动插入分号。
- 当遇到 `continue`、`break`、`return`、`throw` 或 `yield` 标记，并且在下一个标记之前遇到行终止符时，则在 `continue`、`break`、`return`、`throw` 或 `yield` 标记之后自动插入分号。
- 当箭头函数的参数后面紧跟行终止符，而不是 `=>` 标记时，自动插入分号，并且标点符号导致语法错误。
- 当 `async` 标记后面紧跟行终止符，而不是 `function`、`IdentifierName` 或 `(` 标记时，自动插入分号，并且 `async` 标记不会被视为与后续标记属于同一表达式或类元素。
- 当 `async` 标记后面紧跟行终止符，而不是 `*` 标记时，自动插入分号，并且标点符号导致语法错误。

对 ECMAScript 程序员的实际建议是：

- 后缀 `++` 或 `--` 运算符应与其操作数在同一行。
- `return` 或 `throw` 语句中的表达式，或 `yield` 表达式中的赋值表达式，应从 `return`、`throw` 或 `yield` 标记所在的同一行开始。
- `break` 或 `continue` 语句中的 `LabelIdentifier` 应与 `break` 或 `continue` 标记在同一行。
- 箭头函数参数的结尾和 `=>` 应在同一行。
- `async` 标记应与紧跟的异步函数或方法在同一行。

### 12.10.2 自动分号插入的例子

本节为非规范性内容。

源代码

```
{ 1 2 } 3
```

即使在自动分号插入规则下，也不是 ECMAScript 语法中的有效句子。相反，源代码

```
{ 1
2 } 3
```

也不是有效的 ECMAScript 句子，但通过自动分号插入会被转换为以下内容：

```
{ 1
;2 ;} 3;
```

这是一个有效的 ECMAScript 句子。

源代码

```
for (a; b
)
```

不是一个有效的 ECMAScript 句子，自动分号插入也不会更改它，因为 `for` 语句的头部需要分号。自动分号插入从不会插入 `for` 语句头部的两个分号之一。

源代码

```
return
a + b
```

通过自动分号插入转换为以下内容：

```
return;
a + b;
```

**注1**：表达式 `a + b` 不被视为 `return` 语句返回的值，因为 `return` 标记和它之间有一个行终止符。

源代码

```
a = b
++c
```

通过自动分号插入转换为以下内容：

```
a = b;
++c;
```

**注2**：标记 `++` 不被视为应用于变量 `b` 的后缀运算符，因为 `b` 和 `++` 之间有一个行终止符。

源代码

```
if (a > b)
else c = d
```

不是一个有效的 ECMAScript 句子，自动分号插入在 `else` 标记之前也不会更改它，即使在此点没有适用的语法生成式，因为自动插入的分号会被解析为空语句。

源代码

```
a = b + c
(d + e).print()
```

不会被自动分号插入更改，因为第二行开始的括号表达式可以被解释为函数调用的参数列表：

```
a = b + c(d + e).print()
```

在需要赋值语句以左括号开始的情况下，程序员最好在前一个语句的结尾提供一个显式分号，而不是依赖于自动分号插入。

### 12.10.3 自动分号插入的有趣情况

本节为非规范性内容。

ECMAScript 程序可以依赖自动分号插入来编写很少分号的风格。如上所述，分号不会在每个换行符处插入，自动分号插入可能依赖于跨行终止符的多个标记。

随着新的语法特性的添加，可能会添加额外的语法生成式，从而在解析时导致依赖于前面的自动分号插入的行改变语法生成式。

对于本节的目的，如果一个地方的分号可能插入或不插入，这取决于之前的源文本，则该自动分号插入的情况被视为有趣的。本节的其余部分描述了此版本 ECMAScript 中一些有趣的自动分号插入情况。

#### 12.10.3.1 语句列表中的有趣自动分号插入情况

在 `StatementList` 中，许多 `StatementListItems` 以分号结束，可以使用自动分号插入省略分号。根据上述规则，在表达式结束的行末尾，如果下一行以以下任意一种开始，则需要分号：

- 一个左括号 `(`。没有分号，这两行一起被视为 `CallExpression`。
- 一个方括号 `[`。没有分号，这两行一起被视为属性访问，而不是 `ArrayLiteral` 或 `ArrayAssignmentPattern`。
- 一个模板字面量 `` ` ``。没有分号，这两行一起被解释为一个标记的模板（见 13.3.11），前一个表达式作为 `MemberExpression`。
- 一元 `+` 或 `-`。没有分号，这两行一起被解释为相应的二元运算符的使用。
- 一个正则表达式字面量。没有分号，这两行一起可能被解析为 `/` 乘法运算符，例如如果正则表达式有标志。

#### 12.10.3.2 自动分号插入和“[no LineTerminator here]”的情况

本节为非规范性内容。

ECMAScript 包含语法生成式，其中包括“[no LineTerminator here]”。这些生成式有时是语法中有可选操作数的一种方式。在这些位置引入行终止符将通过使用没有可选操作数的语法生成式来改变源文本的语法生成式。

本节的其余部分描述了此版本 ECMAScript 中使用“[no LineTerminator here]”的一些生成式。

#### 12.10.3.2.1 带有可选操作数和“[no LineTerminator here]”的语法生成式列表

- UpdateExpression
- ContinueStatement
- BreakStatement
- ReturnStatement
- YieldExpression
- Async Function Definitions (15.8) 与 Function Definitions (15.2) 的关系

### 13 ECMAScript 语言：表达式

#### 13.1 标识符

#### 语法
```
IdentifierReference[Yield, Await] :
    Identifier
    [~Yield] yield
    [~Await] await

BindingIdentifier[Yield, Await] :
    Identifier
    yield
    await

LabelIdentifier[Yield, Await] :
    Identifier
    [~Yield] yield
    [~Await] await

Identifier :
    IdentifierName but not ReservedWord
```

**注意**：`yield` 和 `await` 作为语法中的 `BindingIdentifier` 是允许的，并在以下静态语义中被禁止，以防止在以下情况下自动分号插入：

```javascript
let
await 0;
```

#### 13.1.1 静态语义：早期错误
```
BindingIdentifier : Identifier
```
如果 `IsStrict(this production)` 为真并且 `Identifier` 的 `StringValue` 为 "arguments" 或 "eval"，则这是一个语法错误。

```
IdentifierReference : yield
BindingIdentifier : yield
LabelIdentifier : yield
```
如果 `IsStrict(this production)` 为真，则这是一个语法错误。

```
IdentifierReference : await
BindingIdentifier : await
LabelIdentifier : await
```
如果语法的目标符号是 `Module`，则这是一个语法错误。

```
BindingIdentifier[Yield, Await] : yield
```
如果此生成式具有 `[Yield]` 参数，则这是一个语法错误。

```
BindingIdentifier[Yield, Await] : await
```
如果此生成式具有 `[Await]` 参数，则这是一个语法错误。

```
IdentifierReference[Yield, Await] : Identifier
BindingIdentifier[Yield, Await] : Identifier
LabelIdentifier[Yield, Await] : Identifier
```
如果此生成式具有 `[Yield]` 参数并且 `Identifier` 的 `StringValue` 为 "yield"，则这是一个语法错误。
如果此生成式具有 `[Await]` 参数并且 `Identifier` 的 `StringValue` 为 "await"，则这是一个语法错误。

```
Identifier : IdentifierName but not ReservedWord
```
如果 `IsStrict(this phrase)` 为真并且 `IdentifierName` 的 `StringValue` 是 "implements"、"interface"、"let"、"package"、"private"、"protected"、"public"、"static" 或 "yield" 之一，则这是一个语法错误。
如果语法的目标符号是 `Module` 并且 `IdentifierName` 的 `StringValue` 是 "await"，则这是一个语法错误。
如果 `IdentifierName` 的 `StringValue` 是任何 `ReservedWord` 的 `StringValue`（除了 `yield` 或 `await`），则这是一个语法错误。

**注意**：`IdentifierName` 的 `StringValue` 会将 `IdentifierName` 中的任何 Unicode 转义序列规范化，因此不能使用这些转义序列来编写代码点序列与 `ReservedWord` 相同的标识符。

#### 13.1.2 静态语义：StringValue
语法导向操作 `StringValue` 不接受参数并返回一个字符串。它按以下生成式逐段定义：

```
IdentifierName ::
    IdentifierStart
    IdentifierName IdentifierPart
```
1. 设 `idTextUnescaped` 为 `IdentifierName` 的 `IdentifierCodePoints`。
2. 返回 `CodePointsToString(idTextUnescaped)`。

```
IdentifierReference : yield
BindingIdentifier : yield
LabelIdentifier : yield
```
1. 返回 `"yield"`。

```
IdentifierReference : await
BindingIdentifier : await
LabelIdentifier : await
```
1. 返回 `"await"`。

```
Identifier : IdentifierName but not ReservedWord
```
1. 返回 `IdentifierName` 的 `StringValue`。

```
PrivateIdentifier ::
    # IdentifierName
```
1. 返回 `0x0023`（NUMBER SIGN）和 `IdentifierName` 的 `StringValue` 的字符串连接。

```
ModuleExportName : StringLiteral
```
1. 返回 `StringLiteral` 的 `SV`。

#### 13.1.3 运行时语义：求值
```
IdentifierReference : Identifier
```
1. 返回 `? ResolveBinding(StringValue of Identifier)`。

```
IdentifierReference : yield
```
1. 返回 `? ResolveBinding("yield")`。

```
IdentifierReference : await
```
1. 返回 `? ResolveBinding("await")`。

**注1**：求值 `IdentifierReference` 的结果总是类型 `Reference` 的值。

**注2**：在非严格代码中，关键字 `yield` 可以作为标识符使用。求值 `IdentifierReference` 时将解析 `yield` 的绑定，仿佛它是一个标识符。早期错误限制确保这种求值只能发生在非严格代码中。

### 13 ECMAScript 语言：表达式

#### 13.2 基本表达式

##### 语法
```
PrimaryExpression[Yield, Await] :
    this
    IdentifierReference[?Yield, ?Await]
    Literal
    ArrayLiteral[?Yield, ?Await]
    ObjectLiteral[?Yield, ?Await]
    FunctionExpression
    ClassExpression[?Yield, ?Await]
    GeneratorExpression
    AsyncFunctionExpression
    AsyncGeneratorExpression
    RegularExpressionLiteral
    TemplateLiteral[?Yield, ?Await, ~Tagged]
    CoverParenthesizedExpressionAndArrowParameterList[?Yield, ?Await]

CoverParenthesizedExpressionAndArrowParameterList[Yield, Await] :
    ( Expression[+In, ?Yield, ?Await] )
    ( Expression[+In, ?Yield, ?Await] , )
    ( )
    ( ... BindingIdentifier[?Yield, ?Await] )
    ( ... BindingPattern[?Yield, ?Await] )
    ( Expression[+In, ?Yield, ?Await] , ... BindingIdentifier[?Yield, ?Await] )
    ( Expression[+In, ?Yield, ?Await] , ... BindingPattern[?Yield, ?Await] )
```

##### 补充语法
当处理生成式 `PrimaryExpression[Yield, Await] : CoverParenthesizedExpressionAndArrowParameterList[?Yield, ?Await]` 的实例时，使用以下语法细化对 `CoverParenthesizedExpressionAndArrowParameterList` 的解释：

```
ParenthesizedExpression[Yield, Await] :
    ( Expression[+In, ?Yield, ?Await] )
```

#### 13.2.1 `this` 关键字

##### 13.2.1.1 运行时语义：求值
```
PrimaryExpression : this
    1. 返回 `? ResolveThisBinding()`。
```

#### 13.2.2 标识符引用
详见 13.1 中的 `IdentifierReference`。

#### 13.2.3 字面量

##### 语法
```
Literal :
    NullLiteral
    BooleanLiteral
    NumericLiteral
    StringLiteral
```

##### 13.2.3.1 运行时语义：求值
```
Literal : NullLiteral
    1. 返回 `null`。

Literal : BooleanLiteral
    1. 如果 `BooleanLiteral` 是 `false` 令牌，返回 `false`。
    2. 如果 `BooleanLiteral` 是 `true` 令牌，返回 `true`。

Literal : NumericLiteral
    1. 返回 `NumericLiteral` 的 `NumericValue`，详见 12.9.3。

Literal : StringLiteral
    1. 返回 `StringLiteral` 的 `SV`，详见 12.9.4.2。
```

#### 13.2.4 数组初始化器

**注意**：`ArrayLiteral` 是描述数组初始化的表达式，使用零个或多个表示数组元素的表达式列表，括在方括号内。元素不一定是字面量；每次评估数组初始化器时，这些元素都会被求值。

数组元素可以在元素列表的开头、中间或末尾被省略。每当元素列表中的逗号前没有 `AssignmentExpression`（即开头或另一个逗号后面的逗号）时，缺失的数组元素会增加数组的长度并增加后续元素的索引。省略的数组元素未定义。如果数组末尾有省略的元素，则该元素不会贡献数组的长度。

##### 语法
```
ArrayLiteral[Yield, Await] :
    [ Elisionopt ]
    [ ElementList[?Yield, ?Await] ]
    [ ElementList[?Yield, ?Await] , Elisionopt ]

ElementList[Yield, Await] :
    Elisionopt AssignmentExpression[+In, ?Yield, ?Await]
    Elisionopt SpreadElement[?Yield, ?Await]
    ElementList[?Yield, ?Await] , Elisionopt AssignmentExpression[+In, ?Yield, ?Await]
    ElementList[?Yield, ?Await] , Elisionopt SpreadElement[?Yield, ?Await]

Elision :
    ,
    Elision ,

SpreadElement[Yield, Await] :
    ... AssignmentExpression[+In, ?Yield, ?Await]
```

##### 13.2.4.1 运行时语义：数组积累
语法导向操作 `ArrayAccumulation` 接受参数 `array`（一个数组）和 `nextIndex`（一个整数），并返回一个包含整数的正常完成或中断完成。它在以下生成式上逐段定义：

```
Elision : ,
    1. 设 `len` 为 `nextIndex + 1`。
    2. 执行 `? Set(array, "length", 𝔽(len), true)`。
    3. 注意：如果 `len` 超过 `2**32 - 1`，上述步骤会抛出异常。
    4. 返回 `len`。

Elision : Elision ,
    1. 返回 `? ArrayAccumulation`，参数为 `Elision` 和 `nextIndex + 1`。

ElementList : Elisionopt AssignmentExpression
    1. 如果存在 `Elision`，则
        a. 使用参数 `array` 和 `nextIndex` 执行 `? ArrayAccumulation`，设置 `nextIndex`。
    2. 令 `initResult` 为 `AssignmentExpression` 的 `? Evaluation`。
    3. 令 `initValue` 为 `? GetValue(initResult)`。
    4. 执行 `! CreateDataPropertyOrThrow(array, ! ToString(𝔽(nextIndex)), initValue)`。
    5. 返回 `nextIndex + 1`。

ElementList : Elisionopt SpreadElement
    1. 如果存在 `Elision`，则
        a. 使用参数 `array` 和 `nextIndex` 执行 `? ArrayAccumulation`，设置 `nextIndex`。
    2. 返回 `? ArrayAccumulation`，参数为 `SpreadElement`、`array` 和 `nextIndex`。

ElementList : ElementList , Elisionopt AssignmentExpression
    1. 使用参数 `array` 和 `nextIndex` 执行 `? ArrayAccumulation`，设置 `nextIndex`。
    2. 如果存在 `Elision`，则
        a. 使用参数 `array` 和 `nextIndex` 执行 `? ArrayAccumulation`，设置 `nextIndex`。
    3. 令 `initResult` 为 `AssignmentExpression` 的 `? Evaluation`。
    4. 令 `initValue` 为 `? GetValue(initResult)`。
    5. 执行 `! CreateDataPropertyOrThrow(array, ! ToString(𝔽(nextIndex)), initValue)`。
    6. 返回 `nextIndex + 1`。

ElementList : ElementList , Elisionopt SpreadElement
    1. 使用参数 `array` 和 `nextIndex` 执行 `? ArrayAccumulation`，设置 `nextIndex`。
    2. 如果存在 `Elision`，则
        a. 使用参数 `array` 和 `nextIndex` 执行 `? ArrayAccumulation`，设置 `nextIndex`。
    3. 返回 `? ArrayAccumulation`，参数为 `SpreadElement`、`array` 和 `nextIndex`。

SpreadElement : ... AssignmentExpression
    1. 令 `spreadRef` 为 `AssignmentExpression` 的 `? Evaluation`。
    2. 令 `spreadObj` 为 `? GetValue(spreadRef)`。
    3. 令 `iteratorRecord` 为 `? GetIterator(spreadObj, SYNC)`。
    4. 重复，
        a. 令 `next` 为 `? IteratorStepValue(iteratorRecord)`。
        b. 如果 `next` 是 `DONE`，返回 `nextIndex`。
        c. 执行 `! CreateDataPropertyOrThrow(array, ! ToString(𝔽(nextIndex)), next)`。
        d. 将 `nextIndex` 设置为 `nextIndex + 1`。
```
**注意**：使用 `CreateDataPropertyOrThrow` 来确保为数组定义自身属性，即使标准内置的数组原型对象已被修改，从而妨碍使用 `[[Set]]` 创建新自身属性。

##### 13.2.4.2 运行时语义：求值
```
ArrayLiteral : [ Elisionopt ]
    1. 令 `array` 为 `! ArrayCreate(0)`。
    2. 如果存在 `Elision`，则
        a. 使用参数 `array` 和 `0` 执行 `? ArrayAccumulation`。
    3. 返回 `array`。

ArrayLiteral : [ ElementList ]
    1. 令 `array` 为 `! ArrayCreate(0)`。
    2. 使用参数 `array` 和 `0` 执行 `? ArrayAccumulation`。
    3. 返回 `array`。

ArrayLiteral : [ ElementList , Elisionopt ]
    1. 令 `array` 为 `! ArrayCreate(0)`。
    2. 使用参数 `array` 和 `0` 执行 `? ArrayAccumulation`，设置 `nextIndex`。
    3. 如果

存在 `Elision`，则
        a. 使用参数 `array` 和 `nextIndex` 执行 `? ArrayAccumulation`。
    4. 返回 `array`。
```

### 13.2.5 对象初始化器

#### 注意 1
对象初始化器是一种描述对象初始化的表达式，形式类似于字面量。它是一个由零个或多个属性键和值对组成的列表，用花括号括起来。值不一定是字面量；每次评估对象初始化器时，这些值都会被求值。

#### 语法
```
ObjectLiteral[Yield, Await] :
    { }
    { PropertyDefinitionList[?Yield, ?Await] }
    { PropertyDefinitionList[?Yield, ?Await] , }

PropertyDefinitionList[Yield, Await] :
    PropertyDefinition[?Yield, ?Await]
    PropertyDefinitionList[?Yield, ?Await] , PropertyDefinition[?Yield, ?Await]

PropertyDefinition[Yield, Await] :
    IdentifierReference[?Yield, ?Await]
    CoverInitializedName[?Yield, ?Await]
    PropertyName[?Yield, ?Await] : AssignmentExpression[+In, ?Yield, ?Await]
    MethodDefinition[?Yield, ?Await]
    ... AssignmentExpression[+In, ?Yield, ?Await]

PropertyName[Yield, Await] :
    LiteralPropertyName
    ComputedPropertyName[?Yield, ?Await]

LiteralPropertyName :
    IdentifierName
    StringLiteral
    NumericLiteral

ComputedPropertyName[Yield, Await] :
    [ AssignmentExpression[+In, ?Yield, ?Await] ]

CoverInitializedName[Yield, Await] :
    IdentifierReference[?Yield, ?Await] Initializer[+In, ?Yield, ?Await]

Initializer[In, Yield, Await] :
    = AssignmentExpression[?In, ?Yield, ?Await]
```

#### 注意 2
`MethodDefinition` 定义见 15.4。

#### 注意 3
在某些上下文中，`ObjectLiteral` 用作更受限的次级语法的覆盖语法。`CoverInitializedName` 生成式是必要的，以完全覆盖这些次级语法。然而，在正常上下文中，当预期实际对象初始化器时，使用此生成式会导致早期语法错误。

#### 13.2.5.1 静态语义：早期错误
```
PropertyDefinition : MethodDefinition
    如果 `MethodDefinition` 的 `HasDirectSuper` 为 `true`，则为语法错误。
    如果 `MethodDefinition` 的 `PrivateBoundIdentifiers` 不为空，则为语法错误。
```
除了描述实际的对象初始化器外，`ObjectLiteral` 生成式还用作 `ObjectAssignmentPattern` 的覆盖语法，并且可能作为 `CoverParenthesizedExpressionAndArrowParameterList` 的一部分被识别。当 `ObjectLiteral` 出现在需要 `ObjectAssignmentPattern` 的上下文中时，不适用以下早期错误规则。此外，当初次解析 `CoverParenthesizedExpressionAndArrowParameterList` 或 `CoverCallExpressionAndAsyncArrowHead` 时，也不适用这些规则。

```
PropertyDefinition : CoverInitializedName
    如果此生成式匹配任何源文本，则为语法错误。
```
#### 注意 1
该生成式存在是为了让 `ObjectLiteral` 可以作为 `ObjectAssignmentPattern` 的覆盖语法。它不能出现在实际的对象初始化器中。

```
ObjectLiteral :
    { PropertyDefinitionList }
    { PropertyDefinitionList , }
    如果 `PropertyDefinitionList` 的 `PropertyNameList` 包含任何 "__proto__" 的重复条目，并且至少两个条目来自形式 `PropertyDefinition : PropertyName : AssignmentExpression` 的生成式，则为语法错误。如果此 `ObjectLiteral` 包含在为 `JSON.parse` 解析的脚本中，则不适用此规则（参见 `JSON.parse` 的步骤 4）。
```
#### 注意 2
`PropertyNameList` 返回的列表不包括使用 `ComputedPropertyName` 定义的属性名称。

#### 13.2.5.2 静态语义：是否计算属性键
语法导向操作 `IsComputedPropertyKey` 不接受参数，返回一个布尔值。它在以下生成式上逐段定义：

```
PropertyName : LiteralPropertyName
    1. 返回 `false`。

PropertyName : ComputedPropertyName
    1. 返回 `true`。
```

#### 13.2.5.3 静态语义：属性名称列表
语法导向操作 `PropertyNameList` 不接受参数，返回一个字符串列表。它在以下生成式上逐段定义：

```
PropertyDefinitionList : PropertyDefinition
    1. 令 `propName` 为 `PropertyDefinition` 的 `PropName`。
    2. 如果 `propName` 为空，返回一个新的空列表。
    3. 返回 « propName »。

PropertyDefinitionList : PropertyDefinitionList , PropertyDefinition
    1. 令 `list` 为 `PropertyDefinitionList` 的 `PropertyNameList`。
    2. 令 `propName` 为 `PropertyDefinition` 的 `PropName`。
    3. 如果 `propName` 为空，返回 `list`。
    4. 返回 `list` 和 « propName » 的列表连接。
```

#### 13.2.5.4 运行时语义：求值
```
ObjectLiteral : { }
    1. 返回 `OrdinaryObjectCreate(%Object.prototype%)`。

ObjectLiteral :
    { PropertyDefinitionList }
    { PropertyDefinitionList , }
    1. 令 `obj` 为 `OrdinaryObjectCreate(%Object.prototype%)`。
    2. 使用参数 `obj` 执行 `PropertyDefinitionList` 的 `PropertyDefinitionEvaluation`。
    3. 返回 `obj`。
```

```
LiteralPropertyName : IdentifierName
    1. 返回 `IdentifierName` 的 `StringValue`。

LiteralPropertyName : StringLiteral
    1. 返回 `StringLiteral` 的 `SV`。

LiteralPropertyName : NumericLiteral
    1. 令 `nbr` 为 `NumericLiteral` 的 `NumericValue`。
    2. 返回 `! ToString(nbr)`。

ComputedPropertyName : [ AssignmentExpression ]
    1. 令 `exprValue` 为 `AssignmentExpression` 的 `Evaluation`。
    2. 令 `propName` 为 `GetValue(exprValue)`。
    3. 返回 `ToPropertyKey(propName)`。
```

#### 13.2.5.5 运行时语义：属性定义求值
语法导向操作 `PropertyDefinitionEvaluation` 接受参数 `object`（一个对象），返回一个包含未使用值的正常完成或中断完成。它在以下生成式上逐段定义：

```
PropertyDefinitionList : PropertyDefinitionList , PropertyDefinition
    1. 使用参数 `object` 执行 `PropertyDefinitionList` 的 `PropertyDefinitionEvaluation`。
    2. 使用参数 `object` 执行 `PropertyDefinition` 的 `PropertyDefinitionEvaluation`。
    3. 返回未使用值。
```

```
PropertyDefinition : ... AssignmentExpression
    1. 令 `exprValue` 为 `AssignmentExpression` 的 `Evaluation`。
    2. 令 `fromValue` 为 `GetValue(exprValue)`。
    3. 令 `excludedNames` 为一个新的空列表。
    4. 执行 `CopyDataProperties(object, fromValue, excludedNames)`。
    5. 返回未使用值。
```

```
PropertyDefinition : IdentifierReference
    1. 令 `propName` 为 `IdentifierReference` 的 `StringValue`。
    2. 令 `exprValue` 为 `IdentifierReference` 的 `Evaluation`。
    3. 令 `propValue` 为 `GetValue(exprValue)`。
    4. 断言：`object` 是一个普通的、可扩展的对象，没有不可配置的属性。
    5. 执行 `CreateDataPropertyOrThrow(object, propName, propValue)`。
    6. 返回未使用值。
```

```
PropertyDefinition : PropertyName : AssignmentExpression
    1. 令 `propKey` 为 `PropertyName` 的 `Evaluation`。
    2. 如果此 `PropertyDefinition` 包含在为 `JSON.parse` 解析的脚本中（参见 `JSON.parse` 的步骤 7），则
        a. 令 `isProtoSetter` 为 `false`。
    3. 否则，如果 `propKey` 是 "__proto__" 且 `PropertyName` 的 `IsComputedPropertyKey` 为 `false`，则
        a. 令 `isProtoSetter` 为 `true`。
    4. 否则，
        a. 令 `isProtoSetter` 为 `false`。
    5. 如果 `AssignmentExpression` 的 `IsAnonymousFunctionDefinition` 为 `true` 且 `isProtoSetter` 为 `false`，则
        a. 令 `propValue` 为 `AssignmentExpression` 的 `NamedEvaluation`，参数为 `propKey`。
    6. 否则，
        a. 令 `exprValueRef` 为 `AssignmentExpression` 的 `Evaluation`。
        b. 令 `propValue` 为 `GetValue(exprValueRef)`。
    7. 如果 `isProtoSetter` 为 `true`，则
        a. 如果 `propValue` 是一个对象或 `propValue` 为 `null`，则
            i

. 执行 `object.[[SetPrototypeOf]](propValue)`。
        b. 返回未使用值。
    8. 断言：`object` 是一个普通的、可扩展的对象，没有不可配置的属性。
    9. 执行 `CreateDataPropertyOrThrow(object, propKey, propValue)`。
    10. 返回未使用值。
```

```
PropertyDefinition : MethodDefinition
    1. 使用参数 `object` 和 `true` 执行 `MethodDefinition` 的 `MethodDefinitionEvaluation`。
    2. 返回未使用值。
```

### 13.2.6 函数定义表达式

参见 15.2 中 `PrimaryExpression : FunctionExpression`。

参见 15.5 中 `PrimaryExpression : GeneratorExpression`。

参见 15.7 中 `PrimaryExpression : ClassExpression`。

参见 15.8 中 `PrimaryExpression : AsyncFunctionExpression`。

参见 15.6 中 `PrimaryExpression : AsyncGeneratorExpression`。

### 13.2.7 正则表达式字面量

#### 语法
参见 12.9.5。

#### 13.2.7.1 静态语义：早期错误

`PrimaryExpression : RegularExpressionLiteral`

如果 `IsValidRegularExpressionLiteral(RegularExpressionLiteral)` 为 `false`，则为语法错误。

#### 13.2.7.2 静态语义：IsValidRegularExpressionLiteral（literal）

抽象操作 `IsValidRegularExpressionLiteral` 接受参数 `literal`（一个 `RegularExpressionLiteral` 解析节点）并返回一个布尔值。它确定其参数是否为有效的正则表达式字面量。调用时执行以下步骤：

1. 令 `flags` 为 `literal` 的 `FlagText`。
2. 如果 `flags` 包含除 `d`, `g`, `i`, `m`, `s`, `u`, `v`, 或 `y` 之外的任何代码点，或如果 `flags` 中的任何代码点出现多次，返回 `false`。
3. 如果 `flags` 包含 `u`，令 `u` 为 `true`；否则令 `u` 为 `false`。
4. 如果 `flags` 包含 `v`，令 `v` 为 `true`；否则令 `v` 为 `false`。
5. 令 `patternText` 为 `literal` 的 `BodyText`。
6. 如果 `u` 为 `false` 且 `v` 为 `false`，则
   a. 令 `stringValue` 为 `patternText` 的 `CodePointsToString`。
   b. 将 `patternText` 设置为通过将 `stringValue` 的每个 16 位元素解释为一个 Unicode BMP 代码点而得出的代码点序列。不对这些元素应用 UTF-16 解码。
7. 令 `parseResult` 为 `ParsePattern(patternText, u, v)`。
8. 如果 `parseResult` 是一个解析节点，返回 `true`；否则返回 `false`。

#### 13.2.7.3 运行时语义：求值

`PrimaryExpression : RegularExpressionLiteral`

1. 令 `pattern` 为 `RegularExpressionLiteral` 的 `BodyText` 的 `CodePointsToString`。
2. 令 `flags` 为 `RegularExpressionLiteral` 的 `FlagText` 的 `CodePointsToString`。
3. 返回 `! RegExpCreate(pattern, flags)`。

### 13.2.8 模板字面量

#### 语法
```javascript
TemplateLiteral[Yield, Await, Tagged] :
  NoSubstitutionTemplate
  SubstitutionTemplate[?Yield, ?Await, ?Tagged]

SubstitutionTemplate[Yield, Await, Tagged] :
  TemplateHead Expression[+In, ?Yield, ?Await] TemplateSpans[?Yield, ?Await, ?Tagged]

TemplateSpans[Yield, Await, Tagged] :
  TemplateTail
  TemplateMiddleList[?Yield, ?Await, ?Tagged] TemplateTail

TemplateMiddleList[Yield, Await, Tagged] :
  TemplateMiddle Expression[+In, ?Yield, ?Await]
  TemplateMiddleList[?Yield, ?Await, ?Tagged] TemplateMiddle Expression[+In, ?Yield, ?Await]
```

#### 13.2.8.1 静态语义：早期错误

```javascript
TemplateLiteral[Yield, Await, Tagged] : NoSubstitutionTemplate
  如果没有设置 [Tagged] 参数且 NoSubstitutionTemplate 包含 NotEscapeSequence，则为语法错误。

TemplateLiteral[Yield, Await, Tagged] : SubstitutionTemplate[?Yield, ?Await, ?Tagged]
  如果带有 false 参数的 TemplateLiteral 的 TemplateStrings 元素数量大于等于 2**32，则为语法错误。

SubstitutionTemplate[Yield, Await, Tagged] : TemplateHead Expression[+In, ?Yield, ?Await] TemplateSpans[?Yield, ?Await, ?Tagged]
  如果没有设置 [Tagged] 参数且 TemplateHead 包含 NotEscapeSequence，则为语法错误。

TemplateSpans[Yield, Await, Tagged] : TemplateTail
  如果没有设置 [Tagged] 参数且 TemplateTail 包含 NotEscapeSequence，则为语法错误。

TemplateMiddleList[Yield, Await, Tagged] :
  TemplateMiddle Expression[+In, ?Yield, ?Await]
  TemplateMiddleList[?Yield, ?Await, ?Tagged] TemplateMiddle Expression[+In, ?Yield, ?Await]
  如果没有设置 [Tagged] 参数且 TemplateMiddle 包含 NotEscapeSequence，则为语法错误。
```

#### 13.2.8.2 静态语义：模板字符串

语法导向操作 TemplateStrings 接受参数 raw（一个布尔值）并返回一个字符串或 undefined 的列表。它根据以下生成式定义：

```javascript
TemplateLiteral : NoSubstitutionTemplate
  1. 返回 « TemplateString(NoSubstitutionTemplate, raw) »。

SubstitutionTemplate : TemplateHead Expression TemplateSpans
  1. 令 head 为 « TemplateString(TemplateHead, raw) »。
  2. 令 tail 为带有 raw 参数的 TemplateSpans 的 TemplateStrings。
  3. 返回 head 和 tail 的列表连接。

TemplateSpans : TemplateTail
  1. 返回 « TemplateString(TemplateTail, raw) »。

TemplateSpans : TemplateMiddleList TemplateTail
  1. 令 middle 为带有 raw 参数的 TemplateMiddleList 的 TemplateStrings。
  2. 令 tail 为 « TemplateString(TemplateTail, raw) »。
  3. 返回 middle 和 tail 的列表连接。

TemplateMiddleList : TemplateMiddle Expression
  1. 返回 « TemplateString(TemplateMiddle, raw) »。

TemplateMiddleList : TemplateMiddleList TemplateMiddle Expression
  1. 令 front 为带有 raw 参数的 TemplateMiddleList 的 TemplateStrings。
  2. 令 last 为 « TemplateString(TemplateMiddle, raw) »。
  3. 返回 front 和 last 的列表连接。
```

#### 13.2.8.3 静态语义：TemplateString（templateToken，raw）

抽象操作 TemplateString 接受参数 templateToken（一个 NoSubstitutionTemplate 解析节点，一个 TemplateHead 解析节点，一个 TemplateMiddle 解析节点，或一个 TemplateTail 解析节点）和 raw（一个布尔值）并返回一个字符串或 undefined。当调用时，执行以下步骤：

1. 如果 raw 为 true，则
   a. 令 string 为 templateToken 的 TRV。
2. 否则，
   a. 令 string 为 templateToken 的 TV。
3. 返回 string。

**注意**：如果 raw 为 false 且 templateToken 包含 NotEscapeSequence，则此操作返回 undefined。在所有其他情况下，它返回一个字符串。

#### 13.2.8.4 获取模板对象（templateLiteral）

抽象操作 GetTemplateObject 接受参数 templateLiteral（一个解析节点）并返回一个数组。当调用时，执行以下步骤：

1. 令 realm 为当前的 Realm 记录。
2. 令 templateRegistry 为 realm.[[TemplateMap]]。
3. 对于 templateRegistry 中的每个元素 e，执行
   a. 如果 e.[[Site]] 与 templateLiteral 是相同的解析节点，则
     i. 返回 e.[[Array]]。
4. 令 rawStrings 为带有 true 参数的 templateLiteral 的 TemplateStrings。
5. 断言：rawStrings 是一个字符串列表。
6. 令 cookedStrings 为带有 false 参数的 templateLiteral 的 TemplateStrings。
7. 令 count 为 cookedStrings 列表中的元素数量。
8. 断言：count ≤ 2**32 - 1。
9. 令 template 为 ! ArrayCreate(count)。
10. 令 rawObj 为 ! ArrayCreate(count)。
11. 令 index 为 0。
12. 重复，直到 index < count，
    a. 令 prop 为 ! ToString(𝔽(index))。
    b. 令 cookedValue 为 cookedStrings[index]。
    c. 执行 ! DefinePropertyOrThrow(template, prop, PropertyDescriptor { [[Value]]: cookedValue, [[Writable]]: false, [[Enumerable]]: true, [[Configurable]]: false })。
    d. 令 rawValue 为 rawStrings[index] 的字符串值。
    e. 执行 ! DefinePropertyOrThrow(rawObj, prop, PropertyDescriptor { [[Value]]: rawValue, [[Writable]]: false, [[Enumerable]]: true, [[Configurable]]: false })。
    f. 将 index 设置为 index + 1。
13. 执行 ! SetIntegrityLevel(rawObj, FROZEN)。
14. 执行 ! DefinePropertyOrThrow(template, "raw", PropertyDescriptor { [[Value]]: rawObj, [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false })。
15. 执行 ! SetIntegrityLevel(template, FROZEN)。
16. 将记录 { [[Site]]: templateLiteral, [[Array]]: template } 添加到 realm.[[TemplateMap]] 中。
17. 返回 template。

**注意 1**：创建模板对象不能导致意外完成。

**注意 2**：领域的程序代码中的每个 TemplateLiteral 都与一个唯一的模板对象相关联，该模板对象在标记模板的求值中使用（13.2.8.6）。模板对象是冻结的，并且每次求值特定标记模板时使用相同的模板对象。模板对象是首次求值 TemplateLiteral 时懒创建的还是首次求值前急创建的是实现选择，这对于 ECMAScript 代码来说是不可观察的。

**注意 3**：本规范的未来版本可能会定义模板对象的其他不可枚举属性。

#### 13.2.8.5 运行时语义：替换求值

语法导向操作 SubstitutionEvaluation 不接受参数并返回一个包含 ECMAScript 语言值的列表或意外完成。它根据以下生成式定义：

```javascript
TemplateSpans : TemplateTail
  1. 返回一个新的空列表。

TemplateSpans : TemplateMiddleList TemplateTail
  1. 返回带有 TemplateMiddleList 的 SubstitutionEvaluation。

TemplateMiddleList : TemplateMiddle Expression
  1. 令 subRef 为 ? Evaluation of Expression。
  2. 令 sub 为 ? GetValue(subRef)。
  3. 返回 « sub »。

TemplateMiddleList : TemplateMiddleList TemplateMiddle Expression
  1. 令 preceding 为带有 TemplateMiddleList 的 SubstitutionEvaluation。
  2. 令 nextRef 为 ? Evaluation of Expression。
  3. 令 next 为 ? GetValue(nextRef)。
  4. 返回 preceding 和 « next » 的列表连接。
```

#### 13.2.8.6 运行时语义：求值

```javascript
TemplateLiteral : NoSubstitutionTemplate
  1. 返回 NoSubstitutionTemplate 的 TV，如 12.9.6 中所定义。

SubstitutionTemplate : TemplateHead Expression TemplateSpans
  1. 令 head 为 TemplateHead 的 TV，如 12.9.6 中所定义。
  2. 令 subRef 为 ? Evaluation of Expression。
  3. 令 sub 为 ? GetValue(subRef)。
  4. 令 middle 为 ? ToString(sub)。
  5. 令 tail 为 ? Evaluation of TemplateSpans。
  6. 返回 head、middle 和 tail 的字符串连接。
  
**注意 1**：对 Expression 值应用的字符串转换语义类似于 `String.prototype.concat`，而不是 `+` 运算符。

TemplateSpans : TemplateTail
  1. 返回 TemplateTail 的 TV，如 12.9.6 中所定义。

TemplateSpans : TemplateMiddleList TemplateTail
  1. 令 head 为带有 TemplateMiddleList 的 Evaluation。
  2. 令 tail 为 Template

Tail 的 TV，如 12.9.6 中所定义。
  3. 返回 head 和 tail 的字符串连接。

TemplateMiddleList : TemplateMiddle Expression
  1. 令 head 为 TemplateMiddle 的 TV，如 12.9.6 中所定义。
  2. 令 subRef 为 ? Evaluation of Expression。
  3. 令 sub 为 ? GetValue(subRef)。
  4. 令 middle 为 ? ToString(sub)。
  5. 返回 head 和 middle 的字符串连接。

**注意 2**：对 Expression 值应用的字符串转换语义类似于 `String.prototype.concat`，而不是 `+` 运算符。

TemplateMiddleList : TemplateMiddleList TemplateMiddle Expression
  1. 令 rest 为带有 TemplateMiddleList 的 Evaluation。
  2. 令 middle 为 TemplateMiddle 的 TV，如 12.9.6 中所定义。
  3. 令 subRef 为 ? Evaluation of Expression。
  4. 令 sub 为 ? GetValue(subRef)。
  5. 令 last 为 ? ToString(sub)。
  6. 返回 rest、middle 和 last 的字符串连接。

**注意 3**：对 Expression 值应用的字符串转换语义类似于 `String.prototype.concat`，而不是 `+` 运算符。
```

### 13.2.9 分组操作符

#### 13.2.9.1 静态语义：早期错误
```javascript
PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList
CoverParenthesizedExpressionAndArrowParameterList 必须覆盖一个 ParenthesizedExpression。
```

#### 13.2.9.2 运行时语义：求值
```javascript
PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList
1. 令 expr 为 CoverParenthesizedExpressionAndArrowParameterList 所覆盖的 ParenthesizedExpression。
2. 返回 expr 的 ? Evaluation。
```
```javascript
ParenthesizedExpression : ( Expression )
1. 返回 Expression 的 ? Evaluation。这个结果可能是 Reference 类型。
```
**注意**：这个算法不会对 Expression 的 Evaluation 结果应用 GetValue。这样设计的主要动机是为了使诸如 delete 和 typeof 等操作符可以应用于带括号的表达式。

### 13.3 左侧表达式

#### 语法
```javascript
MemberExpression[Yield, Await] :
  PrimaryExpression[?Yield, ?Await]
  MemberExpression[?Yield, ?Await] [ Expression[+In, ?Yield, ?Await] ]
  MemberExpression[?Yield, ?Await] . IdentifierName
  MemberExpression[?Yield, ?Await] TemplateLiteral[?Yield, ?Await, +Tagged]
  SuperProperty[?Yield, ?Await]
  MetaProperty
  new MemberExpression[?Yield, ?Await] Arguments[?Yield, ?Await]
  MemberExpression[?Yield, ?Await] . PrivateIdentifier

SuperProperty[Yield, Await] :
  super [ Expression[+In, ?Yield, ?Await] ]
  super . IdentifierName

MetaProperty :
  NewTarget
  ImportMeta

NewTarget :
  new . target

ImportMeta :
  import . meta

NewExpression[Yield, Await] :
  MemberExpression[?Yield, ?Await]
  new NewExpression[?Yield, ?Await]

CallExpression[Yield, Await] :
  CoverCallExpressionAndAsyncArrowHead[?Yield, ?Await]
  SuperCall[?Yield, ?Await]
  ImportCall[?Yield, ?Await]
  CallExpression[?Yield, ?Await] Arguments[?Yield, ?Await]
  CallExpression[?Yield, ?Await] [ Expression[+In, ?Yield, ?Await] ]
  CallExpression[?Yield, ?Await] . IdentifierName
  CallExpression[?Yield, ?Await] TemplateLiteral[?Yield, ?Await, +Tagged]
  CallExpression[?Yield, ?Await] . PrivateIdentifier

SuperCall[Yield, Await] :
  super Arguments[?Yield, ?Await]

ImportCall[Yield, Await] :
  import ( AssignmentExpression[+In, ?Yield, ?Await] )

Arguments[Yield, Await] :
  ( )
  ( ArgumentList[?Yield, ?Await] )
  ( ArgumentList[?Yield, ?Await] , )

ArgumentList[Yield, Await] :
  AssignmentExpression[+In, ?Yield, ?Await]
  ... AssignmentExpression[+In, ?Yield, ?Await]
  ArgumentList[?Yield, ?Await] , AssignmentExpression[+In, ?Yield, ?Await]
  ArgumentList[?Yield, ?Await] , ... AssignmentExpression[+In, ?Yield, ?Await]

OptionalExpression[Yield, Await] :
  MemberExpression[?Yield, ?Await] OptionalChain[?Yield, ?Await]
  CallExpression[?Yield, ?Await] OptionalChain[?Yield, ?Await]
  OptionalExpression[?Yield, ?Await] OptionalChain[?Yield, ?Await]

OptionalChain[Yield, Await] :
  ?. Arguments[?Yield, ?Await]
  ?. [ Expression[+In, ?Yield, ?Await] ]
  ?. IdentifierName
  ?. TemplateLiteral[?Yield, ?Await, +Tagged]
  ?. PrivateIdentifier
  OptionalChain[?Yield, ?Await] Arguments[?Yield, ?Await]
  OptionalChain[?Yield, ?Await] [ Expression[+In, ?Yield, ?Await] ]
  OptionalChain[?Yield, ?Await] . IdentifierName
  OptionalChain[?Yield, ?Await] TemplateLiteral[?Yield, ?Await, +Tagged]
  OptionalChain[?Yield, ?Await] . PrivateIdentifier

LeftHandSideExpression[Yield, Await] :
  NewExpression[?Yield, ?Await]
  CallExpression[?Yield, ?Await]
  OptionalExpression[?Yield, ?Await]
```

#### 补充语法
在处理生成式 CallExpression : CoverCallExpressionAndAsyncArrowHead 时，使用以下语法细化 CoverCallExpressionAndAsyncArrowHead 的解释：
```javascript
CallMemberExpression[Yield, Await] :
  MemberExpression[?Yield, ?Await] Arguments[?Yield, ?Await]
```

### 13.3.1 静态语义

#### 13.3.1.1 静态语义：早期错误
```javascript
OptionalChain :
  ?. TemplateLiteral
  OptionalChain TemplateLiteral
```
如果任何源代码文本与此生成式匹配，则这是一个语法错误。

**注意**：
该生成式存在的目的是防止自动分号插入规则（12.10）应用于如下代码：
```javascript
a?.b
`c`
```
使其被解释为两个有效的语句。其目的是保持与没有可选链的类似代码的一致性：
```javascript
a.b
`c`
```
这是一个有效的语句，且不会应用自动分号插入。

```javascript
ImportMeta :
  import . meta
```
如果语法目标符号不是 Module，则这是一个语法错误。

### 13.3.2 属性访问器

**注意**：
属性通过名称访问，使用点符号或括号符号：

```javascript
MemberExpression . IdentifierName
CallExpression . IdentifierName
```
或者括号符号：

```javascript
MemberExpression [ Expression ]
CallExpression [ Expression ]
```
点符号解释如下：

```javascript
MemberExpression . IdentifierName
```
其行为与下述形式相同：

```javascript
MemberExpression [ <identifier-name-string> ]
```
同样，

```javascript
CallExpression . IdentifierName
```
其行为与下述形式相同：

```javascript
CallExpression [ <identifier-name-string> ]
```
其中 `<identifier-name-string>` 是 IdentifierName 的 StringValue。

#### 13.3.2.1 运行时语义：求值
```javascript
MemberExpression : MemberExpression [ Expression ]
1. 令 baseReference 为 MemberExpression 的 ? Evaluation。
2. 令 baseValue 为 baseReference 的 ? GetValue。
3. 令 strict 为 IsStrict(this MemberExpression)。
4. 返回 ? EvaluatePropertyAccessWithExpressionKey(baseValue, Expression, strict)。

MemberExpression : MemberExpression . IdentifierName
1. 令 baseReference 为 MemberExpression 的 ? Evaluation。
2. 令 baseValue 为 baseReference 的 ? GetValue。
3. 令 strict 为 IsStrict(this MemberExpression)。
4. 返回 EvaluatePropertyAccessWithIdentifierKey(baseValue, IdentifierName, strict)。

MemberExpression : MemberExpression . PrivateIdentifier
1. 令 baseReference 为 MemberExpression 的 ? Evaluation。
2. 令 baseValue 为 baseReference 的 ? GetValue。
3. 令 fieldNameString 为 PrivateIdentifier 的 StringValue。
4. 返回 MakePrivateReference(baseValue, fieldNameString)。

CallExpression : CallExpression [ Expression ]
1. 令 baseReference 为 CallExpression 的 ? Evaluation。
2. 令 baseValue 为 baseReference 的 ? GetValue。
3. 令 strict 为 IsStrict(this CallExpression)。
4. 返回 ? EvaluatePropertyAccessWithExpressionKey(baseValue, Expression, strict)。

CallExpression : CallExpression . IdentifierName
1. 令 baseReference 为 CallExpression 的 ? Evaluation。
2. 令 baseValue 为 baseReference 的 ? GetValue。
3. 令 strict 为 IsStrict(this CallExpression)。
4. 返回 EvaluatePropertyAccessWithIdentifierKey(baseValue, IdentifierName, strict)。

CallExpression : CallExpression . PrivateIdentifier
1. 令 baseReference 为 CallExpression 的 ? Evaluation。
2. 令 baseValue 为 baseReference 的 ? GetValue。
3. 令 fieldNameString 为 PrivateIdentifier 的 StringValue。
4. 返回 MakePrivateReference(baseValue, fieldNameString)。
```

### 13.3.3 EvaluatePropertyAccessWithExpressionKey ( baseValue, expression, strict )

抽象操作 `EvaluatePropertyAccessWithExpressionKey` 接受参数 baseValue（一个 ECMAScript 语言值）、expression（一个 Expression 解析节点）和 strict（一个布尔值），并返回一个包含引用记录的正常完成或一个突发完成。调用时执行以下步骤：

1. 令 propertyNameReference 为 expression 的 ? Evaluation。
2. 令 propertyNameValue 为 propertyNameReference 的 ? GetValue。
3. **注意**：在大多数情况下，ToPropertyKey 将在此步骤之后立即对 propertyNameValue 执行。然而，在 a[b] = c 的情况下，它将在评估 c 之后执行。
4. 返回引用记录 { [[Base]]: baseValue, [[ReferencedName]]: propertyNameValue, [[Strict]]: strict, [[ThisValue]]: EMPTY }。

### 13.3.4 EvaluatePropertyAccessWithIdentifierKey ( baseValue, identifierName, strict )

抽象操作 `EvaluatePropertyAccessWithIdentifierKey` 接受参数 baseValue（一个 ECMAScript 语言值）、identifierName（一个 IdentifierName 解析节点）和 strict（一个布尔值），并返回一个引用记录。调用时执行以下步骤：

1. 令 propertyNameString 为 identifierName 的 StringValue。
2. 返回引用记录 { [[Base]]: baseValue, [[ReferencedName]]: propertyNameString, [[Strict]]: strict, [[ThisValue]]: EMPTY }。

### 13.3.5 new 操作符

#### 13.3.5.1 运行时语义：求值
```javascript
NewExpression : new NewExpression
1. 返回 ? EvaluateNew(NewExpression, EMPTY)。

MemberExpression : new MemberExpression Arguments
1. 返回 ? EvaluateNew(MemberExpression, Arguments)。
```

##### 13.3.5.1.1 EvaluateNew ( constructExpr, arguments )

抽象操作 `EvaluateNew` 接受参数 constructExpr（一个 NewExpression 解析节点或一个 MemberExpression 解析节点）和 arguments（EMPTY 或 Arguments 解析节点），并返回一个包含 ECMAScript 语言值的正常完成或一个突发完成。调用时执行以下步骤：

1. 令 ref 为 constructExpr 的 ? Evaluation。
2. 令 constructor 为 ref 的 ? GetValue。
3. 如果 arguments 是 EMPTY，
  a. 令 argList 为一个新的空列表。
4. 否则，
  a. 令 argList 为 arguments 的 ? ArgumentListEvaluation。
5. 如果 IsConstructor(constructor) 为 false，抛出一个 TypeError 异常。
6. 返回 ? Construct(constructor, argList)。

### 13.3.6 函数调用

#### 13.3.6.1 运行时语义：求值
```javascript
CallExpression : CoverCallExpressionAndAsyncArrowHead
1. 令 expr 为 CoverCallExpressionAndAsyncArrowHead 所覆盖的 CallMemberExpression。
2. 令 memberExpr 为 expr 的 MemberExpression。
3. 令 arguments 为 expr 的 Arguments。
4. 令 ref 为 memberExpr 的 ? Evaluation。
5. 令 func 为 ref 的 ? GetValue。
6. 如果 ref 是一个引用记录，IsPropertyReference(ref) 为 false，并且 ref.[[ReferencedName]] 是 "eval"，那么
  a. 如果 SameValue(func, %eval%) 为 true，
    i. 令 argList 为 arguments 的 ? ArgumentListEvaluation。
    ii. 如果 argList 没有元素，返回 undefined。
    iii. 令 evalArg 为 argList 的第一个元素。
    iv. 如果 IsStrict(this CallExpression) 为 true，令 strictCaller 为 true。否则令 strictCaller 为 false。
    v. 返回 ? PerformEval(evalArg, strictCaller, true)。
7. 令 thisCall 为 this CallExpression。
8. 令 tailCall 为 IsInTailPosition(thisCall)。
9. 返回 ? EvaluateCall(func, ref, arguments, tailCall)。

CallExpression : CallExpression Arguments
1. 令 ref 为 CallExpression 的 ? Evaluation。
2. 令 func 为 ref 的 ? GetValue。
3. 令 thisCall 为 this CallExpression。
4. 令 tailCall 为 IsInTailPosition(thisCall)。
5. 返回 ? EvaluateCall(func, ref, Arguments, tailCall)。
```

#### 13.3.6.2 EvaluateCall ( func, ref, arguments, tailPosition )

抽象操作 `EvaluateCall` 接受参数 func（一个 ECMAScript 语言值）、ref（一个 ECMAScript 语言值或一个引用记录）、arguments（一个解析节点）和 tailPosition（一个布尔值），并返回一个包含 ECMAScript 语言值的正常完成或一个突发完成。调用时执行以下步骤：

1. 如果 ref 是一个引用记录，
  a. 如果 IsPropertyReference(ref) 为 true，
    i. 令 thisValue 为 GetThisValue(ref)。
  b. 否则，
    i. 令 refEnv 为 ref.[[Base]]。
    ii. 断言：refEnv 是一个环境记录。
    iii. 令 thisValue 为 refEnv.WithBaseObject()。
2. 否则，
  a. 令 thisValue 为 undefined。
3. 令 argList 为 arguments 的 ? ArgumentListEvaluation。
4. 如果 func 不是对象，抛出一个 TypeError 异常。
5. 如果 IsCallable(func) 为 false，抛出一个 TypeError 异常。
6. 如果 tailPosition 为 true，执行 PrepareForTailCall()。
7. 返回 ? Call(func, thisValue, argList)。

### 13.3.7 super 关键字

#### 13.3.7.1 运行时语义：求值
```javascript
SuperProperty : super [ Expression ]
1. 令 env 为 GetThisEnvironment()。
2. 令 actualThis 为 ? env.GetThisBinding()。
3. 令 propertyNameReference 为 Expression 的 ? Evaluation。
4. 令 propertyNameValue 为 propertyNameReference 的 ? GetValue。
5. 令 strict 为 IsStrict(this SuperProperty)。
6. 注意：在大多数情况下，ToPropertyKey 将在此步骤之后立即对 propertyNameValue 执行。然而，在 super[b] = c 的情况下，它将在评估 c 之后执行。
7. 返回 ? MakeSuperPropertyReference(actualThis, propertyNameValue, strict)。

SuperProperty : super . IdentifierName
1. 令 env 为 GetThisEnvironment()。
2. 令 actualThis 为 ? env.GetThisBinding()。
3. 令 propertyKey 为 IdentifierName 的 StringValue。
4. 令 strict 为 IsStrict(this SuperProperty)。
5. 返回 ? MakeSuperPropertyReference(actualThis, propertyKey, strict)。

SuperCall : super Arguments
1. 令 newTarget 为 GetNewTarget()。
2. 断言：newTarget 是一个对象。
3. 令 func 为 GetSuperConstructor()。
4. 令 argList 为 Arguments 的 ? ArgumentListEvaluation。
5. 如果 IsConstructor(func) 为 false，抛出一个 TypeError 异常。
6. 令 result 为 ? Construct(func, argList, newTarget)。
7. 令 thisER 为 GetThisEnvironment()。
8. 执行 ? thisER.BindThisValue(result)。
9. 令 F 为 thisER.[[FunctionObject]]。
10. 断言：F 是一个 ECMAScript 函数对象。
11. 执行 ? InitializeInstanceElements(result, F)。
12. 返回 result。
```

#### 13.3.7.2 GetSuperConstructor ( )
抽象操作 `GetSuperConstructor` 不接受任何参数，返回一个 ECMAScript 语言值。调用时执行以下步骤：

1. 令 envRec 为 GetThisEnvironment()。
2. 断言：envRec 是一个函数环境记录。
3. 令 activeFunction 为 envRec.[[FunctionObject]]。
4. 断言：activeFunction 是一个 ECMAScript 函数对象。
5. 令 superConstructor 为 ! activeFunction.[[GetPrototypeOf]]()。
6. 返回 superConstructor。

#### 13.3.7.3 MakeSuperPropertyReference ( actualThis, propertyKey, strict )
抽象操作 `MakeSuperPropertyReference` 接受参数 actualThis（一个 ECMAScript 语言值）、propertyKey（一个 ECMAScript 语言值）和 strict（一个布尔值），并返回一个包含超级引用记录的正常完成或一个抛出完成。调用时执行以下步骤：

1. 令 env 为 GetThisEnvironment()。
2. 断言：env.HasSuperBinding() 为 true。
3. 令 baseValue 为 ? env.GetSuperBase()。
4. 返回引用记录 { [[Base]]: baseValue, [[ReferencedName]]: propertyKey, [[Strict]]: strict, [[ThisValue]]: actualThis }。

### 13.3.8 参数列表

**注意**：
参数列表的求值产生一个值的列表。

#### 13.3.8.1 运行时语义：ArgumentListEvaluation
语法导向操作 `ArgumentListEvaluation` 不接受任何参数，返回一个包含 ECMAScript 语言值列表的正常完成或一个突发完成。它根据以下生成式分片定义：

```javascript
Arguments : ( )
1. 返回一个新的空列表。

ArgumentList : AssignmentExpression
1. 令 ref 为 AssignmentExpression 的 ? Evaluation。
2. 令 arg 为 ref 的 ? GetValue。
3. 返回 « arg »。

ArgumentList : ... AssignmentExpression
1. 令 list 为一个新的空列表。
2. 令 spreadRef 为 AssignmentExpression 的 ? Evaluation。
3. 令 spreadObj 为 spreadRef 的 ? GetValue。
4. 令 iteratorRecord 为 ? GetIterator(spreadObj, SYNC)。
5. 重复，
  a. 令 next 为 iteratorRecord 的 ? IteratorStepValue。
  b. 如果 next 是 DONE，返回 list。
  c. 将 next 添加到 list。

ArgumentList : ArgumentList , AssignmentExpression
1. 令 precedingArgs 为 ArgumentList 的 ? ArgumentListEvaluation。
2. 令 ref 为 AssignmentExpression 的 ? Evaluation。
3. 令 arg 为 ref 的 ? GetValue。
4. 返回 precedingArgs 和 « arg » 的列表连接。

ArgumentList : ArgumentList , ... AssignmentExpression
1. 令 precedingArgs 为 ArgumentList 的 ? ArgumentListEvaluation。
2. 令 spreadRef 为 AssignmentExpression 的 ? Evaluation。
3. 令 iteratorRecord 为 ? GetIterator(? GetValue(spreadRef), SYNC)。
4. 重复，
  a. 令 next 为 iteratorRecord 的 ? IteratorStepValue。
  b. 如果 next 是 DONE，返回 precedingArgs。
  c. 将 next 添加到 precedingArgs。

TemplateLiteral : NoSubstitutionTemplate
1. 令 templateLiteral 为 this TemplateLiteral。
2. 令 siteObj 为 GetTemplateObject(templateLiteral)。
3. 返回 « siteObj »。

TemplateLiteral : SubstitutionTemplate
1. 令 templateLiteral 为 this TemplateLiteral。
2. 令 siteObj 为 GetTemplateObject(templateLiteral)。
3. 令 remaining 为 SubstitutionTemplate 的 ? ArgumentListEvaluation。
4. 返回 « siteObj » 和 remaining 的列表连接。

SubstitutionTemplate : TemplateHead Expression TemplateSpans
1. 令 firstSubRef 为 Expression 的 ? Evaluation。
2. 令 firstSub 为 firstSubRef 的 ? GetValue。
3. 令 restSub 为 TemplateSpans 的 ? SubstitutionEvaluation。
4. 断言：restSub 是一个可能为空的列表。
5. 返回 « firstSub » 和 restSub 的列表连接。
```

### 13.3.9 可选链

**注意**：
可选链是一系列一个或多个属性访问和函数调用，其中第一个以 ?. 令牌开头。

#### 13.3.9.1 运行时语义：求值
```javascript
OptionalExpression :
  MemberExpression OptionalChain
  1. 令 baseReference 为 MemberExpression 的 ? Evaluation。
  2. 令 baseValue 为 baseReference 的 ? GetValue。
  3. 如果 baseValue 是 undefined 或 null，
    a. 返回 undefined。
  4. 返回 OptionalChain 的 ? ChainEvaluation，参数为 baseValue 和 baseReference。

OptionalExpression :
  CallExpression OptionalChain
  1. 令 baseReference 为 CallExpression 的 ? Evaluation。
  2. 令 baseValue 为 baseReference 的 ? GetValue。
  3. 如果 baseValue 是 undefined 或 null，
    a. 返回 undefined。
  4. 返回 OptionalChain 的 ? ChainEvaluation，参数为 baseValue 和 baseReference。

OptionalExpression :
  OptionalExpression OptionalChain
  1. 令 baseReference 为 OptionalExpression 的 ? Evaluation。
  2. 令 baseValue 为 baseReference 的 ? GetValue。
  3. 如果 baseValue 是 undefined 或 null，
    a. 返回 undefined。
  4. 返回 OptionalChain 的 ? ChainEvaluation，参数为 baseValue 和 baseReference。
```

#### 13.3.9.2 运行时语义：ChainEvaluation
语法导向操作 `ChainEvaluation` 接受参数 baseValue（一个 ECMAScript 语言值）和 baseReference（一个 ECMAScript 语言值或引用记录），返回一个包含 ECMAScript 语言值或引用记录的正常完成或一个突发完成。它根据以下生成式分片定义：

```javascript
OptionalChain : ?. Arguments
1. 令 thisChain 为 this OptionalChain。
2. 令 tailCall 为 IsInTailPosition(thisChain)。
3. 返回 ? EvaluateCall(baseValue, baseReference, Arguments, tailCall)。

OptionalChain : ?. [ Expression ]
1. 令 strict 为 IsStrict(this OptionalChain)。
2. 返回 ? EvaluatePropertyAccessWithExpressionKey(baseValue, Expression, strict)。

OptionalChain : ?. IdentifierName
1. 令 strict 为 IsStrict(this OptionalChain)。
2. 返回 EvaluatePropertyAccessWithIdentifierKey(baseValue, IdentifierName, strict)。

OptionalChain : ?. PrivateIdentifier
1. 令 fieldNameString 为 PrivateIdentifier 的 StringValue。
2. 返回 MakePrivateReference(baseValue, fieldNameString)。

OptionalChain : OptionalChain Arguments
1. 令 optionalChain 为 OptionalChain。
2. 令 newReference 为 optionalChain 的 ? ChainEvaluation，参数为 baseValue 和 baseReference。
3. 令 newValue 为 newReference 的 ? GetValue。
4. 令 thisChain 为 this OptionalChain。
5. 令 tailCall 为 IsInTailPosition(thisChain)。
6. 返回 ? EvaluateCall(newValue, newReference, Arguments, tailCall)。

OptionalChain : OptionalChain [ Expression ]
1. 令 optionalChain 为 OptionalChain。
2. 令 newReference 为 optionalChain 的 ? ChainEvaluation，参数为 baseValue 和 baseReference。
3. 令 newValue 为 newReference 的 ? GetValue。
4. 令 strict 为 IsStrict(this OptionalChain)。
5. 返回 ? EvaluatePropertyAccessWithExpressionKey(newValue, Expression, strict)。

OptionalChain : OptionalChain . IdentifierName
1. 令 optionalChain 为 OptionalChain。
2. 令 newReference 为 optionalChain 的 ? ChainEvaluation，参数为

 baseValue 和 baseReference。
3. 令 newValue 为 newReference 的 ? GetValue。
4. 令 strict 为 IsStrict(this OptionalChain)。
5. 返回 EvaluatePropertyAccessWithIdentifierKey(newValue, IdentifierName, strict)。

OptionalChain : OptionalChain . PrivateIdentifier
1. 令 optionalChain 为 OptionalChain。
2. 令 newReference 为 optionalChain 的 ? ChainEvaluation，参数为 baseValue 和 baseReference。
3. 令 newValue 为 newReference 的 ? GetValue。
4. 令 fieldNameString 为 PrivateIdentifier 的 StringValue。
5. 返回 MakePrivateReference(newValue, fieldNameString)。
```

### 13.3.10 Import 调用

#### 13.3.10.1 运行时语义：求值
```javascript
ImportCall : import ( AssignmentExpression )
1. 令 referrer 为 GetActiveScriptOrModule()。
2. 如果 referrer 为 null，设置 referrer 为当前的 Realm Record。
3. 令 argRef 为 AssignmentExpression 的 ? Evaluation。
4. 令 specifier 为 argRef 的 ? GetValue。
5. 令 promiseCapability 为 ! NewPromiseCapability(%Promise%)。
6. 令 specifierString 为 Completion(ToString(specifier))。
7. IfAbruptRejectPromise(specifierString, promiseCapability)。
8. 执行 HostLoadImportedModule(referrer, specifierString, EMPTY, promiseCapability)。
9. 返回 promiseCapability.[[Promise]]。
```

#### 13.3.10.1.1 ContinueDynamicImport ( promiseCapability, moduleCompletion )
抽象操作 `ContinueDynamicImport` 接受参数 promiseCapability（一个 PromiseCapability 记录）和 moduleCompletion（包含模块记录的正常完成或一个抛出完成），并返回 UNUSED。它完成由 import() 调用启动的动态导入过程，根据需要解析或拒绝由该调用返回的承诺。调用时执行以下步骤：

1. 如果 moduleCompletion 是一个突发完成，
  a. 执行 ! Call(promiseCapability.[[Reject]], undefined, « moduleCompletion.[[Value]] »)。
  b. 返回 UNUSED。
2. 令 module 为 moduleCompletion.[[Value]]。
3. 令 loadPromise 为 module.LoadRequestedModules()。
4. 令 rejectedClosure 为一个新的抽象闭包，参数为 (reason)，捕获 promiseCapability 并在调用时执行以下步骤：
  a. 执行 ! Call(promiseCapability.[[Reject]], undefined, « reason »)。
  b. 返回 UNUSED。
5. 令 onRejected 为 CreateBuiltinFunction(rejectedClosure, 1, "", « »)。
6. 令 linkAndEvaluateClosure 为一个新的抽象闭包，没有参数，捕获 module, promiseCapability 和 onRejected，并在调用时执行以下步骤：
  a. 令 link 为 Completion(module.Link())。
  b. 如果 link 是一个突发完成，
    i. 执行 ! Call(promiseCapability.[[Reject]], undefined, « link.[[Value]] »)。
    ii. 返回 UNUSED。
  c. 令 evaluatePromise 为 module.Evaluate()。
  d. 令 fulfilledClosure 为一个新的抽象闭包，没有参数，捕获 module 和 promiseCapability，并在调用时执行以下步骤：
    i. 令 namespace 为 GetModuleNamespace(module)。
    ii. 执行 ! Call(promiseCapability.[[Resolve]], undefined, « namespace »)。
    iii. 返回 UNUSED。
  e. 令 onFulfilled 为 CreateBuiltinFunction(fulfilledClosure, 0, "", « »)。
  f. 执行 PerformPromiseThen(evaluatePromise, onFulfilled, onRejected)。
  g. 返回 UNUSED。
7. 令 linkAndEvaluate 为 CreateBuiltinFunction(linkAndEvaluateClosure, 0, "", « »)。
8. 执行 PerformPromiseThen(loadPromise, linkAndEvaluate, onRejected)。
9. 返回 UNUSED。

### 13.3.11 标记模板

**注意**：
标记模板是一个函数调用，其中调用的参数来自 TemplateLiteral (13.2.8)。实际参数包括一个模板对象 (13.2.8.4) 和通过评估嵌入在 TemplateLiteral 中的表达式所产生的值。

#### 13.3.11.1 运行时语义：求值
```javascript
MemberExpression : MemberExpression TemplateLiteral
1. 令 tagRef 为 MemberExpression 的 ? Evaluation。
2. 令 tagFunc 为 tagRef 的 ? GetValue。
3. 令 thisCall 为 this MemberExpression。
4. 令 tailCall 为 IsInTailPosition(thisCall)。
5. 返回 ? EvaluateCall(tagFunc, tagRef, TemplateLiteral, tailCall)。

CallExpression : CallExpression TemplateLiteral
1. 令 tagRef 为 CallExpression 的 ? Evaluation。
2. 令 tagFunc 为 tagRef 的 ? GetValue。
3. 令 thisCall 为 this CallExpression。
4. 令 tailCall 为 IsInTailPosition(thisCall)。
5. 返回 ? EvaluateCall(tagFunc, tagRef, TemplateLiteral, tailCall)。
```

### 13.3.12 元属性

#### 13.3.12.1 运行时语义：求值
```javascript
NewTarget : new . target
1. 返回 GetNewTarget()。

ImportMeta : import . meta
1. 令 module 为 GetActiveScriptOrModule()。
2. 断言：module 是一个源文本模块记录。
3. 令 importMeta 为 module.[[ImportMeta]]。
4. 如果 importMeta 为 EMPTY，
  a. 设置 importMeta 为 OrdinaryObjectCreate(null)。
  b. 令 importMetaValues 为 HostGetImportMetaProperties(module)。
  c. 对于 importMetaValues 中的每个记录 { [[Key]], [[Value]] } p，
    i. 执行 ! CreateDataPropertyOrThrow(importMeta, p.[[Key]], p.[[Value]])。
  d. 执行 HostFinalizeImportMeta(importMeta, module)。
  e. 设置 module.[[ImportMeta]] 为 importMeta。
  f. 返回 importMeta。
5. 否则，
  a. 断言：importMeta 是一个对象。
  b. 返回 importMeta。
```

#### 13.3.12.1.1 HostGetImportMetaProperties ( moduleRecord )
宿主定义的抽象操作 `HostGetImportMetaProperties` 接受参数 moduleRecord（一个模块记录）并返回一个具有字段 [[Key]]（属性键）和 [[Value]]（ECMAScript 语言值）的记录列表。它允许宿主为从 import.meta 返回的对象提供属性键和值。

默认实现 `HostGetImportMetaProperties` 是返回一个新的空列表。

#### 13.3.12.1.2 HostFinalizeImportMeta ( importMeta, moduleRecord )
宿主定义的抽象操作 `HostFinalizeImportMeta` 接受参数 importMeta（一个对象）和 moduleRecord（一个模块记录），并返回 UNUSED。它允许宿主执行任何特殊操作以准备从 import.meta 返回的对象。

大多数宿主只需定义 `HostGetImportMetaProperties`，并保持 `HostFinalizeImportMeta` 的默认行为。然而，`HostFinalizeImportMeta` 为需要在对象暴露给 ECMAScript 代码之前直接操作对象的宿主提供了一个“逃生口”。

默认实现 `HostFinalizeImportMeta` 是返回 UNUSED。

### 13.4 更新表达式

#### 语法
```javascript
UpdateExpression[Yield, Await] :
  LeftHandSideExpression[?Yield, ?Await]
  LeftHandSideExpression[?Yield, ?Await] [no LineTerminator here] ++
  LeftHandSideExpression[?Yield, ?Await] [no LineTerminator here] --
  ++ UnaryExpression[?Yield, ?Await]
  -- UnaryExpression[?Yield, ?Await]
```

#### 13.4.1 静态语义：早期错误
```javascript
UpdateExpression :
  LeftHandSideExpression ++
  LeftHandSideExpression --
```
如果 `LeftHandSideExpression` 的 `AssignmentTargetType` 不是 `SIMPLE`，则为早期语法错误。

```javascript
UpdateExpression :
  ++ UnaryExpression
  -- UnaryExpression
```
如果 `UnaryExpression` 的 `AssignmentTargetType` 不是 `SIMPLE`，则为早期语法错误。

#### 13.4.2 后缀递增操作符

##### 13.4.2.1 运行时语义：求值
```javascript
UpdateExpression : LeftHandSideExpression ++
1. 令 lhs 为 LeftHandSideExpression 的 ? Evaluation。
2. 令 oldValue 为 ? ToNumeric(? GetValue(lhs))。
3. 如果 oldValue 是一个 Number，
  a. 令 newValue 为 Number::add(oldValue, 1𝔽)。
4. 否则，
  a. 断言：oldValue 是一个 BigInt。
  b. 令 newValue 为 BigInt::add(oldValue, 1ℤ)。
5. 执行 ? PutValue(lhs, newValue)。
6. 返回 oldValue。
```

#### 13.4.3 后缀递减操作符

##### 13.4.3.1 运行时语义：求值
```javascript
UpdateExpression : LeftHandSideExpression --
1. 令 lhs 为 LeftHandSideExpression 的 ? Evaluation。
2. 令 oldValue 为 ? ToNumeric(? GetValue(lhs))。
3. 如果 oldValue 是一个 Number，
  a. 令 newValue 为 Number::subtract(oldValue, 1𝔽)。
4. 否则，
  a. 断言：oldValue 是一个 BigInt。
  b. 令 newValue 为 BigInt::subtract(oldValue, 1ℤ)。
5. 执行 ? PutValue(lhs, newValue)。
6. 返回 oldValue。
```

#### 13.4.4 前缀递增操作符

##### 13.4.4.1 运行时语义：求值
```javascript
UpdateExpression : ++ UnaryExpression
1. 令 expr 为 UnaryExpression 的 ? Evaluation。
2. 令 oldValue 为 ? ToNumeric(? GetValue(expr))。
3. 如果 oldValue 是一个 Number，
  a. 令 newValue 为 Number::add(oldValue, 1𝔽)。
4. 否则，
  a. 断言：oldValue 是一个 BigInt。
  b. 令 newValue 为 BigInt::add(oldValue, 1ℤ)。
5. 执行 ? PutValue(expr, newValue)。
6. 返回 newValue。
```

#### 13.4.5 前缀递减操作符

##### 13.4.5.1 运行时语义：求值
```javascript
UpdateExpression : -- UnaryExpression
1. 令 expr 为 UnaryExpression 的 ? Evaluation。
2. 令 oldValue 为 ? ToNumeric(? GetValue(expr))。
3. 如果 oldValue 是一个 Number，
  a. 令 newValue 为 Number::subtract(oldValue, 1𝔽)。
4. 否则，
  a. 断言：oldValue 是一个 BigInt。
  b. 令 newValue 为 BigInt::subtract(oldValue, 1ℤ)。
5. 执行 ? PutValue(expr, newValue)。
6. 返回 newValue。
```


### 13.5 一元运算符

#### 语法
```javascript
UnaryExpression[Yield, Await] :
  UpdateExpression[?Yield, ?Await]
  delete UnaryExpression[?Yield, ?Await]
  void UnaryExpression[?Yield, ?Await]
  typeof UnaryExpression[?Yield, ?Await]
  + UnaryExpression[?Yield, ?Await]
  - UnaryExpression[?Yield, ?Await]
  ~ UnaryExpression[?Yield, ?Await]
  ! UnaryExpression[?Yield, ?Await]
  [+Await] AwaitExpression[?Yield]
```

#### 13.5.1 `delete` 运算符

##### 13.5.1.1 静态语义：早期错误
```javascript
UnaryExpression : delete UnaryExpression
```
如果 `IsStrict(UnaryExpression)` 为 true 并且派生的 `UnaryExpression` 是 `PrimaryExpression : IdentifierReference`、`MemberExpression : MemberExpression . PrivateIdentifier`、`CallExpression : CallExpression . PrivateIdentifier`、`OptionalChain : ?. PrivateIdentifier` 或 `OptionalChain : OptionalChain . PrivateIdentifier`，则为语法错误。

如果派生的 `UnaryExpression` 是 `PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList` 并且 `CoverParenthesizedExpressionAndArrowParameterList` 最终派生出的短语在 `UnaryExpression` 的位置会根据这些规则产生语法错误，则为语法错误。此规则递归应用。

**注**: 最后一条规则意味着表达式如 `delete (((foo)))` 因为递归应用第一条规则会产生早期错误。

##### 13.5.1.2 运行时语义：求值
```javascript
UnaryExpression : delete UnaryExpression
1. 令 ref 为 UnaryExpression 的 ? Evaluation。
2. 如果 ref 不是一个引用记录，返回 true。
3. 如果 `IsUnresolvableReference(ref)` 为 true，则
  a. 断言：ref.[[Strict]] 为 false。
  b. 返回 true。
4. 如果 `IsPropertyReference(ref)` 为 true，则
  a. 断言：`IsPrivateReference(ref)` 为 false。
  b. 如果 `IsSuperReference(ref)` 为 true，抛出一个 ReferenceError 异常。
  c. 令 baseObj 为 ? ToObject(ref.[[Base]])。
  d. 如果 ref.[[ReferencedName]] 不是一个属性键，则
    i. 将 ref.[[ReferencedName]] 设置为 ? ToPropertyKey(ref.[[ReferencedName]])。
  e. 令 deleteStatus 为 ? baseObj.[[Delete]](ref.[[ReferencedName]])。
  f. 如果 deleteStatus 为 false 并且 ref.[[Strict]] 为 true，抛出一个 TypeError 异常。
  g. 返回 deleteStatus。
5. 否则，
  a. 令 base 为 ref.[[Base]]。
  b. 断言：base 是一个环境记录。
  c. 返回 ? base.DeleteBinding(ref.[[ReferencedName]])。
```

**注1**: 当 `delete` 运算符在严格模式代码中出现时，如果它的 `UnaryExpression` 是对变量、函数参数或函数名称的直接引用，则抛出一个 `SyntaxError` 异常。此外，如果 `delete` 运算符在严格模式代码中出现并且要删除的属性具有属性 `[[Configurable]]: false`（或不能被删除），则抛出一个 `TypeError` 异常。

**注2**: 在步骤 4.c 中创建的对象在上述抽象操作和普通对象 `[[Delete]]` 内部方法之外不可访问。实现可能选择避免实际创建该对象。

#### 13.5.2 `void` 运算符

##### 13.5.2.1 运行时语义：求值
```javascript
UnaryExpression : void UnaryExpression
1. 令 expr 为 UnaryExpression 的 ? Evaluation。
2. 执行 ? GetValue(expr)。
3. 返回 undefined。
```

**注**: `GetValue` 必须被调用，即使其值未被使用，因为它可能具有可观察的副作用。

#### 13.5.3 `typeof` 运算符

##### 13.5.3.1 运行时语义：求值
```javascript
UnaryExpression : typeof UnaryExpression
1. 令 val 为 UnaryExpression 的 ? Evaluation。
2. 如果 val 是一个引用记录，则
  a. 如果 `IsUnresolvableReference(val)` 为 true，返回 "undefined"。
3. 将 val 设置为 ? GetValue(val)。
4. 如果 val 是 `undefined`，返回 "undefined"。
5. 如果 val 是 `null`，返回 "object"。
6. 如果 val 是 `String`，返回 "string"。
7. 如果 val 是 `Symbol`，返回 "symbol"。
8. 如果 val 是 `Boolean`，返回 "boolean"。
9. 如果 val 是 `Number`，返回 "number"。
10. 如果 val 是 `BigInt`，返回 "bigint"。
11. 断言：val 是一个对象。
12. **注**: 此步骤在 B.3.6.3 节中被替换。
13. 如果 val 具有 `[[Call]]` 内部槽，返回 "function"。
14. 返回 "object"。
```

#### 13.5.4 一元 `+` 运算符

**注**: 一元 `+` 运算符将其操作数转换为 `Number` 类型。

##### 13.5.4.1 运行时语义：求值
```javascript
UnaryExpression : + UnaryExpression
1. 令 expr 为 UnaryExpression 的 ? Evaluation。
2. 返回 ? ToNumber(? GetValue(expr))。
```

#### 13.5.5 一元 `-` 运算符

**注**: 一元 `-` 运算符将其操作数转换为数值，然后取反。对 `+0𝔽` 取反得到 `-0𝔽`，对 `-0𝔽` 取反得到 `+0𝔽`。

##### 13.5.5.1 运行时语义：求值
```javascript
UnaryExpression : - UnaryExpression
1. 令 expr 为 UnaryExpression 的 ? Evaluation。
2. 令 oldValue 为 ? ToNumeric(? GetValue(expr))。
3. 如果 oldValue 是一个 `Number`，
  a. 返回 `Number::unaryMinus(oldValue)`。
4. 否则，
  a. 断言：oldValue 是一个 `BigInt`。
  b. 返回 `BigInt::unaryMinus(oldValue)`。
```

#### 13.5.6 按位非运算符 (`~`)

##### 13.5.6.1 运行时语义：求值
```javascript
UnaryExpression : ~ UnaryExpression
1. 令 expr 为 UnaryExpression 的 ? Evaluation。
2. 令 oldValue 为 ? ToNumeric(? GetValue(expr))。
3. 如果 oldValue 是一个 `Number`，
  a. 返回 `Number::bitwiseNOT(oldValue)`。
4. 否则，
  a. 断言：oldValue 是一个 `BigInt`。
  b. 返回 `BigInt::bitwiseNOT(oldValue)`。
```

#### 13.5.7 逻辑非运算符 (`!`)

##### 13.5.7.1 运行时语义：求值
```javascript
UnaryExpression : ! UnaryExpression
1. 令 expr 为 UnaryExpression 的 ? Evaluation。
2. 令 oldValue 为 `ToBoolean(? GetValue(expr))`。
3. 如果 oldValue 为 `true`，返回 `false`。
4. 返回 `true`。
```

### 13.6 幂运算符
#### 语法
```javascript
ExponentiationExpression[Yield, Await] :
  UnaryExpression[?Yield, ?Await]
  UpdateExpression[?Yield, ?Await] ** ExponentiationExpression[?Yield, ?Await]
```

#### 13.6.1 运行时语义：求值
```javascript
ExponentiationExpression : UpdateExpression ** ExponentiationExpression
1. 返回 ? EvaluateStringOrNumericBinaryExpression(UpdateExpression, **, ExponentiationExpression)。
```

### 13.7 乘法运算符
#### 语法
```javascript
MultiplicativeExpression[Yield, Await] :
  ExponentiationExpression[?Yield, ?Await]
  MultiplicativeExpression[?Yield, ?Await] MultiplicativeOperator ExponentiationExpression[?Yield, ?Await]

MultiplicativeOperator : one of
  * / %
```

**注意**：
- `*` 运算符进行乘法运算，产生操作数的乘积。
- `/` 运算符进行除法运算，产生操作数的商。
- `%` 运算符产生操作数除法后的余数。

#### 13.7.1 运行时语义：求值
```javascript
MultiplicativeExpression : MultiplicativeExpression MultiplicativeOperator ExponentiationExpression
1. 令 opText 为 MultiplicativeOperator 匹配的源文本。
2. 返回 ? EvaluateStringOrNumericBinaryExpression(MultiplicativeExpression, opText, ExponentiationExpression)。
```

### 13.8 加法运算符
#### 语法
```javascript
AdditiveExpression[Yield, Await] :
  MultiplicativeExpression[?Yield, ?Await]
  AdditiveExpression[?Yield, ?Await] + MultiplicativeExpression[?Yield, ?Await]
  AdditiveExpression[?Yield, ?Await] - MultiplicativeExpression[?Yield, ?Await]
```

#### 13.8.1 加法运算符 (`+`)
**注意**：加法运算符进行字符串连接或数值加法运算。

##### 13.8.1.1 运行时语义：求值
```javascript
AdditiveExpression : AdditiveExpression + MultiplicativeExpression
1. 返回 ? EvaluateStringOrNumericBinaryExpression(AdditiveExpression, +, MultiplicativeExpression)。
```

#### 13.8.2 减法运算符 (`-`)
**注意**：`-` 运算符进行减法运算，产生操作数的差值。

##### 13.8.2.1 运行时语义：求值
```javascript
AdditiveExpression : AdditiveExpression - MultiplicativeExpression
1. 返回 ? EvaluateStringOrNumericBinaryExpression(AdditiveExpression, -, MultiplicativeExpression)。
```

### 13.9 按位移位运算符
#### 语法
```javascript
ShiftExpression[Yield, Await] :
  AdditiveExpression[?Yield, ?Await]
  ShiftExpression[?Yield, ?Await] << AdditiveExpression[?Yield, ?Await]
  ShiftExpression[?Yield, ?Await] >> AdditiveExpression[?Yield, ?Await]
  ShiftExpression[?Yield, ?Await] >>> AdditiveExpression[?Yield, ?Await]
```

#### 13.9.1 左移运算符 (`<<`)
**注意**：对左操作数进行按位左移运算，移位的位数由右操作数指定。

##### 13.9.1.1 运行时语义：求值
```javascript
ShiftExpression : ShiftExpression << AdditiveExpression
1. 返回 ? EvaluateStringOrNumericBinaryExpression(ShiftExpression, <<, AdditiveExpression)。
```

#### 13.9.2 带符号右移运算符 (`>>`)
**注意**：对左操作数进行符号填充的按位右移运算，移位的位数由右操作数指定。

##### 13.9.2.1 运行时语义：求值
```javascript
ShiftExpression : ShiftExpression >> AdditiveExpression
1. 返回 ? EvaluateStringOrNumericBinaryExpression(ShiftExpression, >>, AdditiveExpression)。
```

#### 13.9.3 无符号右移运算符 (`>>>`)
**注意**：对左操作数进行零填充的按位右移运算，移位的位数由右操作数指定。

##### 13.9.3.1 运行时语义：求值
```javascript
ShiftExpression : ShiftExpression >>> AdditiveExpression
1. 返回 ? EvaluateStringOrNumericBinaryExpression(ShiftExpression, >>>, AdditiveExpression)。
```

### 13.10 关系运算符
**注意1**：求值关系运算符的结果总是布尔类型，反映运算符命名的关系在其两个操作数之间是否成立。

#### 语法
```javascript
RelationalExpression[In, Yield, Await] :
  ShiftExpression[?Yield, ?Await]
  RelationalExpression[?In, ?Yield, ?Await] < ShiftExpression[?Yield, ?Await]
  RelationalExpression[?In, ?Yield, ?Await] > ShiftExpression[?Yield, ?Await]
  RelationalExpression[?In, ?Yield, ?Await] <= ShiftExpression[?Yield, ?Await]
  RelationalExpression[?In, ?Yield, ?Await] >= ShiftExpression[?Yield, ?Await]
  RelationalExpression[?In, ?Yield, ?Await] instanceof ShiftExpression[?Yield, ?Await]
  [+In] RelationalExpression[+In, ?Yield, ?Await] in ShiftExpression[?Yield, ?Await]
  [+In] PrivateIdentifier in ShiftExpression[?Yield, ?Await]
```

**注意2**：`[In]` 语法参数是为了避免在关系表达式中将 `in` 运算符与 `for` 语句中的 `in` 运算符混淆。

#### 13.10.1 运行时语义：求值
```javascript
RelationalExpression : RelationalExpression < ShiftExpression
1. 令 lref 为 RelationalExpression 的 ? Evaluation。
2. 令 lval 为 ? GetValue(lref)。
3. 令 rref 为 ShiftExpression 的 ? Evaluation。
4. 令 rval 为 ? GetValue(rref)。
5. 令 r 为 ? IsLessThan(lval, rval, true)。
6. 如果 r 为 undefined，返回 false。否则，返回 r。

RelationalExpression : RelationalExpression > ShiftExpression
1. 令 lref 为 RelationalExpression 的 ? Evaluation。
2. 令 lval 为 ? GetValue(lref)。
3. 令 rref 为 ShiftExpression 的 ? Evaluation。
4. 令 rval 为 ? GetValue(rref)。
5. 令 r 为 ? IsLessThan(rval, lval, false)。
6. 如果 r 为 undefined，返回 false。否则，返回 r。

RelationalExpression : RelationalExpression <= ShiftExpression
1. 令 lref 为 RelationalExpression 的 ? Evaluation。
2. 令 lval 为 ? GetValue(lref)。
3. 令 rref 为 ShiftExpression 的 ? Evaluation。
4. 令 rval 为 ? GetValue(rref)。
5. 令 r 为 ? IsLessThan(rval, lval, false)。
6. 如果 r 为 true 或 undefined，返回 false。否则，返回 true。

RelationalExpression : RelationalExpression >= ShiftExpression
1. 令 lref 为 RelationalExpression 的 ? Evaluation。
2. 令 lval 为 ? GetValue(lref)。
3. 令 rref 为 ShiftExpression 的 ? Evaluation。
4. 令 rval 为 ? GetValue(rref)。
5. 令 r 为 ? IsLessThan(lval, rval, true)。
6. 如果 r 为 true 或 undefined，返回 false。否则，返回 true。

RelationalExpression : RelationalExpression instanceof ShiftExpression
1. 令 lref 为 RelationalExpression 的 ? Evaluation。
2. 令 lval 为 ? GetValue(lref)。
3. 令 rref 为 ShiftExpression 的 ? Evaluation。
4. 令 rval 为 ? GetValue(rref)。
5. 返回 ? InstanceofOperator(lval, rval)。

RelationalExpression : RelationalExpression in ShiftExpression
1. 令 lref 为 RelationalExpression 的 ? Evaluation。
2. 令 lval 为 ? GetValue(lref)。
3. 令 rref 为 ShiftExpression 的 ? Evaluation。
4. 令 rval 为 ? GetValue(rref)。
5. 如果 rval 不是对象，抛出一个 TypeError 异常。
6. 返回 ? HasProperty(rval, ? ToPropertyKey(lval))。

RelationalExpression : PrivateIdentifier in ShiftExpression
1. 令 privateIdentifier 为 PrivateIdentifier 的 StringValue。
2. 令 rref 为 ShiftExpression 的 ? Evaluation。
3. 令 rval 为 ? GetValue(rref)。
4. 如果 rval 不是对象，抛出一个 TypeError 异常。
5. 令 privateEnv 为当前执行上下文的 PrivateEnvironment。
6. 令 privateName 为 `ResolvePrivateIdentifier(privateEnv, privateIdentifier)`。
7. 如果 `PrivateElementFind(rval, privateName)` 不是 EMPTY，返回 true。
8. 返回 false。
```

#### 13.10.2 `InstanceofOperator (

V, target)`
```javascript
InstanceofOperator (V, target)
抽象操作 `InstanceofOperator` 接受参数 `V`（一个 ECMAScript 语言值）和 `target`（一个 ECMAScript 语言值）并返回一个布尔值或抛出异常。它实现了通用算法，通过查询 `target` 的 `@@hasInstance` 方法或如果不存在，通过确定 `target` 的 "prototype" 属性值是否存在于 `V` 的原型链中来确定 `V` 是否是 `target` 的实例。它在调用时执行以下步骤：

1. 如果 `target` 不是对象，抛出一个 TypeError 异常。
2. 令 `instOfHandler` 为 `GetMethod(target, @@hasInstance)` 的返回值。
3. 如果 `instOfHandler` 不是 `undefined`，则
  a. 返回 `ToBoolean(? Call(instOfHandler, target, « V »))`。
4. 如果 `IsCallable(target)` 为 false，抛出一个 TypeError 异常。
5. 返回 `? OrdinaryHasInstance(target, V)`。
```

**注意**：步骤 4 和 5 提供与以前版本 ECMAScript 的兼容性，这些版本没有使用 `@@hasInstance` 方法来定义 `instanceof` 运算符语义。如果对象未定义或继承 `@@hasInstance`，则使用默认 `instanceof` 语义。

### 13.11 相等运算符
**注意**：求值相等运算符的结果总是布尔类型，反映运算符命名的关系在其两个操作数之间是否成立。

#### 语法
```javascript
EqualityExpression[In, Yield, Await] :
  RelationalExpression[?In, ?Yield, ?Await]
  EqualityExpression[?In, ?Yield, ?Await] == RelationalExpression[?In, ?Yield, ?Await]
  EqualityExpression[?In, ?Yield, ?Await] != RelationalExpression[?In, ?Yield, ?Await]
  EqualityExpression[?In, ?Yield, ?Await] === RelationalExpression[?In, ?Yield, ?Await]
  EqualityExpression[?In, ?Yield, ?Await] !== RelationalExpression[?In, ?Yield, ?Await]
```

#### 13.11.1 运行时语义：求值
```javascript
EqualityExpression : EqualityExpression == RelationalExpression
1. 令 lref 为 EqualityExpression 的 ? Evaluation。
2. 令 lval 为 ? GetValue(lref)。
3. 令 rref 为 RelationalExpression 的 ? Evaluation。
4. 令 rval 为 ? GetValue(rref)。
5. 返回 ? IsLooselyEqual(rval, lval)。

EqualityExpression : EqualityExpression != RelationalExpression
1. 令 lref 为 EqualityExpression 的 ? Evaluation。
2. 令 lval 为 ? GetValue(lref)。
3. 令 rref 为 RelationalExpression 的 ? Evaluation。
4. 令 rval 为 ? GetValue(rref)。
5. 令 r 为 ? IsLooselyEqual(rval, lval)。
6. 如果 r 为 true，返回 false。否则，返回 true。

EqualityExpression : EqualityExpression === RelationalExpression
1. 令 lref 为 EqualityExpression 的 ? Evaluation。
2. 令 lval 为 ? GetValue(lref)。
3. 令 rref 为 RelationalExpression 的 ? Evaluation。
4. 令 rval 为 ? GetValue(rref)。
5. 返回 `IsStrictlyEqual(rval, lval)`。

EqualityExpression : EqualityExpression !== RelationalExpression
1. 令 lref 为 EqualityExpression 的 ? Evaluation。
2. 令 lval 为 ? GetValue(lref)。
3. 令 rref 为 RelationalExpression 的 ? Evaluation。
4. 令 rval 为 ? GetValue(rref)。
5. 令 r 为 `IsStrictlyEqual(rval, lval)`。
6. 如果 r 为 true，返回 false。否则，返回 true。
```

**注意1**：鉴于上述相等定义：

字符串比较可以通过 `${a} == ${b}` 强制进行。
数字比较可以通过 `+a == +b` 强制进行。
布尔比较可以通过 `!a == !b` 强制进行。

**注意2**：相等运算符保持以下不变性：

`A != B` 等价于 `!(A == B)`。
`A == B` 等价于 `B == A`，除了 `A` 和 `B` 的求值顺序。

**注意3**：相等运算符并不总是传递的。例如，可能存在两个不同的字符串对象，每个都表示相同的字符串值；每个字符串对象通过 `==` 运算符与字符串值相比会被认为相等，但这两个字符串对象彼此之间不会相等。例如：

```javascript
new String("a") == "a" 和 "a" == new String("a") 都为 true。
new String("a") == new String("a") 为 false。
```

**注意4**：字符串的比较使用对代码单元值序列的简单相等性测试。不会尝试使用 Unicode 规范中定义的更复杂的字符或字符串相等性定义和排序顺序。因此，根据 Unicode 标准规范化相等的字符串值可能被测试为不相等。实际上，这种算法假定两个字符串已经处于规范化形式。

### 13.12 二进制按位运算符
#### 语法
```javascript
BitwiseANDExpression[In, Yield, Await] :
  EqualityExpression[?In, ?Yield, ?Await]
  BitwiseANDExpression[?In, ?Yield, ?Await] & EqualityExpression[?In, ?Yield, ?Await]

BitwiseXORExpression[In, Yield, Await] :
  BitwiseANDExpression[?In, ?Yield, ?Await]
  BitwiseXORExpression[?In, ?Yield, ?Await] ^ BitwiseANDExpression[?In, ?Yield, ?Await]

BitwiseORExpression[In, Yield, Await] :
  BitwiseXORExpression[?In, ?Yield, ?Await]
  BitwiseORExpression[?In, ?Yield, ?Await] | BitwiseXORExpression[?In, ?Yield, ?Await]
```

#### 13.12.1 运行时语义：求值
```javascript
BitwiseANDExpression : BitwiseANDExpression & EqualityExpression
1. 返回 ? EvaluateStringOrNumericBinaryExpression(BitwiseANDExpression, &, EqualityExpression)。

BitwiseXORExpression : BitwiseXORExpression ^ BitwiseANDExpression
1. 返回 ? EvaluateStringOrNumericBinaryExpression(BitwiseXORExpression, ^, BitwiseANDExpression)。

BitwiseORExpression : BitwiseORExpression | BitwiseXORExpression
1. 返回 ? EvaluateStringOrNumericBinaryExpression(BitwiseORExpression, |, BitwiseXORExpression)。
```

### 13.13 二进制逻辑运算符
#### 语法
```javascript
LogicalANDExpression[In, Yield, Await] :
  BitwiseORExpression[?In, ?Yield, ?Await]
  LogicalANDExpression[?In, ?Yield, ?Await] && BitwiseORExpression[?In, ?Yield, ?Await]

LogicalORExpression[In, Yield, Await] :
  LogicalANDExpression[?In, ?Yield, ?Await]
  LogicalORExpression[?In, ?Yield, ?Await] || LogicalANDExpression[?In, ?Yield, ?Await]

CoalesceExpression[In, Yield, Await] :
  CoalesceExpressionHead[?In, ?Yield, ?Await] ?? BitwiseORExpression[?In, ?Yield, ?Await]

CoalesceExpressionHead[In, Yield, Await] :
  CoalesceExpression[?In, ?Yield, ?Await]
  BitwiseORExpression[?In, ?Yield, ?Await]

ShortCircuitExpression[In, Yield, Await] :
  LogicalORExpression[?In, ?Yield, ?Await]
  CoalesceExpression[?In, ?Yield, ?Await]
```

**注意**：`&&` 或 `||` 运算符生成的值不一定是布尔类型。生成的值总是两个操作数表达式之一的值。

#### 13.13.1 运行时语义：求值
```javascript
LogicalANDExpression : LogicalANDExpression && BitwiseORExpression
1. 令 lref 为 LogicalANDExpression 的 ? Evaluation。
2. 令 lval 为 ? GetValue(lref)。
3. 令 lbool 为 ToBoolean(lval)。
4. 如果 lbool 为 false，返回 lval。
5. 令 rref 为 BitwiseORExpression 的 ? Evaluation。
6. 返回 ? GetValue(rref)。

LogicalORExpression : LogicalORExpression || LogicalANDExpression
1. 令 lref 为 LogicalORExpression 的 ? Evaluation。
2. 令 lval 为 ? GetValue(lref)。
3. 令 lbool 为 ToBoolean(lval)。
4. 如果 lbool 为 true，返回 lval。
5. 令 rref 为 LogicalANDExpression 的 ? Evaluation。
6. 返回 ? GetValue(rref)。

CoalesceExpression : CoalesceExpressionHead ?? BitwiseORExpression
1. 令 lref 为 CoalesceExpressionHead 的 ? Evaluation。
2. 令 lval 为 ? GetValue(lref)。
3. 如果 l

val 为 undefined 或 null，则
  a. 令 rref 为 BitwiseORExpression 的 ? Evaluation。
  b. 返回 ? GetValue(rref)。
4. 否则，
  a. 返回 lval。
```

### 13.14 条件运算符（ `? :` ）
#### 语法
```javascript
ConditionalExpression[In, Yield, Await] :
  ShortCircuitExpression[?In, ?Yield, ?Await]
  ShortCircuitExpression[?In, ?Yield, ?Await] ? AssignmentExpression[+In, ?Yield, ?Await] : AssignmentExpression[?In, ?Yield, ?Await]
```

**注意**：ECMAScript 中的 ConditionalExpression 语法与 C 和 Java 中的稍有不同，后者允许第二个子表达式为 Expression，但限制第三个表达式为 ConditionalExpression。ECMAScript 中的这种差异旨在允许条件表达式的任意一个分支包含赋值表达式，并消除逗号表达式作为中心表达式的困惑和几乎无用的情况。

#### 13.14.1 运行时语义：求值
```javascript
ConditionalExpression : ShortCircuitExpression ? AssignmentExpression : AssignmentExpression
1. 令 lref 为 ShortCircuitExpression 的 ? Evaluation。
2. 令 lval 为 ToBoolean(? GetValue(lref))。
3. 如果 lval 为 true，则
  a. 令 trueRef 为第一个 AssignmentExpression 的 ? Evaluation。
  b. 返回 ? GetValue(trueRef)。
4. 否则，
  a. 令 falseRef 为第二个 AssignmentExpression 的 ? Evaluation。
  b. 返回 ? GetValue(falseRef)。
```

### 13.15 赋值运算符

#### 语法
```javascript
AssignmentExpression[In, Yield, Await] :
  ConditionalExpression[?In, ?Yield, ?Await]
  [+Yield] YieldExpression[?In, ?Await]
  ArrowFunction[?In, ?Yield, ?Await]
  AsyncArrowFunction[?In, ?Yield, ?Await]
  LeftHandSideExpression[?Yield, ?Await] = AssignmentExpression[?In, ?Yield, ?Await]
  LeftHandSideExpression[?Yield, ?Await] AssignmentOperator AssignmentExpression[?In, ?Yield, ?Await]
  LeftHandSideExpression[?Yield, ?Await] &&= AssignmentExpression[?In, ?Yield, ?Await]
  LeftHandSideExpression[?Yield, ?Await] ||= AssignmentExpression[?In, ?Yield, ?Await]
  LeftHandSideExpression[?Yield, ?Await] ??= AssignmentExpression[?In, ?Yield, ?Await]

AssignmentOperator : one of
  *= /= %= += -= <<= >>= >>>= &= ^= |= **=
```

#### 13.15.1 静态语义：早期错误
```javascript
AssignmentExpression : LeftHandSideExpression = AssignmentExpression
如果 LeftHandSideExpression 是 ObjectLiteral 或 ArrayLiteral，则 LeftHandSideExpression 必须覆盖 AssignmentPattern。
如果 LeftHandSideExpression 既不是 ObjectLiteral 也不是 ArrayLiteral，则如果 LeftHandSideExpression 的 AssignmentTargetType 不是 SIMPLE，则这是一个语法错误。

AssignmentExpression :
  LeftHandSideExpression AssignmentOperator AssignmentExpression
  LeftHandSideExpression &&= AssignmentExpression
  LeftHandSideExpression ||= AssignmentExpression
  LeftHandSideExpression ??= AssignmentExpression
如果 LeftHandSideExpression 的 AssignmentTargetType 不是 SIMPLE，则这是一个语法错误。
```

#### 13.15.2 运行时语义：求值
```javascript
AssignmentExpression : LeftHandSideExpression = AssignmentExpression
1. 如果 LeftHandSideExpression 既不是 ObjectLiteral 也不是 ArrayLiteral，则
  a. 令 lref 为 LeftHandSideExpression 的 ? Evaluation。
  b. 如果 IsAnonymousFunctionDefinition(AssignmentExpression) 为 true 且 IsIdentifierRef of LeftHandSideExpression 为 true，则
    i. 令 lhs 为 LeftHandSideExpression 的 StringValue。
    ii. 令 rval 为 NamedEvaluation of AssignmentExpression with argument lhs 的 ? Evaluation。
  c. 否则，
    i. 令 rref 为 AssignmentExpression 的 ? Evaluation。
    ii. 令 rval 为 rref 的 ? GetValue。
  d. 执行 ? PutValue(lref, rval)。
  e. 返回 rval。
2. 令 assignmentPattern 为被 LeftHandSideExpression 覆盖的 AssignmentPattern。
3. 令 rref 为 AssignmentExpression 的 ? Evaluation。
4. 令 rval 为 rref 的 ? GetValue。
5. 执行 ? DestructuringAssignmentEvaluation of assignmentPattern with argument rval。
6. 返回 rval。

AssignmentExpression : LeftHandSideExpression AssignmentOperator AssignmentExpression
1. 令 lref 为 LeftHandSideExpression 的 ? Evaluation。
2. 令 lval 为 lref 的 ? GetValue。
3. 令 rref 为 AssignmentExpression 的 ? Evaluation。
4. 令 rval 为 rref 的 ? GetValue。
5. 令 assignmentOpText 为 AssignmentOperator 匹配的源文本。
6. 令 opText 为与以下表中 assignmentOpText 关联的 Unicode 代码点序列：
```plaintext
assignmentOpText    opText
**=                **
*=                 *
/=                 /
%=                 %
+=                 +
-=                 -
<<=                <<
>>=                >>
>>>=               >>>
&=                 &
^=                 ^
|=                 |
```
7. 令 r 为 ? ApplyStringOrNumericBinaryOperator(lval, opText, rval)。
8. 执行 ? PutValue(lref, r)。
9. 返回 r。

AssignmentExpression : LeftHandSideExpression &&= AssignmentExpression
1. 令 lref 为 LeftHandSideExpression 的 ? Evaluation。
2. 令 lval 为 lref 的 ? GetValue。
3. 令 lbool 为 ToBoolean(lval)。
4. 如果 lbool 为 false，返回 lval。
5. 如果 IsAnonymousFunctionDefinition(AssignmentExpression) 为 true 且 IsIdentifierRef of LeftHandSideExpression 为 true，则
  a. 令 lhs 为 LeftHandSideExpression 的 StringValue。
  b. 令 rval 为 NamedEvaluation of AssignmentExpression with argument lhs 的 ? Evaluation。
6. 否则，
  a. 令 rref 为 AssignmentExpression 的 ? Evaluation。
  b. 令 rval 为 rref 的 ? GetValue。
7. 执行 ? PutValue(lref, rval)。
8. 返回 rval。

AssignmentExpression : LeftHandSideExpression ||= AssignmentExpression
1. 令 lref 为 LeftHandSideExpression 的 ? Evaluation。
2. 令 lval 为 lref 的 ? GetValue。
3. 令 lbool 为 ToBoolean(lval)。
4. 如果 lbool 为 true，返回 lval。
5. 如果 IsAnonymousFunctionDefinition(AssignmentExpression) 为 true 且 IsIdentifierRef of LeftHandSideExpression 为 true，则
  a. 令 lhs 为 LeftHandSideExpression 的 StringValue。
  b. 令 rval 为 NamedEvaluation of AssignmentExpression with argument lhs 的 ? Evaluation。
6. 否则，
  a. 令 rref 为 AssignmentExpression 的 ? Evaluation。
  b. 令 rval 为 rref 的 ? GetValue。
7. 执行 ? PutValue(lref, rval)。
8. 返回 rval。

AssignmentExpression : LeftHandSideExpression ??= AssignmentExpression
1. 令 lref 为 LeftHandSideExpression 的 ? Evaluation。
2. 令 lval 为 lref 的 ? GetValue。
3. 如果 lval 既不是 undefined 也不是 null，返回 lval。
4. 如果 IsAnonymousFunctionDefinition(AssignmentExpression) 为 true 且 IsIdentifierRef of LeftHandSideExpression 为 true，则
  a. 令 lhs 为 LeftHandSideExpression 的 StringValue。
  b. 令 rval 为 NamedEvaluation of AssignmentExpression with argument lhs 的 ? Evaluation。
5. 否则，
  a. 令 rref 为 AssignmentExpression 的 ? Evaluation。
  b. 令 rval 为 rref 的 ? GetValue。
6. 执行 ? PutValue(lref, rval)。
7. 返回 rval。
```

**注意**：当该表达式在严格模式代码中出现时，如果步骤 1.d、2、2、2、2 中的 lref 是一个不可解决的引用，则会发生运行时错误。如果是这样，则抛出 ReferenceError 异常。此外，如果步骤 8、7、7、6 中的 lref 是具有属性值 { [[Writable]]: false } 的数据属性的引用，或具有属性值 { [[Set]]: undefined } 的访问器属性的引用，或者是 IsExtensible 谓词返回值为 false 的对象的不存在属性的引用，则会发生运行时错误。在这些情况下会抛出 TypeError 异常。

#### 13.15.3 ApplyStringOrNumericBinaryOperator ( lval, opText, rval )
```javascript
ApplyStringOrNumericBinaryOperator ( lval, opText, rval )
抽象操作 `ApplyStringOrNumericBinaryOperator` 接受参数 `lval`（一个 ECMAScript 语言值），`opText`（**、*、/、%、+、-、<<、>>、>>>、&、^、| 之一），以及 `rval`（一个 ECMAScript 语言值），并返回一个包含字符串、BigInt 或数字的正常完成，或抛出异常。它在调用时执行以下步骤：

1. 如果 opText 是 +，则
  a. 令 lprim 为 lval 的 ? ToPrimitive。
  b. 令 rprim 为 rval 的 ? ToPrimitive。
  c. 如果 lprim 是字符串或 rprim 是字符串，则
    i. 令 lstr 为 lprim 的 ? ToString。
    ii. 令 rstr 为 rprim 的 ? ToString。
    iii. 返回 lstr 和 rstr 的字符串连接。
  d. 设置 lval 为 lprim。
  e. 设置 rval 为 rprim。
2. **注意**：此时，必须是数值运算。
3. 令 lnum 为 lval 的 ? ToNumeric。
4. 令 rnum 为 rval 的 ? ToNumeric。
5. 如果 lnum 的类型不是 rnum 的类型，则抛出 TypeError 异常。
6. 如果 lnum 是 BigInt，则
  a. 如果 opText 是 **，返回 ? BigInt::exponentiate(lnum, rnum)。
  b. 如果 opText 是 /，返回 ? BigInt::divide(lnum, rnum)。
  c. 如果 opText 是 %，返回 ? BigInt::remainder(lnum, rnum)。
  d. 如果 opText 是 >>>，返回 ? BigInt::unsignedRightShift(lnum, rnum)。
7. 令操作为与下表中 opText 和 lnum 类型关联的抽象操作：
```plaintext
opText	Type(lnum)	operation
**	Number	Number::exponentiate
*	Number	Number::multiply
*	BigInt	BigInt::multiply
/	Number	Number::divide
%	Number	Number::remainder
+	Number	Number::add
+	BigInt	BigInt::add
-	Number	Number::

subtract
-	BigInt	BigInt::subtract
<<	Number	Number::leftShift
<<	BigInt	BigInt::leftShift
>>	Number	Number::signedRightShift
>>	BigInt	BigInt::signedRightShift
>>>	Number	Number::unsignedRightShift
&	Number	Number::bitwiseAND
&	BigInt	BigInt::bitwiseAND
^	Number	Number::bitwiseXOR
^	BigInt	BigInt::bitwiseXOR
|	Number	Number::bitwiseOR
|	BigInt	BigInt::bitwiseOR
```
8. 返回 operation(lnum, rnum)。

**注意 1**：在步骤 1.a 和 1.b 中调用 ToPrimitive 时不提供提示。除了日期外，所有标准对象在没有提示的情况下都像给定 NUMBER 一样处理；日期在没有提示的情况下处理得像给定 STRING 一样。奇异对象可能以其他方式处理提示的缺失。

**注意 2**：步骤 1.c 不同于 IsLessThan 算法的步骤 3，使用逻辑或操作而不是逻辑与操作。

#### 13.15.4 EvaluateStringOrNumericBinaryExpression ( leftOperand, opText, rightOperand )
```javascript
EvaluateStringOrNumericBinaryExpression ( leftOperand, opText, rightOperand )
抽象操作 `EvaluateStringOrNumericBinaryExpression` 接受参数 `leftOperand`（一个 Parse Node）、`opText`（Unicode 代码点序列）和 `rightOperand`（一个 Parse Node），并返回一个包含字符串、BigInt 或数字的正常完成，或中断完成。它在调用时执行以下步骤：

1. 令 lref 为 leftOperand 的 ? Evaluation。
2. 令 lval 为 lref 的 ? GetValue。
3. 令 rref 为 rightOperand 的 ? Evaluation。
4. 令 rval 为 rref 的 ? GetValue。
5. 返回 ? ApplyStringOrNumericBinaryOperator(lval, opText, rval)。
```

#### 13.15.5 解构赋值
补充语法
在某些情况下，当处理以下产生式的一个实例时
```javascript
AssignmentExpression : LeftHandSideExpression = AssignmentExpression
```
对 LeftHandSideExpression 的解释会使用以下语法进行改进：

```javascript
AssignmentPattern[Yield, Await] :
  ObjectAssignmentPattern[?Yield, ?Await]
  ArrayAssignmentPattern[?Yield, ?Await]

ObjectAssignmentPattern[Yield, Await] :
  { }
  { AssignmentRestProperty[?Yield, ?Await] }
  { AssignmentPropertyList[?Yield, ?Await] }
  { AssignmentPropertyList[?Yield, ?Await] , AssignmentRestProperty[?Yield, ?Await]opt }

ArrayAssignmentPattern[Yield, Await] :
  [ Elisionopt AssignmentRestElement[?Yield, ?Await]opt ]
  [ AssignmentElementList[?Yield, ?Await] ]
  [ AssignmentElementList[?Yield, ?Await] , Elisionopt AssignmentRestElement[?Yield, ?Await]opt ]

AssignmentRestProperty[Yield, Await] :
  ... DestructuringAssignmentTarget[?Yield, ?Await]

AssignmentPropertyList[Yield, Await] :
  AssignmentProperty[?Yield, ?Await]
  AssignmentPropertyList[?Yield, ?Await] , AssignmentProperty[?Yield, ?Await]

AssignmentElementList[Yield, Await] :
  AssignmentElisionElement[?Yield, ?Await]
  AssignmentElementList[?Yield, ?Await] , AssignmentElisionElement[?Yield, ?Await]

AssignmentElisionElement[Yield, Await] :
  Elisionopt AssignmentElement[?Yield, ?Await]

AssignmentProperty[Yield, Await] :
  IdentifierReference[?Yield, ?Await] Initializer[+In, ?Yield, ?Await]opt
  PropertyName[?Yield, ?Await] : AssignmentElement[?Yield, ?Await]

AssignmentElement[Yield, Await] :
  DestructuringAssignmentTarget[?Yield, ?Await] Initializer[+In, ?Yield, ?Await]opt

AssignmentRestElement[Yield, Await] :
  ... DestructuringAssignmentTarget[?Yield, ?Await]

DestructuringAssignmentTarget[Yield, Await] :
  LeftHandSideExpression[?Yield, ?Await]
```

##### 13.15.5.1 静态语义：早期错误
```javascript
AssignmentProperty : IdentifierReference Initializeropt
如果 IdentifierReference 的 AssignmentTargetType 不是 SIMPLE，则这是一个语法错误。

AssignmentRestProperty : ... DestructuringAssignmentTarget
如果 DestructuringAssignmentTarget 是 ArrayLiteral 或 ObjectLiteral，则这是一个语法错误。

DestructuringAssignmentTarget : LeftHandSideExpression
如果 LeftHandSideExpression 是 ObjectLiteral 或 ArrayLiteral，则 LeftHandSideExpression 必须覆盖 AssignmentPattern。
如果 LeftHandSideExpression 既不是 ObjectLiteral 也不是 ArrayLiteral，则如果 LeftHandSideExpression 的 AssignmentTargetType 不是 SIMPLE，则这是一个语法错误。
```

##### 13.15.5.2 运行时语义：解构赋值求值
```javascript
ObjectAssignmentPattern : { }
1. 执行 ? RequireObjectCoercible(value)。
2. 返回 UNUSED。

ObjectAssignmentPattern :
  { AssignmentPropertyList }
  { AssignmentPropertyList , }
1. 执行 ? RequireObjectCoercible(value)。
2. 执行 ? PropertyDestructuringAssignmentEvaluation of AssignmentPropertyList with argument value。
3. 返回 UNUSED。

ObjectAssignmentPattern : { AssignmentRestProperty }
1. 执行 ? RequireObjectCoercible(value)。
2. 令 excludedNames 为一个新的空列表。
3. 返回 ? RestDestructuringAssignmentEvaluation of AssignmentRestProperty with arguments value and excludedNames。

ObjectAssignmentPattern : { AssignmentPropertyList , AssignmentRestProperty }
1. 执行 ? RequireObjectCoercible(value)。
2. 令 excludedNames 为 PropertyDestructuringAssignmentEvaluation of AssignmentPropertyList with argument value 的 ? 结果。
3. 返回 ? RestDestructuringAssignmentEvaluation of AssignmentRestProperty with arguments value and excludedNames。

ArrayAssignmentPattern : [ ]
1. 令 iteratorRecord 为 GetIterator(value, SYNC) 的 ? 结果。
2. 返回 IteratorClose(iteratorRecord, NormalCompletion(UNUSED)) 的 ? 结果。

ArrayAssignmentPattern : [ Elision ]
1. 令 iteratorRecord 为 GetIterator(value, SYNC) 的 ? 结果。
2. 令 result 为 Completion(IteratorDestructuringAssignmentEvaluation of Elision with argument iteratorRecord)。
3. 如果 iteratorRecord.[[Done]] 为 false，返回 IteratorClose(iteratorRecord, result) 的 ? 结果。
4. 返回 result。

ArrayAssignmentPattern : [ Elisionopt AssignmentRestElement ]
1. 令 iteratorRecord 为 GetIterator(value, SYNC) 的 ? 结果。
2. 如果 Elision 存在，则
  a. 令 status 为 Completion(IteratorDestructuringAssignmentEvaluation of Elision with argument iteratorRecord)。
  b. 如果 status 是一个突发完成，
    i. 断言：iteratorRecord.[[Done]] 为 true。
    ii. 返回 ? status。
3. 令 result 为 Completion(IteratorDestructuringAssignmentEvaluation of AssignmentRestElement with argument iteratorRecord)。
4. 如果 iteratorRecord.[[Done]] 为 false，返回 IteratorClose(iteratorRecord, result) 的 ? 结果。
5. 返回 result。

ArrayAssignmentPattern : [ AssignmentElementList ]
1. 令 iteratorRecord 为 GetIterator(value, SYNC) 的 ? 结果。
2. 令 result 为 Completion(IteratorDestructuringAssignmentEvaluation of AssignmentElementList with argument iteratorRecord)。
3. 如果 iteratorRecord.[[Done]] 为 false，返回 IteratorClose(iteratorRecord, result) 的 ? 结果。
4. 返回 result。

ArrayAssignmentPattern : [ AssignmentElementList , Elisionopt AssignmentRestElementopt ]
1. 令 iteratorRecord 为 GetIterator(value, SYNC) 的 ? 结果。
2. 令 status 为 Completion(IteratorDestructuringAssignmentEvaluation of AssignmentElementList with argument iteratorRecord)。
3. 如果 status 是一个突发完成，
  a. 如果 iteratorRecord.[[Done]] 为 false，返回 IteratorClose(iteratorRecord, status) 的 ? 结果。
  b. 返回 ? status。
4. 如果 Elision 存在，则
  a. 设置 status 为 Completion(IteratorDestructuringAssignmentEvaluation of Elision with argument iteratorRecord)。
  b. 如果 status 是一个突发完成，
    i. 断言：iteratorRecord.[[Done]] 为 true。
    ii. 返回 ? status。
5. 如果 AssignmentRestElement 存在，则
  a. 设置 status 为 Completion(IteratorDestructuringAssignmentEvaluation of AssignmentRestElement with argument iteratorRecord)。
6. 如果 iteratorRecord.[[Done]] 为 false，返回 IteratorClose(iteratorRecord, status) 的 ? 结果。
7. 返回 ? status。
```

##### 13.15.5.3 运行时语义：PropertyDestructuringAssignmentEvaluation
```javascript
PropertyDestructuringAssignmentEvaluation ( value )
语法导向操作 `PropertyDestructuringAssignmentEvaluation` 接受参数 value（一个 ECMAScript 语言值），并返回包含属性键列表的正常完成，或中断完成。它收集所有解构属性键的列表。根据以下产生式分段定义：

AssignmentPropertyList : AssignmentPropertyList , AssignmentProperty
1. 令 propertyNames 为 PropertyDestructuringAssignmentEvaluation of AssignmentPropertyList with argument value 的 ? 结果。
2. 令 nextNames 为 PropertyDestructuringAssignmentEvaluation of AssignmentProperty with

 argument value 的 ? 结果。
3. 返回 propertyNames 和 nextNames 的列表连接。

AssignmentProperty : IdentifierReference Initializeropt
1. 令 P 为 IdentifierReference 的 StringValue。
2. 令 lref 为 ResolveBinding(P) 的 ? 结果。
3. 令 v 为 GetV(value, P) 的 ? 结果。
4. 如果 Initializer 存在且 v 为 undefined，则
  a. 如果 IsAnonymousFunctionDefinition(Initializer) 为 true，则
    i. 设置 v 为 NamedEvaluation of Initializer with argument P 的 ? 结果。
  b. 否则，
    i. 令 defaultValue 为 Initializer 的 ? Evaluation。
    ii. 设置 v 为 defaultValue 的 ? GetValue。
5. 执行 ? PutValue(lref, v)。
6. 返回 « P »。

AssignmentProperty : PropertyName : AssignmentElement
1. 令 name 为 PropertyName 的 ? Evaluation。
2. 执行 ? KeyedDestructuringAssignmentEvaluation of AssignmentElement with arguments value and name。
3. 返回 « name »。
```

##### 13.15.5.4 运行时语义：RestDestructuringAssignmentEvaluation
```javascript
RestDestructuringAssignmentEvaluation ( value, excludedNames )
语法导向操作 `RestDestructuringAssignmentEvaluation` 接受参数 value（一个 ECMAScript 语言值）和 excludedNames（属性键列表），并返回包含 UNUSED 的正常完成，或中断完成。根据以下产生式分段定义：

AssignmentRestProperty : ... DestructuringAssignmentTarget
1. 令 lref 为 DestructuringAssignmentTarget 的 ? Evaluation。
2. 令 restObj 为 OrdinaryObjectCreate(%Object.prototype%)。
3. 执行 ? CopyDataProperties(restObj, value, excludedNames)。
4. 返回 ? PutValue(lref, restObj)。
```

##### 13.15.5.5 运行时语义：IteratorDestructuringAssignmentEvaluation
```javascript
IteratorDestructuringAssignmentEvaluation ( iteratorRecord )
语法导向操作 `IteratorDestructuringAssignmentEvaluation` 接受参数 iteratorRecord（一个迭代器记录），并返回包含 UNUSED 的正常完成，或中断完成。根据以下产生式分段定义：

AssignmentElementList : AssignmentElisionElement
1. 返回 IteratorDestructuringAssignmentEvaluation of AssignmentElisionElement with argument iteratorRecord 的 ? 结果。

AssignmentElementList : AssignmentElementList , AssignmentElisionElement
1. 执行 IteratorDestructuringAssignmentEvaluation of AssignmentElementList with argument iteratorRecord 的 ? 结果。
2. 返回 IteratorDestructuringAssignmentEvaluation of AssignmentElisionElement with argument iteratorRecord 的 ? 结果。

AssignmentElisionElement : AssignmentElement
1. 返回 IteratorDestructuringAssignmentEvaluation of AssignmentElement with argument iteratorRecord 的 ? 结果。

AssignmentElisionElement : Elision AssignmentElement
1. 执行 IteratorDestructuringAssignmentEvaluation of Elision with argument iteratorRecord 的 ? 结果。
2. 返回 IteratorDestructuringAssignmentEvaluation of AssignmentElement with argument iteratorRecord 的 ? 结果。

Elision : ,
1. 如果 iteratorRecord.[[Done]] 为 false，则
  a. 执行 IteratorStep(iteratorRecord) 的 ? 结果。
2. 返回 UNUSED。

Elision : Elision ,
1. 执行 IteratorDestructuringAssignmentEvaluation of Elision with argument iteratorRecord 的 ? 结果。
2. 如果 iteratorRecord.[[Done]] 为 false，则
  a. 执行 IteratorStep(iteratorRecord) 的 ? 结果。
3. 返回 UNUSED。

AssignmentElement : DestructuringAssignmentTarget Initializeropt
1. 如果 DestructuringAssignmentTarget 既不是 ObjectLiteral 也不是 ArrayLiteral，则
  a. 令 lref 为 DestructuringAssignmentTarget 的 ? Evaluation。
2. 令 value 为 undefined。
3. 如果 iteratorRecord.[[Done]] 为 false，则
  a. 令 next 为 IteratorStepValue(iteratorRecord) 的 ? 结果。
  b. 如果 next 不是 DONE，则
    i. 设置 value 为 next。
4. 如果 Initializer 存在且 value 为 undefined，则
  a. 如果 IsAnonymousFunctionDefinition(Initializer) 为 true 且 IsIdentifierRef of DestructuringAssignmentTarget 为 true，则
    i. 令 target 为 DestructuringAssignmentTarget 的 StringValue。
    ii. 令 v 为 NamedEvaluation of Initializer with argument target 的 ? 结果。
  b. 否则，
    i. 令 defaultValue 为 Initializer 的 ? Evaluation。
    ii. 令 v 为 defaultValue 的 ? GetValue。
5. 否则，
  a. 令 v 为 value。
6. 如果 DestructuringAssignmentTarget 是 ObjectLiteral 或 ArrayLiteral，则
  a. 令 nestedAssignmentPattern 为被 DestructuringAssignmentTarget 覆盖的 AssignmentPattern。
  b. 返回 DestructuringAssignmentEvaluation of nestedAssignmentPattern with argument v 的 ? 结果。
7. 返回 ? PutValue(lref, v)。

**注意**：从左到右的求值顺序通过在访问迭代器或求值 Initializer 之前求值一个不是解构模式的 DestructuringAssignmentTarget 来维护。

AssignmentRestElement : ... DestructuringAssignmentTarget
1. 如果 DestructuringAssignmentTarget 既不是 ObjectLiteral 也不是 ArrayLiteral，则
  a. 令 lref 为 DestructuringAssignmentTarget 的 ? Evaluation。
2. 令 A 为 ! ArrayCreate(0)。
3. 令 n 为 0。
4. 重复，直到 iteratorRecord.[[Done]] 为 false，
  a. 令 next 为 IteratorStepValue(iteratorRecord) 的 ? 结果。
  b. 如果 next 不是 DONE，则
    i. 执行 ! CreateDataPropertyOrThrow(A, ! ToString(𝔽(n)), next)。
    ii. 设置 n 为 n + 1。
5. 如果 DestructuringAssignmentTarget 既不是 ObjectLiteral 也不是 ArrayLiteral，则
  a. 返回 ? PutValue(lref, A)。
6. 令 nestedAssignmentPattern 为被 DestructuringAssignmentTarget 覆盖的 AssignmentPattern。
7. 返回 DestructuringAssignmentEvaluation of nestedAssignmentPattern with argument A 的 ? 结果。
```

##### 13.15.5.6 运行时语义：KeyedDestructuringAssignmentEvaluation
```javascript
KeyedDestructuringAssignmentEvaluation ( value, propertyName )
语法导向操作 `KeyedDestructuringAssignmentEvaluation` 接受参数 value（一个 ECMAScript 语言值）和 propertyName（一个属性键），并返回包含 UNUSED 的正常完成，或中断完成。根据以下产生式分段定义：

AssignmentElement : DestructuringAssignmentTarget Initializeropt
1. 如果 DestructuringAssignmentTarget 既不是 ObjectLiteral 也不是 ArrayLiteral，则
  a. 令 lref 为 DestructuringAssignmentTarget 的 ? Evaluation。
2. 令 v 为 GetV(value, propertyName) 的 ? 结果。
3. 如果 Initializer 存在且 v 为 undefined，则
  a. 如果 IsAnonymousFunctionDefinition(Initializer) 为 true 且 IsIdentifierRef of DestructuringAssignmentTarget 为 true，则
    i. 令 target 为 DestructuringAssignmentTarget 的 StringValue。
    ii. 令 rhsValue 为 NamedEvaluation of Initializer with argument target 的 ? 结果。
  b. 否则，
    i. 令 defaultValue 为 Initializer 的 ? Evaluation。
    ii. 令 rhsValue 为 defaultValue 的 ? GetValue。
4. 否则，
  a. 令 rhsValue 为 v。
5. 如果 DestructuringAssignmentTarget 是 ObjectLiteral 或 ArrayLiteral，则
  a. 令 assignmentPattern 为被 DestructuringAssignmentTarget 覆盖的 AssignmentPattern。
  b. 返回 DestructuringAssignmentEvaluation of assignmentPattern with argument rhsValue 的 ? 结果。
6. 返回 ? PutValue(lref, rhsValue)。
```

### 13.16 逗号运算符 ( , )

#### 语法
```javascript
Expression[In, Yield, Await] :
  AssignmentExpression[?In, ?Yield, ?Await]
  Expression[?In, ?Yield, ?Await] , AssignmentExpression[?In, ?Yield, ?Await]
```

#### 13.16.1 运行时语义：求值
```javascript
Expression : Expression , AssignmentExpression
1. 令 lref 为 Expression 的 ? Evaluation。
2. 执行 lref 的 ? GetValue。
3. 令 rref 为 AssignmentExpression 的 ? Evaluation。
4. 返回 rref 的 ? GetValue。

**注意**：必须调用 GetValue，即使其值未被使用，因为它可能具有可观察的副作用。
```

### 14 ECMAScript 语言：语句和声明

#### 语法
```javascript
Statement[Yield, Await, Return] :
  BlockStatement[?Yield, ?Await, ?Return]
  VariableStatement[?Yield, ?Await]
  EmptyStatement
  ExpressionStatement[?Yield, ?Await]
  IfStatement[?Yield, ?Await, ?Return]
  BreakableStatement[?Yield, ?Await, ?Return]
  ContinueStatement[?Yield, ?Await]
  BreakStatement[?Yield, ?Await]
  [+Return] ReturnStatement[?Yield, ?Await]
  WithStatement[?Yield, ?Await, ?Return]
  LabelledStatement[?Yield, ?Await, ?Return]
  ThrowStatement[?Yield, ?Await]
  TryStatement[?Yield, ?Await, ?Return]
  DebuggerStatement
Declaration[Yield, Await] :
  HoistableDeclaration[?Yield, ?Await, ~Default]
  ClassDeclaration[?Yield, ?Await, ~Default]
  LexicalDeclaration[+In, ?Yield, ?Await]
HoistableDeclaration[Yield, Await, Default] :
  FunctionDeclaration[?Yield, ?Await, ?Default]
  GeneratorDeclaration[?Yield, ?Await, ?Default]
  AsyncFunctionDeclaration[?Yield, ?Await, ?Default]
  AsyncGeneratorDeclaration[?Yield, ?Await, ?Default]
BreakableStatement[Yield, Await, Return] :
  IterationStatement[?Yield, ?Await, ?Return]
  SwitchStatement[?Yield, ?Await, ?Return]
```

#### 14.1 语句语义

##### 14.1.1 运行时语义：求值

**HoistableDeclaration** : GeneratorDeclaration / AsyncFunctionDeclaration / AsyncGeneratorDeclaration
1. 返回 EMPTY。

**HoistableDeclaration** : FunctionDeclaration
1. 返回 FunctionDeclaration 的 ? 求值结果。

**BreakableStatement** : IterationStatement / SwitchStatement
1. 令 newLabelSet 为一个新的空列表。
2. 返回带有 newLabelSet 参数的此 BreakableStatement 的 ? LabelledEvaluation 结果。

#### 14.2 代码块

##### 语法
```javascript
BlockStatement[Yield, Await, Return] :
  Block[?Yield, ?Await, ?Return]

Block[Yield, Await, Return] :
  { StatementList[?Yield, ?Await, ?Return]opt }

StatementList[Yield, Await, Return] :
  StatementListItem[?Yield, ?Await, ?Return]
  StatementList[?Yield, ?Await, ?Return] StatementListItem[?Yield, ?Await, ?Return]

StatementListItem[Yield, Await, Return] :
  Statement[?Yield, ?Await, ?Return]
  Declaration[?Yield, ?Await]
```

##### 14.2.1 静态语义：早期错误
**Block** : { **StatementList** }
- 如果 StatementList 的 LexicallyDeclaredNames 包含任何重复条目，则为语法错误。
- 如果 StatementList 的 LexicallyDeclaredNames 中的任何元素也出现在 StatementList 的 VarDeclaredNames 中，则为语法错误。

##### 14.2.2 运行时语义：求值
**Block** : { }
1. 返回 EMPTY。

**Block** : { **StatementList** }
1. 令 oldEnv 为运行执行上下文的 LexicalEnvironment。
2. 令 blockEnv 为 NewDeclarativeEnvironment(oldEnv)。
3. 执行 BlockDeclarationInstantiation(StatementList, blockEnv)。
4. 将运行执行上下文的 LexicalEnvironment 设置为 blockEnv。
5. 令 blockValue 为 Completion(Evaluation of StatementList)。
6. 将运行执行上下文的 LexicalEnvironment 设置回 oldEnv。
7. 返回 ? blockValue。

**注意1**：无论如何控制离开 Block，LexicalEnvironment 总是恢复到其原始状态。

**StatementList** : StatementList StatementListItem
1. 令 sl 为 StatementList 的 ? 求值结果。
2. 令 s 为 StatementListItem 的 Completion(Evaluation) 结果。
3. 返回 ? UpdateEmpty(s, sl)。

**注意2**：StatementList 的值是 StatementList 中最后一个值产生项的值。例如，以下对 eval 函数的调用都返回值 1：

```javascript
eval("1;;;;;")
eval("1;{}")
eval("1;var a;")
```

##### 14.2.3 BlockDeclarationInstantiation (code, env)
抽象操作 BlockDeclarationInstantiation 接受参数 code（一个解析节点）和 env（一个声明环境记录）并返回 UNUSED。code 是对应块体的解析节点。env 是要创建绑定的环境记录。

**注意**：当评估 Block 或 CaseBlock 时，会创建一个新的声明环境记录，并在环境记录中实例化每个块作用域变量、常量、函数或类的绑定。

调用时执行以下步骤：
1. 令 declarations 为 code 的 LexicallyScopedDeclarations。
2. 令 privateEnv 为运行执行上下文的 PrivateEnvironment。
3. 对于 declarations 中的每个元素 d，
  a. 对于 d 的 BoundNames 中的每个元素 dn，
    i. 如果 d 的 IsConstantDeclaration 为 true，
      1. 执行 ! env.CreateImmutableBinding(dn, true)。
    ii. 否则，
      1. 执行 ! env.CreateMutableBinding(dn, false)。**注意**：此步骤在 B.3.2.6 节中被替换。
  b. 如果 d 是 FunctionDeclaration、GeneratorDeclaration、AsyncFunctionDeclaration 或 AsyncGeneratorDeclaration，
    i. 令 fn 为 d 的 BoundNames 的唯一元素。
    ii. 令 fo 为 d 的 InstantiateFunctionObject 结果，参数为 env 和 privateEnv。
    iii. 执行 ! env.InitializeBinding(fn, fo)。**注意**：此步骤在 B.3.2.6 节中被替换。
4. 返回 UNUSED。

#### 14.3 声明和变量声明

##### 14.3.1 let 和 const 声明

**注意**：let 和 const 声明定义的变量作用域为运行执行上下文的 LexicalEnvironment。这些变量在其包含的环境记录实例化时被创建，但在其 LexicalBinding 求值之前不能以任何方式访问。由带有 Initializer 的 LexicalBinding 定义的变量在 LexicalBinding 求值时被赋值为 Initializer 的 AssignmentExpression 的值，而不是在变量创建时。如果 let 声明中的 LexicalBinding 没有 Initializer，则在 LexicalBinding 求值时变量被赋值为 undefined。

##### 语法
```javascript
LexicalDeclaration[In, Yield, Await] :
  LetOrConst BindingList[?In, ?Yield, ?Await] ;

LetOrConst :
  let
  const

BindingList[In, Yield, Await] :
  LexicalBinding[?In, ?Yield, ?Await]
  BindingList[?In, ?Yield, ?Await] , LexicalBinding[?In, ?Yield, ?Await]

LexicalBinding[In, Yield, Await] :
  BindingIdentifier[?Yield, ?Await] Initializer[?In, ?Yield, ?Await]opt
  BindingPattern[?Yield, ?Await] Initializer[?In, ?Yield, ?Await]
```

##### 14.3.1.1 静态语义：早期错误
**LexicalDeclaration** : LetOrConst BindingList ;
- 如果 BindingList 的 BoundNames 包含 "let"，则为语法错误。
- 如果 BindingList 的 BoundNames 包含任何重复条目，则为语法错误。

**LexicalBinding** : BindingIdentifier Initializeropt
- 如果 Initializer 不存在且包含此 LexicalBinding 的 LexicalDeclaration 的 IsConstantDeclaration 为 true，则为语法错误。

##### 14.3.1.2 运行时语义：求值
**LexicalDeclaration** : LetOrConst BindingList ;
1. 执行 BindingList 的 ? 求值。
2. 返回 EMPTY。

**BindingList** : BindingList , LexicalBinding
1. 执行 BindingList 的 ? 求值。
2. 返回 LexicalBinding 的 ? 求值结果。

**LexicalBinding** : BindingIdentifier
1. 令 lhs 为 BindingIdentifier 的 StringValue 的 ! ResolveBinding 结果。
2. 执行 ! InitializeReferencedBinding(lhs, undefined)。
3. 返回 EMPTY。

**注意**：静态语义规则确保此形式的 LexicalBinding 不会出现在 const 声明中。

**LexicalBinding** : BindingIdentifier Initializer
1. 令 bindingId 为 BindingIdentifier 的 StringValue。
2. 令 lhs 为 bindingId 的 ! ResolveBinding 结果。
3. 如果 Initializer 的 IsAnonymousFunctionDefinition 为 true，
  a. 令 value 为 bindingId 参数的 Initializer 的 ? NamedEvaluation 结果。
4. 否则，
  a. 令 rhs 为 Initializer 的 ? 求值结果。
  b. 令 value 为 rhs 的 ? GetValue 结果。
5. 执行 ! InitializeReferencedBinding(lhs, value)。
6. 返回 EMPTY。

**LexicalBinding** : BindingPattern Initializer
1. 令 rhs 为 Initializer 的 ? 求值结果。
2. 令 value 为 rhs 的 ? GetValue 结果。
3. 令 env 为运行执行上下文的 LexicalEnvironment。
4. 返回 BindingPattern 的 BindingInitialization

，参数为 value 和 env。

##### 14.3.2 变量声明

**注意**：var 声明定义的变量作用域为运行执行上下文的 VariableEnvironment。Var 变量在其包含的环境记录实例化时被创建，并在创建时初始化为 undefined。在任何 VariableEnvironment 范围内，VariableDeclaration 中的通用 BindingIdentifier 可能会出现多次，但这些声明只定义一个变量。由带有 Initializer 的 VariableDeclaration 定义的变量在 VariableDeclaration 执行时被赋值为 Initializer 的 AssignmentExpression 的值，而不是在变量创建时。

##### 语法
```javascript
VariableStatement[Yield, Await] :
  var VariableDeclarationList[+In, ?Yield, ?Await] ;

VariableDeclarationList[In, Yield, Await] :
  VariableDeclaration[?In, ?Yield, ?Await]
  VariableDeclarationList[?In, ?Yield, ?Await] , VariableDeclaration[?In, ?Yield, ?Await]

VariableDeclaration[In, Yield, Await] :
  BindingIdentifier[?Yield, ?Await] Initializer[?In, ?Yield, ?Await]opt
  BindingPattern[?Yield, ?Await] Initializer[?In, ?Yield, ?Await]
```

##### 14.3.2.1 运行时语义：求值
**VariableStatement** : var **VariableDeclarationList** ;
1. 执行 VariableDeclarationList 的 ? 求值。
2. 返回 EMPTY。

**VariableDeclarationList** : VariableDeclarationList , **VariableDeclaration**
1. 执行 VariableDeclarationList 的 ? 求值。
2. 返回 VariableDeclaration 的 ? 求值结果。

**VariableDeclaration** : BindingIdentifier
1. 返回 EMPTY。

**VariableDeclaration** : BindingIdentifier Initializer
1. 令 bindingId 为 BindingIdentifier 的 StringValue。
2. 令 lhs 为 bindingId 的 ? ResolveBinding 结果。
3. 如果 Initializer 的 IsAnonymousFunctionDefinition 为 true，
  a. 令 value 为 bindingId 参数的 Initializer 的 ? NamedEvaluation 结果。
4. 否则，
  a. 令 rhs 为 Initializer 的 ? 求值结果。
  b. 令 value 为 rhs 的 ? GetValue 结果。
5. 执行 ? PutValue(lhs, value)。
6. 返回 EMPTY。

**注意**：如果 VariableDeclaration 嵌套在 with 语句中且 VariableDeclaration 中的 BindingIdentifier 与 with 语句的对象环境记录的绑定对象的属性名相同，则第 5 步将为属性赋值，而不是为 Identifier 的 VariableEnvironment 绑定赋值。

**VariableDeclaration** : BindingPattern Initializer
1. 令 rhs 为 Initializer 的 ? 求值结果。
2. 令 rval 为 rhs 的 ? GetValue 结果。
3. 返回 BindingPattern 的 BindingInitialization，参数为 rval 和 undefined。

##### 14.3.3 解构绑定模式

##### 语法
```javascript
BindingPattern[Yield, Await] :
  ObjectBindingPattern[?Yield, ?Await]
  ArrayBindingPattern[?Yield, ?Await]

ObjectBindingPattern[Yield, Await] :
  { }
  { BindingRestProperty[?Yield, ?Await] }
  { BindingPropertyList[?Yield, ?Await] }
  { BindingPropertyList[?Yield, ?Await] , BindingRestProperty[?Yield, ?Await]opt }

ArrayBindingPattern[Yield, Await] :
  [ Elisionopt BindingRestElement[?Yield, ?Await]opt ]
  [ BindingElementList[?Yield, ?Await] ]
  [ BindingElementList[?Yield, ?Await] , Elisionopt BindingRestElement[?Yield, ?Await]opt ]

BindingRestProperty[Yield, Await] :
  ... BindingIdentifier[?Yield, ?Await]

BindingPropertyList[Yield, Await] :
  BindingProperty[?Yield, ?Await]
  BindingPropertyList[?Yield, ?Await] , BindingProperty[?Yield, ?Await]

BindingElementList[Yield, Await] :
  BindingElisionElement[?Yield, ?Await]
  BindingElementList[?Yield, ?Await] , BindingElisionElement[?Yield, ?Await]

BindingElisionElement[Yield, Await] :
  Elisionopt BindingElement[?Yield, ?Await]

BindingProperty[Yield, Await] :
  SingleNameBinding[?Yield, ?Await]
  PropertyName[?Yield, ?Await] : BindingElement[?Yield, ?Await]

BindingElement[Yield, Await] :
  SingleNameBinding[?Yield, ?Await]
  BindingPattern[?Yield, ?Await] Initializer[+In, ?Yield, ?Await]opt

SingleNameBinding[Yield, Await] :
  BindingIdentifier[?Yield, ?Await] Initializer[+In, ?Yield, ?Await]opt

BindingRestElement[Yield, Await] :
  ... BindingIdentifier[?Yield, ?Await]
  ... BindingPattern[?Yield, ?Await]
```

##### 14.3.3.1 运行时语义：属性绑定初始化

语法定向操作 PropertyBindingInitialization 接受参数 value（一个 ECMAScript 语言值）和 environment（一个环境记录或 undefined），返回包含属性键列表的正常完成或突发完成。它收集所有绑定属性名的列表。它在以下规则中分段定义：

**BindingPropertyList** : BindingPropertyList , **BindingProperty**
1. 令 boundNames 为 PropertyBindingInitialization，参数为 value 和 environment 的 ? 求值结果。
2. 令 nextNames 为 BindingProperty，参数为 value 和 environment 的 ? 求值结果。
3. 返回 boundNames 和 nextNames 的列表连接。

**BindingProperty** : SingleNameBinding
1. 令 name 为 SingleNameBinding 的 BoundNames 唯一元素。
2. 执行 KeyedBindingInitialization，参数为 value，environment 和 name 的 ? 求值结果。
3. 返回 « name »。

**BindingProperty** : PropertyName : **BindingElement**
1. 令 P 为 PropertyName 的 ? 求值结果。
2. 执行 KeyedBindingInitialization，参数为 value，environment 和 P 的 ? 求值结果。
3. 返回 « P »。

##### 14.3.3.2 运行时语义：剩余绑定初始化

语法定向操作 RestBindingInitialization 接受参数 value（一个 ECMAScript 语言值），environment（一个环境记录或 undefined）和 excludedNames（一个属性键列表），返回包含 UNUSED 的正常完成或突发完成。它在以下规则中分段定义：

**BindingRestProperty** : ... BindingIdentifier
1. 令 lhs 为 StringValue of BindingIdentifier 的 ? ResolveBinding 结果。
2. 令 restObj 为 OrdinaryObjectCreate(%Object.prototype%)。
3. 执行 CopyDataProperties(restObj, value, excludedNames) 的 ? 求值结果。
4. 如果 environment 是 undefined，则返回 PutValue(lhs, restObj) 的 ? 求值结果。
5. 返回 InitializeReferencedBinding(lhs, restObj) 的 ? 求值结果。

##### 14.3.3.3 运行时语义：键绑定初始化

语法定向操作 KeyedBindingInitialization 接受参数 value（一个 ECMAScript 语言值），environment（一个环境记录或 undefined）和 propertyName（一个属性键），返回包含 UNUSED 的正常完成或突发完成。

**注意**：undefined 作为 environment 传递时表示应该使用 PutValue 操作分配初始化值。对于 var 语句和某些非严格函数的形式参数列表（见 10.2.11），这种情况会发生。在这些情况下，在评估初始化器之前会提升和预初始化词法绑定。

它在以下规则中分段定义：

**BindingElement** : BindingPattern Initializeropt
1. 令 v 为 GetV(value, propertyName) 的 ? 求值结果。
2. 如果 Initializer 存在且 v 是 undefined，
  a. 令 defaultValue 为 Initializer 的 ? 求值结果。
  b. 令 v 为 defaultValue 的 ? GetValue 结果。
3. 返回 BindingPattern 的 BindingInitialization，参数为 v 和 environment 的 ? 求值结果。

**SingleNameBinding** : BindingIdentifier Initializeropt
1. 令 bindingId 为 BindingIdentifier 的 StringValue。
2. 令 lhs 为 bindingId，environment 的 ? ResolveBinding 结果。
3. 令 v 为 GetV(value, propertyName) 的 ? 求值结果。
4. 如果 Initializer 存在且 v 是 undefined，
  a. 如果 Initializer 的 IsAnonymousFunctionDefinition 为 true，
    i. 令 v 为 bindingId 参数的 Initializer 的 ? NamedEvaluation 结果。
  b. 否则，
    i. 令 defaultValue 为 Initializer 的 ? 求值结果。
    ii. 令 v 为 defaultValue 的 ? GetValue 结果。
5. 如果 environment 是 undefined，则返回 PutValue(lhs, v) 的 ? 求值结果。
6. 返回 InitializeReferencedBinding(lhs, v) 的 ? 求值结果。

#### 14.4 空语句

##### 语法
```javascript
EmptyStatement :
  ;
```

##### 14.4.1 运行时语义：求值
**EmptyStatement** : ;
1. 返回 EMPTY。

#### 14.5 表达式语句

##### 语法
```javascript
ExpressionStatement[Yield, Await] :
  [lookahead ∉ { {, function, async [no LineTerminator here] function, class, let [ }] Expression[+In, ?Yield, ?Await

] ;
```

**注意**：表达式语句不能以 U+007B（左花括号）开头，因为这可能会使其与 Block 模糊不清。表达式语句不能以 function 或 class 关键字开头，因为这会使其与 FunctionDeclaration、GeneratorDeclaration 或 ClassDeclaration 模糊不清。表达式语句不能以 async function 开头，因为这会使其与 AsyncFunctionDeclaration 或 AsyncGeneratorDeclaration 模糊不清。表达式语句不能以 let [ 开头，因为这会使其与以 ArrayBindingPattern 开头的 let LexicalDeclaration 模糊不清。

##### 14.5.1 运行时语义：求值
**ExpressionStatement** : Expression ;
1. 令 exprRef 为 Expression 的 ? 求值结果。
2. 返回 exprRef 的 ? GetValue 结果。

#### 14.6 if 语句

##### 语法
```javascript
IfStatement[Yield, Await, Return] :
  if ( Expression[+In, ?Yield, ?Await] ) Statement[?Yield, ?Await, ?Return] else Statement[?Yield, ?Await, ?Return]
  if ( Expression[+In, ?Yield, ?Await] ) Statement[?Yield, ?Await, ?Return] [lookahead ≠ else]
```

**注意**：lookahead-restriction [lookahead ≠ else] 以通常方式解决了经典的“悬挂 else”问题。即，当关联的 if 的选择具有歧义时，else 与最近的（最内层的）候选 if 关联。

##### 14.6.1 静态语义：早期错误
**IfStatement** : if ( **Expression** ) **Statement** else **Statement**
- 如果第一个 Statement 的 IsLabelledFunction 为 true，则为语法错误。
- 如果第二个 Statement 的 IsLabelledFunction 为 true，则为语法错误。

**IfStatement** : if ( **Expression** ) **Statement**
- 如果 Statement 的 IsLabelledFunction 为 true，则为语法错误。

**注意**：仅在实现了 B.3.1 中指定的扩展时才需要应用此规则。

##### 14.6.2 运行时语义：求值
**IfStatement** : if ( **Expression** ) **Statement** else **Statement**
1. 令 exprRef 为 Expression 的 ? 求值结果。
2. 令 exprValue 为 ToBoolean(? GetValue(exprRef))。
3. 如果 exprValue 为 true，
  a. 令 stmtCompletion 为第一个 Statement 的 Completion(Evaluation) 结果。
4. 否则，
  a. 令 stmtCompletion 为第二个 Statement 的 Completion(Evaluation) 结果。
5. 返回 ? UpdateEmpty(stmtCompletion, undefined)。

**IfStatement** : if ( **Expression** ) **Statement**
1. 令 exprRef 为 Expression 的 ? 求值结果。
2. 令 exprValue 为 ToBoolean(? GetValue(exprRef))。
3. 如果 exprValue 为 false，
  a. 返回 undefined。
4. 否则，
  a. 令 stmtCompletion 为 Statement 的 Completion(Evaluation) 结果。
  b. 返回 ? UpdateEmpty(stmtCompletion, undefined)。

#### 14.7 迭代语句

##### 语法
```javascript
IterationStatement[Yield, Await, Return] :
  DoWhileStatement[?Yield, ?Await, ?Return]
  WhileStatement[?Yield, ?Await, ?Return]
  ForStatement[?Yield, ?Await, ?Return]
  ForInOfStatement[?Yield, ?Await, ?Return]
```

##### 14.7.1 语义

###### 14.7.1.1 LoopContinues (completion, labelSet)
抽象操作 LoopContinues 接受参数 completion（一个完成记录）和 labelSet（一个字符串列表），返回布尔值。调用时执行以下步骤：

1. 如果 completion 是正常完成，返回 true。
2. 如果 completion 不是继续完成，返回 false。
3. 如果 completion.[[Target]] 是 EMPTY，返回 true。
4. 如果 labelSet 包含 completion.[[Target]]，返回 true。
5. 返回 false。

**注意**：在 IterationStatement 的 Statement 部分内，可以使用 ContinueStatement 开始新的迭代。

###### 14.7.1.2 运行时语义：LoopEvaluation
语法定向操作 LoopEvaluation 接受参数 labelSet（一个字符串列表），返回包含 ECMAScript 语言值的正常完成或突发完成。它在以下规则中分段定义：

**IterationStatement** : DoWhileStatement
1. 返回 DoWhileStatement 带有 labelSet 参数的 DoWhileLoopEvaluation 结果。

**IterationStatement** : WhileStatement
1. 返回 WhileStatement 带有 labelSet 参数的 WhileLoopEvaluation 结果。

**IterationStatement** : ForStatement
1. 返回 ForStatement 带有 labelSet 参数的 ForLoopEvaluation 结果。

**IterationStatement** : ForInOfStatement
1. 返回 ForInOfStatement 带有 labelSet 参数的 ForInOfLoopEvaluation 结果。

#### 14.7.2 do-while 语句

##### 语法
```javascript
DoWhileStatement[Yield, Await, Return] :
  do Statement[?Yield, ?Await, ?Return] while ( Expression[+In, ?Yield, ?Await] ) ;
```

##### 14.7.2.1 静态语义：早期错误
**DoWhileStatement** : do **Statement** while (**Expression**) ;
- 如果 Statement 的 IsLabelledFunction 为 true，则为语法错误。

**注意**：仅在实现了 B.3.1 中指定的扩展时才需要应用此规则。

##### 14.7.2.2 运行时语义：DoWhileLoopEvaluation
语法定向操作 DoWhileLoopEvaluation 接受参数 labelSet（一个字符串列表），返回包含 ECMAScript 语言值的正常完成或突发完成。它在以下规则中分段定义：

**DoWhileStatement** : do **Statement** while (**Expression**) ;
1. 令 V 为 undefined。
2. 重复以下步骤：
  a. 令 stmtResult 为 Statement 的 Completion(Evaluation) 结果。
  b. 如果 LoopContinues(stmtResult, labelSet) 为 false，返回 ? UpdateEmpty(stmtResult, V)。
  c. 如果 stmtResult.[[Value]] 不是 EMPTY，设置 V 为 stmtResult.[[Value]]。
  d. 令 exprRef 为 Expression 的 ? 求值结果。
  e. 令 exprValue 为 ? GetValue(exprRef)。
  f. 如果 ToBoolean(exprValue) 为 false，返回 V。

#### 14.7.3 while 语句

##### 语法
```javascript
WhileStatement[Yield, Await, Return] :
  while ( Expression[+In, ?Yield, ?Await] ) Statement[?Yield, ?Await, ?Return]
```

##### 14.7.3.1 静态语义：早期错误
**WhileStatement** : while (**Expression**) **Statement**
- 如果 Statement 的 IsLabelledFunction 为 true，则为语法错误。

**注意**：仅在实现了 B.3.1 中指定的扩展时才需要应用此规则。

##### 14.7.3.2 运行时语义：WhileLoopEvaluation
语法定向操作 WhileLoopEvaluation 接受参数 labelSet（一个字符串列表），返回包含 ECMAScript 语言值的正常完成或突发完成。它在以下规则中分段定义：

**WhileStatement** : while (**Expression**) **Statement**
1. 令 V 为 undefined。
2. 重复以下步骤：
  a. 令 exprRef 为 Expression 的 ? 求值结果。
  b. 令 exprValue 为 ? GetValue(exprRef)。
  c. 如果 ToBoolean(exprValue) 为 false，返回 V。
  d. 令 stmtResult 为 Statement 的 Completion(Evaluation) 结果。
  e. 如果 LoopContinues(stmtResult, labelSet) 为 false，返回 ? UpdateEmpty(stmtResult, V)。
  f. 如果 stmtResult.[[Value]] 不是 EMPTY，设置 V 为 stmtResult.[[Value]]。

#### 14.7.4 for 语句

##### 语法
```javascript
ForStatement[Yield, Await, Return] :
  for ( [lookahead ≠ let [] Expression[~In, ?Yield, ?Await]opt ; Expression[+In, ?Yield, ?Await]opt ; Expression[+In, ?Yield, ?Await]opt ) Statement[?Yield, ?Await, ?Return]
  for ( var VariableDeclarationList[~In, ?Yield, ?Await] ; Expression[+In, ?Yield, ?Await]opt ; Expression[+In, ?Yield, ?Await]opt ) Statement[?Yield, ?Await, ?Return]
  for ( LexicalDeclaration[~In, ?Yield, ?Await] Expression[+In, ?Yield, ?Await]opt ; Expression[+In, ?Yield, ?Await]opt ) Statement[?Yield, ?Await, ?Return]
```

##### 14.7.4.1 静态语义：早期错误
**ForStatement** :
```javascript
for ( Expressionopt ; Expressionopt ; Expressionopt ) Statement
for ( var VariableDeclarationList ; Expressionopt ; Expressionopt ) Statement
for ( LexicalDeclaration Expressionopt ; Expressionopt ) Statement
```
- 如果 Statement 的 Is

LabelledFunction 为 true，则为语法错误。

**注意**：仅在实现了 B.3.1 中指定的扩展时才需要应用此规则。

**ForStatement** : for ( LexicalDeclaration Expressionopt ; Expressionopt ) Statement
- 如果 LexicalDeclaration 的 BoundNames 中的任何元素也出现在 Statement 的 VarDeclaredNames 中，则为语法错误。

##### 14.7.4.2 运行时语义：ForLoopEvaluation
语法定向操作 ForLoopEvaluation 接受参数 labelSet（一个字符串列表），返回包含 ECMAScript 语言值的正常完成或突发完成。它在以下规则中分段定义：

**ForStatement** : for ( **Expression**opt ; **Expression**opt ; **Expression**opt ) **Statement**
1. 如果第一个 Expression 存在，
  a. 令 exprRef 为第一个 Expression 的 ? 求值结果。
  b. 执行 ? GetValue(exprRef)。
2. 如果第二个 Expression 存在，令 test 为第二个 Expression；否则，令 test 为 EMPTY。
3. 如果第三个 Expression 存在，令 increment 为第三个 Expression；否则，令 increment 为 EMPTY。
4. 返回 ForBodyEvaluation(test, increment, Statement, « », labelSet) 的 ? 求值结果。

**ForStatement** : for ( var **VariableDeclarationList** ; **Expression**opt ; **Expression**opt ) **Statement**
1. 执行 VariableDeclarationList 的 ? 求值结果。
2. 如果第一个 Expression 存在，令 test 为第一个 Expression；否则，令 test 为 EMPTY。
3. 如果第二个 Expression 存在，令 increment 为第二个 Expression；否则，令 increment 为 EMPTY。
4. 返回 ForBodyEvaluation(test, increment, Statement, « », labelSet) 的 ? 求值结果。

**ForStatement** : for ( **LexicalDeclaration** **Expression**opt ; **Expression**opt ) **Statement**
1. 令 oldEnv 为运行执行上下文的 LexicalEnvironment。
2. 令 loopEnv 为 NewDeclarativeEnvironment(oldEnv)。
3. 令 isConst 为 LexicalDeclaration 的 IsConstantDeclaration 结果。
4. 令 boundNames 为 LexicalDeclaration 的 BoundNames 结果。
5. 对于 boundNames 的每个元素 dn，
  a. 如果 isConst 为 true，
    i. 执行 ! loopEnv.CreateImmutableBinding(dn, true)。
  b. 否则，
    i. 执行 ! loopEnv.CreateMutableBinding(dn, false)。
6. 将运行执行上下文的 LexicalEnvironment 设置为 loopEnv。
7. 令 forDcl 为 LexicalDeclaration 的 Completion(Evaluation) 结果。
8. 如果 forDcl 是突发完成，
  a. 将运行执行上下文的 LexicalEnvironment 设置回 oldEnv。
  b. 返回 forDcl 的 ? 求值结果。
9. 如果 isConst 为 false，令 perIterationLets 为 boundNames；否则令 perIterationLets 为一个新的空列表。
10. 如果第一个 Expression 存在，令 test 为第一个 Expression；否则，令 test 为 EMPTY。
11. 如果第二个 Expression 存在，令 increment 为第二个 Expression；否则，令 increment 为 EMPTY。
12. 令 bodyResult 为 ForBodyEvaluation(test, increment, Statement, perIterationLets, labelSet) 的 Completion 结果。
13. 将运行执行上下文的 LexicalEnvironment 设置回 oldEnv。
14. 返回 bodyResult 的 ? 求值结果。

##### 14.7.4.3 ForBodyEvaluation (test, increment, stmt, perIterationBindings, labelSet)
### 14.7.4.3 ForBodyEvaluation (test, increment, stmt, perIterationBindings, labelSet)

抽象操作 ForBodyEvaluation 接受参数 test（一个表达式解析节点或 EMPTY）、increment（一个表达式解析节点或 EMPTY）、stmt（一个语句解析节点）、perIterationBindings（一个字符串列表）和 labelSet（一个字符串列表），并返回包含 ECMAScript 语言值的正常完成或突发完成。调用时执行以下步骤：

1. 令 V 为 undefined。
2. 执行 ? CreatePerIterationEnvironment(perIterationBindings)。
3. 重复以下步骤：
    a. 如果 test 不是 EMPTY，则：
        i. 令 testRef 为 test 的 ? 求值结果。
        ii. 令 testValue 为 testRef 的 ? GetValue 结果。
        iii. 如果 ToBoolean(testValue) 为 false，返回 V。
    b. 令 result 为 stmt 的 Completion(Evaluation) 结果。
    c. 如果 LoopContinues(result, labelSet) 为 false，返回 ? UpdateEmpty(result, V)。
    d. 如果 result.[[Value]] 不是 EMPTY，设置 V 为 result.[[Value]]。
    e. 执行 ? CreatePerIterationEnvironment(perIterationBindings)。
    f. 如果 increment 不是 EMPTY，则：
        i. 令 incRef 为 increment 的 ? 求值结果。
        ii. 执行 incRef 的 ? GetValue 结果。

### 14.7.4.4 CreatePerIterationEnvironment (perIterationBindings)

抽象操作 CreatePerIterationEnvironment 接受参数 perIterationBindings（一个字符串列表），返回包含 UNUSED 的正常完成或一个抛出完成。调用时执行以下步骤：

1. 如果 perIterationBindings 有任何元素，则：
    a. 令 lastIterationEnv 为运行执行上下文的 LexicalEnvironment。
    b. 令 outer 为 lastIterationEnv.[[OuterEnv]]。
    c. 断言：outer 不是 null。
    d. 令 thisIterationEnv 为 NewDeclarativeEnvironment(outer)。
    e. 对于 perIterationBindings 的每个元素 bn，执行：
        i. 执行 ! thisIterationEnv.CreateMutableBinding(bn, false)。
        ii. 令 lastValue 为 lastIterationEnv.GetBindingValue(bn, true) 的 ? 求值结果。
        iii. 执行 ! thisIterationEnv.InitializeBinding(bn, lastValue)。
    f. 将运行执行上下文的 LexicalEnvironment 设置为 thisIterationEnv。
2. 返回 UNUSED。

### 14.7.5 for-in、for-of 和 for-await-of 语句

#### 语法
```javascript
ForInOfStatement[Yield, Await, Return] :
    for ( [lookahead ≠ let [] LeftHandSideExpression[?Yield, ?Await] in Expression[+In, ?Yield, ?Await] ) Statement[?Yield, ?Await, ?Return]
    for ( var ForBinding[?Yield, ?Await] in Expression[+In, ?Yield, ?Await] ) Statement[?Yield, ?Await, ?Return]
    for ( ForDeclaration[?Yield, ?Await] in Expression[+In, ?Yield, ?Await] ) Statement[?Yield, ?Await, ?Return]
    for ( [lookahead ∉ { let, async of }] LeftHandSideExpression[?Yield, ?Await] of AssignmentExpression[+In, ?Yield, ?Await] ) Statement[?Yield, ?Await, ?Return]
    for ( var ForBinding[?Yield, ?Await] of AssignmentExpression[+In, ?Yield, ?Await] ) Statement[?Yield, ?Await, ?Return]
    for ( ForDeclaration[?Yield, ?Await] of AssignmentExpression[+In, ?Yield, ?Await] ) Statement[?Yield, ?Await, ?Return]
    [+Await] for await ( [lookahead ≠ let] LeftHandSideExpression[?Yield, ?Await] of AssignmentExpression[+In, ?Yield, ?Await] ) Statement[?Yield, ?Await, ?Return]
    [+Await] for await ( var ForBinding[?Yield, ?Await] of AssignmentExpression[+In, ?Yield, ?Await] ) Statement[?Yield, ?Await, ?Return]
    [+Await] for await ( ForDeclaration[?Yield, ?Await] of AssignmentExpression[+In, ?Yield, ?Await] ) Statement[?Yield, ?Await, ?Return]
```

**ForDeclaration[Yield, Await]** :
```javascript
    LetOrConst ForBinding[?Yield, ?Await]
```

**ForBinding[Yield, Await]** :
```javascript
    BindingIdentifier[?Yield, ?Await]
    BindingPattern[?Yield, ?Await]
```

**注意**：本节由附录 B.3.5 扩展。

### 14.7.5.1 静态语义：早期错误

```javascript
ForInOfStatement :
    for ( LeftHandSideExpression in Expression ) Statement
    for ( var ForBinding in Expression ) Statement
    for ( ForDeclaration in Expression ) Statement
    for ( LeftHandSideExpression of AssignmentExpression ) Statement
    for ( var ForBinding of AssignmentExpression ) Statement
    for ( ForDeclaration of AssignmentExpression ) Statement
    for await ( LeftHandSideExpression of AssignmentExpression ) Statement
    for await ( var ForBinding of AssignmentExpression ) Statement
    for await ( ForDeclaration of AssignmentExpression ) Statement
```
- 如果 Statement 的 IsLabelledFunction 为 true，则为语法错误。

**注意**：仅在实现了 B.3.1 中指定的扩展时才需要应用此规则。

```javascript
ForInOfStatement :
    for ( LeftHandSideExpression in Expression ) Statement
    for ( LeftHandSideExpression of AssignmentExpression ) Statement
    for await ( LeftHandSideExpression of AssignmentExpression ) Statement
```
- 如果 LeftHandSideExpression 是 ObjectLiteral 或 ArrayLiteral，LeftHandSideExpression 必须覆盖 AssignmentPattern。
- 如果 LeftHandSideExpression 既不是 ObjectLiteral 也不是 ArrayLiteral，如果 LeftHandSideExpression 的 AssignmentTargetType 不是 SIMPLE，则为语法错误。

```javascript
ForInOfStatement :
    for ( ForDeclaration in Expression ) Statement
    for ( ForDeclaration of AssignmentExpression ) Statement
    for await ( ForDeclaration of AssignmentExpression ) Statement
```
- 如果 ForDeclaration 的 BoundNames 包含 "let"，则为语法错误。
- 如果 ForDeclaration 的 BoundNames 的任何元素也出现在 Statement 的 VarDeclaredNames 中，则为语法错误。
- 如果 ForDeclaration 的 BoundNames 包含任何重复项，则为语法错误。

### 14.7.5.2 静态语义：IsDestructuring

语法定向操作 IsDestructuring 不接受任何参数并返回布尔值。它在以下规则中分段定义：

```javascript
MemberExpression : PrimaryExpression
```
1. 如果 PrimaryExpression 是 ObjectLiteral 或 ArrayLiteral，返回 true。
2. 返回 false。

```javascript
MemberExpression :
    MemberExpression [ Expression ]
    MemberExpression . IdentifierName
    MemberExpression TemplateLiteral
    SuperProperty
    MetaProperty
    new MemberExpression Arguments
    MemberExpression . PrivateIdentifier
```

```javascript
NewExpression :
    new NewExpression
```

```javascript
LeftHandSideExpression :
    CallExpression
    OptionalExpression
```
1. 返回 false。

```javascript
ForDeclaration : LetOrConst ForBinding
```
1. 返回 ForBinding 的 IsDestructuring 结果。

```javascript
ForBinding : BindingIdentifier
```
1. 返回 false。

```javascript
ForBinding : BindingPattern
```
1. 返回 true。

**注意**：本节由附录 B.3.5 扩展。

### 14.7.5.3 运行时语义：ForDeclarationBindingInitialization

语法定向操作 ForDeclarationBindingInitialization 接受参数 value（一个 ECMAScript 语言值）和 environment（一个环境记录或 undefined），并返回包含 UNUSED 的正常完成或突发完成。

**注意**：undefined 作为 environment 传递时表示应使用 PutValue 操作分配初始化值。对于 var 语句和某些非严格函数的形式参数列表（见 10.2.11），这种情况会发生。在这些情况下，在评估初始化器之前会提升和预初始化词法绑定。

它在以下规则中分段定义：

```javascript
ForDeclaration : LetOrConst ForBinding
```
1. 返回 ForBinding 的 BindingInitialization，参数为 value 和 environment 的 ? 求值结果。

### 14.7.5.4 运行时语义：ForDeclarationBindingInstantiation

语法定向操作 ForDeclarationBindingInstantiation 接受参数 environment（一个声明环境记录），并返回 UNUSED。它在以下规则中分段定义：

```javascript
ForDeclaration : LetOrConst ForBinding
```
1. 对于 ForBinding 的 BoundNames 的每个元素 name，执行：
    a. 如果 LetOrConst 的 IsConstantDeclaration 为 true，则：
        i. 执行 ! environment.CreateImmutableBinding(name, true)。
    b. 否则：
        i. 执行 ! environment.CreateMutableBinding(name, false)。
2. 返回 UNUSED。

### 14.7.5.5 运行时语义：ForInOfLoopEvaluation

语法定向操作 ForInOfLoopEvaluation 接受参数 labelSet（一个字符串列表），并返回包含 ECMAScript 语言值的正常完成或突发完成。它在以下规则中分

段定义：

```javascript
ForInOfStatement : for ( LeftHandSideExpression in Expression ) Statement
```
1. 令 keyResult 为 ForIn/OfHeadEvaluation(« », Expression, ENUMERATE) 的 ? 求值结果。
2. 返回 ForIn/OfBodyEvaluation(LeftHandSideExpression, Statement, keyResult, ENUMERATE, ASSIGNMENT, labelSet) 的 ? 求值结果。

```javascript
ForInOfStatement : for ( var ForBinding in Expression ) Statement
```
1. 令 keyResult 为 ForIn/OfHeadEvaluation(« », Expression, ENUMERATE) 的 ? 求值结果。
2. 返回 ForIn/OfBodyEvaluation(ForBinding, Statement, keyResult, ENUMERATE, VAR-BINDING, labelSet) 的 ? 求值结果。

```javascript
ForInOfStatement : for ( ForDeclaration in Expression ) Statement
```
1. 令 keyResult 为 ForIn/OfHeadEvaluation(BoundNames of ForDeclaration, Expression, ENUMERATE) 的 ? 求值结果。
2. 返回 ForIn/OfBodyEvaluation(ForDeclaration, Statement, keyResult, ENUMERATE, LEXICAL-BINDING, labelSet) 的 ? 求值结果。

```javascript
ForInOfStatement : for ( LeftHandSideExpression of AssignmentExpression ) Statement
```
1. 令 keyResult 为 ForIn/OfHeadEvaluation(« », AssignmentExpression, ITERATE) 的 ? 求值结果。
2. 返回 ForIn/OfBodyEvaluation(LeftHandSideExpression, Statement, keyResult, ITERATE, ASSIGNMENT, labelSet) 的 ? 求值结果。

```javascript
ForInOfStatement : for ( var ForBinding of AssignmentExpression ) Statement
```
1. 令 keyResult 为 ForIn/OfHeadEvaluation(« », AssignmentExpression, ITERATE) 的 ? 求值结果。
2. 返回 ForIn/OfBodyEvaluation(ForBinding, Statement, keyResult, ITERATE, VAR-BINDING, labelSet) 的 ? 求值结果。

```javascript
ForInOfStatement : for ( ForDeclaration of AssignmentExpression ) Statement
```
1. 令 keyResult 为 ForIn/OfHeadEvaluation(BoundNames of ForDeclaration, AssignmentExpression, ITERATE) 的 ? 求值结果。
2. 返回 ForIn/OfBodyEvaluation(ForDeclaration, Statement, keyResult, ITERATE, LEXICAL-BINDING, labelSet) 的 ? 求值结果。

```javascript
ForInOfStatement : for await ( LeftHandSideExpression of AssignmentExpression ) Statement
```
1. 令 keyResult 为 ForIn/OfHeadEvaluation(« », AssignmentExpression, ASYNC-ITERATE) 的 ? 求值结果。
2. 返回 ForIn/OfBodyEvaluation(LeftHandSideExpression, Statement, keyResult, ITERATE, ASSIGNMENT, labelSet, ASYNC) 的 ? 求值结果。

```javascript
ForInOfStatement : for await ( var ForBinding of AssignmentExpression ) Statement
```
1. 令 keyResult 为 ForIn/OfHeadEvaluation(« », AssignmentExpression, ASYNC-ITERATE) 的 ? 求值结果。
2. 返回 ForIn/OfBodyEvaluation(ForBinding, Statement, keyResult, ITERATE, VAR-BINDING, labelSet, ASYNC) 的 ? 求值结果。

```javascript
ForInOfStatement : for await ( ForDeclaration of AssignmentExpression ) Statement
```
1. 令 keyResult 为 ForIn/OfHeadEvaluation(BoundNames of ForDeclaration, AssignmentExpression, ASYNC-ITERATE) 的 ? 求值结果。
2. 返回 ForIn/OfBodyEvaluation(ForDeclaration, Statement, keyResult, ITERATE, LEXICAL-BINDING, labelSet, ASYNC) 的 ? 求值结果。

**注意**：本节由附录 B.3.5 扩展。

### 14.7.5.6 ForIn/OfHeadEvaluation (uninitializedBoundNames, expr, iterationKind)

抽象操作 ForIn/OfHeadEvaluation 接受参数 uninitializedBoundNames（一个字符串列表）、expr（一个表达式解析节点或赋值表达式解析节点）和 iterationKind（ENUMERATE、ITERATE 或 ASYNC-ITERATE），并返回包含迭代器记录的正常完成或突发完成。调用时执行以下步骤：

1. 令 oldEnv 为运行执行上下文的 LexicalEnvironment。
2. 如果 uninitializedBoundNames 不是空的，则：
    a. 断言：uninitializedBoundNames 没有重复项。
    b. 令 newEnv 为 NewDeclarativeEnvironment(oldEnv)。
    c. 对于 uninitializedBoundNames 的每个字符串 name，执行：
        i. 执行 ! newEnv.CreateMutableBinding(name, false)。
    d. 将运行执行上下文的 LexicalEnvironment 设置为 newEnv。
3. 令 exprRef 为 expr 的 Completion(Evaluation) 结果。
4. 将运行执行上下文的 LexicalEnvironment 设置回 oldEnv。
5. 令 exprValue 为 exprRef 的 ? GetValue 结果。
6. 如果 iterationKind 是 ENUMERATE，则：
    a. 如果 exprValue 是 undefined 或 null，则：
        i. 返回 Completion Record { [[Type]]: BREAK, [[Value]]: EMPTY, [[Target]]: EMPTY }。
    b. 令 obj 为 exprValue 的 ! ToObject 结果。
    c. 令 iterator 为 EnumerateObjectProperties(obj)。
    d. 令 nextMethod 为 iterator 的 ! GetV("next") 结果。
    e. 返回迭代器记录 { [[Iterator]]: iterator, [[NextMethod]]: nextMethod, [[Done]]: false }。
7. 否则：
    a. 断言：iterationKind 是 ITERATE 或 ASYNC-ITERATE。
    b. 如果 iterationKind 是 ASYNC-ITERATE，令 iteratorKind 为 ASYNC。
    c. 否则，令 iteratorKind 为 SYNC。
    d. 返回 exprValue 的 ? GetIterator(iteratorKind) 结果。

### 14.7.5.7 ForIn/OfBodyEvaluation (lhs, stmt, iteratorRecord, iterationKind, lhsKind, labelSet [, iteratorKind])

抽象操作 ForIn/OfBodyEvaluation 接受参数 lhs（一个解析节点）、stmt（一个语句解析节点）、iteratorRecord（一个迭代器记录）、iterationKind（ENUMERATE 或 ITERATE）、lhsKind（ASSIGNMENT、VAR-BINDING 或 LEXICAL-BINDING）、labelSet（一个字符串列表）和可选参数 iteratorKind（SYNC 或 ASYNC），并返回包含 ECMAScript 语言值的正常完成或突发完成。调用时执行以下步骤：

1. 如果 iteratorKind 未提供，设置 iteratorKind 为 SYNC。
2. 令 oldEnv 为运行执行上下文的 LexicalEnvironment。
3. 令 V 为 undefined。
4. 令 destructuring 为 lhs 的 IsDestructuring 结果。
5. 如果 destructuring 为 true 且 lhsKind 为 ASSIGNMENT，则：
    a. 断言：lhs 是一个 LeftHandSideExpression。
    b. 令 assignmentPattern 为 lhs 覆盖的 AssignmentPattern。
6. 重复以下步骤：
    a. 令 nextResult 为 iteratorRecord.[[NextMethod]] 调用 iteratorRecord.[[Iterator]] 的 ? 结果。
    b. 如果 iteratorKind 为 ASYNC，设置 nextResult 为 nextResult 的 ? Await 结果。
    c. 如果 nextResult 不是对象，抛出一个 TypeError 异常。
    d. 令 done 为 nextResult 的 ? IteratorComplete 结果。
    e. 如果 done 为 true，返回 V。
    f. 令 nextValue 为 nextResult 的 ? IteratorValue 结果。
    g. 如果 lhsKind 为 ASSIGNMENT 或 VAR-BINDING，则：
        i. 如果 destructuring 为 true，则：
            1. 如果 lhsKind 为 ASSIGNMENT，则：
                a. 令 status 为 assignmentPattern 的 DestructuringAssignmentEvaluation，参数为 nextValue 的 Completion 结果。
            2. 否则：
                a. 断言：lhsKind 为 VAR-BINDING。
                b. 断言：lhs 是一个 ForBinding。
                c. 令 status 为 lhs 的 BindingInitialization，参数为 nextValue 和 undefined 的 Completion 结果。
        ii. 否则：
            1. 令 lhsRef 为 lhs 的 Completion(Evaluation) 结果。（可能会重复评估）
            2. 如果 lhsRef 是突发完成，则：
                a. 令 status 为 lhsRef。
            3. 否则：
                a. 令 status 为 lhsRef.[[Value]] 的 Completion(PutValue) 结果。
    h. 否则：
        i. 断言：lhsKind 为 LEXICAL-BINDING。
        ii. 断言：lhs 是一个 ForDeclaration。
        iii. 令 iterationEnv 为 NewDeclarativeEnvironment(oldEnv)。
        iv. 执行 lhs 的 ForDeclarationBindingInstantiation，参数为 iterationEnv。
        v. 将运行执行上下文的 LexicalEnvironment 设置为 iterationEnv。
        vi. 如果 destructuring 为 true，则：
            1. 令 status 为 lhs 的 ForDeclarationBindingInitialization，参数为 nextValue 和 iterationEnv 的 Completion 结果。
        vii. 否则：
            1. 断言：lhs 绑定单个名称。
            2. 令 lhsName 为 lhs 的 BoundNames 的唯一元素。
            3. 令 lhsRef 为 ! ResolveBinding(lhsName)。
            4. 令 status 为 lhs

Ref 的 Completion(InitializeReferencedBinding)，参数为 nextValue 的结果。
    i. 如果 status 是突发完成，则：
        i. 将运行执行上下文的 LexicalEnvironment 设置回 oldEnv。
        ii. 如果 iteratorKind 为 ASYNC，返回 iteratorRecord 的 ? AsyncIteratorClose，参数为 status 的结果。
        iii. 如果 iterationKind 为 ENUMERATE，则：
            1. 返回 ? status。
        iv. 否则：
            1. 断言：iterationKind 为 ITERATE。
            2. 返回 iteratorRecord 的 ? IteratorClose，参数为 status 的结果。
    j. 令 result 为 stmt 的 Completion(Evaluation) 结果。
    k. 将运行执行上下文的 LexicalEnvironment 设置回 oldEnv。
    l. 如果 LoopContinues(result, labelSet) 为 false，则：
        i. 如果 iterationKind 为 ENUMERATE，则：
            1. 返回 ? UpdateEmpty(result, V)。
        ii. 否则：
            1. 断言：iterationKind 为 ITERATE。
            2. 设置 status 为 ? UpdateEmpty(result, V) 的 Completion 结果。
            3. 如果 iteratorKind 为 ASYNC，返回 iteratorRecord 的 ? AsyncIteratorClose，参数为 status 的结果。
            4. 返回 iteratorRecord 的 ? IteratorClose，参数为 status 的结果。
    m. 如果 result.[[Value]] 不是 EMPTY，设置 V 为 result.[[Value]]。

### 14.7.5.8 运行时语义：Evaluation

**BindingIdentifier** :
```javascript
    Identifier
    yield
    await
```
1. 令 bindingId 为 BindingIdentifier 的 StringValue。
2. 返回 ? ResolveBinding(bindingId)。

### 14.7.5.9 EnumerateObjectProperties (O)

抽象操作 EnumerateObjectProperties 接受参数 O（一个对象）并返回一个迭代器。调用时执行以下步骤：

1. 返回一个迭代器对象（27.1.1.2），其 next 方法迭代 O 的所有字符串值键的可枚举属性。迭代器对象对 ECMAScript 代码从不可直接访问。迭代属性的机制和顺序没有指定，但必须符合以下规则：
    - 迭代器的 throw 和 return 方法为 null，且不会被调用。
    - 迭代器的 next 方法处理对象属性以确定属性键是否应作为迭代器值返回。
    - 返回的属性键不包括符号键。
    - 在迭代过程中，如果目标对象的属性被删除，在处理该属性键之前被忽略。
    - 如果在迭代过程中向目标对象添加了新的属性，这些新属性在活动枚举中不保证被处理。
    - 在任何枚举中，迭代器的 next 方法最多返回一次属性名称。

枚举目标对象的属性包括枚举其原型、原型的原型等递归属性；但如果原型的属性名称与迭代器的 next 方法已处理的属性名称相同，则不会处理原型的该属性。确定是否已处理原型对象的属性时不考虑 [[Enumerable]] 属性的值。枚举原型对象的可枚举属性名称必须通过调用 EnumerateObjectProperties，参数为原型对象来获取。EnumerateObjectProperties 必须通过调用目标对象的 [[OwnPropertyKeys]] 内部方法获取自身属性键。目标对象的属性属性必须通过调用其 [[GetOwnProperty]] 内部方法获取。

此外，如果 O 或其原型链中的任何对象不是 Proxy 异种对象、TypedArray、模块命名空间异种对象或实现提供的异种对象，则迭代器的行为必须如 CreateForInIterator(O) 给定的迭代器，除非发生以下情况之一：
- O 的 [[Prototype]] 内部插槽的值或其原型链中的对象的值发生变化，
- 从 O 或其原型链中的对象中删除属性，
- 向 O 的原型链中的对象添加属性，
- O 的属性或其原型链中的对象的 [[Enumerable]] 属性的值发生变化。

**注意 1**：ECMAScript 实现不需要直接实现 14.7.5.10.2.1 中的算法。它们可以选择任何不会偏离该算法行为的实现，除非违反上述约束之一。

以下是符合这些规则的 ECMAScript 生成器函数的一个信息定义：

```javascript
function* EnumerateObjectProperties(obj) {
  const visited = new Set();
  for (const key of Reflect.ownKeys(obj)) {
    if (typeof key === "symbol") continue;
    const desc = Reflect.getOwnPropertyDescriptor(obj, key);
    if (desc) {
      visited.add(key);
      if (desc.enumerable) yield key;
    }
  }
  const proto = Reflect.getPrototypeOf(obj);
  if (proto === null) return;
  for (const protoKey of EnumerateObjectProperties(proto)) {
    if (!visited.has(protoKey)) yield protoKey;
  }
}
```

**注意 2**：选择不需要与 CreateForInIterator 匹配行为的异种对象列表，因为在这些情况下，历史上实现行为不同，而在所有其他情况下，行为一致。

### 14.7.5.10 For-In 迭代器对象

For-In 迭代器是表示特定对象的特定迭代的对象。For-In 迭代器对象对 ECMAScript 代码从不可直接访问；它们仅用于说明 EnumerateObjectProperties 的行为。

### 14.7.5.10.1 CreateForInIterator (object)

抽象操作 CreateForInIterator 接受参数 object（一个对象）并返回一个 For-In 迭代器。它用于创建一个 For-In 迭代器对象，该对象按特定顺序迭代对象的自有和继承的可枚举字符串属性。调用时执行以下步骤：

1. 令 iterator 为 OrdinaryObjectCreate(%ForInIteratorPrototype%, « [[Object]], [[ObjectWasVisited]], [[VisitedKeys]], [[RemainingKeys]] »)。
2. 设置 iterator.[[Object]] 为 object。
3. 设置 iterator.[[ObjectWasVisited]] 为 false。
4. 设置 iterator.[[VisitedKeys]] 为一个新的空列表。
5. 设置 iterator.[[RemainingKeys]] 为一个新的空列表。
6. 返回 iterator。

### 14.7.5.10.2 %ForInIteratorPrototype% 对象

%ForInIteratorPrototype% 对象：
- 拥有所有 For-In 迭代器对象继承的属性。
- 是一个普通对象。
- 具有 [[Prototype]] 内部插槽，其值为 %IteratorPrototype%。
- 对 ECMAScript 代码从不可直接访问。
- 具有以下属性：

#### 14.7.5.10.2.1 %ForInIteratorPrototype%.next()

1. 令 O 为 this 值。
2. 断言：O 是一个对象。
3. 断言：O 具有所有 For-In 迭代器实例的内部插槽（14.7.5.10.3）。
4. 令 object 为 O.[[Object]]。
5. 重复以下步骤：
    a. 如果 O.[[ObjectWasVisited]] 为 false，则：
        i. 令 keys 为 object 的 [[OwnPropertyKeys]]() 的 ? 结果。
        ii. 对 keys 的每个元素 key，执行：
            1. 如果 key 是一个字符串，则：
                a. 将 key 附加到 O.[[RemainingKeys]]。
        iii. 设置 O.[[ObjectWasVisited]] 为 true。
    b. 重复执行，直到 O.[[RemainingKeys]] 为空：
        i. 令 r 为 O.[[RemainingKeys]] 的第一个元素。
        ii. 从 O.[[RemainingKeys]] 中移除第一个元素。
        iii. 如果 O.[[VisitedKeys]] 不包含 r，则：
            1. 令 desc 为 object 的 [[GetOwnProperty]](r) 的 ? 结果。
            2. 如果 desc 不为 undefined，则：
                a. 将 r 附加到 O.[[VisitedKeys]]。
                b. 如果 desc.[[Enumerable]] 为 true，返回 CreateIterResultObject(r, false)。
    c. 设置 object 为 object 的 [[GetPrototypeOf]]() 的 ? 结果。
    d. 设置 O.[[Object]] 为 object。
    e. 设置 O.[[ObjectWasVisited]] 为 false。
    f. 如果 object 为 null，返回 CreateIterResultObject(undefined, true)。

### 14.7.5.10.3 For-In 迭代器实例的属性

For-In 迭代器实例是继承 %ForInIteratorPrototype% 内在对象属性的普通对象。For-In 迭代器实例最初使用表 38 中列出的内部插槽创建。

表 38：For-In 迭代器实例的内部插槽

| 内部插槽         | 类型      | 描述                           |
|------------------|-----------|--------------------------------|
| [[Object]]       | 对象      | 被迭代属性的对象值             |
| [[ObjectWasVisited]] | 布尔值  | 如果迭代器已在 [[Object]] 上调用 [[OwnPropertyKeys]] 则为 true，否则为 false |
| [[VisitedKeys]]  | 字符串列表 | 迄今为止由该迭代

器发出的值     |
| [[RemainingKeys]] | 字符串列表 | 在遍历其原型之前当前对象剩余的待发出值（如果其原型不为 null） |

### 14.8 continue 语句

#### 语法

```javascript
ContinueStatement[Yield, Await] :
  continue ;
  continue [no LineTerminator here] LabelIdentifier[?Yield, ?Await] ;
```

#### 14.8.1 静态语义：早期错误

```javascript
ContinueStatement :
  continue ;
  continue LabelIdentifier ;
```

如果此 ContinueStatement 没有直接或间接嵌套在一个 IterationStatement 内（但不跨越函数或静态初始化块边界），则为语法错误。

#### 14.8.2 运行时语义：求值

```javascript
ContinueStatement : continue ;
  1. 返回 Completion Record { [[Type]]: CONTINUE, [[Value]]: EMPTY, [[Target]]: EMPTY }。
```

```javascript
ContinueStatement : continue LabelIdentifier ;
  1. 令 label 为 LabelIdentifier 的 StringValue。
  2. 返回 Completion Record { [[Type]]: CONTINUE, [[Value]]: EMPTY, [[Target]]: label }。
```

### 14.9 break 语句

#### 语法

```javascript
BreakStatement[Yield, Await] :
  break ;
  break [no LineTerminator here] LabelIdentifier[?Yield, ?Await] ;
```

#### 14.9.1 静态语义：早期错误

```javascript
BreakStatement : break ;
```

如果此 BreakStatement 没有直接或间接嵌套在一个 IterationStatement 或 SwitchStatement 内（但不跨越函数或静态初始化块边界），则为语法错误。

#### 14.9.2 运行时语义：求值

```javascript
BreakStatement : break ;
  1. 返回 Completion Record { [[Type]]: BREAK, [[Value]]: EMPTY, [[Target]]: EMPTY }。
```

```javascript
BreakStatement : break LabelIdentifier ;
  1. 令 label 为 LabelIdentifier 的 StringValue。
  2. 返回 Completion Record { [[Type]]: BREAK, [[Value]]: EMPTY, [[Target]]: label }。
```

### 14.10 return 语句

#### 语法

```javascript
ReturnStatement[Yield, Await] :
  return ;
  return [no LineTerminator here] Expression[+In, ?Yield, ?Await] ;
```

**注意**：return 语句会导致函数停止执行，并在大多数情况下将值返回给调用者。如果省略 Expression，返回值为 undefined。否则，返回值为 Expression 的值。return 语句可能不会根据周围上下文将值实际返回给调用者。例如，在 try 块中，return 语句的 Completion Record 可能在 finally 块的求值期间被另一个 Completion Record 替换。

#### 14.10.1 运行时语义：求值

```javascript
ReturnStatement : return ;
  1. 返回 Completion Record { [[Type]]: RETURN, [[Value]]: undefined, [[Target]]: EMPTY }。
```

```javascript
ReturnStatement : return Expression ;
  1. 令 exprRef 为 Expression 的 ? 求值结果。
  2. 令 exprValue 为 exprRef 的 ? GetValue 结果。
  3. 如果 GetGeneratorKind() 为 ASYNC，则将 exprValue 设置为 ? Await(exprValue)。
  4. 返回 Completion Record { [[Type]]: RETURN, [[Value]]: exprValue, [[Target]]: EMPTY }。
```

### 14.11 with 语句

**注意 1**：不建议在新的 ECMAScript 代码中使用 Legacy with 语句。考虑在严格模式代码和非严格代码中都允许的替代方法，例如解构赋值。

#### 语法

```javascript
WithStatement[Yield, Await, Return] :
  with ( Expression[+In, ?Yield, ?Await] ) Statement[?Yield, ?Await, ?Return]
```

**注意 2**：with 语句为计算对象添加一个对象环境记录到运行执行上下文的词法环境中。然后，它使用这个增强的词法环境执行一个语句。最后，它恢复原来的词法环境。

#### 14.11.1 静态语义：早期错误

```javascript
WithStatement : with ( Expression ) Statement
```

- 如果 IsStrict(this production) 为 true，则为语法错误。
- 如果 IsLabelledFunction(Statement) 为 true，则为语法错误。

**注意**：仅在实现了 B.3.1 中指定的扩展时才需要应用第二条规则。

#### 14.11.2 运行时语义：求值

```javascript
WithStatement : with ( Expression ) Statement
  1. 令 val 为 Expression 的 ? 求值结果。
  2. 令 obj 为 ? ToObject(? GetValue(val))。
  3. 令 oldEnv 为运行执行上下文的 LexicalEnvironment。
  4. 令 newEnv 为 NewObjectEnvironment(obj, true, oldEnv)。
  5. 将运行执行上下文的 LexicalEnvironment 设置为 newEnv。
  6. 令 C 为 Statement 的 Completion(Evaluation) 结果。
  7. 将运行执行上下文的 LexicalEnvironment 设置回 oldEnv。
  8. 返回 ? UpdateEmpty(C, undefined)。
```

**注意**：无论控制如何离开嵌入的 Statement，无论是正常还是通过某种形式的突发完成或异常，LexicalEnvironment 都始终恢复到其原始状态。

### 14.12 switch 语句

#### 语法

```javascript
SwitchStatement[Yield, Await, Return] :
  switch ( Expression[+In, ?Yield, ?Await] ) CaseBlock[?Yield, ?Await, ?Return]
```

**CaseBlock**[Yield, Await, Return] :
```javascript
{ CaseClauses[?Yield, ?Await, ?Return]opt }
{ CaseClauses[?Yield, ?Await, ?Return]opt DefaultClause[?Yield, ?Await, ?Return] CaseClauses[?Yield, ?Await, ?Return]opt }
```

**CaseClauses**[Yield, Await, Return] :
```javascript
CaseClause[?Yield, ?Await, ?Return]
CaseClauses[?Yield, ?Await, ?Return] CaseClause[?Yield, ?Await, ?Return]
```

**CaseClause**[Yield, Await, Return] :
```javascript
case Expression[+In, ?Yield, ?Await] : StatementList[?Yield, ?Await, ?Return]opt
```

**DefaultClause**[Yield, Await, Return] :
```javascript
default : StatementList[?Yield, ?Await, ?Return]opt
```

#### 14.12.1 静态语义：早期错误

```javascript
SwitchStatement : switch ( Expression ) CaseBlock
```

- 如果 CaseBlock 的 LexicallyDeclaredNames 中包含任何重复条目，则为语法错误。
- 如果 CaseBlock 的 LexicallyDeclaredNames 的任何元素也出现在 CaseBlock 的 VarDeclaredNames 中，则为语法错误。

#### 14.12.2 运行时语义：CaseBlockEvaluation

语法定向操作 CaseBlockEvaluation 接受参数 input（一个 ECMAScript 语言值），返回包含 ECMAScript 语言值的正常完成或突发完成。它在以下规则中分段定义：

```javascript
CaseBlock : { }
  1. 返回 undefined。
```

```javascript
CaseBlock : { CaseClauses }
  1. 令 V 为 undefined。
  2. 令 A 为 CaseClauses 中的 CaseClause 项列表，按源代码顺序排列。
  3. 令 found 为 false。
  4. 对于 A 中的每个 CaseClause C，
    a. 如果 found 为 false，
      i. 将 found 设置为 ? CaseClauseIsSelected(C, input)。
    b. 如果 found 为 true，
      i. 令 R 为 C 的 Completion(Evaluation) 结果。
      ii. 如果 R.[[Value]] 不是 EMPTY，将 V 设置为 R.[[Value]]。
      iii. 如果 R 是突发完成，返回 ? UpdateEmpty(R, V)。
  5. 返回 V。
```

```javascript
CaseBlock : { CaseClausesopt DefaultClause CaseClausesopt }
  1. 令 V 为 undefined。
  2. 如果存在第一个 CaseClauses，
    a. 令 A 为第一个 CaseClauses 中的 CaseClause 项列表，按源代码顺序排列。
  3. 否则，
    a. 令 A 为一个新的空列表。
  4. 令 found 为 false。
  5. 对于 A 中的每个 CaseClause C，
    a. 如果 found 为 false，
      i. 将 found 设置为 ? CaseClauseIsSelected(C, input)。
    b. 如果 found 为 true，
      i. 令 R 为 C 的 Completion(Evaluation) 结果。
      ii. 如果 R.[[Value]] 不是 EMPTY，将 V 设置为 R.[[Value]]。
      iii. 如果 R 是突发完成，返回 ? UpdateEmpty(R, V)。
  6. 令 foundInB 为 false。
  7. 如果存在第二个 CaseClauses，
    a. 令 B 为第二个 CaseClauses 中的 CaseClause 项列表，

按源代码顺序排列。
  8. 否则，
    a. 令 B 为一个新的空列表。
  9. 如果 found 为 false，
    a. 对于 B 中的每个 CaseClause C，
      i. 如果 foundInB 为 false，
        1. 将 foundInB 设置为 ? CaseClauseIsSelected(C, input)。
      ii. 如果 foundInB 为 true，
        1. 令 R 为 CaseClause C 的 Completion(Evaluation) 结果。
        2. 如果 R.[[Value]] 不是 EMPTY，将 V 设置为 R.[[Value]]。
        3. 如果 R 是突发完成，返回 ? UpdateEmpty(R, V)。
  10. 如果 foundInB 为 true，返回 V。
  11. 令 defaultR 为 DefaultClause 的 Completion(Evaluation) 结果。
  12. 如果 defaultR.[[Value]] 不是 EMPTY，将 V 设置为 defaultR.[[Value]]。
  13. 如果 defaultR 是突发完成，返回 ? UpdateEmpty(defaultR, V)。
  14. **注意**：以下是第二个 CaseClauses 的另一个完整迭代。
  15. 对于 B 中的每个 CaseClause C，
    a. 令 R 为 CaseClause C 的 Completion(Evaluation) 结果。
    b. 如果 R.[[Value]] 不是 EMPTY，将 V 设置为 R.[[Value]]。
    c. 如果 R 是突发完成，返回 ? UpdateEmpty(R, V)。
  16. 返回 V。
```

#### 14.12.3 CaseClauseIsSelected (C, input)

抽象操作 CaseClauseIsSelected 接受参数 C（一个 CaseClause 解析节点）和 input（一个 ECMAScript 语言值），返回包含布尔值的正常完成或突发完成。它确定 C 是否匹配 input。调用时执行以下步骤：

1. 断言：C 是生产式 CaseClause : case Expression : StatementListopt 的实例。
2. 令 exprRef 为 C 的 Expression 的 ? 求值结果。
3. 令 clauseSelector 为 exprRef 的 ? GetValue 结果。
4. 返回 IsStrictlyEqual(input, clauseSelector)。
**注意**：此操作不执行 C 的 StatementList（如果有）。CaseBlock 算法使用其返回值确定要开始执行的 StatementList。

#### 14.12.4 运行时语义：求值

```javascript
SwitchStatement : switch ( Expression ) CaseBlock
  1. 令 exprRef 为 Expression 的 ? 求值结果。
  2. 令 switchValue 为 exprRef 的 ? GetValue 结果。
  3. 令 oldEnv 为运行执行上下文的 LexicalEnvironment。
  4. 令 blockEnv 为 NewDeclarativeEnvironment(oldEnv)。
  5. 执行 BlockDeclarationInstantiation(CaseBlock, blockEnv)。
  6. 将运行执行上下文的 LexicalEnvironment 设置为 blockEnv。
  7. 令 R 为 CaseBlockEvaluation(CaseBlock, switchValue) 的 Completion 结果。
  8. 将运行执行上下文的 LexicalEnvironment 设置回 oldEnv。
  9. 返回 R。
```

**注意**：无论控制如何离开 SwitchStatement，LexicalEnvironment 都始终恢复到其原始状态。

```javascript
CaseClause : case Expression :
  1. 返回 EMPTY。
```

```javascript
CaseClause : case Expression : StatementList
  1. 返回 StatementList 的 ? 求值结果。
```

```javascript
DefaultClause : default :
  1. 返回 EMPTY。
```

```javascript
DefaultClause : default : StatementList
  1. 返回 StatementList 的 ? 求值结果。
```

### 14.13 带标签的语句

#### 语法

```javascript
LabelledStatement[Yield, Await, Return] :
  LabelIdentifier[?Yield, ?Await] : LabelledItem[?Yield, ?Await, ?Return]

LabelledItem[Yield, Await, Return] :
  Statement[?Yield, ?Await, ?Return]
  FunctionDeclaration[?Yield, ?Await, ~Default]
```

**注意**：
一个语句可以由一个标签前缀。带标签的语句仅与带标签的 break 和 continue 语句结合使用。ECMAScript 没有 goto 语句。一个语句可以是 LabelledStatement 的一部分，而该 LabelledStatement 本身又可以是另一个 LabelledStatement 的一部分，依此类推。通过这种方式引入的标签在描述单个语句的语义时被统称为“当前标签集”。

#### 14.13.1 静态语义：早期错误

```javascript
LabelledItem : FunctionDeclaration
```

如果任何源文本匹配此生成式，则为语法错误。

**注意**：B.3.1 中提供了此规则的替代定义。

#### 14.13.2 静态语义：IsLabelledFunction（stmt）

抽象操作 IsLabelledFunction 接受参数 stmt（一个 Statement 解析节点）并返回一个布尔值。调用时执行以下步骤：

1. 如果 stmt 不是 LabelledStatement，则返回 false。
2. 令 item 为 stmt 的 LabelledItem。
3. 如果 item 是 LabelledItem : FunctionDeclaration，则返回 true。
4. 令 subStmt 为 item 的 Statement。
5. 返回 IsLabelledFunction(subStmt)。

#### 14.13.3 运行时语义：求值

```javascript
LabelledStatement : LabelIdentifier : LabelledItem
  1. 返回 ? LabelledEvaluation(this LabelledStatement, « ») 的结果。
```

#### 14.13.4 运行时语义：LabelledEvaluation

语法定向操作 LabelledEvaluation 接受参数 labelSet（一个字符串列表）并返回包含 ECMAScript 语言值的正常完成或突发完成。它在以下规则中分段定义：

```javascript
BreakableStatement : IterationStatement
  1. 令 stmtResult 为 Completion(LoopEvaluation(IterationStatement, labelSet)) 的结果。
  2. 如果 stmtResult 是 break 完成，
    a. 如果 stmtResult.[[Target]] 是 EMPTY，
      i. 如果 stmtResult.[[Value]] 是 EMPTY，将 stmtResult 设置为 NormalCompletion(undefined)。
      ii. 否则，将 stmtResult 设置为 NormalCompletion(stmtResult.[[Value]])。
  3. 返回 ? stmtResult。
```

```javascript
BreakableStatement : SwitchStatement
  1. 令 stmtResult 为 Completion(Evaluation(SwitchStatement)) 的结果。
  2. 如果 stmtResult 是 break 完成，
    a. 如果 stmtResult.[[Target]] 是 EMPTY，
      i. 如果 stmtResult.[[Value]] 是 EMPTY，将 stmtResult 设置为 NormalCompletion(undefined)。
      ii. 否则，将 stmtResult 设置为 NormalCompletion(stmtResult.[[Value]])。
  3. 返回 ? stmtResult。
```

**注意 1**：BreakableStatement 是可以通过未标记的 BreakStatement 退出的语句。

```javascript
LabelledStatement : LabelIdentifier : LabelledItem
  1. 令 label 为 LabelIdentifier 的 StringValue。
  2. 令 newLabelSet 为 labelSet 和 « label » 的列表连接。
  3. 令 stmtResult 为 Completion(LabelledEvaluation(LabelledItem, newLabelSet)) 的结果。
  4. 如果 stmtResult 是 break 完成且 stmtResult.[[Target]] 是 label，
    a. 将 stmtResult 设置为 NormalCompletion(stmtResult.[[Value]])。
  5. 返回 ? stmtResult。
```

```javascript
LabelledItem : FunctionDeclaration
  1. 返回 ? Evaluation(FunctionDeclaration) 的结果。
```

```javascript
Statement :
  BlockStatement
  VariableStatement
  EmptyStatement
  ExpressionStatement
  IfStatement
  ContinueStatement
  BreakStatement
  ReturnStatement
  WithStatement
  ThrowStatement
  TryStatement
  DebuggerStatement
  1. 返回 ? Evaluation(Statement) 的结果。
```

**注意 2**：只有两个 Statement 的生成式在 LabelledEvaluation 中有特殊语义：BreakableStatement 和 LabelledStatement。

### 14.14 throw 语句

#### 语法

```javascript
ThrowStatement[Yield, Await] :
  throw [no LineTerminator here] Expression[+In, ?Yield, ?Await] ;
```

#### 14.14.1 运行时语义：求值

```javascript
ThrowStatement : throw Expression ;
  1. 令 exprRef 为 Expression 的 ? 求值结果。
  2. 令 exprValue 为 exprRef 的 ? GetValue 结果。
  3. 返回 ThrowCompletion(exprValue)。
```

### 14.15 try 语句

#### 语法

```javascript
TryStatement[Yield, Await, Return] :
  try Block[?Yield, ?Await, ?Return] Catch[?Yield, ?Await, ?Return]
  try Block[?Yield, ?Await, ?Return] Finally[?Yield, ?Await, ?Return]
  try Block[?Yield, ?Await, ?Return] Catch[?Yield, ?Await, ?Return] Finally[?Yield, ?Await, ?Return]
```

**Catch**[Yield, Await, Return] :
```javascript
catch ( CatchParameter[?Yield, ?Await] ) Block[?Yield, ?Await, ?Return]
catch Block[?Yield, ?Await, ?Return]
```

**Finally**[Yield, Await, Return] :
```javascript
finally Block[?Yield, ?Await, ?Return]
```

**CatchParameter**[Yield, Await] :
```javascript
BindingIdentifier[?Yield, ?Await]
BindingPattern[?Yield, ?Await]
```

**注意**：
try 语句包含可能发生异常情况的代码块，例如运行时错误或 throw 语句。catch 子句提供异常处理代码。当 catch 子句捕获异常时，其 CatchParameter 绑定到该异常。

#### 14.15.1 静态语义：早期错误

```javascript
Catch : catch ( CatchParameter ) Block
```

- 如果 CatchParameter 的 BoundNames 包含任何重复元素，则为语法错误。
- 如果 CatchParameter 的 BoundNames 的任何元素也出现在 Block 的 LexicallyDeclaredNames 中，则为语法错误。
- 如果 CatchParameter 的 BoundNames 的任何元素也出现在 Block 的 VarDeclaredNames 中，则为语法错误。

**注意**：B.3.4 中给出了此生成式的替代静态语义。

#### 14.15.2 运行时语义：CatchClauseEvaluation

语法定向操作 CatchClauseEvaluation 接受参数 thrownValue（一个 ECMAScript 语言值），返回包含 ECMAScript 语言值的正常完成或突发完成。它在以下规则中分段定义：

```javascript
Catch : catch ( CatchParameter ) Block
  1. 令 oldEnv 为运行执行上下文的 LexicalEnvironment。
  2. 令 catchEnv 为 NewDeclarativeEnvironment(oldEnv)。
  3. 对于 CatchParameter 的 BoundNames 中的每个元素 argName，
    a. 执行 ! catchEnv.CreateMutableBinding(argName, false)。
  4. 将运行执行上下文的 LexicalEnvironment 设置为 catchEnv。
  5. 令 status 为 Completion(BindingInitialization(CatchParameter, thrownValue, catchEnv)) 的结果。
  6. 如果 status 是突发完成，
    a. 将运行执行上下文的 LexicalEnvironment 设置回 oldEnv。
    b. 返回 ? status。
  7. 令 B 为 Block 的 Completion(Evaluation) 结果。
  8. 将运行执行上下文的 LexicalEnvironment 设置回 oldEnv。
  9. 返回 ? B。
```

```javascript
Catch : catch Block
  1. 返回 ? Evaluation(Block) 的结果。
```

**注意**：无论控制如何离开 Block，LexicalEnvironment 始终恢复到其原始状态。

#### 14.15.3 运行时语义：求值

```javascript
TryStatement : try Block Catch
  1. 令 B 为 Block 的 Completion(Evaluation) 结果。
  2. 如果 B 是 throw 完成，令 C 为 CatchClauseEvaluation(Catch, B.[[Value]]) 的 Completion 结果。
  3. 否则，令 C 为 B。
  4. 返回 ? UpdateEmpty(C, undefined)。
```

```javascript
TryStatement : try Block Finally
  1. 令 B 为 Block 的 Completion(Evaluation) 结果。
  2. 令 F 为 Finally 的 Completion(Evaluation) 结果。
  3. 如果 F 是正常完成，将 F 设置为 B。
  4. 返回 ? UpdateEmpty(F, undefined)。
```

```javascript
TryStatement : try Block Catch Finally
  1. 令 B 为 Block 的 Completion(Evaluation) 结果。
  2. 如果 B 是 throw 完成，令 C 为 CatchClauseEvaluation(Catch, B.[[Value]]) 的 Completion 结果。
  

 3. 否则，令 C 为 B。
   4. 令 F 为 Finally 的 Completion(Evaluation) 结果。
   5. 如果 F 是正常完成，将 F 设置为 C。
   6. 返回 ? UpdateEmpty(F, undefined)。
```

### 14.16 debugger 语句

#### 语法

```javascript
DebuggerStatement :
  debugger ;
```

#### 14.16.1 运行时语义：求值

**注意**：
评估 DebuggerStatement 可能允许在调试器中运行时造成断点。如果没有调试器存在或激活，此语句没有可观察到的效果。

```javascript
DebuggerStatement : debugger ;
  1. 如果有可用且启用的实现定义的调试工具，
    a. 执行实现定义的调试操作。
    b. 返回一个新的实现定义的 Completion 记录。
  2. 否则，
    a. 返回 EMPTY。
```

### 15 ECMAScript 语言：函数和类

**注意**：各种 ECMAScript 语言元素会创建 ECMAScript 函数对象（10.2）。这些函数的求值始于其 [[Call]] 内部方法的执行（10.2.1）。

#### 15.1 参数列表

##### 语法

```javascript
UniqueFormalParameters[Yield, Await] :
  FormalParameters[?Yield, ?Await]

FormalParameters[Yield, Await] :
  [empty]
  FunctionRestParameter[?Yield, ?Await]
  FormalParameterList[?Yield, ?Await]
  FormalParameterList[?Yield, ?Await] ,
  FormalParameterList[?Yield, ?Await] , FunctionRestParameter[?Yield, ?Await]

FormalParameterList[Yield, Await] :
  FormalParameter[?Yield, ?Await]
  FormalParameterList[?Yield, ?Await] , FormalParameter[?Yield, ?Await]

FunctionRestParameter[Yield, Await] :
  BindingRestElement[?Yield, ?Await]

FormalParameter[Yield, Await] :
  BindingElement[?Yield, ?Await]
```

##### 15.1.1 静态语义：早期错误

```javascript
UniqueFormalParameters : FormalParameters
```

- 如果 FormalParameters 的 BoundNames 包含任何重复元素，则为语法错误。

```javascript
FormalParameters : FormalParameterList
```

- 如果 FormalParameterList 的 IsSimpleParameterList 为 false 且 FormalParameterList 的 BoundNames 包含任何重复元素，则为语法错误。

**注意**：仅对具有简单参数列表且未在严格模式代码中定义的函数，允许在 FormalParameterList 中多次出现相同的 BindingIdentifier。

##### 15.1.2 静态语义：ContainsExpression

语法定向操作 ContainsExpression 不接受参数并返回布尔值。它在以下生成式中分段定义：

```javascript
ObjectBindingPattern :
  { }
  { BindingRestProperty }
  1. 返回 false。

ObjectBindingPattern : { BindingPropertyList , BindingRestProperty }
  1. 返回 BindingPropertyList 的 ContainsExpression。

ArrayBindingPattern : [ Elisionopt ]
  1. 返回 false。

ArrayBindingPattern : [ Elisionopt BindingRestElement ]
  1. 返回 BindingRestElement 的 ContainsExpression。

ArrayBindingPattern : [ BindingElementList , Elisionopt ]
  1. 返回 BindingElementList 的 ContainsExpression。

ArrayBindingPattern : [ BindingElementList , Elisionopt BindingRestElement ]
  1. 令 has 为 BindingElementList 的 ContainsExpression。
  2. 如果 has 为 true，则返回 true。
  3. 返回 BindingRestElement 的 ContainsExpression。

BindingPropertyList : BindingPropertyList , BindingProperty
  1. 令 has 为 BindingPropertyList 的 ContainsExpression。
  2. 如果 has 为 true，则返回 true。
  3. 返回 BindingProperty 的 ContainsExpression。

BindingElementList : BindingElementList , BindingElisionElement
  1. 令 has 为 BindingElementList 的 ContainsExpression。
  2. 如果 has 为 true，则返回 true。
  3. 返回 BindingElisionElement 的 ContainsExpression。

BindingElisionElement : Elisionopt BindingElement
  1. 返回 BindingElement 的 ContainsExpression。

BindingProperty : PropertyName : BindingElement
  1. 令 has 为 PropertyName 的 IsComputedPropertyKey。
  2. 如果 has 为 true，则返回 true。
  3. 返回 BindingElement 的 ContainsExpression。

BindingElement : BindingPattern Initializer
  1. 返回 true。

SingleNameBinding : BindingIdentifier
  1. 返回 false。

SingleNameBinding : BindingIdentifier Initializer
  1. 返回 true。

BindingRestElement : ... BindingIdentifier
  1. 返回 false。

BindingRestElement : ... BindingPattern
  1. 返回 BindingPattern 的 ContainsExpression。

FormalParameters : [empty]
  1. 返回 false。

FormalParameters : FormalParameterList , FunctionRestParameter
  1. 如果 FormalParameterList 的 ContainsExpression 为 true，则返回 true。
  2. 返回 FunctionRestParameter 的 ContainsExpression。

FormalParameterList : FormalParameterList , FormalParameter
  1. 如果 FormalParameterList 的 ContainsExpression 为 true，则返回 true。
  2. 返回 FormalParameter 的 ContainsExpression。

ArrowParameters : BindingIdentifier
  1. 返回 false。

ArrowParameters : CoverParenthesizedExpressionAndArrowParameterList
  1. 令 formals 为 CoverParenthesizedExpressionAndArrowParameterList 所涵盖的 ArrowFormalParameters。
  2. 返回 formals 的 ContainsExpression。

AsyncArrowBindingIdentifier : BindingIdentifier
  1. 返回 false。
```

##### 15.1.3 静态语义：IsSimpleParameterList

语法定向操作 IsSimpleParameterList 不接受参数并返回布尔值。它在以下生成式中分段定义：

```javascript
BindingElement : BindingPattern
  1. 返回 false。

BindingElement : BindingPattern Initializer
  1. 返回 false。

SingleNameBinding : BindingIdentifier
  1. 返回 true。

SingleNameBinding : BindingIdentifier Initializer
  1. 返回 false。

FormalParameters : [empty]
  1. 返回 true。

FormalParameters : FunctionRestParameter
  1. 返回 false。

FormalParameters : FormalParameterList , FunctionRestParameter
  1. 返回 false。

FormalParameterList : FormalParameterList , FormalParameter
  1. 如果 FormalParameterList 的 IsSimpleParameterList 为 false，则返回 false。
  2. 返回 FormalParameter 的 IsSimpleParameterList。

FormalParameter : BindingElement
  1. 返回 BindingElement 的 IsSimpleParameterList。

ArrowParameters : BindingIdentifier
  1. 返回 true。

ArrowParameters : CoverParenthesizedExpressionAndArrowParameterList
  1. 令 formals 为 CoverParenthesizedExpressionAndArrowParameterList 所涵盖的 ArrowFormalParameters。
  2. 返回 formals 的 IsSimpleParameterList。

AsyncArrowBindingIdentifier : BindingIdentifier
  1. 返回 true。

CoverCallExpressionAndAsyncArrowHead : MemberExpression Arguments
  1. 令 head 为 CoverCallExpressionAndAsyncArrowHead 所涵盖的 AsyncArrowHead。
  2. 返回 head 的 IsSimpleParameterList。
```

##### 15.1.4 静态语义：HasInitializer

语法定向操作 HasInitializer 不接受参数并返回布尔值。它在以下生成式中分段定义：

```javascript
BindingElement : BindingPattern
  1. 返回 false。

BindingElement : BindingPattern Initializer
  1. 返回 true。

SingleNameBinding : BindingIdentifier
  1. 返回 false。

SingleNameBinding : BindingIdentifier Initializer
  1. 返回 true。

FormalParameterList : FormalParameterList , FormalParameter
  1. 如果 FormalParameterList 的 HasInitializer 为 true，则返回 true。
  2. 返回 FormalParameter 的 HasInitializer。
```

##### 15.1.5 静态语义：ExpectedArgumentCount

语法定向操作 ExpectedArgumentCount 不接受参数并返回一个整数。它在以下生成式中分段定义：

```javascript
FormalParameters :
  [empty]
  FunctionRestParameter
  1. 返回 0。

FormalParameters : FormalParameterList , FunctionRestParameter
  1. 返回 FormalParameterList 的 ExpectedArgumentCount。
```

**注意**：FormalParameterList 的 ExpectedArgumentCount 是 rest 参数或第一个带有初始化器的 FormalParameter 左侧的 FormalParameters 的数量。在第一个带有初始化器的参数之后允许出现没有初始化器的 FormalParameter，但这些参数被认为是可选的，默认值为 undefined。

```javascript
FormalParameterList : FormalParameter
  1. 如果 FormalParameter 的 HasInitializer 为 true，则返回 0。
  2. 返回 1。

FormalParameterList : FormalParameterList , FormalParameter
  1. 令 count 为 FormalParameterList 的 ExpectedArgumentCount。
  2. 如果 FormalParameterList 的 HasInitializer 为 true 或 FormalParameter 的 HasInitializer 为 true，则返回 count。
  3. 返回 count + 1。

ArrowParameters : BindingIdentifier
  1. 返回 1。

ArrowParameters : CoverParenthesizedExpressionAndArrowParameterList
  1. 令 formals 为 CoverParenthesizedExpressionAndArrowParameterList 所涵盖的 ArrowFormalParameters。
  2. 返回 formals 的 ExpectedArgumentCount。

PropertySetParameterList : FormalParameter
  1. 如果 FormalParameter 的 HasInitializer 为 true，则返回 0。
  2. 返回 1。

AsyncArrowBindingIdentifier : BindingIdentifier
  1. 返回 1。
```

### 15.2 函数定义

#### 语法

```javascript
FunctionDeclaration[Yield, Await, Default] :
  function BindingIdentifier[?Yield, ?Await] ( FormalParameters[~Yield, ~Await] ) { FunctionBody[~Yield, ~Await] }
  [+Default] function ( FormalParameters[~Yield, ~Await] ) { FunctionBody[~Yield, ~Await] }

FunctionExpression :
  function BindingIdentifier[~Yield, ~Await]opt ( FormalParameters[~Yield, ~Await] ) { FunctionBody[~Yield, ~Await] }

FunctionBody[Yield, Await] :
  FunctionStatementList[?Yield, ?Await]

FunctionStatementList[Yield, Await] :
  StatementList[?Yield, ?Await, +Return]opt
```

#### 15.2.1 静态语义：早期错误

```javascript
FunctionDeclaration :
  function BindingIdentifier ( FormalParameters ) { FunctionBody }
  function ( FormalParameters ) { FunctionBody }

FunctionExpression :
  function BindingIdentifieropt ( FormalParameters ) { FunctionBody }
```

- 如果 IsStrict(FormalParameters) 为 true，则适用 UniqueFormalParameters : FormalParameters 的早期错误规则。
- 如果 BindingIdentifier 存在且 IsStrict(BindingIdentifier) 为 true，则如果 BindingIdentifier 的 StringValue 是 "eval" 或 "arguments"，则为语法错误。
- 如果 FunctionBodyContainsUseStrict 的 FunctionBody 为 true 且 FormalParameters 的 IsSimpleParameterList 为 false，则为语法错误。
- 如果 FormalParameters 的 BoundNames 中的任何元素也出现在 FunctionBody 的 LexicallyDeclaredNames 中，则为语法错误。
- 如果 FormalParameters 包含 SuperProperty，则为语法错误。
- 如果 FunctionBody 包含 SuperProperty，则为语法错误。
- 如果 FormalParameters 包含 SuperCall，则为语法错误。
- 如果 FunctionBody 包含 SuperCall，则为语法错误。

**注意**：FunctionBody 的 LexicallyDeclaredNames 不包括使用 var 或 function 声明绑定的标识符。

```javascript
FunctionBody : FunctionStatementList
```

- 如果 FunctionStatementList 的 LexicallyDeclaredNames 包含任何重复条目，则为语法错误。
- 如果 FunctionStatementList 的 LexicallyDeclaredNames 中的任何元素也出现在 FunctionStatementList 的 VarDeclaredNames 中，则为语法错误。
- 如果 FunctionStatementList 的 ContainsDuplicateLabels 参数为 « » 为 true，则为语法错误。
- 如果 FunctionStatementList 的 ContainsUndefinedBreakTarget 参数为 « » 为 true，则为语法错误。
- 如果 FunctionStatementList 的 ContainsUndefinedContinueTarget 参数为 « » 和 « » 为 true，则为语法错误。

#### 15.2.2 静态语义：FunctionBodyContainsUseStrict

语法定向操作 FunctionBodyContainsUseStrict 不接受参数并返回布尔值。它在以下生成式中分段定义：

```javascript
FunctionBody : FunctionStatementList
1. 如果 FunctionBody 的 Directive Prologue 包含 Use Strict Directive，则返回 true；否则返回 false。
```

#### 15.2.3 运行时语义：EvaluateFunctionBody

语法定向操作 EvaluateFunctionBody 接受参数 functionObject（一个 ECMAScript 函数对象）和 argumentsList（一个 ECMAScript 语言值的列表），并返回一个包含 ECMAScript 语言值的正常完成或一个突然完成。它在以下生成式中分段定义：

```javascript
FunctionBody : FunctionStatementList
1. 执行 ? FunctionDeclarationInstantiation(functionObject, argumentsList)。
2. 返回 ? Evaluation of FunctionStatementList。
```

#### 15.2.4 运行时语义：InstantiateOrdinaryFunctionObject

语法定向操作 InstantiateOrdinaryFunctionObject 接受参数 env（一个 Environment Record）和 privateEnv（一个 PrivateEnvironment Record 或 null），并返回一个 ECMAScript 函数对象。它在以下生成式中分段定义：

```javascript
FunctionDeclaration : function BindingIdentifier ( FormalParameters ) { FunctionBody }
1. 令 name 为 BindingIdentifier 的 StringValue。
2. 令 sourceText 为 FunctionDeclaration 匹配的源文本。
3. 令 F 为 OrdinaryFunctionCreate(%Function.prototype%, sourceText, FormalParameters, FunctionBody, NON-LEXICAL-THIS, env, privateEnv)。
4. 执行 SetFunctionName(F, name)。
5. 执行 MakeConstructor(F)。
6. 返回 F。

FunctionDeclaration : function ( FormalParameters ) { FunctionBody }
1. 令 sourceText 为 FunctionDeclaration 匹配的源文本。
2. 令 F 为 OrdinaryFunctionCreate(%Function.prototype%, sourceText, FormalParameters, FunctionBody, NON-LEXICAL-THIS, env, privateEnv)。
3. 执行 SetFunctionName(F, "default")。
4. 执行 MakeConstructor(F)。
5. 返回 F。
```

**注意**：匿名的 FunctionDeclaration 只能作为 export default 声明的一部分出现，因此其函数代码总是严格模式代码。

#### 15.2.5 运行时语义：InstantiateOrdinaryFunctionExpression

语法定向操作 InstantiateOrdinaryFunctionExpression 接受可选参数 name（一个 property key 或 Private Name），并返回一个 ECMAScript 函数对象。它在以下生成式中分段定义：

```javascript
FunctionExpression : function ( FormalParameters ) { FunctionBody }
1. 如果 name 不存在，设置 name 为 ""。
2. 令 env 为运行执行上下文的 LexicalEnvironment。
3. 令 privateEnv 为运行执行上下文的 PrivateEnvironment。
4. 令 sourceText 为 FunctionExpression 匹配的源文本。
5. 令 closure 为 OrdinaryFunctionCreate(%Function.prototype%, sourceText, FormalParameters, FunctionBody, NON-LEXICAL-THIS, env, privateEnv)。
6. 执行 SetFunctionName(closure, name)。
7. 执行 MakeConstructor(closure)。
8. 返回 closure。

FunctionExpression : function BindingIdentifier ( FormalParameters ) { FunctionBody }
1. 断言：name 不存在。
2. 设置 name 为 BindingIdentifier 的 StringValue。
3. 令 outerEnv 为运行执行上下文的 LexicalEnvironment。
4. 令 funcEnv 为 NewDeclarativeEnvironment(outerEnv)。
5. 执行 ! funcEnv.CreateImmutableBinding(name, false)。
6. 令 privateEnv 为运行执行上下文的 PrivateEnvironment。
7. 令 sourceText 为 FunctionExpression 匹配的源文本。
8. 令 closure 为 OrdinaryFunctionCreate(%Function.prototype%, sourceText, FormalParameters, FunctionBody, NON-LEXICAL-THIS, funcEnv, privateEnv)。
9. 执行 SetFunctionName(closure, name)。
10. 执行 MakeConstructor(closure)。
11. 执行 ! funcEnv.InitializeBinding(name, closure)。
12. 返回 closure。
```

**注意**：FunctionExpression 中的 BindingIdentifier 可以从 FunctionExpression 的 FunctionBody 内部引用，以允许函数递归调用自身。然而，与 FunctionDeclaration 不同，FunctionExpression 中的 BindingIdentifier 不能从 FunctionExpression 的外部引用，也不会影响包围 FunctionExpression 的作用域。

#### 15.2.6 运行时语义：Evaluation

```javascript
FunctionDeclaration : function BindingIdentifier ( FormalParameters ) { FunctionBody }
1. 返回 EMPTY。

FunctionDeclaration : function ( FormalParameters ) { FunctionBody }
1. 返回 EMPTY。

FunctionExpression : function BindingIdentifieropt ( FormalParameters ) { FunctionBody }
1. 返回 InstantiateOrdinaryFunctionExpression of FunctionExpression。
```

**注意**1：在 B.3.2 中提供了一个替代语义。

**注意**2：每个使用 FunctionDeclaration 或 FunctionExpression 定义的函数都会自动创建一个 "prototype" 属性，以允许函数作为构造函数使用。

```javascript
FunctionStatementList : [empty]
1. 返回 undefined。
```

### 15.3 箭头函数定义

#### 语法

```javascript
ArrowFunction[In, Yield, Await] :
  ArrowParameters[?Yield, ?Await] [no LineTerminator here] => ConciseBody[?In]

ArrowParameters[Yield, Await] :
  BindingIdentifier[?Yield, ?Await]
  CoverParenthesizedExpressionAndArrowParameterList[?Yield, ?Await]

ConciseBody[In] :
  [lookahead ≠ {] ExpressionBody[?In, ~Await]
  { FunctionBody[~Yield, ~Await] }

ExpressionBody[In, Await] :
  AssignmentExpression[?In, ~Yield, ?Await]
```

补充语法

在处理以下生成式的实例时：
```javascript
ArrowParameters[Yield, Await] : CoverParenthesizedExpressionAndArrowParameterList[?Yield, ?Await]
```
CoverParenthesizedExpressionAndArrowParameterList 使用以下语法进行解释：

```javascript
ArrowFormalParameters[Yield, Await] :
  ( UniqueFormalParameters[?Yield, ?Await] )
```

#### 15.3.1 静态语义：早期错误

```javascript
ArrowFunction : ArrowParameters => ConciseBody
```
- 如果 ArrowParameters 包含 YieldExpression，则为语法错误。
- 如果 ArrowParameters 包含 AwaitExpression，则为语法错误。
- 如果 ConciseBodyContainsUseStrict 的 ConciseBody 为 true 且 ArrowParameters 的 IsSimpleParameterList 为 false，则为语法错误。
- 如果 ArrowParameters 的 BoundNames 中的任何元素也出现在 ConciseBody 的 LexicallyDeclaredNames 中，则为语法错误。

```javascript
ArrowParameters : CoverParenthesizedExpressionAndArrowParameterList
```
CoverParenthesizedExpressionAndArrowParameterList 必须覆盖一个 ArrowFormalParameters。

#### 15.3.2 静态语义：ConciseBodyContainsUseStrict

语法定向操作 ConciseBodyContainsUseStrict 不接受参数并返回布尔值。它在以下生成式中分段定义：

```javascript
ConciseBody : ExpressionBody
1. 返回 false。

ConciseBody : { FunctionBody }
1. 返回 FunctionBodyContainsUseStrict of FunctionBody。
```

#### 15.3.3 运行时语义：EvaluateConciseBody

语法定向操作 EvaluateConciseBody 接受参数 functionObject（一个 ECMAScript 函数对象）和 argumentsList（一个 ECMAScript 语言值的列表），并返回一个包含 ECMAScript 语言值的正常完成或一个突然完成。它在以下生成式中分段定义：

```javascript
ConciseBody : ExpressionBody
1. 执行 ? FunctionDeclarationInstantiation(functionObject, argumentsList)。
2. 返回 ? Evaluation of ExpressionBody。
```

#### 15.3.4 运行时语义：InstantiateArrowFunctionExpression

语法定向操作 InstantiateArrowFunctionExpression 接受可选参数 name（一个属性键或私有名称），并返回一个 ECMAScript 函数对象。它在以下生成式中分段定义：

```javascript
ArrowFunction : ArrowParameters => ConciseBody
1. 如果 name 不存在，设置 name 为 ""。
2. 令 env 为运行执行上下文的 LexicalEnvironment。
3. 令 privateEnv 为运行执行上下文的 PrivateEnvironment。
4. 令 sourceText 为 ArrowFunction 匹配的源文本。
5. 令 closure 为 OrdinaryFunctionCreate(%Function.prototype%, sourceText, ArrowParameters, ConciseBody, LEXICAL-THIS, env, privateEnv)。
6. 执行 SetFunctionName(closure, name)。
7. 返回 closure。
```

**注意**：ArrowFunction 不会为 arguments、super、this 或 new.target 定义局部绑定。任何对 arguments、super、this 或 new.target 的引用都必须解析为词法上包围环境中的绑定。通常这将是紧邻包围函数的 Function Environment。尽管 ArrowFunction 可能包含对 super 的引用，但在第5步中创建的函数对象不会通过执行 MakeMethod 成为方法。引用 super 的 ArrowFunction 总是包含在非箭头函数中，必要的状态可以通过函数对象捕获的 env 访问。

#### 15.3.5 运行时语义：Evaluation

```javascript
ArrowFunction : ArrowParameters => ConciseBody
1. 返回 InstantiateArrowFunctionExpression of ArrowFunction。

ExpressionBody : AssignmentExpression
1. 令 exprRef 为 ? Evaluation of AssignmentExpression。
2. 令 exprValue 为 ? GetValue(exprRef)。
3. 返回 Completion Record { [[Type]]: RETURN, [[Value]]: exprValue, [[Target]]: EMPTY }。
```

### 15.4 方法定义

#### 语法

```javascript
MethodDefinition[Yield, Await] :
  ClassElementName[?Yield, ?Await] ( UniqueFormalParameters[~Yield, ~Await] ) { FunctionBody[~Yield, ~Await] }
  GeneratorMethod[?Yield, ?Await]
  AsyncMethod[?Yield, ?Await]
  AsyncGeneratorMethod[?Yield, ?Await]
  get ClassElementName[?Yield, ?Await] ( ) { FunctionBody[~Yield, ~Await] }
  set ClassElementName[?Yield, ?Await] ( PropertySetParameterList ) { FunctionBody[~Yield, ~Await] }

PropertySetParameterList :
  FormalParameter[~Yield, ~Await]
```

#### 15.4.1 静态语义：早期错误

```javascript
MethodDefinition : ClassElementName ( UniqueFormalParameters ) { FunctionBody }
```
- 如果 FunctionBodyContainsUseStrict 的 FunctionBody 为 true 且 UniqueFormalParameters 的 IsSimpleParameterList 为 false，则为语法错误。
- 如果 UniqueFormalParameters 的 BoundNames 中的任何元素也出现在 FunctionBody 的 LexicallyDeclaredNames 中，则为语法错误。

```javascript
MethodDefinition : set ClassElementName ( PropertySetParameterList ) { FunctionBody }
```
- 如果 PropertySetParameterList 的 BoundNames 包含任何重复元素，则为语法错误。
- 如果 FunctionBodyContainsUseStrict 的 FunctionBody 为 true 且 PropertySetParameterList 的 IsSimpleParameterList 为 false，则为语法错误。
- 如果 PropertySetParameterList 的 BoundNames 中的任何元素也出现在 FunctionBody 的 LexicallyDeclaredNames 中，则为语法错误。

#### 15.4.2 静态语义：HasDirectSuper

语法定向操作 HasDirectSuper 不接受参数并返回布尔值。它在以下生成式中分段定义：

```javascript
MethodDefinition : ClassElementName ( UniqueFormalParameters ) { FunctionBody }
1. 如果 UniqueFormalParameters 包含 SuperCall，则返回 true。
2. 返回 FunctionBody Contains SuperCall。

MethodDefinition : get ClassElementName ( ) { FunctionBody }
1. 返回 FunctionBody Contains SuperCall。

MethodDefinition : set ClassElementName ( PropertySetParameterList ) { FunctionBody }
1. 如果 PropertySetParameterList 包含 SuperCall，则返回 true。
2. 返回 FunctionBody Contains SuperCall。

GeneratorMethod : * ClassElementName ( UniqueFormalParameters ) { GeneratorBody }
1. 如果 UniqueFormalParameters 包含 SuperCall，则返回 true。
2. 返回 GeneratorBody Contains SuperCall。

AsyncGeneratorMethod : async * ClassElementName ( UniqueFormalParameters ) { AsyncGeneratorBody }
1. 如果 UniqueFormalParameters 包含 SuperCall，则返回 true。
2. 返回 AsyncGeneratorBody Contains SuperCall。

AsyncMethod : async ClassElementName ( UniqueFormalParameters ) { AsyncFunctionBody }
1. 如果 UniqueFormalParameters 包含 SuperCall，则返回 true。
2. 返回 AsyncFunctionBody Contains SuperCall。
```

#### 15.4.3 静态语义：SpecialMethod

语法定向操作 SpecialMethod 不接受参数并返回布尔值。它在以下生成式中分段定义：

```javascript
MethodDefinition : ClassElementName ( UniqueFormalParameters ) { FunctionBody }
1. 返回 false。

MethodDefinition :
  GeneratorMethod
  AsyncMethod
  AsyncGeneratorMethod
  get ClassElementName ( ) { FunctionBody }
  set ClassElementName ( PropertySetParameterList ) { FunctionBody }
1. 返回 true。
```

#### 15.4.4 运行时语义：DefineMethod

语法定向操作 DefineMethod 接受参数 object（一个对象）和可选参数 functionPrototype（一个对象），并返回一个包含字段 [[Key]]（一个属性键）和 [[Closure]]（一个 ECMAScript 函数对象）的正常完成或一个突然完成。它在以下生成式中分段定义：

```javascript
MethodDefinition : ClassElementName ( UniqueFormalParameters ) { FunctionBody }
1. 令 propKey 为 ? Evaluation of ClassElementName。
2. 令 env 为运行执行上下文的 LexicalEnvironment。
3. 令 privateEnv 为运行执行上下文的 PrivateEnvironment。
4. 如果 functionPrototype 存在，则
  a. 令 prototype 为 functionPrototype。
5. 否则，
  a. 令 prototype 为 %Function.prototype%。
6. 令 sourceText 为 MethodDefinition 匹配的源文本。
7. 令 closure 为 OrdinaryFunctionCreate(prototype, sourceText, UniqueFormalParameters, FunctionBody, NON-LEXICAL-THIS, env, privateEnv)。
8. 执行 MakeMethod(closure, object)。
9. 返回 Record { [[Key]]: propKey, [[Closure]]: closure }。
```

#### 15.4.5 运行时语义：MethodDefinitionEvaluation

语法定向操作 MethodDefinition

Evaluation 接受参数 object（一个对象）和 enumerable（一个布尔值），并返回一个包含 PrivateElement 或 UNUSED 的正常完成或一个突然完成。它在以下生成式中分段定义：

```javascript
MethodDefinition : ClassElementName ( UniqueFormalParameters ) { FunctionBody }
1. 令 methodDef 为 ? DefineMethod of MethodDefinition with argument object。
2. 执行 SetFunctionName(methodDef.[[Closure]], methodDef.[[Key]])。
3. 返回 ? DefineMethodProperty(object, methodDef.[[Key]], methodDef.[[Closure]], enumerable)。

MethodDefinition : get ClassElementName ( ) { FunctionBody }
1. 令 propKey 为 ? Evaluation of ClassElementName。
2. 令 env 为运行执行上下文的 LexicalEnvironment。
3. 令 privateEnv 为运行执行上下文的 PrivateEnvironment。
4. 令 sourceText 为 MethodDefinition 匹配的源文本。
5. 令 formalParameterList 为一个生成式 FormalParameters : [empty] 的实例。
6. 令 closure 为 OrdinaryFunctionCreate(%Function.prototype%, sourceText, formalParameterList, FunctionBody, NON-LEXICAL-THIS, env, privateEnv)。
7. 执行 MakeMethod(closure, object)。
8. 执行 SetFunctionName(closure, propKey, "get")。
9. 如果 propKey 是一个私有名称，则
  a. 返回 PrivateElement { [[Key]]: propKey, [[Kind]]: ACCESSOR, [[Get]]: closure, [[Set]]: undefined }。
10. 否则，
  a. 令 desc 为 PropertyDescriptor { [[Get]]: closure, [[Enumerable]]: enumerable, [[Configurable]]: true }。
  b. 执行 ? DefinePropertyOrThrow(object, propKey, desc)。
  c. 返回 UNUSED。

MethodDefinition : set ClassElementName ( PropertySetParameterList ) { FunctionBody }
1. 令 propKey 为 ? Evaluation of ClassElementName。
2. 令 env 为运行执行上下文的 LexicalEnvironment。
3. 令 privateEnv 为运行执行上下文的 PrivateEnvironment。
4. 令 sourceText 为 MethodDefinition 匹配的源文本。
5. 令 closure 为 OrdinaryFunctionCreate(%Function.prototype%, sourceText, PropertySetParameterList, FunctionBody, NON-LEXICAL-THIS, env, privateEnv)。
6. 执行 MakeMethod(closure, object)。
7. 执行 SetFunctionName(closure, propKey, "set")。
8. 如果 propKey 是一个私有名称，则
  a. 返回 PrivateElement { [[Key]]: propKey, [[Kind]]: ACCESSOR, [[Get]]: undefined, [[Set]]: closure }。
9. 否则，
  a. 令 desc 为 PropertyDescriptor { [[Set]]: closure, [[Enumerable]]: enumerable, [[Configurable]]: true }。
  b. 执行 ? DefinePropertyOrThrow(object, propKey, desc)。
  c. 返回 UNUSED。

GeneratorMethod : * ClassElementName ( UniqueFormalParameters ) { GeneratorBody }
1. 令 propKey 为 ? Evaluation of ClassElementName。
2. 令 env 为运行执行上下文的 LexicalEnvironment。
3. 令 privateEnv 为运行执行上下文的 PrivateEnvironment。
4. 令 sourceText 为 GeneratorMethod 匹配的源文本。
5. 令 closure 为 OrdinaryFunctionCreate(%GeneratorFunction.prototype%, sourceText, UniqueFormalParameters, GeneratorBody, NON-LEXICAL-THIS, env, privateEnv)。
6. 执行 MakeMethod(closure, object)。
7. 执行 SetFunctionName(closure, propKey)。
8. 令 prototype 为 OrdinaryObjectCreate(%GeneratorFunction.prototype.prototype%)。
9. 执行 ! DefinePropertyOrThrow(closure, "prototype", PropertyDescriptor { [[Value]]: prototype, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false })。
10. 返回 ? DefineMethodProperty(object, propKey, closure, enumerable)。

AsyncGeneratorMethod : async * ClassElementName ( UniqueFormalParameters ) { AsyncGeneratorBody }
1. 令 propKey 为 ? Evaluation of ClassElementName。
2. 令 env 为运行执行上下文的 LexicalEnvironment。
3. 令 privateEnv 为运行执行上下文的 PrivateEnvironment。
4. 令 sourceText 为 AsyncGeneratorMethod 匹配的源文本。
5. 令 closure 为 OrdinaryFunctionCreate(%AsyncGeneratorFunction.prototype%, sourceText, UniqueFormalParameters, AsyncGeneratorBody, NON-LEXICAL-THIS, env, privateEnv)。
6. 执行 MakeMethod(closure, object)。
7. 执行 SetFunctionName(closure, propKey)。
8. 令 prototype 为 OrdinaryObjectCreate(%AsyncGeneratorFunction.prototype.prototype%)。
9. 执行 ! DefinePropertyOrThrow(closure, "prototype", PropertyDescriptor { [[Value]]: prototype, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false })。
10. 返回 ? DefineMethodProperty(object, propKey, closure, enumerable)。

AsyncMethod : async ClassElementName ( UniqueFormalParameters ) { AsyncFunctionBody }
1. 令 propKey 为 ? Evaluation of ClassElementName。
2. 令 env 为运行执行上下文的 LexicalEnvironment。
3. 令 privateEnv 为运行执行上下文的 PrivateEnvironment。
4. 令 sourceText 为 AsyncMethod 匹配的源文本。
5. 令 closure 为 OrdinaryFunctionCreate(%AsyncFunction.prototype%, sourceText, UniqueFormalParameters, AsyncFunctionBody, NON-LEXICAL-THIS, env, privateEnv)。
6. 执行 MakeMethod(closure, object)。
7. 执行 SetFunctionName(closure, propKey)。
8. 返回 ? DefineMethodProperty(object, propKey, closure, enumerable)。
```

**注意**：翻译保留了 ECMAScript 规范中的许多术语和结构，以确保技术准确性和清晰度。

### 15.5 生成器函数定义

#### 语法

```javascript
GeneratorDeclaration[Yield, Await, Default] :
  function * BindingIdentifier[?Yield, ?Await] ( FormalParameters[+Yield, ~Await] ) { GeneratorBody }
  [+Default] function * ( FormalParameters[+Yield, ~Await] ) { GeneratorBody }

GeneratorExpression :
  function * BindingIdentifier[+Yield, ~Await]opt ( FormalParameters[+Yield, ~Await] ) { GeneratorBody }

GeneratorMethod[Yield, Await] :
  * ClassElementName[?Yield, ?Await] ( UniqueFormalParameters[+Yield, ~Await] ) { GeneratorBody }

GeneratorBody :
  FunctionBody[+Yield, ~Await]

YieldExpression[In, Await] :
  yield
  yield [no LineTerminator here] AssignmentExpression[?In, +Yield, ?Await]
  yield [no LineTerminator here] * AssignmentExpression[?In, +Yield, ?Await]
```

#### 注释

1. `yield` 后立即跟随的语法上下文需要使用 `InputElementRegExpOrTemplateTail` 词法目标。
2. `YieldExpression` 不能在生成器函数的 `FormalParameters` 中使用，因为作为 `FormalParameters` 的一部分的任何表达式在生成的生成器处于可恢复状态之前都会被评估。
3. 与生成器相关的抽象操作定义在 27.5.3 中。

#### 15.5.1 静态语义：早期错误

```javascript
GeneratorMethod : * ClassElementName ( UniqueFormalParameters ) { GeneratorBody }
```
- 如果 `GeneratorMethod` 的 `HasDirectSuper` 为 true，则为语法错误。
- 如果 `UniqueFormalParameters` 包含 `YieldExpression`，则为语法错误。
- 如果 `GeneratorBody` 的 `FunctionBodyContainsUseStrict` 为 true 且 `UniqueFormalParameters` 的 `IsSimpleParameterList` 为 false，则为语法错误。
- 如果 `UniqueFormalParameters` 的 `BoundNames` 中的任何元素也出现在 `GeneratorBody` 的 `LexicallyDeclaredNames` 中，则为语法错误。

```javascript
GeneratorDeclaration :
  function * BindingIdentifier ( FormalParameters ) { GeneratorBody }
  function * ( FormalParameters ) { GeneratorBody }
GeneratorExpression :
  function * BindingIdentifieropt ( FormalParameters ) { GeneratorBody }
```
- 如果 `FormalParameters` 的 `IsStrict` 为 true，则应用 `UniqueFormalParameters` 的早期错误规则。
- 如果 `BindingIdentifier` 存在且其 `IsStrict` 为 true，则如果 `BindingIdentifier` 的 `StringValue` 是 "eval" 或 "arguments"，则为语法错误。
- 如果 `GeneratorBody` 的 `FunctionBodyContainsUseStrict` 为 true 且 `FormalParameters` 的 `IsSimpleParameterList` 为 false，则为语法错误。
- 如果 `FormalParameters` 的 `BoundNames` 中的任何元素也出现在 `GeneratorBody` 的 `LexicallyDeclaredNames` 中，则为语法错误。
- 如果 `FormalParameters` 包含 `YieldExpression`，则为语法错误。
- 如果 `FormalParameters` 包含 `SuperProperty`，则为语法错误。
- 如果 `GeneratorBody` 包含 `SuperProperty`，则为语法错误。
- 如果 `FormalParameters` 包含 `SuperCall`，则为语法错误。
- 如果 `GeneratorBody` 包含 `SuperCall`，则为语法错误。

#### 15.5.2 运行时语义：EvaluateGeneratorBody

语法定向操作 `EvaluateGeneratorBody` 接受参数 `functionObject`（一个 ECMAScript 函数对象）和 `argumentsList`（一个 ECMAScript 语言值的列表），并返回一个抛出完成或一个返回完成。它在以下生成式中分段定义：

```javascript
GeneratorBody : FunctionBody
1. 执行 ? FunctionDeclarationInstantiation(functionObject, argumentsList)。
2. 令 G 为 ? OrdinaryCreateFromConstructor(functionObject, "%GeneratorFunction.prototype.prototype%", « [[GeneratorState]], [[GeneratorContext]], [[GeneratorBrand]] »)。
3. 将 G.[[GeneratorBrand]] 设置为空。
4. 执行 GeneratorStart(G, FunctionBody)。
5. 返回 Completion Record { [[Type]]: RETURN, [[Value]]: G, [[Target]]: EMPTY }。
```

#### 15.5.3 运行时语义：InstantiateGeneratorFunctionObject

语法定向操作 `InstantiateGeneratorFunctionObject` 接受参数 `env`（一个环境记录）和 `privateEnv`（一个私有环境记录或 null），并返回一个 ECMAScript 函数对象。它在以下生成式中分段定义：

```javascript
GeneratorDeclaration : function * BindingIdentifier ( FormalParameters ) { GeneratorBody }
1. 令 name 为 `BindingIdentifier` 的 `StringValue`。
2. 令 sourceText 为 `GeneratorDeclaration` 匹配的源文本。
3. 令 F 为 OrdinaryFunctionCreate(%GeneratorFunction.prototype%, sourceText, FormalParameters, GeneratorBody, NON-LEXICAL-THIS, env, privateEnv)。
4. 执行 SetFunctionName(F, name)。
5. 令 prototype 为 OrdinaryObjectCreate(%GeneratorFunction.prototype.prototype%)。
6. 执行 ! DefinePropertyOrThrow(F, "prototype", PropertyDescriptor { [[Value]]: prototype, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false })。
7. 返回 F。

GeneratorDeclaration : function * ( FormalParameters ) { GeneratorBody }
1. 令 sourceText 为 `GeneratorDeclaration` 匹配的源文本。
2. 令 F 为 OrdinaryFunctionCreate(%GeneratorFunction.prototype%, sourceText, FormalParameters, GeneratorBody, NON-LEXICAL-THIS, env, privateEnv)。
3. 执行 SetFunctionName(F, "default")。
4. 令 prototype 为 OrdinaryObjectCreate(%GeneratorFunction.prototype.prototype%)。
5. 执行 ! DefinePropertyOrThrow(F, "prototype", PropertyDescriptor { [[Value]]: prototype, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false })。
6. 返回 F。
```

注释：匿名 `GeneratorDeclaration` 只能作为 `export default` 声明的一部分出现，因此其函数代码始终是严格模式代码。

#### 15.5.4 运行时语义：InstantiateGeneratorFunctionExpression

语法定向操作 `InstantiateGeneratorFunctionExpression` 接受可选参数 `name`（一个属性键或私有名称），并返回一个 ECMAScript 函数对象。它在以下生成式中分段定义：

```javascript
GeneratorExpression : function * ( FormalParameters ) { GeneratorBody }
1. 如果 `name` 不存在，设置 `name` 为 ""。
2. 令 `env` 为运行执行上下文的 `LexicalEnvironment`。
3. 令 `privateEnv` 为运行执行上下文的 `PrivateEnvironment`。
4. 令 `sourceText` 为 `GeneratorExpression` 匹配的源文本。
5. 令 `closure` 为 OrdinaryFunctionCreate(%GeneratorFunction.prototype%, sourceText, FormalParameters, GeneratorBody, NON-LEXICAL-THIS, env, privateEnv)。
6. 执行 SetFunctionName(closure, name)。
7. 令 `prototype` 为 OrdinaryObjectCreate(%GeneratorFunction.prototype.prototype%)。
8. 执行 ! DefinePropertyOrThrow(closure, "prototype", PropertyDescriptor { [[Value]]: prototype, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false })。
9. 返回 `closure`。

GeneratorExpression : function * BindingIdentifier ( FormalParameters ) { GeneratorBody }
1. 断言：`name` 不存在。
2. 设置 `name` 为 `BindingIdentifier` 的 `StringValue`。
3. 令 `outerEnv` 为运行执行上下文的 `LexicalEnvironment`。
4. 令 `funcEnv` 为 `NewDeclarativeEnvironment(outerEnv)`。
5. 执行 ! funcEnv.CreateImmutableBinding(name, false)。
6. 令 `privateEnv` 为运行执行上下文的 `PrivateEnvironment`。
7. 令 `sourceText` 为 `GeneratorExpression` 匹配的源文本。
8. 令 `closure` 为 OrdinaryFunctionCreate(%GeneratorFunction.prototype%, sourceText, FormalParameters, GeneratorBody, NON-LEXICAL-THIS, funcEnv, privateEnv)。
9. 执行 SetFunctionName(closure, name)。
10. 令 `prototype` 为 OrdinaryObjectCreate(%GeneratorFunction.prototype.prototype%)。
11. 执行 ! DefinePropertyOrThrow(closure, "prototype", PropertyDescriptor { [[Value]]: prototype, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false })。
12. 执行 ! funcEnv.InitializeBinding(name, closure)。
13. 返回 `closure`。
```

注释：在 `GeneratorExpression` 中，`BindingIdentifier` 可以从 `GeneratorExpression` 的 `FunctionBody` 内引用，以允许生成器代码递归调用自身。然而，与 `GeneratorDeclaration` 不同，`GeneratorExpression` 中的 `BindingIdentifier` 不能从包含 `GeneratorExpression` 的作用域引用，并且不会影响该作用域。

#### 15.5.5 运行时语义：Evaluation

```javascript
GeneratorExpression : function * BindingIdentifieropt ( FormalParameters ) { GeneratorBody }
1. 返回 `InstantiateGeneratorFunctionExpression` of `Generator

Expression`。

YieldExpression : yield
1. 返回 ? Yield(undefined)。

YieldExpression : yield AssignmentExpression
1. 令 `exprRef` 为 ? Evaluation of `AssignmentExpression`。
2. 令 `value` 为 ? GetValue(exprRef)。
3. 返回 ? Yield(value)。

YieldExpression : yield * AssignmentExpression
1. 令 `generatorKind` 为 `GetGeneratorKind()`。
2. 令 `exprRef` 为 ? Evaluation of `AssignmentExpression`。
3. 令 `value` 为 ? GetValue(exprRef)。
4. 令 `iteratorRecord` 为 ? GetIterator(value, `generatorKind`)。
5. 令 `iterator` 为 `iteratorRecord.[[Iterator]]`。
6. 令 `received` 为 `NormalCompletion(undefined)`。
7. 重复，
  a. 如果 `received` 是正常完成，
    i. 令 `innerResult` 为 ? Call(`iteratorRecord.[[NextMethod]]`, `iteratorRecord.[[Iterator]]`, « `received.[[Value]]` »)。
    ii. 如果 `generatorKind` 是 `ASYNC`，将 `innerResult` 设置为 ? Await(`innerResult`)。
    iii. 如果 `innerResult` 不是对象，则抛出 `TypeError` 异常。
    iv. 令 `done` 为 ? IteratorComplete(`innerResult`)。
    v. 如果 `done` 为 true，
      1. 返回 ? IteratorValue(`innerResult`)。
    vi. 如果 `generatorKind` 是 `ASYNC`，将 `received` 设置为 `Completion(AsyncGeneratorYield(? IteratorValue(innerResult)))`。
    vii. 否则，将 `received` 设置为 `Completion(GeneratorYield(innerResult))`。
  b. 否则，如果 `received` 是抛出完成，
    i. 令 `throw` 为 ? GetMethod(`iterator`, "throw")。
    ii. 如果 `throw` 未定义，
      1. 令 `innerResult` 为 ? Call(`throw`, `iterator`, « `received.[[Value]]` »)。
      2. 如果 `generatorKind` 是 `ASYNC`，将 `innerResult` 设置为 ? Await(`innerResult`)。
      3. 注释：来自内部迭代器 `throw` 方法的异常被传播。内部 `throw` 方法的正常完成类似于内部 `next` 处理。
      4. 如果 `innerResult` 不是对象，则抛出 `TypeError` 异常。
      5. 令 `done` 为 ? IteratorComplete(`innerResult`)。
      6. 如果 `done` 为 true，
        a. 返回 ? IteratorValue(`innerResult`)。
      7. 如果 `generatorKind` 是 `ASYNC`，将 `received` 设置为 `Completion(AsyncGeneratorYield(? IteratorValue(innerResult)))`。
      8. 否则，将 `received` 设置为 `Completion(GeneratorYield(innerResult))`。
    iii. 否则，
      1. 注释：如果 `iterator` 没有 `throw` 方法，这个抛出将终止 `yield*` 循环。但首先我们需要给 `iterator` 一个清理的机会。
      2. 令 `closeCompletion` 为 `Completion Record { [[Type]]: NORMAL, [[Value]]: EMPTY, [[Target]]: EMPTY }`。
      3. 如果 `generatorKind` 是 `ASYNC`，执行 ? AsyncIteratorClose(`iteratorRecord`, `closeCompletion`)。
      4. 否则，执行 ? IteratorClose(`iteratorRecord`, `closeCompletion`)。
      5. 注释：下一步抛出一个 `TypeError` 以指示存在 `yield*` 协议违规：`iterator` 没有 `throw` 方法。
      6. 抛出 `TypeError` 异常。
  c. 否则，
    i. 断言：`received` 是返回完成。
    ii. 令 `return` 为 ? GetMethod(`iterator`, "return")。
    iii. 如果 `return` 未定义，
      1. 将 `value` 设置为 `received.[[Value]]`。
      2. 如果 `generatorKind` 是 `ASYNC`，
        a. 将 `value` 设置为 ? Await(`value`)。
      3. 返回 `Completion Record { [[Type]]: RETURN, [[Value]]: value, [[Target]]: EMPTY }`。
    iv. 令 `innerReturnResult` 为 ? Call(`return`, `iterator`, « `received.[[Value]]` »)。
    v. 如果 `generatorKind` 是 `ASYNC`，将 `innerReturnResult` 设置为 ? Await(`innerReturnResult`)。
    vi. 如果 `innerReturnResult` 不是对象，则抛出 `TypeError` 异常。
    vii. 令 `done` 为 ? IteratorComplete(`innerReturnResult`)。
    viii. 如果 `done` 为 true，
      1. 将 `value` 设置为 ? IteratorValue(`innerReturnResult`)。
      2. 返回 `Completion Record { [[Type]]: RETURN, [[Value]]: value, [[Target]]: EMPTY }`。
    ix. 如果 `generatorKind` 是 `ASYNC`，将 `received` 设置为 `Completion(AsyncGeneratorYield(? IteratorValue(innerReturnResult)))`。
    x. 否则，将 `received` 设置为 `Completion(GeneratorYield(innerReturnResult))`。
```

### 15.6 异步生成器函数定义

#### 语法

```javascript
AsyncGeneratorDeclaration[Yield, Await, Default] :
  async [no LineTerminator here] function * BindingIdentifier[?Yield, ?Await] ( FormalParameters[+Yield, +Await] ) { AsyncGeneratorBody }
  [+Default] async [no LineTerminator here] function * ( FormalParameters[+Yield, +Await] ) { AsyncGeneratorBody }

AsyncGeneratorExpression :
  async [no LineTerminator here] function * BindingIdentifier[+Yield, +Await]opt ( FormalParameters[+Yield, +Await] ) { AsyncGeneratorBody }

AsyncGeneratorMethod[Yield, Await] :
  async [no LineTerminator here] * ClassElementName[?Yield, ?Await] ( UniqueFormalParameters[+Yield, +Await] ) { AsyncGeneratorBody }

AsyncGeneratorBody :
  FunctionBody[+Yield, +Await]
```

#### 注释

1. `YieldExpression` 和 `AwaitExpression` 不能在异步生成器函数的 `FormalParameters` 中使用，因为作为 `FormalParameters` 的一部分的任何表达式在生成的异步生成器处于可恢复状态之前都会被评估。
2. 与异步生成器相关的抽象操作定义在 27.6.3 中。

#### 15.6.1 静态语义：早期错误

```javascript
AsyncGeneratorMethod : async * ClassElementName ( UniqueFormalParameters ) { AsyncGeneratorBody }
```
- 如果 `AsyncGeneratorMethod` 的 `HasDirectSuper` 为 true，则为语法错误。
- 如果 `UniqueFormalParameters` 包含 `YieldExpression`，则为语法错误。
- 如果 `UniqueFormalParameters` 包含 `AwaitExpression`，则为语法错误。
- 如果 `AsyncGeneratorBody` 的 `FunctionBodyContainsUseStrict` 为 true 且 `UniqueFormalParameters` 的 `IsSimpleParameterList` 为 false，则为语法错误。
- 如果 `UniqueFormalParameters` 的 `BoundNames` 中的任何元素也出现在 `AsyncGeneratorBody` 的 `LexicallyDeclaredNames` 中，则为语法错误。

```javascript
AsyncGeneratorDeclaration :
  async function * BindingIdentifier ( FormalParameters ) { AsyncGeneratorBody }
  async function * ( FormalParameters ) { AsyncGeneratorBody }
AsyncGeneratorExpression :
  async function * BindingIdentifieropt ( FormalParameters ) { AsyncGeneratorBody }
```
- 如果 `FormalParameters` 的 `IsStrict` 为 true，则应用 `UniqueFormalParameters` 的早期错误规则。
- 如果 `BindingIdentifier` 存在且其 `IsStrict` 为 true，则如果 `BindingIdentifier` 的 `StringValue` 是 "eval" 或 "arguments"，则为语法错误。
- 如果 `AsyncGeneratorBody` 的 `FunctionBodyContainsUseStrict` 为 true 且 `FormalParameters` 的 `IsSimpleParameterList` 为 false，则为语法错误。
- 如果 `FormalParameters` 的 `BoundNames` 中的任何元素也出现在 `AsyncGeneratorBody` 的 `LexicallyDeclaredNames` 中，则为语法错误。
- 如果 `FormalParameters` 包含 `YieldExpression`，则为语法错误。
- 如果 `FormalParameters` 包含 `AwaitExpression`，则为语法错误。
- 如果 `FormalParameters` 包含 `SuperProperty`，则为语法错误。
- 如果 `AsyncGeneratorBody` 包含 `SuperProperty`，则为语法错误。
- 如果 `FormalParameters` 包含 `SuperCall`，则为语法错误。
- 如果 `AsyncGeneratorBody` 包含 `SuperCall`，则为语法错误。

#### 15.6.2 运行时语义：EvaluateAsyncGeneratorBody

语法定向操作 `EvaluateAsyncGeneratorBody` 接受参数 `functionObject`（一个 ECMAScript 函数对象）和 `argumentsList`（一个 ECMAScript 语言值的列表），并返回一个抛出完成或一个返回完成。它在以下生成式中分段定义：

```javascript
AsyncGeneratorBody

 : FunctionBody
1. 执行 ? FunctionDeclarationInstantiation(functionObject, argumentsList)。
2. 令 generator 为 ? OrdinaryCreateFromConstructor(functionObject, "%AsyncGeneratorFunction.prototype.prototype%", « [[AsyncGeneratorState]], [[AsyncGeneratorContext]], [[AsyncGeneratorQueue]], [[GeneratorBrand]] »)。
3. 将 generator.[[GeneratorBrand]] 设置为空。
4. 执行 AsyncGeneratorStart(generator, FunctionBody)。
5. 返回 Completion Record { [[Type]]: RETURN, [[Value]]: generator, [[Target]]: EMPTY }。
```

#### 15.6.3 运行时语义：InstantiateAsyncGeneratorFunctionObject

语法定向操作 `InstantiateAsyncGeneratorFunctionObject` 接受参数 `env`（一个环境记录）和 `privateEnv`（一个私有环境记录或 null），并返回一个 ECMAScript 函数对象。它在以下生成式中分段定义：

```javascript
AsyncGeneratorDeclaration : async function * BindingIdentifier ( FormalParameters ) { AsyncGeneratorBody }
1. 令 name 为 `BindingIdentifier` 的 `StringValue`。
2. 令 sourceText 为 `AsyncGeneratorDeclaration` 匹配的源文本。
3. 令 F 为 OrdinaryFunctionCreate(%AsyncGeneratorFunction.prototype%, sourceText, FormalParameters, AsyncGeneratorBody, NON-LEXICAL-THIS, env, privateEnv)。
4. 执行 SetFunctionName(F, name)。
5. 令 prototype 为 OrdinaryObjectCreate(%AsyncGeneratorFunction.prototype.prototype%)。
6. 执行 ! DefinePropertyOrThrow(F, "prototype", PropertyDescriptor { [[Value]]: prototype, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false })。
7. 返回 F。

AsyncGeneratorDeclaration : async function * ( FormalParameters ) { AsyncGeneratorBody }
1. 令 sourceText 为 `AsyncGeneratorDeclaration` 匹配的源文本。
2. 令 F 为 OrdinaryFunctionCreate(%AsyncGeneratorFunction.prototype%, sourceText, FormalParameters, AsyncGeneratorBody, NON-LEXICAL-THIS, env, privateEnv)。
3. 执行 SetFunctionName(F, "default")。
4. 令 prototype 为 OrdinaryObjectCreate(%AsyncGeneratorFunction.prototype.prototype%)。
5. 执行 ! DefinePropertyOrThrow(F, "prototype", PropertyDescriptor { [[Value]]: prototype, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false })。
6. 返回 F。
```

注释：匿名 `AsyncGeneratorDeclaration` 只能作为 `export default` 声明的一部分出现。

#### 15.6.4 运行时语义：InstantiateAsyncGeneratorFunctionExpression

语法定向操作 `InstantiateAsyncGeneratorFunctionExpression` 接受可选参数 `name`（一个属性键或私有名称），并返回一个 ECMAScript 函数对象。它在以下生成式中分段定义：

```javascript
AsyncGeneratorExpression : async function * ( FormalParameters ) { AsyncGeneratorBody }
1. 如果 `name` 不存在，设置 `name` 为 ""。
2. 令 `env` 为运行执行上下文的 `LexicalEnvironment`。
3. 令 `privateEnv` 为运行执行上下文的 `PrivateEnvironment`。
4. 令 `sourceText` 为 `AsyncGeneratorExpression` 匹配的源文本。
5. 令 `closure` 为 OrdinaryFunctionCreate(%AsyncGeneratorFunction.prototype%, sourceText, FormalParameters, AsyncGeneratorBody, NON-LEXICAL-THIS, env, privateEnv)。
6. 执行 SetFunctionName(closure, name)。
7. 令 `prototype` 为 OrdinaryObjectCreate(%AsyncGeneratorFunction.prototype.prototype%)。
8. 执行 ! DefinePropertyOrThrow(closure, "prototype", PropertyDescriptor { [[Value]]: prototype, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false })。
9. 返回 `closure`。

AsyncGeneratorExpression : async function * BindingIdentifier ( FormalParameters ) { AsyncGeneratorBody }
1. 断言：`name` 不存在。
2. 设置 `name` 为 `BindingIdentifier` 的 `StringValue`。
3. 令 `outerEnv` 为运行执行上下文的 `LexicalEnvironment`。
4. 令 `funcEnv` 为 `NewDeclarativeEnvironment(outerEnv)`。
5. 执行 ! funcEnv.CreateImmutableBinding(name, false)。
6. 令 `privateEnv` 为运行执行上下文的 `PrivateEnvironment`。
7. 令 `sourceText` 为 `AsyncGeneratorExpression` 匹配的源文本。
8. 令 `closure` 为 OrdinaryFunctionCreate(%AsyncGeneratorFunction.prototype%, sourceText, FormalParameters, AsyncGeneratorBody, NON-LEXICAL-THIS, funcEnv, privateEnv)。
9. 执行 SetFunctionName(closure, name)。
10. 令 `prototype` 为 OrdinaryObjectCreate(%AsyncGeneratorFunction.prototype.prototype%)。
11. 执行 ! DefinePropertyOrThrow(closure, "prototype", PropertyDescriptor { [[Value]]: prototype, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false })。
12. 执行 ! funcEnv.InitializeBinding(name, closure)。
13. 返回 `closure`。
```

注释：在 `AsyncGeneratorExpression` 中，`BindingIdentifier` 可以从 `AsyncGeneratorExpression` 的 `AsyncGeneratorBody` 内引用，以允许生成器代码递归调用自身。然而，与 `AsyncGeneratorDeclaration` 不同，`AsyncGeneratorExpression` 中的 `BindingIdentifier` 不能从包含 `AsyncGeneratorExpression` 的作用域引用，并且不会影响该作用域。

#### 15.6.5 运行时语义：Evaluation

```javascript
AsyncGeneratorExpression : async function * BindingIdentifieropt ( FormalParameters ) { AsyncGeneratorBody }
1. 返回 `InstantiateAsyncGeneratorFunctionExpression` of `AsyncGeneratorExpression`。
```

### 15.7 类定义

#### 语法

```javascript
ClassDeclaration[Yield, Await, Default] :
  class BindingIdentifier[?Yield, ?Await] ClassTail[?Yield, ?Await]
  [+Default] class ClassTail[?Yield, ?Await]

ClassExpression[Yield, Await] :
  class BindingIdentifier[?Yield, ?Await]opt ClassTail[?Yield, ?Await]

ClassTail[Yield, Await] :
  ClassHeritage[?Yield, ?Await]opt { ClassBody[?Yield, ?Await]opt }

ClassHeritage[Yield, Await] :
  extends LeftHandSideExpression[?Yield, ?Await]

ClassBody[Yield, Await] :
  ClassElementList[?Yield, ?Await]

ClassElementList[Yield, Await] :
  ClassElement[?Yield, ?Await]
  ClassElementList[?Yield, ?Await] ClassElement[?Yield, ?Await]

ClassElement[Yield, Await] :
  MethodDefinition[?Yield, ?Await]
  static MethodDefinition[?Yield, ?Await]
  FieldDefinition[?Yield, ?Await] ;
  static FieldDefinition[?Yield, ?Await] ;
  ClassStaticBlock
  ;

FieldDefinition[Yield, Await] :
  ClassElementName[?Yield, ?Await] Initializer[+In, ?Yield, ?Await]opt

ClassElementName[Yield, Await] :
  PropertyName[?Yield, ?Await]
  PrivateIdentifier

ClassStaticBlock :
  static { ClassStaticBlockBody }

ClassStaticBlockBody :
  ClassStaticBlockStatementList

ClassStaticBlockStatementList :
  StatementList[~Yield, +Await, ~Return]opt
```

注释：类定义始终是严格模式代码。

#### 15.7.1 静态语义：早期错误

```javascript
ClassTail : ClassHeritageopt { ClassBody }
```
- 如果 `ClassHeritage` 不存在，并且以下算法返回 true，则为语法错误：
  1. 令 `constructor` 为 `ClassBody` 的 `ConstructorMethod`。
  2. 如果 `constructor` 为 `EMPTY`，则返回 `false`。
  3. 返回 `constructor` 的 `HasDirectSuper`。

```javascript
ClassBody : ClassElementList
```
- 如果 `ClassElementList` 的 `PrototypePropertyNameList` 包含多于一次的 "constructor" 出现，则为语法错误。
- 如果 `ClassElementList` 的 `PrivateBoundIdentifiers` 包含任何重复条目，除非名称一次用于 getter，一次用于 setter，并且没有其他条目，并且 getter 和 setter 要么都是静态的，要么都是非静态的，则为语法错误。

```javascript
ClassElement : MethodDefinition
```
- 如果 `MethodDefinition` 的 `PropName` 不是 "constructor" 且 `MethodDefinition` 的 `HasDirectSuper` 为 true，则为语法错误。
- 如果 `MethodDefinition` 的 `PropName` 是 "constructor" 且 `MethodDefinition` 的 `SpecialMethod` 为 true，则为语法错误。

```javascript
ClassElement : static MethodDefinition
```
- 如果 `MethodDefinition` 的 `HasDirectSuper` 为 true，则为语法错误。
- 如果 `MethodDefinition` 的 `PropName` 是 "prototype"，则为语法错误。

```javascript
ClassElement : FieldDefinition ;
```
- 如果 `FieldDefinition` 的 `PropName` 是 "constructor"，则为语法错误。

```javascript
ClassElement : static FieldDefinition ;
```
- 如果 `FieldDefinition` 的 `PropName` 是 "prototype" 或 "constructor"，则为语法错误。

```javascript
FieldDefinition :
  ClassElementName Initializeropt
```
- 如果 `Initializer` 存在且 `Initializer` 的 `ContainsArguments` 为 true，则为语法错误。
- 如果 `Initializer` 存在且 `Initializer` 的 `ContainsSuperCall` 为 true，则为语法错误。

```javascript
ClassElementName : PrivateIdentifier
```
- 如果 `PrivateIdentifier` 的 `StringValue` 是 "#constructor"，则为语法错误。

```javascript
ClassStaticBlockBody : ClassStaticBlockStatementList
```
- 如果 `ClassStaticBlockStatementList` 的 `LexicallyDeclaredNames` 包含任何重复条目，则为语法错误。
- 如果 `ClassStaticBlockStatementList` 的 `LexicallyDeclaredNames` 的任何元素也出现在 `ClassStaticBlockStatementList` 的 `VarDeclaredNames` 中，则为语法错误。
- 如果 `ClassStaticBlockStatementList` 的 `ContainsDuplicateLabels` 为 true，则为语法错误。
- 如果 `ClassStaticBlockStatementList` 的 `ContainsUndefinedBreakTarget` 为 true，则为语法错误。
- 如果 `ClassStaticBlockStatementList` 的 `ContainsUndefinedContinueTarget` 为 true，则为语法错误。
- 如果 `ClassStaticBlockStatementList` 的 `ContainsArguments` 为 true，则为语法错误。
- 如果 `ClassStaticBlockStatementList` 的 `ContainsSuperCall` 为 true，则为语法错误。
- 如果 `ClassStaticBlockStatementList` 的 `ContainsAwait` 为 true，则为语法错误。

#### 15.7.2 静态语义：ClassElementKind

语法定向操作 `ClassElementKind` 不接受参数并返回 `CONSTRUCTOR-METHOD`、`NON-CONSTRUCTOR-METHOD` 或 `EMPTY`。它在以下生成式中分段定义：

```javascript
ClassElement : MethodDefinition
```
1. 如果 `MethodDefinition` 的 `PropName` 是 "constructor"，返回 `CONSTRUCTOR-METHOD`。
2. 返回 `NON-CONSTRUCTOR-METHOD`。

```javascript
ClassElement :
  static MethodDefinition
  FieldDefinition ;
  static FieldDefinition ;
```
1. 返回 `NON-CONSTRUCTOR-METHOD`。

```javascript
ClassElement : ClassStaticBlock
```
1. 返回 `NON-CONSTRUCTOR-METHOD`。

```javascript
ClassElement : ;
```
1. 返回 `EMPTY`。

#### 15.7.3 静态语义：ConstructorMethod

语法定向操作 `ConstructorMethod` 不接受参数并返回一个 `ClassElement` 解析节点或 `EMPTY`。它在以下生成式中分段定义：

```javascript
ClassElementList : ClassElement
```
1. 如果 `ClassElement` 的 `ClassElementKind` 是 `CONSTRUCTOR-METHOD`，返回 `ClassElement`。
2. 返回 `EMPTY`。

```javascript
ClassElementList : ClassElementList ClassElement
```
1. 令 `head` 为 `ClassElementList` 的 `ConstructorMethod`。
2. 如果 `head` 不是 `EMPTY`，返回 `head`。
3. 如果 `ClassElement` 的 `ClassElementKind` 是 `CONSTRUCTOR-METHOD`，返回 `ClassElement`。
4. 返回 `EMPTY`。

注释：早期错误规则确保只有一个名为 "constructor" 的方法定义，并且它不是访问器属性或生成器定义。

#### 15.7.4 静态语义：IsStatic

语法定向操作 `IsStatic` 不接受参数并返回布尔值。它在以下生成式中分段定义：

```javascript
ClassElement : MethodDefinition
```
1. 返回 `false`。

```javascript
ClassElement : static MethodDefinition
```
1. 返回 `true`。

```javascript
ClassElement : FieldDefinition ;
```
1. 返回 `false`。

```javascript
ClassElement : static FieldDefinition ;
```
1. 返回 `true`。

```javascript
ClassElement : ClassStaticBlock
```
1. 返回 `true`。

```javascript
ClassElement : ;
```
1. 返回 `false`。

#### 15.7.5 静态语义：NonConstructorElements

语法定向操作 `NonConstructorElements` 不接受参数并返回一个 `ClassElement` 解析节点的列表。它在以下生成式中分段定义：

```javascript
ClassElementList : ClassElement
```
1. 如果 `ClassElement` 的 `ClassElementKind` 是 `NON-CONSTRUCTOR-METHOD`，
  a. 返回 « `ClassElement` »。
2. 返回一个新的空列表。

```javascript
ClassElementList : ClassElementList ClassElement
```
1. 令 `list` 为 `ClassElementList` 的 `NonConstructorElements`。
2. 如果 `ClassElement` 的 `ClassElementKind` 是 `NON-CONSTRUCTOR-METHOD`，
  a. 将 `ClassElement` 添加到 `list` 的末尾。
3. 返回 `list`。

#### 15.7.6 静态语义：PrototypePropertyNameList

语法定向操作 `PrototypePropertyNameList` 不接受参数并返回一个属性键的列表。它在以下生成式中分段定义：

```javascript
ClassElementList : ClassElement
```
1. 令 `propName` 为 `ClassElement` 的 `PropName`。
2. 如果 `propName` 是 `EMPTY`，返回一个新的空列表。
3. 如果 `ClassElement` 的 `IsStatic` 为 true，返回一个新的空列表。
4. 返回 « `propName` »。

```javascript
ClassElementList : ClassElementList ClassElement
```
1. 令 `list` 为 `ClassElementList` 的 `PrototypePropertyNameList`。
2. 令 `propName` 为 `ClassElement` 的 `PropName`。
3. 如果 `propName` 是 `EMPTY`，返回 `list`

。
4. 如果 `ClassElement` 的 `IsStatic` 为 true，返回 `list`。
5. 返回 `list` 和 « `propName` » 的列表连接。

#### 15.7.7 静态语义：AllPrivateIdentifiersValid

语法定向操作 `AllPrivateIdentifiersValid` 接受参数 `names`（一个字符串列表）并返回布尔值。

在此规范中未列出的每个语法生成式替代隐式具有以下 `AllPrivateIdentifiersValid` 的默认定义：

1. 对于此解析节点的每个子节点 `child`，执行：
  a. 如果 `child` 是非终结符的一个实例，则
    i. 如果 `child` 的 `AllPrivateIdentifiersValid` 参数为 `names` 为 false，返回 false。
2. 返回 true。

```javascript
MemberExpression : MemberExpression . PrivateIdentifier
```
1. 如果 `names` 包含 `PrivateIdentifier` 的 `StringValue`，
  a. 返回 `MemberExpression` 的 `AllPrivateIdentifiersValid` 参数为 `names`。

```javascript
CallExpression : CallExpression . PrivateIdentifier
```
1. 如果 `names` 包含 `PrivateIdentifier` 的 `StringValue`，
  a. 返回 `CallExpression` 的 `AllPrivateIdentifiersValid` 参数为 `names`。

```javascript
OptionalChain : ?. PrivateIdentifier
```
1. 如果 `names` 包含 `PrivateIdentifier` 的 `StringValue`，返回 true。

```javascript
OptionalChain : OptionalChain . PrivateIdentifier
```
1. 如果 `names` 包含 `PrivateIdentifier` 的 `StringValue`，
  a. 返回 `OptionalChain` 的 `AllPrivateIdentifiersValid` 参数为 `names`。

```javascript
ClassBody : ClassElementList
```
1. 令 `newNames` 为 `names` 和 `ClassBody` 的 `PrivateBoundIdentifiers` 的列表连接。
2. 返回 `ClassElementList` 的 `AllPrivateIdentifiersValid` 参数为 `newNames`。

```javascript
RelationalExpression : PrivateIdentifier in ShiftExpression
```
1. 如果 `names` 包含 `PrivateIdentifier` 的 `StringValue`，
  a. 返回 `ShiftExpression` 的 `AllPrivateIdentifiersValid` 参数为 `names`。

#### 15.7.8 静态语义：PrivateBoundIdentifiers

语法定向操作 `PrivateBoundIdentifiers` 不接受参数并返回字符串列表。它在以下生成式中分段定义：

```javascript
FieldDefinition : ClassElementName Initializeropt
```
1. 返回 `ClassElementName` 的 `PrivateBoundIdentifiers`。

```javascript
ClassElementName : PrivateIdentifier
```
1. 返回一个唯一元素为 `PrivateIdentifier` 的 `StringValue` 的列表。

```javascript
ClassElementName :
  PropertyName
```
- 无操作

```javascript
ClassElement :
  ClassStaticBlock
  ;
```
1. 返回一个新的空列表。

```javascript
ClassElementList : ClassElementList ClassElement
```
1. 令 `names1` 为 `ClassElementList` 的 `PrivateBoundIdentifiers`。
2. 令 `names2` 为 `ClassElement` 的 `PrivateBoundIdentifiers`。
3. 返回 `names1` 和 `names2` 的列表连接。

```javascript
MethodDefinition :
  ClassElementName ( UniqueFormalParameters ) { FunctionBody }
  get ClassElementName ( ) { FunctionBody }
  set ClassElementName ( PropertySetParameterList ) { FunctionBody }
GeneratorMethod :
  * ClassElementName ( UniqueFormalParameters ) { GeneratorBody }
AsyncMethod :
  async ClassElementName ( UniqueFormalParameters ) { AsyncFunctionBody }
AsyncGeneratorMethod :
  async * ClassElementName ( UniqueFormalParameters ) { AsyncGeneratorBody }
```
1. 返回 `ClassElementName` 的 `PrivateBoundIdentifiers`。

#### 15.7.9 静态语义：ContainsArguments

语法定向操作 `ContainsArguments` 不接受参数并返回布尔值。

在此规范中未列出的每个语法生成式替代隐式具有以下 `ContainsArguments` 的默认定义：

1. 对于此解析节点的每个子节点 `child`，执行：
  a. 如果 `child` 是非终结符的一个实例，则
    i. 如果 `child` 的 `ContainsArguments` 为 true，返回 true。
2. 返回 false。

```javascript
IdentifierReference : Identifier
```
1. 如果 `Identifier` 的 `StringValue` 是 "arguments"，返回 true。
2. 返回 false。

```javascript
FunctionDeclaration :
  function BindingIdentifier ( FormalParameters ) { FunctionBody }
  function ( FormalParameters ) { FunctionBody }
FunctionExpression :
  function BindingIdentifieropt ( FormalParameters ) { FunctionBody }
GeneratorDeclaration :
  function * BindingIdentifier ( FormalParameters ) { GeneratorBody }
  function * ( FormalParameters ) { GeneratorBody }
GeneratorExpression :
  function * BindingIdentifieropt ( FormalParameters ) { GeneratorBody }
AsyncGeneratorDeclaration :
  async function * BindingIdentifier ( FormalParameters ) { AsyncGeneratorBody }
  async function * ( FormalParameters ) { AsyncGeneratorBody }
AsyncGeneratorExpression :
  async function * BindingIdentifieropt ( FormalParameters ) { AsyncGeneratorBody }
AsyncFunctionDeclaration :
  async function BindingIdentifier ( FormalParameters ) { AsyncFunctionBody }
  async function ( FormalParameters ) { AsyncFunctionBody }
AsyncFunctionExpression :
  async function BindingIdentifieropt ( FormalParameters ) { AsyncFunctionBody }
```
1. 返回 false。

```javascript
MethodDefinition :
  ClassElementName ( UniqueFormalParameters ) { FunctionBody }
  get ClassElementName ( ) { FunctionBody }
  set ClassElementName ( PropertySetParameterList ) { FunctionBody }
GeneratorMethod :
  * ClassElementName ( UniqueFormalParameters ) { GeneratorBody }
AsyncGeneratorMethod :
  async * ClassElementName ( UniqueFormalParameters ) { AsyncGeneratorBody }
AsyncMethod :
  async ClassElementName ( UniqueFormalParameters ) { AsyncFunctionBody }
```
1. 返回 `ClassElementName` 的 `ContainsArguments`。

#### 15.7.10 运行时语义：ClassFieldDefinitionEvaluation

语法定向操作 `ClassFieldDefinitionEvaluation` 接受参数 `homeObject`（一个对象）并返回包含 `ClassFieldDefinition` 记录或一个突然完成的正常完成。它在以下生成式中分段定义：

```javascript
FieldDefinition : ClassElementName Initializeropt
```
1. 令 `name` 为 ? `ClassElementName` 的求值。
2. 如果 `Initializer` 存在，
  a. 令 `formalParameterList` 为生成式 `FormalParameters : [empty]` 的一个实例。
  b. 令 `env` 为运行执行上下文的 `LexicalEnvironment`。
  c. 令 `privateEnv` 为运行执行上下文的 `PrivateEnvironment`。
  d. 令 `sourceText` 为 Unicode 代码点的空序列。
  e. 令 `initializer` 为 `OrdinaryFunctionCreate(%Function.prototype%, sourceText, formalParameterList, Initializer, NON-LEXICAL-THIS, env, privateEnv)`。
  f. 执行 `MakeMethod(initializer, homeObject)`。
  g. 设置 `initializer.[[ClassFieldInitializerName]]` 为 `name`。
3. 否则，
  a. 令 `initializer` 为 `EMPTY`。
4. 返回 `ClassFieldDefinition` 记录 { [[Name]]: `name`, [[Initializer]]: `initializer` }。

注释：为 `initializer` 创建的函数永远不能直接访问 ECMAScript 代码。

#### 15.7.11 运行时语义：ClassStaticBlockDefinitionEvaluation

语法定向操作 `ClassStaticBlockDefinitionEvaluation` 接受参数 `homeObject`（一个对象）并返回 `ClassStaticBlockDefinition` 记录。它在以下生成式中分段定义：

```javascript
ClassStaticBlock : static { ClassStaticBlockBody }
```
1. 令 `lex` 为运行执行上下文的 `LexicalEnvironment`。
2. 令 `privateEnv` 为运行执行上下文的 `PrivateEnvironment`。
3. 令 `sourceText` 为 Unicode 代码点的空序列。
4. 令 `formalParameters` 为生成式 `FormalParameters : [empty]` 的一个实例。
5. 令 `bodyFunction` 为 `OrdinaryFunctionCreate(%Function.prototype%, sourceText, formalParameters, ClassStaticBlockBody, NON-LEXICAL-THIS, lex, privateEnv)`。
6. 执行 `MakeMethod(bodyFunction, homeObject)`。
7. 返回 `ClassStaticBlockDefinition` 记录 { [[BodyFunction]]: `bodyFunction` }。

注释：函数 `bodyFunction` 永远不能直接访问 ECMAScript 代码。

#### 15.7.12 运行时语义：EvaluateClassStaticBlockBody

语法定向操作 `EvaluateClassStaticBlockBody` 接受参数 `functionObject`（一个 ECMAScript 函数对象）并返回包含 ECMAScript 语言值或突然完成的正常完成。它在以下生成式中分段定义：

```javascript
ClassStaticBlockBody : ClassStaticBlockStatementList
```
1. 断言：`functionObject` 是由 `ClassStaticBlockDefinitionEvaluation` 步骤 5 创建的合成函数。
2. 执行 ! `FunctionDeclarationInstantiation(functionObject, « »)`。
3. 返回 ? `ClassStaticBlockStatementList` 的求值。

#### 15.7.13 运行时语义：ClassElementEvaluation



语法定向操作 `ClassElementEvaluation` 接受参数 `object`（一个对象）并返回包含 `ClassFieldDefinition` 记录、`ClassStaticBlockDefinition` 记录、`PrivateElement` 或 `UNUSED` 的正常完成，或突然完成。它在以下生成式中分段定义：

```javascript
ClassElement :
  FieldDefinition ;
  static FieldDefinition ;
```
1. 返回 ? `ClassFieldDefinitionEvaluation`，参数为 `FieldDefinition` 和 `object`。

```javascript
ClassElement :
  MethodDefinition
  static MethodDefinition
```
1. 返回 ? `MethodDefinitionEvaluation`，参数为 `MethodDefinition` 和 `object` 和 `false`。

```javascript
ClassElement : ClassStaticBlock
```
1. 返回 `ClassStaticBlock` 的 `ClassStaticBlockDefinitionEvaluation`，参数为 `object`。

```javascript
ClassElement : ;
```
1. 返回 `UNUSED`。

#### 15.7.14 运行时语义：ClassDefinitionEvaluation

语法定向操作 `ClassDefinitionEvaluation` 接受参数 `classBinding`（一个字符串或未定义）和 `className`（一个属性键或私有名称）并返回包含函数对象的正常完成或突然完成。

注释：为了便于规范，私有方法和访问器与私有字段一起包含在类实例的 `[[PrivateElements]]` 插槽中。然而，任何给定对象都有该类定义的所有或无私有方法和访问器。此功能设计为实现可以选择使用不需要单独跟踪每个方法或访问器的策略来实现私有方法和访问器。

例如，实现可以直接将实例私有方法与其对应的私有名称关联，并为每个对象跟踪哪些类构造函数已使用该对象作为其 `this` 值运行。然后，在对象上查找实例私有方法的过程包括检查定义方法的类构造函数是否已用于初始化对象，然后返回与私有名称关联的方法。

这与私有字段不同：由于字段初始化器在类实例化期间可能抛出异常，因此单个对象可能具有给定类的某些私有字段的适当子集，因此一般必须单独跟踪私有字段。

它在以下生成式中分段定义：

```javascript
ClassTail : ClassHeritageopt { ClassBodyopt }
```
1. 令 `env` 为运行执行上下文的 `LexicalEnvironment`。
2. 令 `classEnv` 为 `NewDeclarativeEnvironment(env)`。
3. 如果 `classBinding` 不是 `undefined`，
  a. 执行 ! `classEnv.CreateImmutableBinding(classBinding, true)`。
4. 令 `outerPrivateEnvironment` 为运行执行上下文的 `PrivateEnvironment`。
5. 令 `classPrivateEnvironment` 为 `NewPrivateEnvironment(outerPrivateEnvironment)`。
6. 如果 `ClassBody` 存在，
  a. 对于 `ClassBody` 的 `PrivateBoundIdentifiers` 的每个字符串 `dn`，
    i. 如果 `classPrivateEnvironment.[[Names]]` 包含一个私有名称 `pn`，且 `pn.[[Description]]` 是 `dn`，
      1. 断言：这仅可能用于 getter/setter 对。
    ii. 否则，
      1. 令 `name` 为新的私有名称，其 `[[Description]]` 是 `dn`。
      2. 将 `name` 添加到 `classPrivateEnvironment.[[Names]]`。
7. 如果 `ClassHeritage` 不存在，
  a. 令 `protoParent` 为 `%Object.prototype%`。
  b. 令 `constructorParent` 为 `%Function.prototype%`。
8. 否则，
  a. 将运行执行上下文的 `LexicalEnvironment` 设置为 `classEnv`。
  b. 注释：评估 `ClassHeritage` 时，运行执行上下文的 `PrivateEnvironment` 是 `outerPrivateEnvironment`。
  c. 令 `superclassRef` 为 `ClassHeritage` 的完成求值。
  d. 将运行执行上下文的 `LexicalEnvironment` 设置为 `env`。
  e. 令 `superclass` 为 ? `GetValue(? superclassRef)`。
  f. 如果 `superclass` 为 `null`，
    i. 令 `protoParent` 为 `null`。
    ii. 令 `constructorParent` 为 `%Function.prototype%`。
  g. 否则如果 `IsConstructor(superclass)` 为 `false`，
    i. 抛出一个 `TypeError` 异常。
  h. 否则，
    i. 令 `protoParent` 为 ? `Get(superclass, "prototype")`。
    ii. 如果 `protoParent` 不是一个对象且不是 `null`，抛出一个 `TypeError` 异常。
    iii. 令 `constructorParent` 为 `superclass`。
9. 令 `proto` 为 `OrdinaryObjectCreate(protoParent)`。
10. 如果 `ClassBody` 不存在，令 `constructor` 为 `EMPTY`。
11. 否则，令 `constructor` 为 `ClassBody` 的 `ConstructorMethod`。
12. 将运行执行上下文的 `LexicalEnvironment` 设置为 `classEnv`。
13. 将运行执行上下文的 `PrivateEnvironment` 设置为 `classPrivateEnvironment`。
14. 如果 `constructor` 为 `EMPTY`，
  a. 令 `defaultConstructor` 为一个新的抽象闭包，没有参数，捕获无内容，执行以下步骤：
    i. 令 `args` 为通过 `[[Call]]` 或 `[[Construct]]` 传递给此函数的参数列表。
    ii. 如果 `NewTarget` 为 `undefined`，抛出一个 `TypeError` 异常。
    iii. 令 `F` 为活动函数对象。
    iv. 如果 `F.[[ConstructorKind]]` 是 `DERIVED`，
      1. 注释：此分支的行为类似于 `constructor(...args) { super(...args); }`。最显著的区别是，虽然上述 ECMAScript 源代码可观察地调用 `%Array.prototype%` 的 `@@iterator` 方法，但此函数不会。
      2. 令 `func` 为 ! `F.[[GetPrototypeOf]]()`。
      3. 如果 `func` 不是构造函数，抛出一个 `TypeError` 异常。
      4. 令 `result` 为 ? `Construct(func, args, NewTarget)`。
    v. 否则，
      1. 注释：此分支的行为类似于 `constructor() {}`。
      2. 令 `result` 为 ? `OrdinaryCreateFromConstructor(NewTarget, "%Object.prototype%")`。
    vi. 执行 ? `InitializeInstanceElements(result, F)`。
    vii. 返回 `result`。
  b. 令 `F` 为 `CreateBuiltinFunction(defaultConstructor, 0, className, « [[ConstructorKind]], [[SourceText]] », 当前 Realm 记录, constructorParent)`。
15. 否则，
  a. 令 `constructorInfo` 为 ! `DefineMethod(constructor, proto, constructorParent)`。
  b. 令 `F` 为 `constructorInfo.[[Closure]]`。
  c. 执行 `MakeClassConstructor(F)`。
  d. 执行 `SetFunctionName(F, className)`。
16. 执行 `MakeConstructor(F, false, proto)`。
17. 如果 `ClassHeritage` 存在，设置 `F.[[ConstructorKind]]` 为 `DERIVED`。
18. 执行 ! `DefineMethodProperty(proto, "constructor", F, false)`。
19. 如果 `ClassBody` 不存在，令 `elements` 为一个新的空列表。
20. 否则，令 `elements` 为 `ClassBody` 的 `NonConstructorElements`。
21. 令 `instancePrivateMethods` 为一个新的空列表。
22. 令 `staticPrivateMethods` 为一个新的空列表。
23. 令 `instanceFields` 为一个新的空列表。
24. 令 `staticElements` 为一个新的空列表。
25. 对于 `elements` 的每个 `ClassElement` e，执行
  a. 如果 `e` 的 `IsStatic` 为 `false`，
    i. 令 `element` 为 `Completion(ClassElementEvaluation(e, proto))`。
  b. 否则，
    i. 令 `element` 为 `Completion(ClassElementEvaluation(e, F))`。
  c. 如果 `element` 是突然完成，
    i. 将运行执行上下文的 `LexicalEnvironment` 设置为 `env`。
    ii. 将运行执行上下文的 `PrivateEnvironment` 设置为 `outerPrivateEnvironment`。
    iii. 返回 ? `element`。
  d. 将 `element` 设置为 ! `element`。
  e. 如果 `element` 是 `PrivateElement`，
    i. 断言：`element.[[Kind]]` 是 `METHOD` 或 `ACCESSOR`。
    ii. 如果 `e` 的 `IsStatic` 为 `false`，令 `container` 为 `instancePrivateMethods`。
    iii. 否则，令 `container` 为 `staticPrivateMethods`。
    iv. 如果 `container` 包含一个 `PrivateElement` pe，其 `[[Key]]` 为 `element.[[Key]]`，
      1

. 断言：`element.[[Kind]]` 和 `pe.[[Kind]]` 都是 `ACCESSOR`。
      2. 如果 `element.[[Get]]` 是 `undefined`，
        a. 令 `combined` 为 `PrivateElement { [[Key]]: element.[[Key]], [[Kind]]: ACCESSOR, [[Get]]: pe.[[Get]], [[Set]]: element.[[Set]] }`。
      3. 否则，
        a. 令 `combined` 为 `PrivateElement { [[Key]]: element.[[Key]], [[Kind]]: ACCESSOR, [[Get]]: element.[[Get]], [[Set]]: pe.[[Set]] }`。
      4. 用 `combined` 替换 `container` 中的 `pe`。
    v. 否则，
      1. 将 `element` 添加到 `container`。
  f. 否则如果 `element` 是 `ClassFieldDefinition` 记录，
    i. 如果 `e` 的 `IsStatic` 为 `false`，将 `element` 添加到 `instanceFields`。
    ii. 否则，将 `element` 添加到 `staticElements`。
  g. 否则如果 `element` 是 `ClassStaticBlockDefinition` 记录，
    i. 将 `element` 添加到 `staticElements`。
26. 将运行执行上下文的 `LexicalEnvironment` 设置为 `env`。
27. 如果 `classBinding` 不是 `undefined`，
  a. 执行 ! `classEnv.InitializeBinding(classBinding, F)`。
28. 设置 `F.[[PrivateMethods]]` 为 `instancePrivateMethods`。
29. 设置 `F.[[Fields]]` 为 `instanceFields`。
30. 对于 `staticPrivateMethods` 的每个 `PrivateElement` 方法，
  a. 执行 ! `PrivateMethodOrAccessorAdd(F, method)`。
31. 对于 `staticElements` 的每个 `ClassFieldDefinition` 记录 `elementRecord`，
  a. 如果 `elementRecord` 是 `ClassFieldDefinition` 记录，
    i. 令 `result` 为 `Completion(DefineField(F, elementRecord))`。
  b. 否则，
    i. 断言：`elementRecord` 是 `ClassStaticBlockDefinition` 记录。
    ii. 令 `result` 为 `Completion(Call(elementRecord.[[BodyFunction]], F))`。
  c. 如果 `result` 是突然完成，
    i. 将运行执行上下文的 `PrivateEnvironment` 设置为 `outerPrivateEnvironment`。
    ii. 返回 ? `result`。
32. 将运行执行上下文的 `PrivateEnvironment` 设置为 `outerPrivateEnvironment`。
33. 返回 `F`。

#### 15.7.15 运行时语义：BindingClassDeclarationEvaluation

语法定向操作 `BindingClassDeclarationEvaluation` 不接受参数并返回包含函数对象的正常完成或突然完成。它在以下生成式中分段定义：

```javascript
ClassDeclaration : class BindingIdentifier ClassTail
```
1. 令 `className` 为 `BindingIdentifier` 的 `StringValue`。
2. 令 `value` 为 ? `ClassDefinitionEvaluation(ClassTail, className, className)`。
3. 将 `value.[[SourceText]]` 设置为 `ClassDeclaration` 匹配的源文本。
4. 令 `env` 为运行执行上下文的 `LexicalEnvironment`。
5. 执行 ? `InitializeBoundName(className, value, env)`。
6. 返回 `value`。

```javascript
ClassDeclaration : class ClassTail
```
1. 令 `value` 为 ? `ClassDefinitionEvaluation(ClassTail, undefined, "default")`。
2. 将 `value.[[SourceText]]` 设置为 `ClassDeclaration` 匹配的源文本。
3. 返回 `value`。

注释：`ClassDeclaration : class ClassTail` 仅作为 `ExportDeclaration` 的一部分出现，并且其绑定的建立在该生成式的评估操作中处理。见 16.2.3.7。

#### 15.7.16 运行时语义：Evaluation

```javascript
ClassDeclaration : class BindingIdentifier ClassTail
```
1. 执行 ? `BindingClassDeclarationEvaluation(this ClassDeclaration)`。
2. 返回 `EMPTY`。

注释：`ClassDeclaration : class ClassTail` 仅作为 `ExportDeclaration` 的一部分出现，且永远不会直接评估。

```javascript
ClassExpression : class ClassTail
```
1. 令 `value` 为 ? `ClassDefinitionEvaluation(ClassTail, undefined, "")`。
2. 将 `value.[[SourceText]]` 设置为 `ClassExpression` 匹配的源文本。
3. 返回 `value`。

```javascript
ClassExpression : class BindingIdentifier ClassTail
```
1. 令 `className` 为 `BindingIdentifier` 的 `StringValue`。
2. 令 `value` 为 ? `ClassDefinitionEvaluation(ClassTail, className, className)`。
3. 将 `value.[[SourceText]]` 设置为 `ClassExpression` 匹配的源文本。
4. 返回 `value`。

```javascript
ClassElementName : PrivateIdentifier
```
1. 令 `privateIdentifier` 为 `PrivateIdentifier` 的 `StringValue`。
2. 令 `privateEnvRec` 为运行执行上下文的 `PrivateEnvironment`。
3. 令 `names` 为 `privateEnvRec.[[Names]]`。
4. 断言：`names` 中只有一个元素是私有名称，其 `[[Description]]` 是 `privateIdentifier`。
5. 令 `privateName` 为 `names` 中 `[[Description]]` 为 `privateIdentifier` 的私有名称。
6. 返回 `privateName`。

```javascript
ClassStaticBlockStatementList : [empty]
```
1. 返回 `undefined`。

### 15.8 异步函数定义

#### 语法

```javascript
AsyncFunctionDeclaration[Yield, Await, Default] :
  async [no LineTerminator here] function BindingIdentifier[?Yield, ?Await] ( FormalParameters[~Yield, +Await] ) { AsyncFunctionBody }
  [+Default] async [no LineTerminator here] function ( FormalParameters[~Yield, +Await] ) { AsyncFunctionBody }

AsyncFunctionExpression :
  async [no LineTerminator here] function BindingIdentifier[~Yield, +Await]opt ( FormalParameters[~Yield, +Await] ) { AsyncFunctionBody }

AsyncMethod[Yield, Await] :
  async [no LineTerminator here] ClassElementName[?Yield, ?Await] ( UniqueFormalParameters[~Yield, +Await] ) { AsyncFunctionBody }

AsyncFunctionBody :
  FunctionBody[~Yield, +Await]

AwaitExpression[Yield] :
  await UnaryExpression[?Yield, +Await]
```

#### 注释

1. 当 [Await] 参数存在时，await 被解析为 AwaitExpression 的关键字。 [Await] 参数在以下上下文的顶层存在，尽管在某些上下文中根据非终结符可能不存在此参数，例如 FunctionBody：

  - 在 AsyncFunctionBody 中。
  - 在 AsyncFunctionDeclaration、AsyncFunctionExpression、AsyncGeneratorDeclaration 或 AsyncGeneratorExpression 的 FormalParameters 中。在这种情况下，AwaitExpression 是通过静态语义作为语法错误。
  - 在模块中。

2. 当 Script 是语法目标符号时，await 可以在 [Await] 参数不存在时解析为标识符。这包括以下上下文：

  - 在 AsyncFunctionBody 或上述异步函数形式参数之外的任何地方。
  - 在 FunctionExpression、GeneratorExpression 或 AsyncGeneratorExpression 的 BindingIdentifier 中。

3. 与 YieldExpression 不同，省略 AwaitExpression 的操作数是语法错误。你必须 await 一些东西。

#### 15.8.1 静态语义：早期错误

```javascript
AsyncMethod : async ClassElementName ( UniqueFormalParameters ) { AsyncFunctionBody }
```

- 如果 AsyncFunctionBody 的 FunctionBodyContainsUseStrict 为 true 且 UniqueFormalParameters 的 IsSimpleParameterList 为 false，则这是语法错误。
- 如果 HasDirectSuper 的 AsyncMethod 为 true，则这是语法错误。
- 如果 UniqueFormalParameters 包含 AwaitExpression，则这是语法错误。
- 如果 UniqueFormalParameters 的 BoundNames 中的任何元素也出现在 AsyncFunctionBody 的 LexicallyDeclaredNames 中，则这是语法错误。

```javascript
AsyncFunctionDeclaration :
  async function BindingIdentifier ( FormalParameters ) { AsyncFunctionBody }
  async function ( FormalParameters ) { AsyncFunctionBody }

AsyncFunctionExpression :
  async function BindingIdentifieropt ( FormalParameters ) { AsyncFunctionBody }
```

- 如果 AsyncFunctionBody 的 FunctionBodyContainsUseStrict 为 true 且 FormalParameters 的 IsSimpleParameterList 为 false，则这是语法错误。
- 如果 FormalParameters 包含 AwaitExpression，则这是语法错误。
- 如果 FormalParameters 是严格模式，则应用 UniqueFormalParameters 的早期错误规则。
- 如果 BindingIdentifier 存在并且 IsStrict(BindingIdentifier) 为 true，如果 BindingIdentifier 的 StringValue 是 "eval" 或 "arguments"，则这是语法错误。
- 如果 FormalParameters 的 BoundNames 中的任何元素也出现在 AsyncFunctionBody 的 LexicallyDeclaredNames 中，则这是语法错误。
- 如果 FormalParameters 包含 SuperProperty，则这是语法错误。
- 如果 AsyncFunctionBody 包含 SuperProperty，则这是语法错误。
- 如果 FormalParameters 包含 SuperCall，则这是语法错误。
- 如果 AsyncFunctionBody 包含 SuperCall，则这是语法错误。

#### 15.8.2 运行时语义：InstantiateAsyncFunctionObject

语法定向操作 InstantiateAsyncFunctionObject 接受参数 env（环境记录）和 privateEnv（私有环境记录或 null）并返回 ECMAScript 函数对象。它在以下生成式中分段定义：

```javascript
AsyncFunctionDeclaration : async function BindingIdentifier ( FormalParameters ) { AsyncFunctionBody }
```

1. 令 name 为 BindingIdentifier 的 StringValue。
2. 令 sourceText 为 AsyncFunctionDeclaration 匹配的源文本。
3. 令 F 为 OrdinaryFunctionCreate(%AsyncFunction.prototype%, sourceText, FormalParameters, AsyncFunctionBody, NON-LEXICAL-THIS, env, privateEnv)。
4. 执行 SetFunctionName(F, name)。
5. 返回 F。

```javascript
AsyncFunctionDeclaration : async function ( FormalParameters ) { AsyncFunctionBody }
```

1. 令 sourceText 为 AsyncFunctionDeclaration 匹配的源文本。
2. 令 F 为 OrdinaryFunctionCreate(%AsyncFunction.prototype%, sourceText, FormalParameters, AsyncFunctionBody, NON-LEXICAL-THIS, env, privateEnv)。
3. 执行 SetFunctionName(F, "default")。
4. 返回 F。

#### 15.8.3 运行时语义：InstantiateAsyncFunctionExpression

语法定向操作 InstantiateAsyncFunctionExpression 接受可选参数 name（属性键或私有名称）并返回 ECMAScript 函数对象。它在以下生成式中分段定义：

```javascript
AsyncFunctionExpression : async function ( FormalParameters ) { AsyncFunctionBody }
```

1. 如果 name 不存在，设置 name 为 ""。
2. 令 env 为运行执行上下文的 LexicalEnvironment。
3. 令 privateEnv 为运行执行上下文的 PrivateEnvironment。
4. 令 sourceText 为 AsyncFunctionExpression 匹配的源文本。
5. 令 closure 为 OrdinaryFunctionCreate(%AsyncFunction.prototype%, sourceText, FormalParameters, AsyncFunctionBody, NON-LEXICAL-THIS, env, privateEnv)。
6. 执行 SetFunctionName(closure, name)。
7. 返回 closure。

```javascript
AsyncFunctionExpression : async function BindingIdentifier ( FormalParameters ) { AsyncFunctionBody }
```

1. 断言：name 不存在。
2. 设置 name 为 BindingIdentifier 的 StringValue。
3. 令 outerEnv 为运行执行上下文的 LexicalEnvironment。
4. 令 funcEnv 为 NewDeclarativeEnvironment(outerEnv)。
5. 执行 ! funcEnv.CreateImmutableBinding(name, false)。
6. 令 privateEnv 为运行执行上下文的 PrivateEnvironment。
7. 令 sourceText 为 AsyncFunctionExpression 匹配的源文本。
8. 令 closure 为 OrdinaryFunctionCreate(%AsyncFunction.prototype%, sourceText, FormalParameters, AsyncFunctionBody, NON-LEXICAL-THIS, funcEnv, privateEnv)。
9. 执行 SetFunctionName(closure, name)。
10. 执行 ! funcEnv.InitializeBinding(name, closure)。
11. 返回 closure。

#### 注释

AsyncFunctionExpression 的 BindingIdentifier 可以从 AsyncFunctionExpression 的 AsyncFunctionBody 内部引用，以允许函数递归调用自身。然而，与 FunctionDeclaration 不同，AsyncFunctionExpression 的 BindingIdentifier 不能从 AsyncFunctionExpression 之外的作用域引用并影响它。

#### 15.8.4 运行时语义：EvaluateAsyncFunctionBody

语法定向操作 EvaluateAsyncFunctionBody 接受参数 functionObject（一个 ECMAScript 函数对象）和 argumentsList（一个 ECMAScript 语言值的列表）并返回一个返回完成。它在以下生成式中分段定义：

```javascript
AsyncFunctionBody : FunctionBody
```

1. 令 promiseCapability 为 ! NewPromiseCapability(%Promise%)。
2. 令 declResult 为 Completion(FunctionDeclarationInstantiation(functionObject, argumentsList))。
3. 如果 declResult 是突然完成，
  a. 执行 ! Call(promiseCapability.[[Reject]], undefined, « declResult.[[Value]] »)。
4. 否则，
  a. 执行 AsyncFunctionStart(promiseCapability, FunctionBody)。
5. 返回 Completion Record { [[Type]]: RETURN, [[Value]]: promiseCapability.[[Promise]], [[Target]]: EMPTY }。

#### 15.8.5 运行时语义：Evaluation

```javascript
AsyncFunctionExpression :
  async function BindingIdentifieropt ( FormalParameters ) { AsyncFunctionBody }
```

1. 返回 InstantiateAsyncFunctionExpression of AsyncFunctionExpression。

```javascript
AwaitExpression : await UnaryExpression
```

1. 令 exprRef 为 ? Evaluation of UnaryExpression。
2. 令 value 为 ? GetValue(exprRef)。
3. 返回 ? Await(value)。

### 15.9 异步箭头函数定义

#### 语法

```javascript
AsyncArrowFunction[In, Yield, Await] :
  async [no LineTerminator here] AsyncArrowBindingIdentifier[?Yield] [no LineTerminator here] => AsyncConciseBody[?In]
  CoverCallExpressionAndAsyncArrowHead[?Yield, ?Await] [no LineTerminator here] => AsyncConciseBody[?In]

AsyncConciseBody[In] :
  [lookahead ≠ {] ExpressionBody[?In, +Await]
  { AsyncFunctionBody }

AsyncArrowBindingIdentifier[Yield] :
  BindingIdentifier[?Yield, +Await]

CoverCallExpressionAndAsyncArrowHead[Yield, Await] :
  MemberExpression[?Yield, ?Await] Arguments[?Yield, ?Await]
```

#### 补充语法

在处理生成式 `AsyncArrowFunction : CoverCallExpressionAndAsyncArrowHead => AsyncConciseBody` 的实例时，使用以下语法对 `CoverCallExpressionAndAsyncArrowHead` 的解释进行细化：

```javascript
AsyncArrowHead :
  async [no LineTerminator

 here] ArrowFormalParameters[~Yield, +Await]
```

#### 15.9.1 静态语义：早期错误

```javascript
AsyncArrowFunction : async AsyncArrowBindingIdentifier => AsyncConciseBody
```

- 如果 AsyncArrowBindingIdentifier 的 BoundNames 中的任何元素也出现在 AsyncConciseBody 的 LexicallyDeclaredNames 中，则这是语法错误。

```javascript
AsyncArrowFunction : CoverCallExpressionAndAsyncArrowHead => AsyncConciseBody
```

- CoverCallExpressionAndAsyncArrowHead 必须覆盖一个 AsyncArrowHead。
- 如果 CoverCallExpressionAndAsyncArrowHead 包含 YieldExpression，则这是语法错误。
- 如果 CoverCallExpressionAndAsyncArrowHead 包含 AwaitExpression，则这是语法错误。
- 如果 CoverCallExpressionAndAsyncArrowHead 的 BoundNames 中的任何元素也出现在 AsyncConciseBody 的 LexicallyDeclaredNames 中，则这是语法错误。
- 如果 AsyncConciseBodyContainsUseStrict 的 AsyncConciseBody 为 true 且 CoverCallExpressionAndAsyncArrowHead 的 IsSimpleParameterList 为 false，则这是语法错误。

#### 15.9.2 静态语义：AsyncConciseBodyContainsUseStrict

语法定向操作 AsyncConciseBodyContainsUseStrict 不接受参数并返回一个布尔值。它在以下生成式中分段定义：

```javascript
AsyncConciseBody : ExpressionBody
```

1. 返回 false。

```javascript
AsyncConciseBody : { AsyncFunctionBody }
```

1. 返回 AsyncFunctionBody 的 FunctionBodyContainsUseStrict。

#### 15.9.3 运行时语义：EvaluateAsyncConciseBody

语法定向操作 EvaluateAsyncConciseBody 接受参数 functionObject（一个 ECMAScript 函数对象）和 argumentsList（一个 ECMAScript 语言值的列表）并返回一个返回完成。它在以下生成式中分段定义：

```javascript
AsyncConciseBody : ExpressionBody
```

1. 令 promiseCapability 为 ! NewPromiseCapability(%Promise%)。
2. 令 declResult 为 Completion(FunctionDeclarationInstantiation(functionObject, argumentsList))。
3. 如果 declResult 是突然完成，
  a. 执行 ! Call(promiseCapability.[[Reject]], undefined, « declResult.[[Value]] »)。
4. 否则，
  a. 执行 AsyncFunctionStart(promiseCapability, ExpressionBody)。
5. 返回 Completion Record { [[Type]]: RETURN, [[Value]]: promiseCapability.[[Promise]], [[Target]]: EMPTY }。

#### 15.9.4 运行时语义：InstantiateAsyncArrowFunctionExpression

语法定向操作 InstantiateAsyncArrowFunctionExpression 接受可选参数 name（属性键或私有名称）并返回一个 ECMAScript 函数对象。它在以下生成式中分段定义：

```javascript
AsyncArrowFunction : async AsyncArrowBindingIdentifier => AsyncConciseBody
```

1. 如果 name 不存在，设置 name 为 ""。
2. 令 env 为运行执行上下文的 LexicalEnvironment。
3. 令 privateEnv 为运行执行上下文的 PrivateEnvironment。
4. 令 sourceText 为 AsyncArrowFunction 匹配的源文本。
5. 令 parameters 为 AsyncArrowBindingIdentifier。
6. 令 closure 为 OrdinaryFunctionCreate(%AsyncFunction.prototype%, sourceText, parameters, AsyncConciseBody, LEXICAL-THIS, env, privateEnv)。
7. 执行 SetFunctionName(closure, name)。
8. 返回 closure。

```javascript
AsyncArrowFunction : CoverCallExpressionAndAsyncArrowHead => AsyncConciseBody
```

1. 如果 name 不存在，设置 name 为 ""。
2. 令 env 为运行执行上下文的 LexicalEnvironment。
3. 令 privateEnv 为运行执行上下文的 PrivateEnvironment。
4. 令 sourceText 为 AsyncArrowFunction 匹配的源文本。
5. 令 head 为 CoverCallExpressionAndAsyncArrowHead 覆盖的 AsyncArrowHead。
6. 令 parameters 为 head 的 ArrowFormalParameters。
7. 令 closure 为 OrdinaryFunctionCreate(%AsyncFunction.prototype%, sourceText, parameters, AsyncConciseBody, LEXICAL-THIS, env, privateEnv)。
8. 执行 SetFunctionName(closure, name)。
9. 返回 closure。

#### 15.9.5 运行时语义：Evaluation

```javascript
AsyncArrowFunction :
  async AsyncArrowBindingIdentifier => AsyncConciseBody
  CoverCallExpressionAndAsyncArrowHead => AsyncConciseBody
```

1. 返回 InstantiateAsyncArrowFunctionExpression of AsyncArrowFunction。

### 15.10 尾位置调用

#### 15.10.1 静态语义：IsInTailPosition ( call )

抽象操作 IsInTailPosition 接受参数 call（一个 CallExpression 解析节点、MemberExpression 解析节点或 OptionalChain 解析节点）并返回一个布尔值。调用时执行以下步骤：

1. 如果 IsStrict(call) 为 false，返回 false。
2. 如果 call 不包含在 FunctionBody、ConciseBody 或 AsyncConciseBody 中，返回 false。
3. 令 body 为最接近包含 call 的 FunctionBody、ConciseBody 或 AsyncConciseBody。
4. 如果 body 是 GeneratorBody 的 FunctionBody，返回 false。
5. 如果 body 是 AsyncFunctionBody 的 FunctionBody，返回 false。
6. 如果 body 是 AsyncGeneratorBody 的 FunctionBody，返回 false。
7. 如果 body 是 AsyncConciseBody，返回 false。
8. 返回 HasCallInTailPosition 的结果，参数为 body 和 call。

注释：尾位置调用仅在严格模式代码中定义，因为存在一个常见的非标准语言扩展（见 10.2.4），该扩展允许观察调用者上下文的链。

#### 15.10.2 静态语义：HasCallInTailPosition

语法定向操作 HasCallInTailPosition 接受参数 call（一个 CallExpression 解析节点、MemberExpression 解析节点或 OptionalChain 解析节点）并返回一个布尔值。

注释 1：call 是一个表示特定源文本范围的解析节点。当以下算法将 call 与另一个解析节点进行比较时，这是一个测试它们是否表示相同的源文本。

注释 2：一个可能的尾位置调用是立即跟随 return GetValue 的调用结果的调用。函数调用不能返回一个引用记录，因此这样的 GetValue 操作将始终返回与实际函数调用结果相同的值。

它在以下生成式中分段定义：

```javascript
StatementList : StatementList StatementListItem
```

1. 令 has 为 HasCallInTailPosition of StatementList with argument call。
2. 如果 has 为 true，返回 true。
3. 返回 HasCallInTailPosition of StatementListItem with argument call。

```javascript
FunctionStatementList :
  [empty]
StatementListItem :
  Declaration
Statement :
  VariableStatement
  EmptyStatement
  ExpressionStatement
  ContinueStatement
  BreakStatement
  ThrowStatement
  DebuggerStatement
Block :
  { }
ReturnStatement :
  return ;
LabelledItem :
  FunctionDeclaration
ForInOfStatement :
  for ( LeftHandSideExpression of AssignmentExpression ) Statement
  for ( var ForBinding of AssignmentExpression ) Statement
  for ( ForDeclaration of AssignmentExpression ) Statement
CaseBlock :
  { }
```

1. 返回 false。

```javascript
IfStatement : if ( Expression ) Statement else Statement
```

1. 令 has 为 HasCallInTailPosition of the first Statement with argument call。
2. 如果 has 为 true，返回 true。
3. 返回 HasCallInTailPosition of the second Statement with argument call。

```javascript
IfStatement :
  if ( Expression ) Statement
DoWhileStatement :
  do Statement while ( Expression ) ;
WhileStatement :
  while ( Expression ) Statement
ForStatement :
  for ( Expressionopt ; Expressionopt ; Expressionopt ) Statement
  for ( var VariableDeclarationList ; Expressionopt ; Expressionopt ) Statement
  for ( LexicalDeclaration Expressionopt ; Expressionopt ) Statement
ForInOfStatement :
  for ( LeftHandSideExpression in Expression ) Statement
  for ( var ForBinding in Expression ) Statement
  for ( ForDeclaration in Expression ) Statement
WithStatement :
  with ( Expression ) Statement
```

1. 返回 HasCallInTailPosition of Statement with argument call。

```javascript
LabelledStatement :
  LabelIdentifier : LabelledItem
```

1. 返回 HasCallInTailPosition of LabelledItem with argument call。

```javascript
ReturnStatement : return Expression ;
```

1. 返回 HasCallInTailPosition of Expression with argument call。

```javascript
SwitchStatement : switch ( Expression ) CaseBlock
```

1. 返回 HasCallInTailPosition of CaseBlock with argument call。

```javascript
CaseBlock : { CaseClausesopt DefaultClause CaseClausesopt }
```

1. 令 has 为 false。
2. 如果第一个 CaseClauses 存在，设置 has 为 HasCallInTailPosition of the first CaseClauses with argument call。
3. 如果 has 为 true，返回 true。
4. 设置 has 为 HasCallInTailPosition of DefaultClause with argument call。
5. 如果 has 为 true，返回 true。
6. 如果第二个 CaseClauses 存在，设置 has 为 HasCallInTailPosition of the second CaseClauses with argument call。
7. 返回 has。

```javascript
CaseClauses : CaseClauses CaseClause
```

1. 令 has 为 HasCallInTailPosition of CaseClauses with argument call。
2. 如果 has 为 true，返回 true。
3.

 返回 HasCallInTailPosition of CaseClause with argument call。

```javascript
CaseClause : case Expression : StatementListopt
DefaultClause : default : StatementListopt
```

1. 如果 StatementList 存在，返回 HasCallInTailPosition of StatementList with argument call。
2. 返回 false。

```javascript
TryStatement : try Block Catch
```

1. 返回 HasCallInTailPosition of Catch with argument call。

```javascript
TryStatement :
  try Block Finally
  try Block Catch Finally
```

1. 返回 HasCallInTailPosition of Finally with argument call。

```javascript
Catch : catch ( CatchParameter ) Block
```

1. 返回 HasCallInTailPosition of Block with argument call。

```javascript
AssignmentExpression :
  YieldExpression
  ArrowFunction
  AsyncArrowFunction
  LeftHandSideExpression = AssignmentExpression
  LeftHandSideExpression AssignmentOperator AssignmentExpression
  LeftHandSideExpression &&= AssignmentExpression
  LeftHandSideExpression ||= AssignmentExpression
  LeftHandSideExpression ??= AssignmentExpression
BitwiseANDExpression :
  BitwiseANDExpression & EqualityExpression
BitwiseXORExpression :
  BitwiseXORExpression ^ BitwiseANDExpression
BitwiseORExpression :
  BitwiseORExpression | BitwiseXORExpression
EqualityExpression :
  EqualityExpression == RelationalExpression
  EqualityExpression != RelationalExpression
  EqualityExpression === RelationalExpression
  EqualityExpression !== RelationalExpression
RelationalExpression :
  RelationalExpression < ShiftExpression
  RelationalExpression > ShiftExpression
  RelationalExpression <= ShiftExpression
  RelationalExpression >= ShiftExpression
  RelationalExpression instanceof ShiftExpression
  RelationalExpression in ShiftExpression
  PrivateIdentifier in ShiftExpression
ShiftExpression :
  ShiftExpression << AdditiveExpression
  ShiftExpression >> AdditiveExpression
  ShiftExpression >>> AdditiveExpression
AdditiveExpression :
  AdditiveExpression + MultiplicativeExpression
  AdditiveExpression - MultiplicativeExpression
MultiplicativeExpression :
  MultiplicativeExpression MultiplicativeOperator ExponentiationExpression
ExponentiationExpression :
  UpdateExpression ** ExponentiationExpression
UpdateExpression :
  LeftHandSideExpression ++
  LeftHandSideExpression --
  ++ UnaryExpression
  -- UnaryExpression
UnaryExpression :
  delete UnaryExpression
  void UnaryExpression
  typeof UnaryExpression
  + UnaryExpression
  - UnaryExpression
  ~ UnaryExpression
  ! UnaryExpression
  AwaitExpression
CallExpression :
  SuperCall
  ImportCall
  CallExpression [ Expression ]
  CallExpression . IdentifierName
  CallExpression . PrivateIdentifier
NewExpression :
  new NewExpression
MemberExpression :
  MemberExpression [ Expression ]
  MemberExpression . IdentifierName
  SuperProperty
  MetaProperty
  new MemberExpression Arguments
  MemberExpression . PrivateIdentifier
PrimaryExpression :
  this
  IdentifierReference
  Literal
  ArrayLiteral
  ObjectLiteral
  FunctionExpression
  ClassExpression
  GeneratorExpression
  AsyncFunctionExpression
  AsyncGeneratorExpression
  RegularExpressionLiteral
  TemplateLiteral
```

1. 返回 false。

```javascript
Expression :
  AssignmentExpression
  Expression , AssignmentExpression
```

1. 返回 HasCallInTailPosition of AssignmentExpression with argument call。

```javascript
ConditionalExpression : ShortCircuitExpression ? AssignmentExpression : AssignmentExpression
```

1. 令 has 为 HasCallInTailPosition of the first AssignmentExpression with argument call。
2. 如果 has 为 true，返回 true。
3. 返回 HasCallInTailPosition of the second AssignmentExpression with argument call。

```javascript
LogicalANDExpression : LogicalANDExpression && BitwiseORExpression
```

1. 返回 HasCallInTailPosition of BitwiseORExpression with argument call。

```javascript
LogicalORExpression : LogicalORExpression || LogicalANDExpression
```

1. 返回 HasCallInTailPosition of LogicalANDExpression with argument call。

```javascript
CoalesceExpression : CoalesceExpressionHead ?? BitwiseORExpression
```

1. 返回 HasCallInTailPosition of BitwiseORExpression with argument call。

```javascript
CallExpression :
  CoverCallExpressionAndAsyncArrowHead
  CallExpression Arguments
  CallExpression TemplateLiteral
```

1. 如果这个 CallExpression 是 call，返回 true。
2. 返回 false。

```javascript
OptionalExpression :
  MemberExpression OptionalChain
  CallExpression OptionalChain
  OptionalExpression OptionalChain
```

1. 返回 HasCallInTailPosition of OptionalChain with argument call。

```javascript
OptionalChain :
  ?. [ Expression ]
  ?. IdentifierName
  ?. PrivateIdentifier
  OptionalChain [ Expression ]
  OptionalChain . IdentifierName
  OptionalChain . PrivateIdentifier
```

1. 返回 false。

```javascript
OptionalChain :
  ?. Arguments
  OptionalChain Arguments
```

1. 如果这个 OptionalChain 是 call，返回 true。
2. 返回 false。

```javascript
MemberExpression :
  MemberExpression TemplateLiteral
```

1. 如果这个 MemberExpression 是 call，返回 true。
2. 返回 false。

```javascript
PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList
```

1. 令 expr 为 CoverParenthesizedExpressionAndArrowParameterList 覆盖的 ParenthesizedExpression。
2. 返回 HasCallInTailPosition of expr with argument call。

```javascript
ParenthesizedExpression :
  ( Expression )
```

1. 返回 HasCallInTailPosition of Expression with argument call。

#### 15.10.3 PrepareForTailCall ( )

抽象操作 PrepareForTailCall 不接受参数并返回 UNUSED。调用时执行以下步骤：

1. 断言：当前执行上下文将不再用于评估任何 ECMAScript 代码或内置函数。在调用该抽象操作之后调用 Call 将在执行任何此类评估之前创建并推送一个新的执行上下文。
2. 丢弃与当前执行上下文关联的所有资源。
3. 返回 UNUSED。

尾位置调用必须在调用目标函数之前释放与当前正在执行的函数执行上下文相关的任何瞬态内部资源，或者在支持目标函数时重用这些资源。

注释：例如，尾位置调用应该只增长实现的激活记录堆栈的量，该量大于目标函数的激活记录超过调用函数的激活记录的大小。如果目标函数的激活记录较小，则堆栈的总大小应减少。

### 16 ECMAScript 语言：脚本和模块

#### 16.1 脚本

**语法**

```javascript
Script :
  ScriptBodyopt
ScriptBody :
  StatementList[~Yield, ~Await, ~Return]
```

#### 16.1.1 静态语义：早期错误

```javascript
Script : ScriptBody
```

- 如果 ScriptBody 的 LexicallyDeclaredNames 包含任何重复条目，这是语法错误。
- 如果 ScriptBody 的 LexicallyDeclaredNames 的任何元素也出现在 ScriptBody 的 VarDeclaredNames 中，这是语法错误。

```javascript
ScriptBody : StatementList
```

- 如果 StatementList 包含 super 除非包含 super 的源文本是正在由直接 eval 处理的 eval 代码，这是语法错误。直接 eval 中的 super 的附加早期错误规则在 19.2.1.1 中定义。
- 如果 StatementList 包含 NewTarget 除非包含 NewTarget 的源文本是正在由直接 eval 处理的 eval 代码，这是语法错误。直接 eval 中的 NewTarget 的附加早期错误规则在 19.2.1.1 中定义。
- 如果 StatementList 的 ContainsDuplicateLabels 参数为 « » 为 true，这是语法错误。
- 如果 StatementList 的 ContainsUndefinedBreakTarget 参数为 « » 为 true，这是语法错误。
- 如果 StatementList 的 ContainsUndefinedContinueTarget 参数为 « » 和 « » 为 true，这是语法错误。
- 如果 StatementList 的 AllPrivateIdentifiersValid 参数为 « » 为 false 除非包含 ScriptBody 的源文本是正在由直接 eval 处理的 eval 代码，这是语法错误。

#### 16.1.2 静态语义：ScriptIsStrict

语法定向操作 ScriptIsStrict 不接受参数并返回一个布尔值。它在以下生成式中分段定义：

```javascript
Script : ScriptBodyopt
```

1. 如果 ScriptBody 存在并且 ScriptBody 的 Directive Prologue 包含 Use Strict Directive，返回 true；否则，返回 false。

#### 16.1.3 运行时语义：评估

```javascript
Script : [empty]
```

1. 返回 undefined。

#### 16.1.4 脚本记录

脚本记录封装了关于正在评估的脚本的信息。每个脚本记录包含表 39 中列出的字段。

**表 39：脚本记录字段**

| 字段名               | 值类型                | 含义                                                                 |
|----------------------|-----------------------|----------------------------------------------------------------------|
| [[Realm]]            | 一个 Realm 记录       | 创建此脚本的 realm。                                                 |
| [[ECMAScriptCode]]   | 一个 Script 解析节点  | 此脚本源文本的解析结果。                                             |
| [[LoadedModules]]    | 记录列表，字段为[[Specifier]]（字符串）和[[Module]]（模块记录） | 从此脚本导入的解析的模块记录的映射。列表不包含具有相同[[Specifier]]的两个不同记录。 |
| [[HostDefined]]      | 任何（默认值为 EMPTY）| 保留供主机环境使用，以便与脚本关联附加信息。                         |

#### 16.1.5 ParseScript（sourceText，realm，hostDefined）

抽象操作 ParseScript 接受参数 sourceText（ECMAScript 源文本）、realm（一个 Realm 记录）和 hostDefined（任何）并返回一个脚本记录或非空的 SyntaxError 对象列表。它根据将 sourceText 解析为 Script 的结果创建一个脚本记录。调用时执行以下步骤：

1. 令 script 为 ParseText(sourceText, Script)。
2. 如果 script 是错误列表，返回 script。
3. 返回 Script Record { [[Realm]]: realm, [[ECMAScriptCode]]: script, [[LoadedModules]]: « », [[HostDefined]]: hostDefined }。

**注意** 实现可以在评估 ParseScript 之前解析脚本源文本并分析早期错误条件。然而，任何错误的报告必须推迟到规范实际对该源文本执行 ParseScript 的时候。

#### 16.1.6 ScriptEvaluation（scriptRecord）

抽象操作 ScriptEvaluation 接受参数 scriptRecord（一个脚本记录）并返回一个包含 ECMAScript 语言值的正常完成或突然完成。调用时执行以下步骤：

1. 令 globalEnv 为 scriptRecord.[[Realm]].[[GlobalEnv]]。
2. 令 scriptContext 为一个新的 ECMAScript 代码执行上下文。
3. 设置 scriptContext 的 Function 为 null。
4. 设置 scriptContext 的 Realm 为 scriptRecord.[[Realm]]。
5. 设置 scriptContext 的 ScriptOrModule 为 scriptRecord。
6. 设置 scriptContext 的 VariableEnvironment 为 globalEnv。
7. 设置 scriptContext 的 LexicalEnvironment 为 globalEnv。
8. 设置 scriptContext 的 PrivateEnvironment 为 null。
9. 挂起正在运行的执行上下文。
10. 将 scriptContext 推送到执行上下文堆栈；scriptContext 现在是正在运行的执行上下文。
11. 令 script 为 scriptRecord.[[ECMAScriptCode]]。
12. 令 result 为 Completion(GlobalDeclarationInstantiation(script, globalEnv))。
13. 如果 result 是正常完成，
   a. 将 result 设置为 Completion(Evaluation of script)。
   b. 如果 result 是正常完成且 result.[[Value]] 为 EMPTY，
     i. 将 result 设置为 NormalCompletion(undefined)。
14. 挂起 scriptContext 并将其从执行上下文堆栈中移除。
15. 断言：执行上下文堆栈不为空。
16. 恢复现在在执行上下文堆栈顶部的上下文作为正在运行的执行上下文。
17. 返回 ? result。

#### 16.1.7 GlobalDeclarationInstantiation（script，env）

抽象操作 GlobalDeclarationInstantiation 接受参数 script（一个 Script 解析节点）和 env（一个 Global Environment 记录）并返回一个包含 UNUSED 的正常完成或抛出完成。script 是正在建立执行上下文的 Script。env 是要在其中创建绑定的全局环境。

**注意 1** 当为评估脚本建立执行上下文时，声明在当前全局环境中被实例化。代码中声明的每个全局绑定都被实例化。

调用时执行以下步骤：

1. 令 lexNames 为 script 的 LexicallyDeclaredNames。
2. 令 varNames 为 script 的 VarDeclaredNames。
3. 对于 lexNames 的每个元素 name，执行
   a. 如果 env.HasVarDeclaration(name) 为 true，抛出 SyntaxError 异常。
   b. 如果 env.HasLexicalDeclaration(name) 为 true，抛出 SyntaxError 异常。
   c. 令 hasRestrictedGlobal 为 ? env.HasRestrictedGlobalProperty(name)。
   d. 如果 hasRestrictedGlobal 为 true，抛出 SyntaxError 异常。
4. 对于 varNames 的每个元素 name，执行
   a. 如果 env.HasLexicalDeclaration(name) 为 true，抛出 SyntaxError 异常。
5. 令 varDeclarations 为 script 的 VarScopedDeclarations。
6. 令 functionsToInitialize 为一个新的空列表。
7. 令 declaredFunctionNames 为一个新的空列表。
8. 对于 varDeclarations 的每个元素 d，以倒序执行
   a. 如果 d 不是 VariableDeclaration、ForBinding 或 BindingIdentifier，
     i. 断言：d 是 FunctionDeclaration、GeneratorDeclaration、AsyncFunctionDeclaration 或 AsyncGeneratorDeclaration。
     ii. **注意**：如果同名函数声明有多个，使用最后一个声明。
     iii. 令 fn 为 d 的 BoundNames 的唯一元素。
     iv. 如果 declaredFunctionNames 不包含 fn，
       1. 令 fnDefinable 为 ? env.CanDeclareGlobalFunction(fn)。
       2. 如果 fnDefinable 为 false，抛出 TypeError 异常。
       3. 将 fn 添加到 declaredFunctionNames。
       4. 将 d 插入 functionsToInitialize 的第一个元素。
9. 令 declaredVarNames 为一个新的空列表。
10. 对于 varDeclarations 的每个元素 d，执行
    a. 如果 d 是 VariableDeclaration、ForBinding 或 BindingIdentifier，
      i. 对于 d 的 BoundNames 的每个字符串 vn，执行
        1. 如果 declaredFunctionNames 不包含 vn，
          a. 令 vnDefinable 为 ? env.CanDeclareGlobalVar(vn)。
          b. 如果 vnDefinable 为 false，抛出 TypeError 异常。
          c. 如果 declaredVarNames 不包含 vn，将 vn 添加到 declaredVarNames。
11. **注意**：如果全局对象是普通对象，则在此算法步骤之后不会发生异常终止。然而，如果全局对象是代理异对象，它可能表现出导致某些以下步骤中异常终止的行为。
12. **注意**：附录 B.3.2.2 在此点添加了额外步骤。
13. 令 lexDeclarations 为 script 的 LexicallyScopedDeclarations。
14. 令 privateEnv 为 null。
15. 对于 lexDeclarations 的每个元素 d，执行
    a. **注意**：此时仅实例化词法声明的名称，而不进行初始化。
    b. 对于 d 的 BoundNames 的每个元素 dn，执行
      i. 如果 d 的 IsConstantDeclaration 为 true，
        1. 执行 ? env.CreateImmutableBinding(dn, true)。
      ii

. 否则，
        1. 执行 ? env.CreateMutableBinding(dn, false)。
16. 对于 functionsToInitialize 的每个解析节点 f，执行
    a. 令 fn 为 f 的 BoundNames 的唯一元素。
    b. 令 fo 为 InstantiateFunctionObject 的 f，参数为 env 和 privateEnv。
    c. 执行 ? env.CreateGlobalFunctionBinding(fn, fo, false)。
17. 对于 declaredVarNames 的每个字符串 vn，执行
    a. 执行 ? env.CreateGlobalVarBinding(vn, false)。
18. 返回 UNUSED。

**注意 2** 16.1.1 中指定的早期错误防止函数/var 声明与 let/const/class 声明之间的名称冲突以及单个 Script 内包含的声明的 let/const/class 绑定的重复声明。然而，跨多个 Script 的此类冲突和重复声明在 GlobalDeclarationInstantiation 期间检测到运行时错误。如果检测到任何此类错误，则不会为脚本实例化任何绑定。然而，如果全局对象使用代理异对象定义，则冲突声明的运行时测试可能不可靠，导致突然完成，并且某些全局声明未被实例化。如果发生这种情况，不会评估脚本的代码。

与显式 var 或函数声明不同，直接在全局对象上创建的属性会导致全局绑定，这些绑定可能会被 let/const/class 声明遮蔽。

#### 16.2 模块

**语法**

```javascript
Module :
  ModuleBodyopt
ModuleBody :
  ModuleItemList
ModuleItemList :
  ModuleItem
  ModuleItemList ModuleItem
ModuleItem :
  ImportDeclaration
  ExportDeclaration
  StatementListItem[~Yield, +Await, ~Return]
ModuleExportName :
  IdentifierName
  StringLiteral
```

#### 16.2.1 模块语义

##### 16.2.1.1 静态语义：早期错误

```javascript
ModuleBody : ModuleItemList
```

- 如果 ModuleItemList 的 LexicallyDeclaredNames 包含任何重复条目，这是语法错误。
- 如果 ModuleItemList 的 LexicallyDeclaredNames 的任何元素也出现在 ModuleItemList 的 VarDeclaredNames 中，这是语法错误。
- 如果 ModuleItemList 的 ExportedNames 包含任何重复条目，这是语法错误。
- 如果 ModuleItemList 的 ExportedBindings 的任何元素没有出现在 ModuleItemList 的 VarDeclaredNames 或 ModuleItemList 的 LexicallyDeclaredNames 中，这是语法错误。
- 如果 ModuleItemList 包含 super，这是语法错误。
- 如果 ModuleItemList 包含 NewTarget，这是语法错误。
- 如果 ModuleItemList 的 ContainsDuplicateLabels 参数为 « » 为 true，这是语法错误。
- 如果 ModuleItemList 的 ContainsUndefinedBreakTarget 参数为 « » 为 true，这是语法错误。
- 如果 ModuleItemList 的 ContainsUndefinedContinueTarget 参数为 « » 和 « » 为 true，这是语法错误。
- 如果 ModuleItemList 的 AllPrivateIdentifiersValid 参数为 « » 为 false，这是语法错误。

**注意** ExportedNames 的重复规则意味着 ModuleBody 中的多个 export default ExportDeclaration 项是语法错误。有关冲突或重复声明的附加错误条件在模块链接期间在模块评估之前检查。如果检测到任何此类错误，则不会评估模块。

```javascript
ModuleExportName : StringLiteral
```

- 如果 IsStringWellFormedUnicode（StringLiteral 的 SV）为 false，这是语法错误。

##### 16.2.1.2 静态语义：ImportedLocalNames（importEntries）

抽象操作 ImportedLocalNames 接受参数 importEntries（一个 ImportEntry 记录列表）并返回一个字符串列表。它创建由 importEntries 定义的所有本地名称绑定的列表。调用时执行以下步骤：

1. 令 localNames 为一个新的空列表。
2. 对于 importEntries 的每个 ImportEntry 记录 i，执行
   a. 将 i.[[LocalName]] 添加到 localNames。
3. 返回 localNames。

##### 16.2.1.3 静态语义：ModuleRequests

语法定向操作 ModuleRequests 不接受参数并返回一个字符串列表。它在以下生成式中分段定义：

```javascript
Module : [empty]
```

1. 返回一个新的空列表。

```javascript
ModuleItemList : ModuleItem
```

1. 返回 ModuleItem 的 ModuleRequests。

```javascript
ModuleItemList : ModuleItemList ModuleItem
```

1. 令 moduleNames 为 ModuleItemList 的 ModuleRequests。
2. 令 additionalNames 为 ModuleItem 的 ModuleRequests。
3. 对于 additionalNames 的每个字符串 name，执行
   a. 如果 moduleNames 不包含 name，将 name 添加到 moduleNames。
4. 返回 moduleNames。

```javascript
ModuleItem : StatementListItem
```

1. 返回一个新的空列表。

```javascript
ImportDeclaration : import ImportClause FromClause ;
```

1. 返回 FromClause 的 ModuleRequests。

```javascript
ModuleSpecifier : StringLiteral
```

1. 返回一个列表，其唯一元素是 StringLiteral 的 SV。

```javascript
ExportDeclaration : export ExportFromClause FromClause ;
```

1. 返回 FromClause 的 ModuleRequests。

```javascript
ExportDeclaration :
  export NamedExports ;
  export VariableStatement
  export Declaration
  export default HoistableDeclaration
  export default ClassDeclaration
  export default AssignmentExpression ;
```

1. 返回一个新的空列表。

##### 16.2.1.4 抽象模块记录

模块记录封装了有关单个模块的导入和导出的结构信息。此信息用于链接一组连接的模块的导入和导出。模块记录包括在评估模块时仅使用的四个字段。

对于规范目的，模块记录值是 Record 规范类型的值，可以被认为存在于一个简单的面向对象的层次结构中，其中模块记录是一个抽象类，具有抽象和具体的子类。此规范定义了名为 Cyclic Module Record 的抽象子类及其名为 Source Text Module Record 的具体子类。其他规范和实现可能定义与它们定义的替代模块定义设施相对应的其他模块记录子类。

模块记录定义了表 40 中列出的字段。所有模块定义子类至少包含这些字段。模块记录还定义了表 41 中的抽象方法列表。所有模块定义子类必须提供这些抽象方法的具体实现。

**表 40：模块记录字段**

| 字段名               | 值类型                | 含义                                                                 |
|----------------------|-----------------------|----------------------------------------------------------------------|
| [[Realm]]            | 一个 Realm 记录       | 创建此模块的 realm。                                                 |
| [[Environment]]      | 一个模块环境记录或 EMPTY | 包含此模块顶级绑定的环境记录。此字段在模块链接时设置。               |
| [[Namespace]]        | 一个对象或 EMPTY      | 如果为此模块创建了一个模块命名空间对象（28.3），则为其对象。           |
| [[HostDefined]]      | 任何（默认值为 undefined）| 保留供主机环境使用，以便与模块关联附加信息。                         |

**表 41：模块记录的抽象方法**

| 方法                         | 目的                                                                                                   |
|------------------------------|--------------------------------------------------------------------------------------------------------|
| LoadRequestedModules([hostDefined]) | 准备模块进行链接，通过递归加载其所有依赖项，并返回一个 Promise。                                      |
| GetExportedNames([exportStarSet])   | 返回从此模块直接或间接导出的所有名称的列表。LoadRequestedModules 必须成功完成后才可调用此方法。          |
| ResolveExport(exportName[, resolveSet]) | 返回模块导出的名称的绑定。绑定由 ResolvedBinding 记录表示，形式为 { [[Module]]: Module 记录，[[BindingName]]: String | NAMESPACE }。如果导出是没有直接绑定的模块命名空间对象，则 [[BindingName]] 将设置为 NAMESPACE。如果名称无法解析，则返回 null；如果找到多个绑定，则返回 AMBIGUOUS。每次以特定的 exportName, resolveSet 参数对调用此操作时，必须返回相同的结果。LoadRequestedModules 必须成功完成后才可调用此方法。 |
| Link()                         | 准备模块进行评估，通过传递性解析所有模块依赖项并创建模块环境记录。LoadRequestedModules 必须成功完成后才可调用此方法。 |
| Evaluate()                     | 返回此模块及其依赖项的评估 Promise，成功评估时解析或如果已经成功评估则解析，评估错误时拒绝或如果已经评估失败则拒绝。如果 Promise 被拒绝，主机应处理 Promise 拒绝并重新抛出评估错误。Link 必须成功完成后才可调用此方法。 |

##### 16.2.1.5 循环模块记录

循环模块记录用于表示可以与属于循环模块记录类型子类的其他模块参与依赖循环的模块信息。非循环模块记录子类的模块记录不得与源文本模块记录参加依赖循环。

除了表 40 中定义的字段外，循环模块记录还有表 42 中列出的附加字段。

**表 42：循环模块记录的附加字段**

| 字段名               | 值类型                | 含义                                                                 |
|----------------------|-----------------------|----------------------------------------------------------------------|
| [[Status]]           | NEW, UNLINKED, LINKING,

 LINKED, EVALUATING, EVALUATING-ASYNC, or EVALUATED | 初始值为 NEW。在模块生命周期的不同阶段依次转换状态：UNLINKED、LINKING、LINKED、EVALUATING、可能的 EVALUATING-ASYNC、EVALUATED。EVALUATING-ASYNC 表示该模块已排队等待异步依赖项完成执行，或其 [[HasTLA]] 字段为 true 并已执行且等待顶级完成。 |
| [[EvaluationError]]  | 一个抛出完成或 EMPTY  | 在评估期间发生的异常的抛出完成。如果未发生异常或 [[Status]] 不是 EVALUATED，则为 undefined。               |
| [[DFSIndex]]         | 整数或 EMPTY          | 仅在 Link 和 Evaluate 期间使用的辅助字段。如果 [[Status]] 是 LINKING 或 EVALUATING，此非负数记录在依赖图的深度优先遍历过程中首次访问模块的点。                   |
| [[DFSAncestorIndex]] | 整数或 EMPTY          | 仅在 Link 和 Evaluate 期间使用的辅助字段。如果 [[Status]] 是 LINKING 或 EVALUATING，则为模块自身的 [[DFSIndex]] 或同一强连接组件中“更早”模块的 [[DFSIndex]]。         |
| [[RequestedModules]] | 字符串列表            | 模块表示的模块使用的所有 ModuleSpecifier 字符串的列表。列表按源文本出现顺序排列。               |
| [[LoadedModules]]    | 记录列表，字段为[[Specifier]]（字符串）和[[Module]]（模块记录） | 从此模块导入的解析的模块记录的映射。列表不包含具有相同[[Specifier]]的两个不同记录。       |
| [[CycleRoot]]        | 循环模块记录或 EMPTY  | 循环的第一个访问模块，强连接组件的根 DFS 祖先。对于不在循环中的模块，即为模块自身。一旦 Evaluate 完成，模块的 [[DFSAncestorIndex]] 就是其 [[CycleRoot]] 的 [[DFSIndex]]。         |
| [[HasTLA]]           | 布尔值                | 此模块是否单独异步（例如，如果它是包含顶级 await 的源文本模块记录）。具有异步依赖项并不意味着此字段为 true。此字段在模块解析后不得更改。               |
| [[AsyncEvaluation]]  | 布尔值                | 此模块本身是否异步或具有异步依赖项。注意：此字段设置的顺序用于排序排队的执行。见 16.2.1.5.3.4。               |
| [[TopLevelCapability]] | 一个 PromiseCapability 记录或 EMPTY | 如果此模块是某个循环的 [[CycleRoot]]，并且对该循环中的某个模块调用了 Evaluate()，此字段包含整个评估的 PromiseCapability 记录。用于解决从 Evaluate() 抽象方法返回的 Promise 对象。对于该模块的任何依赖项，如果未启动对这些依赖项的顶级 Evaluate()，则此字段将为空。       |
| [[AsyncParentModules]] | 循环模块记录列表    | 如果此模块或其依赖项具有 [[HasTLA]] 为 true 并且正在执行，此字段跟踪该模块的顶级执行作业的父导入模块。这些父模块在该模块成功完成执行之前不会开始执行。              |
| [[PendingAsyncDependencies]] | 整数或 EMPTY  | 如果此模块有任何异步依赖项，此字段跟踪该模块剩余的异步依赖模块数。具有异步依赖项的模块将在此字段变为 0 且无执行错误时执行。              |

除了表 41 中定义的方法外，循环模块记录还有表 43 中列出的附加方法。

**表 43：循环模块记录的附加抽象方法**

| 方法                        | 目的                                                                                                   |
|-----------------------------|--------------------------------------------------------------------------------------------------------|
| InitializeEnvironment()      | 初始化模块的环境记录，包括解析所有导入的绑定，并创建模块的执行上下文。                                  |
| ExecuteModule([promiseCapability]) | 在其执行上下文中评估模块的代码。如果此模块的 [[HasTLA]] 为 true，则传递一个 PromiseCapability 记录作为参数，并且方法预期解决或拒绝给定的 capability。在这种情况下，该方法不得抛出异常，而应在必要时拒绝 PromiseCapability 记录。 |

GraphLoadingState 记录是包含有关模块图加载过程信息的记录。它用于在调用 HostLoadImportedModule 后继续加载。每个 GraphLoadingState 记录具有表 44 中定义的字段：

**表 44：GraphLoadingState 记录字段**

| 字段名               | 值类型                | 含义                                                                 |
|----------------------|-----------------------|----------------------------------------------------------------------|
| [[PromiseCapability]]| PromiseCapability 记录 | 加载过程完成时要解决的 Promise。                                       |
| [[IsLoading]]        | 布尔值                | 如果加载过程尚未完成（无论成功与否），则为 true。                               |
| [[PendingModulesCount]] | 非负整数            | 跟踪待处理的 HostLoadImportedModule 调用数。                                |
| [[Visited]]          | 循环模块记录列表      | 当前加载过程中已经加载的循环模块记录列表，以避免循环依赖导致的无限循环。                         |
| [[HostDefined]]      | 任何（默认值为 EMPTY）| 包含主机定义的数据，用于从 LoadRequestedModules 调用传递到 HostLoadImportedModule。        |

##### 16.2.1.5.1 LoadRequestedModules（[hostDefined]）

循环模块记录模块的 LoadRequestedModules 具体方法接受可选参数 hostDefined（任何）并返回一个 Promise。它通过递归加载模块的依赖图中的所有依赖项来填充模块记录的 [[LoadedModules]]。调用时执行以下步骤：

1. 如果 hostDefined 不存在，令 hostDefined 为 EMPTY。
2. 令 pc 为 ! NewPromiseCapability(%Promise%)。
3. 令 state 为 GraphLoadingState 记录 { [[IsLoading]]: true, [[PendingModulesCount]]: 1, [[Visited]]: « », [[PromiseCapability]]: pc, [[HostDefined]]: hostDefined }。
4. 执行 InnerModuleLoading(state, module)。
5. 返回 pc.[[Promise]]。

**注意** hostDefined 参数可以用于传递加载导入模块所需的附加信息。例如，HTML 使用它来设置 <link rel="preload" as="..."> 标签的正确获取目标。import() 表达式从不设置 hostDefined 参数。

##### 16.2.1.5.1.1 InnerModuleLoading（state，module）

抽象操作 InnerModuleLoading 接受参数 state（一个 GraphLoadingState 记录）和 module（一个模块记录）并返回 UNUSED。它由 LoadRequestedModules 使用，递归执行模块依赖图的实际加载过程。调用时执行以下步骤：

1. 断言：state.[[IsLoading]] 为 true。
2. 如果 module 是一个循环模块记录，module.[[Status]] 为 NEW，并且 state.[[Visited]] 不包含 module，则
   a. 将 module 添加到 state.[[Visited]]。
   b. 令 requestedModulesCount 为 module.[[RequestedModules]] 中元素的数量。
   c. 将 state.[[PendingModulesCount]] 设置为 state.[[PendingModulesCount]] + requestedModulesCount。
   d. 对于 module.[[RequestedModules]] 的每个字符串 required，执行
     i. 如果 module.[[LoadedModules]] 包含一个 [[Specifier]] 为 required 的记录，则
        1. 令 record 为该记录。
        2. 执行 InnerModuleLoading(state, record.[[Module]])。
     ii. 否则，
        1. 执行 HostLoadImportedModule(module, required, state.[[HostDefined]], state)。
        2. **注意**：HostLoadImportedModule 将调用 FinishLoadingImportedModule，通过 ContinueModuleLoading 重新进入图加载过程。
     iii. 如果 state.[[IsLoading]] 为 false，返回 UNUSED。
3. 断言：state.[[PendingModulesCount]] ≥ 1。
4. 将 state.[[PendingModulesCount]] 设置为 state.[[PendingModulesCount]] - 1。
5. 如果 state.[[PendingModulesCount]] = 0，则
   a. 将 state.[[IsLoading]] 设置为 false。
   b. 对于 state.[[Visited]] 的每个循环模块记录 loaded，执行
      i. 如果 loaded.[[Status]] 为 NEW，将 loaded.[[Status]] 设置为 UNLINKED。
   c. 执行 ! Call(state.[[PromiseCapability]].[[Resolve]], undefined, « undefined »)。
6. 返回 UNUSED。

##### 16.2.1.5.1.2 ContinueModuleLoading（state，moduleCompletion）

抽象操作 ContinueModuleLoading 接受参数 state（一个 GraphLoadingState 记录）和 moduleCompletion（一个包含模块记录的正常完成或抛出完成）并返回 UNUSED。它用于在调用 HostLoadImportedModule 后重新进入加载过程。调用时执行以下步骤：

1. 如果 state.[[IsLoading]] 为 false，返回 UNUSED。
2. 如果 moduleCompletion 是正常完成，则
   a. 执行 InnerModuleLoading(state, moduleCompletion.[[Value]])。
3. 否则，
   a. 将 state.[[IsLoading]] 设置为 false。
   b.

 执行 ! Call(state.[[PromiseCapability]].[[Reject]], undefined, « moduleCompletion.[[Value]] »)。
4. 返回 UNUSED。

### 16.2.1.5.2 链接 ( )
Cyclic Module Record 模块的 Link 具体方法不接受任何参数，并返回包含 UNUSED 的正常完成结果或抛出完成结果。成功时，Link 将此模块的 [[Status]] 从 UNLINKED 转换为 LINKED。失败时，将抛出异常，并且此模块的 [[Status]] 保持为 UNLINKED。（大部分工作由辅助函数 InnerModuleLinking 完成。）调用时执行以下步骤：

1. 断言：module.[[Status]] 是 UNLINKED、LINKED、EVALUATING-ASYNC 或 EVALUATED 之一。
2. 设 stack 为一个新的空列表。
3. 设 result 为 Completion(InnerModuleLinking(module, stack, 0))。
4. 如果 result 是突然完成结果，则
   a. 对于 stack 中的每个 Cyclic Module Record m，
      i. 断言：m.[[Status]] 是 LINKING。
      ii. 将 m.[[Status]] 设为 UNLINKED。
   b. 断言：module.[[Status]] 是 UNLINKED。
   c. 返回 ? result。
5. 断言：module.[[Status]] 是 LINKED、EVALUATING-ASYNC 或 EVALUATED 之一。
6. 断言：stack 是空的。
7. 返回 UNUSED。

### 16.2.1.5.2.1 内部模块链接 ( module, stack, index )
InnerModuleLinking 抽象操作接受参数 module（一个 Module Record）、stack（一个 Cyclic Module Record 列表）和 index（一个非负整数），并返回包含非负整数的正常完成结果或抛出完成结果。它被 Link 用于执行模块的实际链接过程，并递归地在依赖图中的所有其他模块上执行。stack 和 index 参数以及模块的 [[DFSIndex]] 和 [[DFSAncestorIndex]] 字段用于跟踪深度优先搜索 (DFS) 遍历。特别是，[[DFSAncestorIndex]] 用于发现强连接分量 (SCC)，使得所有 SCC 中的模块一起转换为 LINKED。调用时执行以下步骤：

1. 如果 module 不是 Cyclic Module Record，则
   a. 执行 ? module.Link()。
   b. 返回 index。
2. 如果 module.[[Status]] 是 LINKING、LINKED、EVALUATING-ASYNC 或 EVALUATED 之一，则
   a. 返回 index。
3. 断言：module.[[Status]] 是 UNLINKED。
4. 将 module.[[Status]] 设为 LINKING。
5. 将 module.[[DFSIndex]] 设为 index。
6. 将 module.[[DFSAncestorIndex]] 设为 index。
7. 将 index 设为 index + 1。
8. 将 module 附加到 stack。
9. 对于 module.[[RequestedModules]] 的每个 String required，
   a. 设 requiredModule 为 GetImportedModule(module, required)。
   b. 将 index 设为 ? InnerModuleLinking(requiredModule, stack, index)。
   c. 如果 requiredModule 是 Cyclic Module Record，则
      i. 断言：requiredModule.[[Status]] 是 LINKING、LINKED、EVALUATING-ASYNC 或 EVALUATED 之一。
      ii. 断言：requiredModule.[[Status]] 是 LINKING，如果且仅如果 stack 包含 requiredModule。
      iii. 如果 requiredModule.[[Status]] 是 LINKING，则
         1. 将 module.[[DFSAncestorIndex]] 设为 min(module.[[DFSAncestorIndex]], requiredModule.[[DFSAncestorIndex]])。
10. 执行 ? module.InitializeEnvironment()。
11. 断言：module 恰好在 stack 中出现一次。
12. 断言：module.[[DFSAncestorIndex]] ≤ module.[[DFSIndex]]。
13. 如果 module.[[DFSAncestorIndex]] = module.[[DFSIndex]]，则
    a. 设 done 为 false。
    b. 重复，直到 done 为 false，
       i. 设 requiredModule 为 stack 的最后一个元素。
       ii. 删除 stack 的最后一个元素。
       iii. 断言：requiredModule 是 Cyclic Module Record。
       iv. 将 requiredModule.[[Status]] 设为 LINKED。
       v. 如果 requiredModule 和 module 是相同的 Module Record，则将 done 设为 true。
14. 返回 index。

### 16.2.1.5.3 评估 ( )
Cyclic Module Record 模块的 Evaluate 具体方法不接受任何参数并返回一个 Promise。Evaluate 将此模块的 [[Status]] 从 LINKED 转换为 EVALUATING-ASYNC 或 EVALUATED。第一次在给定强连接分量中的模块上调用时，Evaluate 创建并返回一个 Promise，该 Promise 在模块评估完成时解析。此 Promise 存储在组件的 [[CycleRoot]] 的 [[TopLevelCapability]] 字段中。以后对组件中任何模块调用 Evaluate 时，返回相同的 Promise。（大部分工作由辅助函数 InnerModuleEvaluation 完成。）调用时执行以下步骤：

1. 断言：此 Evaluate 调用与周围代理中的另一个 Evaluate 调用不是同时发生的。
2. 断言：module.[[Status]] 是 LINKED、EVALUATING-ASYNC 或 EVALUATED 之一。
3. 如果 module.[[Status]] 是 EVALUATING-ASYNC 或 EVALUATED，则将 module 设为 module.[[CycleRoot]]。
4. 如果 module.[[TopLevelCapability]] 不是 EMPTY，则
   a. 返回 module.[[TopLevelCapability]].[[Promise]]。
5. 设 stack 为一个新的空列表。
6. 设 capability 为 ! NewPromiseCapability(%Promise%)。
7. 将 module.[[TopLevelCapability]] 设为 capability。
8. 设 result 为 Completion(InnerModuleEvaluation(module, stack, 0))。
9. 如果 result 是突然完成结果，则
   a. 对于 stack 中的每个 Cyclic Module Record m，
      i. 断言：m.[[Status]] 是 EVALUATING。
      ii. 将 m.[[Status]] 设为 EVALUATED。
      iii. 将 m.[[EvaluationError]] 设为 result。
   b. 断言：module.[[Status]] 是 EVALUATED。
   c. 断言：module.[[EvaluationError]] 和 result 是相同的完成记录。
   d. 执行 ! Call(capability.[[Reject]], undefined, « result.[[Value]] »)。
10. 否则，
    a. 断言：module.[[Status]] 是 EVALUATING-ASYNC 或 EVALUATED 之一。
    b. 断言：module.[[EvaluationError]] 是 EMPTY。
    c. 如果 module.[[AsyncEvaluation]] 是 false，则
       i. 断言：module.[[Status]] 是 EVALUATED。
       ii. 执行 ! Call(capability.[[Resolve]], undefined, « undefined »)。
    d. 断言：stack 是空的。
11. 返回 capability.[[Promise]]。

### 16.2.1.5.3.1 内部模块评估 ( module, stack, index )
InnerModuleEvaluation 抽象操作接受参数 module（一个 Module Record）、stack（一个 Cyclic Module Record 列表）和 index（一个非负整数），并返回包含非负整数的正常完成结果或抛出完成结果。它被 Evaluate 用于执行模块的实际评估过程，并递归地在依赖图中的所有其他模块上执行。stack 和 index 参数以及模块的 [[DFSIndex]] 和 [[DFSAncestorIndex]] 字段与 InnerModuleLinking 中的使用方式相同。调用时执行以下步骤：

1. 如果 module 不是 Cyclic Module Record，则
   a. 设 promise 为 ! module.Evaluate()。
   b. 断言：promise.[[PromiseState]] 不是 PENDING。
   c. 如果 promise.[[PromiseState]] 是 REJECTED，则
      i. 返回 ThrowCompletion(promise.[[PromiseResult]])。
   d. 返回 index。
2. 如果 module.[[Status]] 是 EVALUATING-ASYNC 或 EVALUATED，则
   a. 如果 module.[[EvaluationError]] 是 EMPTY，则返回 index。
   b. 否则，返回 ? module.[[EvaluationError]]。
3. 如果 module.[[Status]] 是 EVALUATING，则返回 index。
4. 断言：module.[[Status]] 是 LINKED。
5. 将 module.[[Status]] 设为 EVALUATING。
6. 将 module.[[DFSIndex]] 设为 index。
7. 将 module.[[DFSAncestorIndex]] 设为 index。
8. 将 module.[[PendingAsyncDependencies]] 设为 0。
9. 将 index 设为 index + 1。
10. 将 module 附加到 stack。
11. 对于 module.[[RequestedModules]] 的每个 String required，
    a. 设 requiredModule 为 GetImportedModule(module, required)。
    b. 将 index 设为 ? InnerModuleEvaluation(requiredModule, stack, index)。
    c. 如果 requiredModule 是 Cyclic Module Record，则
       i. 断言：requiredModule.[[Status]] 是 EVALUATING、EVALUATING-ASYNC 或 EVALUATED 之一。
       ii. 断言：requiredModule.[[Status]] 是 EVALUATING，如果且仅如果 stack 包含 requiredModule。
      

 iii. 如果 requiredModule.[[Status]] 是 EVALUATING，则
          1. 将 module.[[DFSAncestorIndex]] 设为 min(module.[[DFSAncestorIndex]], requiredModule.[[DFSAncestorIndex]])。
       iv. 否则，
          1. 将 requiredModule 设为 requiredModule.[[CycleRoot]]。
          2. 断言：requiredModule.[[Status]] 是 EVALUATING-ASYNC 或 EVALUATED 之一。
          3. 如果 requiredModule.[[EvaluationError]] 不是 EMPTY，则返回 ? requiredModule.[[EvaluationError]]。
       v. 如果 requiredModule.[[AsyncEvaluation]] 是 true，则
          1. 将 module.[[PendingAsyncDependencies]] 设为 module.[[PendingAsyncDependencies]] + 1。
          2. 将 module 附加到 requiredModule.[[AsyncParentModules]]。
12. 如果 module.[[PendingAsyncDependencies]] > 0 或 module.[[HasTLA]] 是 true，则
    a. 断言：module.[[AsyncEvaluation]] 是 false 并且从未被设置为 true。
    b. 将 module.[[AsyncEvaluation]] 设为 true。
    c. 注意：模块记录的 [[AsyncEvaluation]] 字段转换为 true 的顺序是有意义的。（见 16.2.1.5.3.4。）
    d. 如果 module.[[PendingAsyncDependencies]] = 0，则执行 ExecuteAsyncModule(module)。
13. 否则，
    a. 执行 ? module.ExecuteModule()。
14. 断言：module 恰好在 stack 中出现一次。
15. 断言：module.[[DFSAncestorIndex]] ≤ module.[[DFSIndex]]。
16. 如果 module.[[DFSAncestorIndex]] = module.[[DFSIndex]]，则
    a. 设 done 为 false。
    b. 重复，直到 done 为 false，
       i. 设 requiredModule 为 stack 的最后一个元素。
       ii. 删除 stack 的最后一个元素。
       iii. 断言：requiredModule 是 Cyclic Module Record。
       iv. 如果 requiredModule.[[AsyncEvaluation]] 是 false，则将 requiredModule.[[Status]] 设为 EVALUATED。
       v. 否则，将 requiredModule.[[Status]] 设为 EVALUATING-ASYNC。
       vi. 如果 requiredModule 和 module 是相同的 Module Record，则将 done 设为 true。
       vii. 将 requiredModule.[[CycleRoot]] 设为 module。
17. 返回 index。

### 16.2.1.5.3.2 执行异步模块 ( module )
ExecuteAsyncModule 抽象操作接受参数 module（一个 Cyclic Module Record），并返回 UNUSED。调用时执行以下步骤：

1. 断言：module.[[Status]] 是 EVALUATING 或 EVALUATING-ASYNC 之一。
2. 断言：module.[[HasTLA]] 为 true。
3. 设 capability 为 ! NewPromiseCapability(%Promise%)。
4. 设 fulfilledClosure 为一个新的抽象闭包，没有参数，捕获 module 并在调用时执行以下步骤：
   a. 执行 AsyncModuleExecutionFulfilled(module)。
   b. 返回 undefined。
5. 设 onFulfilled 为 CreateBuiltinFunction(fulfilledClosure, 0, "", « »)。
6. 设 rejectedClosure 为一个新的抽象闭包，具有参数 (error)，捕获 module 并在调用时执行以下步骤：
   a. 执行 AsyncModuleExecutionRejected(module, error)。
   b. 返回 undefined。
7. 设 onRejected 为 CreateBuiltinFunction(rejectedClosure, 0, "", « »)。
8. 执行 PerformPromiseThen(capability.[[Promise]], onFulfilled, onRejected)。
9. 执行 ! module.ExecuteModule(capability)。
10. 返回 UNUSED。

### 16.2.1.5.3.3 收集可用的祖先 ( module, execList )
GatherAvailableAncestors 抽象操作接受参数 module（一个 Cyclic Module Record）和 execList（一个 Cyclic Module Record 列表），并返回 UNUSED。调用时执行以下步骤：

1. 对于 module.[[AsyncParentModules]] 的每个 Cyclic Module Record m，
   a. 如果 execList 不包含 m 且 m.[[CycleRoot]].[[EvaluationError]] 为 EMPTY，则
      i. 断言：m.[[Status]] 是 EVALUATING-ASYNC。
      ii. 断言：m.[[EvaluationError]] 是 EMPTY。
      iii. 断言：m.[[AsyncEvaluation]] 为 true。
      iv. 断言：m.[[PendingAsyncDependencies]] > 0。
      v. 将 m.[[PendingAsyncDependencies]] 设为 m.[[PendingAsyncDependencies]] - 1。
      vi. 如果 m.[[PendingAsyncDependencies]] = 0，则
         1. 将 m 附加到 execList。
         2. 如果 m.[[HasTLA]] 为 false，则执行 GatherAvailableAncestors(m, execList)。
2. 返回 UNUSED。

### 16.2.1.5.3.4 异步模块执行已完成 ( module )
AsyncModuleExecutionFulfilled 抽象操作接受参数 module（一个 Cyclic Module Record），并返回 UNUSED。调用时执行以下步骤：

1. 如果 module.[[Status]] 是 EVALUATED，则
   a. 断言：module.[[EvaluationError]] 不是 EMPTY。
   b. 返回 UNUSED。
2. 断言：module.[[Status]] 是 EVALUATING-ASYNC。
3. 断言：module.[[AsyncEvaluation]] 为 true。
4. 断言：module.[[EvaluationError]] 为 EMPTY。
5. 将 module.[[AsyncEvaluation]] 设为 false。
6. 将 module.[[Status]] 设为 EVALUATED。
7. 如果 module.[[TopLevelCapability]] 不是 EMPTY，则
   a. 断言：module.[[CycleRoot]] 和 module 是相同的 Module Record。
   b. 执行 ! Call(module.[[TopLevelCapability]].[[Resolve]], undefined, « undefined »)。
8. 设 execList 为一个新的空列表。
9. 执行 GatherAvailableAncestors(module, execList)。
10. 设 sortedExecList 为一个列表，其元素是 execList 的元素，按它们在 InnerModuleEvaluation 中将 [[AsyncEvaluation]] 字段设置为 true 的顺序排列。
11. 断言：sortedExecList 的所有元素的 [[AsyncEvaluation]] 字段都设置为 true，[[PendingAsyncDependencies]] 字段设置为 0，并且 [[EvaluationError]] 字段设置为 EMPTY。
12. 对于 sortedExecList 的每个 Cyclic Module Record m，
    a. 如果 m.[[Status]] 是 EVALUATED，则
       i. 断言：m.[[EvaluationError]] 不是 EMPTY。
    b. 否则，如果 m.[[HasTLA]] 为 true，则
       i. 执行 ExecuteAsyncModule(m)。
    c. 否则，
       i. 设 result 为 m.ExecuteModule()。
       ii. 如果 result 是突然完成结果，则
          1. 执行 AsyncModuleExecutionRejected(m, result.[[Value]])。
       iii. 否则，
          1. 将 m.[[Status]] 设为 EVALUATED。
          2. 如果 m.[[TopLevelCapability]] 不是 EMPTY，则
             a. 断言：m.[[CycleRoot]] 和 m 是相同的 Module Record。
             b. 执行 ! Call(m.[[TopLevelCapability]].[[Resolve]], undefined, « undefined »)。
13. 返回 UNUSED。

### 16.2.1.5.3.5 异步模块执行被拒绝 ( module, error )
AsyncModuleExecutionRejected 抽象操作接受参数 module（一个 Cyclic Module Record）和 error（一个 ECMAScript 语言值），并返回 UNUSED。调用时执行以下步骤：

1. 如果 module.[[Status]] 是 EVALUATED，则
   a. 断言：module.[[EvaluationError]] 不是 EMPTY。
   b. 返回 UNUSED。
2. 断言：module.[[Status]] 是 EVALUATING-ASYNC。
3. 断言：module.[[AsyncEvaluation]] 为 true。
4. 断言：module.[[EvaluationError]] 为 EMPTY。
5. 将 module.[[EvaluationError]] 设为 ThrowCompletion(error)。
6. 将 module.[[Status]] 设为 EVALUATED。
7. 对于 module.[[AsyncParentModules]] 的每个 Cyclic Module Record m，
   a. 执行 AsyncModuleExecutionRejected(m, error)。
8. 如果 module.[[TopLevelCapability]] 不是 EMPTY，则
   a. 断言：module.[[CycleRoot]] 和 module 是相同的 Module Record。
   b. 执行 ! Call(module.[[TopLevelCapability]].[[Reject]], undefined, « error »)。
9. 返回 UNUSED。

### 16.2.1.5.4 示例循环模块记录图
本非规范部分提供了一系列示例，展示了几个常见模块图的链接和评估过程，特别关注错误可能发生的情况。

首先，考虑以下简单的模块图：

#### 图2：一个简单的模块图
一个模块图，其中模块A依赖于模块B，模块B依赖于模块C。

首先假设没有错误条件。当主机第一次调用A.LoadRequestedModules()时，假设它会成功完成，并递归加载B和C的依赖项（分别是C和无），然后将A.[[Status]] = B.[[Status]] = C.[[Status]] 设为 UNLINKED。然后，当主机调用A.Link()时，它将成功完成（再次假设），使得A.[[Status]] = B.[[Status]] = C.[[Status]] 设为 LINKED。这些准备步骤可以在任何时候执行。稍后，当主机准备承受模块可能的副作用时，它可以调用A.Evaluate()，这将成功完成，返回一个解析为undefined的Promise（再次假设），并递归先评估C，然后是B。此时每个模块的[[Status]]将为EVALUATED。

接下来，考虑涉及链接错误的情况，在成功调用A.LoadRequestedModules()之后。例如，如果C的InnerModuleLinking成功，但随后B失败，例如因为它导入的某些内容C未提供，则原始的A.Link()将失败，A和B的[[Status]]保持UNLINKED。不过，C的[[Status]]已变为LINKED。

最后，考虑在成功调用Link()后涉及评估错误的情况。例如，如果C的InnerModuleEvaluation成功，但随后B失败，例如因为B包含抛出异常的代码，则原始的A.Evaluate()将失败，返回一个被拒绝的Promise。结果异常将记录在A和B的[[EvaluationError]]字段中，它们的[[Status]]将变为EVALUATED。C也将变为EVALUATED，但与A和B不同，它将不包含[[EvaluationError]]，因为它成功完成了评估。存储异常确保了主机尝试通过调用它们的Evaluate()方法重用A或B时，将遇到相同的异常。（主机不要求重用循环模块记录；同样，主机不要求公开这些方法抛出的异常对象。然而，规范允许这种使用。）

现在考虑一种不同类型的错误情况：

#### 图3：一个无法解析模块的模块图
一个模块图，其中模块A依赖于一个丢失（无法解析）的模块，用???表示。

在这种情况下，模块A声明了对某个其他模块的依赖，但不存在该模块的模块记录，即当请求该模块时，HostLoadImportedModule调用FinishLoadingImportedModule时会抛出异常。可能由于各种原因发生这种情况，例如对应的资源不存在，或者资源存在但ParseModule尝试解析结果源文本时返回一些错误。主机可以选择通过传递给FinishLoadingImportedModule的完成结果公开失败原因。在任何情况下，此异常都会导致加载失败，导致A的[[Status]]保持NEW。

加载、链接和评估错误之间的区别是由于以下特性：

评估必须仅执行一次，因为它可能会产生副作用；因此重要的是记住评估是否已经执行，即使不成功。（在错误情况下，记住异常也很有意义，因为否则后续的Evaluate()调用必须合成一个新的异常。）  
另一方面，链接是无副作用的，因此即使失败，也可以在稍后时间重试而没有问题。  
加载与主机紧密交互，某些主机可能希望允许用户重试失败的加载（例如，如果失败是由于暂时的网络状况不佳导致的）。  
现在，考虑一个具有循环的模块图：

#### 图4：一个循环模块图
一个模块图，其中模块A依赖于模块B和C，但模块B也依赖于模块A。

这里假设入口点是模块A，因此主机通过调用A.LoadRequestedModules()进行操作，这会对A执行InnerModuleLoading。这反过来调用了对B和C的InnerModuleLoading。由于循环，这再次触发了对A的InnerModuleLoading，但此时它是一个无操作，因为在这个LoadRequestedModules过程中，A的依赖加载已经触发。当图中的所有模块都成功加载后，它们的[[Status]]会同时从NEW转换为UNLINKED。

然后主机通过调用A.Link()继续操作，这会对A执行InnerModuleLinking。这反过来调用了对B的InnerModuleLinking。由于循环，这再次触发了对A的InnerModuleLinking，但此时它是一个无操作，因为A.[[Status]]已经是LINKING。当控制返回到A并对C触发InnerModuleLinking时，B.[[Status]]本身保持LINKING。在C.[[Status]]变为LINKED后，A和B会一起从LINKING转换为LINKED；这是设计使然，因为它们形成了一个强连接分量。可以同时转换同一SCC中的模块状态，因为在此阶段，模块图是通过深度优先搜索遍历的。

成功情况下，循环模块图的评估阶段也是类似的。

现在考虑A有一个链接错误的情况；例如，它试图从C导入一个不存在的绑定。在这种情况下，上述步骤仍会发生，包括第二次对A调用InnerModuleLinking的提前返回。然而，一旦我们回到原始的对A的InnerModuleLinking调用，它会在InitializeEnvironment期间失败，即在C.ResolveExport()之后。抛出的SyntaxError异常会传播到A.Link，它会重置当前在其堆栈上的所有模块（这些始终是仍然在LINKING的模块）。因此，A和B变为UNLINKED。注意C保持为LINKED。

或者，考虑A有一个评估错误的情况；例如，其源代码抛出异常。在这种情况下，上述步骤的评估时类比仍会发生，包括第二次对A调用InnerModuleEvaluation的提前返回。然而，一旦我们回到原始的对A的InnerModuleEvaluation调用，它会失败，假设异常被抛出。抛出的异常会传播到A.Evaluate()，它会将错误记录在所有当前在其堆栈上的模块（即，仍在EVALUATING的模块）以及通过[[AsyncParentModules]]，这些模块形成一个链，这些模块通过整个依赖图包含或依赖顶级await通过AsyncModuleExecutionRejected算法。因此，A和B变为EVALUATED，并且异常记录在A和B的[[EvaluationError]]字段中，而C变为EVALUATED但没有[[EvaluationError]]。

最后，考虑一个具有循环的模块图，其中所有模块都异步完成：

#### 图5：一个异步循环模块图
一个模块图，其中模块A依赖于模块B和C，模块B依赖于模块D，模块C依赖于模块D和E，模块D依赖于模块A。

加载和链接如前所述发生，所有模块的[[Status]]都设为LINKED。

调用A.Evaluate()会对A、B和D调用InnerModuleEvaluation，它们都会转换为EVALUATING。然后再次对A调用InnerModuleEvaluation，这是一个无操作，因为它已经在EVALUATING。此时，D.[[PendingAsyncDependencies]]为0，因此调用ExecuteAsyncModule(D)，并用新的PromiseCapability跟踪D的异步执行来调用D.ExecuteModule。我们回到对B的InnerModuleEvaluation，将B.[[PendingAsyncDependencies]]设为1，并将B.[[AsyncEvaluation]]设为true。我们回到原始的对A的InnerModuleEvaluation，将A.[[PendingAsyncDependencies]]设为1。在A的依赖项循环的下一次迭代中，我们对C调用InnerModuleEvaluation，从而对D（再次无操作）和E调用。由于E没有依赖项且不属于循环，因此我们以与D相同的方式调用ExecuteAsyncModule(E)，E会立即从堆栈中移除。我们再次回到原始的对A的InnerModuleEvaluation，将C.[[AsyncEvaluation]]设为true。现在我们完成了A的依赖项循环，将A.[[AsyncEvaluation]]设为true，并将整个强连接分量从堆栈中移除，同时将所有模块转换为EVALUATING-ASYNC。此时，模块的字段如表45所示。

##### 表45：初始Evaluate()调用后的模块字段
| 模块 | [[DFSIndex]] | [[DFSAncestorIndex]] | [[Status]] | [[AsyncEvaluation]] | [[AsyncParentModules]] | [[PendingAsyncDependencies]] |
|------|--------------|----------------------|------------|----------------------|-------------------------|-------------------------------|
| A    | 0            | 0                    | EVALUATING-ASYNC | true                | « »                    | 2（B和C）                    |
| B    | 1            | 0                    | EVALUATING-ASYNC | true                | « A »                  | 1（D）                      |
| C    | 3            | 0                    | EVALUATING-ASYNC | true                | « A »                  | 2（D和E）                    |
| D    | 2            | 0                    | EVALUATING-ASYNC | true                | « B, C »               | 0                            |


| E    | 4            | 4                    | EVALUATING-ASYNC | true                | « C »                  | 0                            |

我们假设E首先完成执行。当发生这种情况时，调用AsyncModuleExecutionFulfilled，E.[[Status]]设为EVALUATED，C.[[PendingAsyncDependencies]]减少为1。更新后的模块字段如表46所示。

##### 表46：模块E完成执行后的模块字段
| 模块 | [[DFSIndex]] | [[DFSAncestorIndex]] | [[Status]] | [[AsyncEvaluation]] | [[AsyncParentModules]] | [[PendingAsyncDependencies]] |
|------|--------------|----------------------|------------|----------------------|-------------------------|-------------------------------|
| C    | 3            | 0                    | EVALUATING-ASYNC | true                | « A »                  | 1（D）                      |
| E    | 4            | 4                    | EVALUATED       | true                | « C »                  | 0                            |

接下来是D完成执行（因为它是唯一一个仍在执行的模块）。当发生这种情况时，再次调用AsyncModuleExecutionFulfilled，D.[[Status]]设为EVALUATED。然后，B.[[PendingAsyncDependencies]]减少为0，调用ExecuteAsyncModule(B)，并开始执行。C.[[PendingAsyncDependencies]]也减少为0，并开始执行（如果B包含await，则可能与B并行执行）。更新后的模块字段如表47所示。

##### 表47：模块D完成执行后的模块字段
| 模块 | [[DFSIndex]] | [[DFSAncestorIndex]] | [[Status]] | [[AsyncEvaluation]] | [[AsyncParentModules]] | [[PendingAsyncDependencies]] |
|------|--------------|----------------------|------------|----------------------|-------------------------|-------------------------------|
| B    | 1            | 0                    | EVALUATING-ASYNC | true                | « A »                  | 0                            |
| C    | 3            | 0                    | EVALUATING-ASYNC | true                | « A »                  | 0                            |
| D    | 2            | 0                    | EVALUATED       | true                | « B, C »               | 0                            |

我们假设接下来是C完成执行。当发生这种情况时，再次调用AsyncModuleExecutionFulfilled，C.[[Status]]设为EVALUATED，A.[[PendingAsyncDependencies]]减少为1。更新后的模块字段如表48所示。

##### 表48：模块C完成执行后的模块字段
| 模块 | [[DFSIndex]] | [[DFSAncestorIndex]] | [[Status]] | [[AsyncEvaluation]] | [[AsyncParentModules]] | [[PendingAsyncDependencies]] |
|------|--------------|----------------------|------------|----------------------|-------------------------|-------------------------------|
| A    | 0            | 0                    | EVALUATING-ASYNC | true                | « »                    | 1（B）                       |
| C    | 3            | 0                    | EVALUATED       | true                | « A »                  | 0                            |

然后，B完成执行。当发生这种情况时，再次调用AsyncModuleExecutionFulfilled，B.[[Status]]设为EVALUATED。A.[[PendingAsyncDependencies]]减少为0，因此调用ExecuteAsyncModule并开始执行。更新后的模块字段如表49所示。

##### 表49：模块B完成执行后的模块字段
| 模块 | [[DFSIndex]] | [[DFSAncestorIndex]] | [[Status]] | [[AsyncEvaluation]] | [[AsyncParentModules]] | [[PendingAsyncDependencies]] |
|------|--------------|----------------------|------------|----------------------|-------------------------|-------------------------------|
| A    | 0            | 0                    | EVALUATING-ASYNC | true                | « »                    | 0                            |
| B    | 1            | 0                    | EVALUATED       | true                | « A »                  | 0                            |

最后，A完成执行。当发生这种情况时，再次调用AsyncModuleExecutionFulfilled，A.[[Status]]设为EVALUATED。此时，A.[[TopLevelCapability]]中的Promise（从A.Evaluate()返回）解析，结束了对该模块图的处理。更新后的模块字段如表50所示。

##### 表50：模块A完成执行后的模块字段
| 模块 | [[DFSIndex]] | [[DFSAncestorIndex]] | [[Status]] | [[AsyncEvaluation]] | [[AsyncParentModules]] | [[PendingAsyncDependencies]] |
|------|--------------|----------------------|------------|----------------------|-------------------------|-------------------------------|
| A    | 0            | 0                    | EVALUATED       | true                | « »                    | 0                            |

或者，考虑一个失败的情况，其中C在B完成执行之前返回错误。当发生这种情况时，调用AsyncModuleExecutionRejected，将C.[[Status]]设为EVALUATED，并将C.[[EvaluationError]]设为错误。然后，通过对每个AsyncParentModules执行AsyncModuleExecutionRejected，将此错误传播给它们。更新后的模块字段如表51所示。

##### 表51：模块C出错后的模块字段
| 模块 | [[DFSIndex]] | [[DFSAncestorIndex]] | [[Status]] | [[AsyncEvaluation]] | [[AsyncParentModules]] | [[PendingAsyncDependencies]] | [[EvaluationError]] |
|------|--------------|----------------------|------------|----------------------|-------------------------|-------------------------------|----------------------|
| A    | 0            | 0                    | EVALUATED       | true                | « »                    | 1（B）                       | EMPTY                |
| C    | 3            | 0                    | EVALUATED       | true                | « A »                  | 0                            | C的评估错误           |

由于C将调用AsyncModuleExecutionRejected，A将被拒绝并与C相同的错误。A.[[Status]]设为EVALUATED。此时，A.[[TopLevelCapability]]中的Promise（从A.Evaluate()返回）被拒绝。更新后的模块字段如表52所示。

##### 表52：模块A被拒绝后的模块字段
| 模块 | [[DFSIndex]] | [[DFSAncestorIndex]] | [[Status]] | [[AsyncEvaluation]] | [[AsyncParentModules]] | [[PendingAsyncDependencies]] | [[EvaluationError]] |
|------|--------------|----------------------|------------|----------------------|-------------------------|-------------------------------|----------------------|
| A    | 0            | 0                    | EVALUATED       | true                | « »                    | 0                            | C的评估错误           |

然后，B在没有错误的情况下完成执行。当发生这种情况时，再次调用AsyncModuleExecutionFulfilled，B.[[Status]]设为EVALUATED。对B调用GatherAvailableAncestors。然而，A.[[CycleRoot]]是A，它有一个评估错误，因此它不会被添加到返回的sortedExecList中，AsyncModuleExecutionFulfilled将返回而不进一步处理。B的任何未来导入者将从A的评估错误解析B.[[CycleRoot]].[[EvaluationError]]。更新后的模块字段如表53所示。

##### 表53：模块B在出错的图中完成执行后的模块字段
| 模块 | [[DFSIndex]] | [[DFSAncestorIndex]] | [[Status]] | [[AsyncEvaluation]] | [[AsyncParentModules]] | [[PendingAsyncDependencies]] | [[EvaluationError]] |
|------|--------------|----------------------|------------|----------------------|-------------------------|-------------------------------|----------------------|
| A    | 0            | 0                    | EVALUATED       | true                | « »                    | 0                            | C的评估错误           |
| B    | 1            | 0                    | EVALUATED       | true                | « A »                  | 0                            | EMPTY                |

### 16.2.1.6 源文本模块记录
源文本模块记录用于表示从ECMAScript源文本（11）定义的模块的信息，该源文本使用目标符号Module进行解析。其字段包含有关模块导入和导出名称的消化信息，其具体方法使用这些消化信息链接和评估模块。

源文本模块记录可以与抽象模块记录类型的其他子类一起存在于模块图中，并且可以与循环模块记录类型的其他子类参与循环。

除了表42中定义的字段外，源文本模块记录还有表54中列出的附加字段。这些字段最初在ParseModule中设置。

##### 表54：源文本模块记录的附加字段
| 字段名称          | 值类型             | 含义                                                            |
|-------------------|--------------------|-----------------------------------------------------------------|
| [[ECMAScriptCode]] | 解析节点            | 使用Module作为目标符号解析此模块的源文本的结果                   |
| [[Context]]        | ECMAScript代码执行上下文或EMPTY | 与此模块关联的执行上下文。直到模块的环境初始化后才为EMPTY       |
| [[ImportMeta]]     | 对象或EMPTY         | 通过import.meta元属性公开的对象。直到被ECMAScript代码访问后才为EMPTY |
| [[ImportEntries]]  | 导入条目记录的列表  | 从此模块的代码派生的导入条目记录列表                             |
| [[LocalExportEntries]]  | 导出条目记录的列表  | 从此模块的代码派生的对应于模块内声明的导出条目记录列表           |
| [[IndirectExportEntries]] | 导出条目记录的

列表  | 从此模块的代码派生的对应于模块内重新导出的导入条目记录或从export * as namespace声明中导出的条目记录列表 |
| [[StarExportEntries]] | 导出条目记录的列表  | 从此模块的代码派生的对应于export *声明的导出条目记录（不包括export * as namespace声明） |

导入条目记录是一个记录，消化了有关单个声明性导入的信息。每个导入条目记录都有表55中定义的字段：

##### 表55：导入条目记录字段
| 字段名称         | 值类型       | 含义                                                                 |
|------------------|--------------|----------------------------------------------------------------------|
| [[ModuleRequest]] | 字符串       | ImportDeclaration的ModuleSpecifier的字符串值                           |
| [[ImportName]]    | 字符串或NAMESPACE-OBJECT | 目标模块导出所需绑定的名称。值NAMESPACE-OBJECT表示导入请求目标模块的命名空间对象 |
| [[LocalName]]     | 字符串       | 在导入模块内本地访问导入值时使用的名称                                 |

##### 注意1
表56给出了用于表示语法导入形式的导入条目记录字段示例：

##### 表56（信息性）：导入形式映射到导入条目记录
| 导入语句形式               | [[ModuleRequest]] | [[ImportName]]   | [[LocalName]]   |
|----------------------------|-------------------|------------------|-----------------|
| import v from "mod";       | "mod"             | "default"        | "v"             |
| import * as ns from "mod"; | "mod"             | NAMESPACE-OBJECT | "ns"            |
| import {x} from "mod";     | "mod"             | "x"              | "x"             |
| import {x as v} from "mod";| "mod"             | "x"              | "v"             |
| import "mod";              | 不创建导入条目记录      |                  |                 |

导出条目记录是一个记录，消化了有关单个声明性导出的信息。每个导出条目记录都有表57中定义的字段：

##### 表57：导出条目记录字段
| 字段名称         | 值类型       | 含义                                                                 |
|------------------|--------------|----------------------------------------------------------------------|
| [[ExportName]]   | 字符串或null  | 模块用来导出此绑定的名称                                              |
| [[ModuleRequest]] | 字符串或null  | ExportDeclaration的ModuleSpecifier的字符串值。如果ExportDeclaration没有ModuleSpecifier，则为null |
| [[ImportName]]    | 字符串、null、ALL或ALL-BUT-DEFAULT | 目标模块导出所需绑定的名称。如果ExportDeclaration没有ModuleSpecifier，则为null。ALL用于export * as ns from "mod"声明。ALL-BUT-DEFAULT用于export * from "mod"声明 |
| [[LocalName]]     | 字符串或null  | 在导入模块内本地访问导出值时使用的名称。如果导出值在模块内不可本地访问，则为null |

##### 注意2
表58给出了用于表示语法导出形式的导出条目记录字段示例：

##### 表58（信息性）：导出形式映射到导出条目记录
| 导出语句形式                    | [[ExportName]] | [[ModuleRequest]] | [[ImportName]]   | [[LocalName]]   |
|---------------------------------|----------------|--------------------|------------------|-----------------|
| export var v;                   | "v"            | null               | null             | "v"             |
| export default function f() {}  | "default"      | null               | null             | "f"             |
| export default function () {}   | "default"      | null               | null             | "*default*"     |
| export default 42;              | "default"      | null               | null             | "*default*"     |
| export {x};                     | "x"            | null               | null             | "x"             |
| export {v as x};                | "x"            | null               | null             | "v"             |
| export {x} from "mod";          | "x"            | "mod"              | "x"              | null            |
| export {v as x} from "mod";     | "x"            | "mod"              | "v"              | null            |
| export * from "mod";            | null           | "mod"              | ALL-BUT-DEFAULT  | null            |
| export * as ns from "mod";      | "ns"           | "mod"              | ALL              | null            |

以下定义了源文本模块记录所需的具体方法和其他抽象操作。

### 16.2.1.6.1 ParseModule (sourceText, realm, hostDefined)
ParseModule 抽象操作接受参数 sourceText（ECMAScript 源文本）、realm（一个 Realm Record）和 hostDefined（任何东西），并返回一个 Source Text Module Record 或非空的 SyntaxError 对象列表。它基于将 sourceText 解析为一个模块的结果创建一个 Source Text Module Record。调用时执行以下步骤：

1. 设 body 为 ParseText(sourceText, Module)。
2. 如果 body 是错误列表，则返回 body。
3. 设 requestedModules 为 body 的 ModuleRequests。
4. 设 importEntries 为 body 的 ImportEntries。
5. 设 importedBoundNames 为 ImportedLocalNames(importEntries)。
6. 设 indirectExportEntries 为一个新的空列表。
7. 设 localExportEntries 为一个新的空列表。
8. 设 starExportEntries 为一个新的空列表。
9. 设 exportEntries 为 body 的 ExportEntries。
10. 对于 exportEntries 的每个 ExportEntry 记录 ee，执行
    a. 如果 ee.[[ModuleRequest]] 为 null，则
        i. 如果 importedBoundNames 不包含 ee.[[LocalName]]，则
            1. 将 ee 添加到 localExportEntries。
        ii. 否则，
            1. 设 ie 为 importEntries 中 [[LocalName]] 为 ee.[[LocalName]] 的元素。
            2. 如果 ie.[[ImportName]] 是 NAMESPACE-OBJECT，则
                a. 注意：这是重新导出导入的模块命名空间对象。
                b. 将 ee 添加到 localExportEntries。
            3. 否则，
                a. 注意：这是重新导出单个名称。
                b. 将 ExportEntry 记录 { [[ModuleRequest]]: ie.[[ModuleRequest]], [[ImportName]]: ie.[[ImportName]], [[LocalName]]: null, [[ExportName]]: ee.[[ExportName]] } 添加到 indirectExportEntries。
    b. 否则如果 ee.[[ImportName]] 是 ALL-BUT-DEFAULT，则
        i. 断言：ee.[[ExportName]] 为 null。
        ii. 将 ee 添加到 starExportEntries。
    c. 否则，
        i. 将 ee 添加到 indirectExportEntries。
11. 设 async 为 body Contains await。
12. 返回 Source Text Module Record { [[Realm]]: realm, [[Environment]]: EMPTY, [[Namespace]]: EMPTY, [[CycleRoot]]: EMPTY, [[HasTLA]]: async, [[AsyncEvaluation]]: false, [[TopLevelCapability]]: EMPTY, [[AsyncParentModules]]: « », [[PendingAsyncDependencies]]: EMPTY, [[Status]]: NEW, [[EvaluationError]]: EMPTY, [[HostDefined]]: hostDefined, [[ECMAScriptCode]]: body, [[Context]]: EMPTY, [[ImportMeta]]: EMPTY, [[RequestedModules]]: requestedModules, [[LoadedModules]]: « », [[ImportEntries]]: importEntries, [[LocalExportEntries]]: localExportEntries, [[IndirectExportEntries]]: indirectExportEntries, [[StarExportEntries]]: starExportEntries, [[DFSIndex]]: EMPTY, [[DFSAncestorIndex]]: EMPTY }。

注意：实现可能在解析模块源文本并分析其早期错误条件之前解析该模块源文本的 ParseModule。 但是，任何错误的报告必须推迟到此规范实际上对该源文本执行 ParseModule 的时候。

### 16.2.1.6.2 GetExportedNames ( [ exportStarSet ] )
Source Text Module Record 模块的 GetExportedNames 具体方法接受可选参数 exportStarSet（一个 Source Text Module Records 列表）并返回一个字符串列表。调用时执行以下步骤：

1. 断言：module.[[Status]] 不是 NEW。
2. 如果未提供 exportStarSet，则设 exportStarSet 为一个新的空列表。
3. 如果 exportStarSet 包含 module，则
    a. 断言：我们已到达 export * 循环的起点。
    b. 返回一个新的空列表。
4. 将 module 添加到 exportStarSet。
5. 设 exportedNames 为一个新的空列表。
6. 对于 module.[[LocalExportEntries]] 的每个 ExportEntry 记录 e，执行
    a. 断言：module 提供此导出的直接绑定。
    b. 断言：e.[[ExportName]] 不是 null。
    c. 将 e.[[ExportName]] 添加到 exportedNames。
7. 对于 module.[[IndirectExportEntries]] 的每个 ExportEntry 记录 e，执行
    a. 断言：module 导入此导出的特定绑定。
    b. 断言：e.[[ExportName]] 不是 null。
    c. 将 e.[[ExportName]] 添加到 exportedNames。
8. 对于 module.[[StarExportEntries]] 的每个 ExportEntry 记录 e，执行
    a. 断言：e.[[ModuleRequest]] 不是 null。
    b. 设 requestedModule 为 GetImportedModule(module, e.[[ModuleRequest]])。
    c. 设 starNames 为 requestedModule.GetExportedNames(exportStarSet)。
    d. 对于 starNames 的每个元素 n，执行
        i. 如果 n 不是 "default"，则
            1. 如果 exportedNames 不包含 n，则
                a. 将 n 添加到 exportedNames。
9. 返回 exportedNames。

注意：GetExportedNames 不会过滤掉或对具有模糊 star 导出绑定的名称抛出异常。

### 16.2.1.6.3 ResolveExport (exportName [ , resolveSet ])
Source Text Module Record 模块的 ResolveExport 具体方法接受参数 exportName（一个字符串）和可选参数 resolveSet（一个包含字段 [[Module]]（一个 Module Record）和 [[ExportName]]（一个字符串）的记录列表）并返回一个 ResolvedBinding 记录、null 或 AMBIGUOUS。

ResolveExport 试图将导入的绑定解析为实际定义的模块和本地绑定名称。定义模块可以是此方法调用的 Module Record 所表示的模块，也可以是该模块导入的其他模块。参数 resolveSet 用于检测未解析的循环导入/导出路径。如果到达的特定 Module Record 和 exportName 对已在 resolveSet 中，则遇到了导入循环。在递归调用 ResolveExport 之前，将 module 和 exportName 对添加到 resolveSet。

如果找到定义模块，则返回 ResolvedBinding 记录 { [[Module]], [[BindingName]] }。此记录标识最初请求的导出的解析绑定，除非这是没有本地绑定的命名空间的导出。在这种情况下，[[BindingName]] 将设置为 NAMESPACE。如果未找到定义或请求被发现是循环的，则返回 null。如果请求被发现是模糊的，则返回 AMBIGUOUS。

调用时执行以下步骤：

1. 断言：module.[[Status]] 不是 NEW。
2. 如果未提供 resolveSet，则设 resolveSet 为一个新的空列表。
3. 对于 resolveSet 中的每个记录 { [[Module]], [[ExportName]] } r，执行
    a. 如果 module 和 r.[[Module]] 是相同的 Module Record 并且 exportName 是 r.[[ExportName]]，则
        i. 断言：这是一个循环导入请求。
        ii. 返回 null。
4. 将记录 { [[Module]]: module, [[ExportName]]: exportName } 添加到 resolveSet。
5. 对于 module.[[LocalExportEntries]] 的每个 ExportEntry 记录 e，执行
    a. 如果 e.[[ExportName]] 是 exportName，则
        i. 断言：module 提供此导出的直接绑定。
        ii. 返回 ResolvedBinding 记录 { [[Module]]: module, [[BindingName]]: e.[[LocalName]] }。
6. 对于 module.[[IndirectExportEntries]] 的每个 ExportEntry 记录 e，执行
    a. 如果 e.[[ExportName]] 是 exportName，则
        i. 断言：e.[[ModuleRequest]] 不是 null。
        ii. 设 importedModule 为 GetImportedModule(module, e.[[ModuleRequest]])。
        iii. 如果 e.[[ImportName]] 是 ALL，则
            1. 断言：module 不提供此导出的直接绑定。
            2. 返回 ResolvedBinding 记录 { [[Module]]: importedModule, [[BindingName]]: NAMESPACE }。
        iv. 否则，
            1. 断言：module 导入此导出的特定绑定。
            2. 返回 importedModule.ResolveExport(e.[[ImportName]], resolveSet)。
7. 如果 exportName 是 "default"，则
    a. 断言：此模块未显式定义默认导出。
    b. 返回 null。
    c. 注意：默认导出不能由 export * from "mod" 声明提供。
8. 设 starResolution 为 null。
9. 对于 module.[[StarExportEntries]] 的每个 ExportEntry 记录 e，执行
    a. 断言：e.[[ModuleRequest]] 不是 null。
    b. 设 importedModule 为 GetImportedModule(module, e.[[ModuleRequest]])。
    c. 设 resolution 为 importedModule.ResolveExport(exportName, resolveSet)。
    d. 如果 resolution 是 AMBIGUOUS，则返回 AMBIGUOUS。
    e. 如果 resolution 不是 null，则


        i. 断言：resolution 是一个 ResolvedBinding 记录。
        ii. 如果 starResolution 是 null，则
            1. 设 starResolution 为 resolution。
        iii. 否则，
            1. 断言：有多个 * 导入包含所请求的名称。
            2. 如果 resolution.[[Module]] 和 starResolution.[[Module]] 不是相同的 Module Record，则返回 AMBIGUOUS。
            3. 如果 resolution.[[BindingName]] 不是 starResolution.[[BindingName]]，并且 resolution.[[BindingName]] 或 starResolution.[[BindingName]] 是 NAMESPACE，则返回 AMBIGUOUS。
            4. 如果 resolution.[[BindingName]] 是字符串，starResolution.[[BindingName]] 也是字符串，并且 resolution.[[BindingName]] 不同于 starResolution.[[BindingName]]，则返回 AMBIGUOUS。
10. 返回 starResolution。

### 16.2.1.6.4 InitializeEnvironment ( )
Source Text Module Record 模块的 InitializeEnvironment 具体方法不接受任何参数，并返回包含 UNUSED 的正常完成结果或抛出完成结果。调用时执行以下步骤：

1. 对于 module.[[IndirectExportEntries]] 的每个 ExportEntry 记录 e，执行
    a. 断言：e.[[ExportName]] 不是 null。
    b. 设 resolution 为 module.ResolveExport(e.[[ExportName]])。
    c. 如果 resolution 是 null 或 AMBIGUOUS，则抛出 SyntaxError 异常。
    d. 断言：resolution 是一个 ResolvedBinding 记录。
2. 断言：module 的所有命名导出都是可解析的。
3. 设 realm 为 module.[[Realm]]。
4. 断言：realm 不是 undefined。
5. 设 env 为 NewModuleEnvironment(realm.[[GlobalEnv]])。
6. 将 module.[[Environment]] 设为 env。
7. 对于 module.[[ImportEntries]] 的每个 ImportEntry 记录 in，执行
    a. 设 importedModule 为 GetImportedModule(module, in.[[ModuleRequest]])。
    b. 如果 in.[[ImportName]] 是 NAMESPACE-OBJECT，则
        i. 设 namespace 为 GetModuleNamespace(importedModule)。
        ii. 执行 ! env.CreateImmutableBinding(in.[[LocalName]], true)。
        iii. 执行 ! env.InitializeBinding(in.[[LocalName]], namespace)。
    c. 否则，
        i. 设 resolution 为 importedModule.ResolveExport(in.[[ImportName]])。
        ii. 如果 resolution 是 null 或 AMBIGUOUS，则抛出 SyntaxError 异常。
        iii. 如果 resolution.[[BindingName]] 是 NAMESPACE，则
            1. 设 namespace 为 GetModuleNamespace(resolution.[[Module]])。
            2. 执行 ! env.CreateImmutableBinding(in.[[LocalName]], true)。
            3. 执行 ! env.InitializeBinding(in.[[LocalName]], namespace)。
        iv. 否则，
            1. 执行 env.CreateImportBinding(in.[[LocalName]], resolution.[[Module]], resolution.[[BindingName]])。
8. 设 moduleContext 为一个新的 ECMAScript 代码执行上下文。
9. 将 moduleContext 的 Function 设为 null。
10. 断言：module.[[Realm]] 不是 undefined。
11. 将 moduleContext 的 Realm 设为 module.[[Realm]]。
12. 将 moduleContext 的 ScriptOrModule 设为 module。
13. 将 moduleContext 的 VariableEnvironment 设为 module.[[Environment]]。
14. 将 moduleContext 的 LexicalEnvironment 设为 module.[[Environment]]。
15. 将 moduleContext 的 PrivateEnvironment 设为 null。
16. 将 module.[[Context]] 设为 moduleContext。
17. 将 moduleContext 推入执行上下文堆栈；moduleContext 现在是正在运行的执行上下文。
18. 设 code 为 module.[[ECMAScriptCode]]。
19. 设 varDeclarations 为 code 的 VarScopedDeclarations。
20. 设 declaredVarNames 为一个新的空列表。
21. 对于 varDeclarations 的每个元素 d，执行
    a. 对于 d 的 BoundNames 的每个元素 dn，执行
        i. 如果 declaredVarNames 不包含 dn，则
            1. 执行 ! env.CreateMutableBinding(dn, false)。
            2. 执行 ! env.InitializeBinding(dn, undefined)。
            3. 将 dn 添加到 declaredVarNames。
22. 设 lexDeclarations 为 code 的 LexicallyScopedDeclarations。
23. 设 privateEnv 为 null。
24. 对于 lexDeclarations 的每个元素 d，执行
    a. 对于 d 的 BoundNames 的每个元素 dn，执行
        i. 如果 d 的 IsConstantDeclaration 为 true，则
            1. 执行 ! env.CreateImmutableBinding(dn, true)。
        ii. 否则，
            1. 执行 ! env.CreateMutableBinding(dn, false)。
        iii. 如果 d 是 FunctionDeclaration、GeneratorDeclaration、AsyncFunctionDeclaration 或 AsyncGeneratorDeclaration，则
            1. 设 fo 为 d 的 InstantiateFunctionObject，参数为 env 和 privateEnv。
            2. 执行 ! env.InitializeBinding(dn, fo)。
25. 将 moduleContext 从执行上下文堆栈中移除。
26. 返回 UNUSED。

### 16.2.1.6.5 ExecuteModule ( [ capability ] )
Source Text Module Record 模块的 ExecuteModule 具体方法接受可选参数 capability（一个 PromiseCapability 记录）并返回包含 UNUSED 的正常完成结果或抛出完成结果。调用时执行以下步骤：

1. 设 moduleContext 为一个新的 ECMAScript 代码执行上下文。
2. 将 moduleContext 的 Function 设为 null。
3. 将 moduleContext 的 Realm 设为 module.[[Realm]]。
4. 将 moduleContext 的 ScriptOrModule 设为 module。
5. 断言：模块已链接且其模块环境中的声明已实例化。
6. 将 moduleContext 的 VariableEnvironment 设为 module.[[Environment]]。
7. 将 moduleContext 的 LexicalEnvironment 设为 module.[[Environment]]。
8. 挂起正在运行的执行上下文。
9. 如果 module.[[HasTLA]] 为 false，则
    a. 断言：capability 不存在。
    b. 将 moduleContext 推入执行上下文堆栈；moduleContext 现在是正在运行的执行上下文。
    c. 设 result 为 Completion(Evaluation of module.[[ECMAScriptCode]])。
    d. 挂起 moduleContext 并将其从执行上下文堆栈中移除。
    e. 恢复现在位于执行上下文堆栈顶部的上下文作为正在运行的执行上下文。
    f. 如果 result 是突然完成，则
        i. 返回 ? result。
10. 否则，
    a. 断言：capability 是一个 PromiseCapability 记录。
    b. 执行 AsyncBlockStart(capability, module.[[ECMAScriptCode]], moduleContext)。
11. 返回 UNUSED。

### 16.2.1.7 GetImportedModule (referrer, specifier)
GetImportedModule 抽象操作接受参数 referrer（一个 Cyclic Module Record）和 specifier（一个字符串），并返回一个 Module Record。调用时执行以下步骤：

1. 断言：referrer.[[LoadedModules]] 中恰好有一个元素是 [[Specifier]] 为 specifier 的记录，因为 LoadRequestedModules 在调用此抽象操作之前已在 referrer 上成功完成。
2. 设 record 为 referrer.[[LoadedModules]] 中 [[Specifier]] 为 specifier 的记录。
3. 返回 record.[[Module]]。

### 16.2.1.8 HostLoadImportedModule (referrer, specifier, hostDefined, payload)
HostLoadImportedModule 是一个宿主定义的抽象操作，接受参数 referrer（一个 Script Record、一个 Cyclic Module Record 或一个 Realm Record）、specifier（一个字符串）、hostDefined（任何东西）和 payload（一个 GraphLoadingState Record 或一个 PromiseCapability Record），并返回 UNUSED。

#### 注意
在某些情况下，referrer 可以是一个 Realm Record，例如在一个 Web 浏览器宿主中。如果用户点击一个如下所示的控件：

```html
<button type="button" onclick="import('./foo.mjs')">Click me</button>
```

在 import() 表达式运行时，将没有活动的脚本或模块。更一般地，这可以发生在宿主将具有 null ScriptOrModule 组件的执行上下文推入执行上下文堆栈的任何情况中。

HostLoadImportedModule 的实现必须符合以下要求：

宿主环境必须执行 FinishLoadingImportedModule(referrer, specifier, payload, result)，其中 result 要么是包含加载的模块记录的正常完成，要么是抛出完成，可以是同步或异步的。
如果多次调用此操作，并且以相同的 (referrer, specifier) 对执行 FinishLoadingImportedModule(referrer, specifier, payload, result)，并且 result 是正常完成，那么每次都必须执行相同结果的 FinishLoadingImportedModule(referrer, specifier, payload, result)。
操作必须将 payload 视为要传递给 FinishLoadingImportedModule 的不透明值。
实际执行的过程由宿主定义，但通常包括执行任何必要的 I/O 操作以加载适当的模块记录。多个不同的 (referrer, specifier) 对可以映射到同一个模块记录实例。实际的映射语义由宿主定义，但通常在映射过程中会对 specifier 进行规范化处理。典型的规范化过程包括扩展相对和缩写路径规范符。

### 16.2.1.9 FinishLoadingImportedModule (referrer, specifier, payload, result)
FinishLoadingImportedModule 抽象操作接受参数 referrer（一个 Script Record、一个 Cyclic Module Record 或一个 Realm Record）、specifier（一个字符串）、payload（一个 GraphLoadingState Record 或一个 PromiseCapability Record）和 result（要么是包含模块记录的正常完成，要么是抛出完成），并返回 UNUSED。调用时执行以下步骤：

1. 如果 result 是正常完成，则
    a. 如果 referrer.[[LoadedModules]] 包含一个 [[Specifier]] 为 specifier 的记录，则
        i. 断言：该记录的 [[Module]] 是 result.[[Value]]。
    b. 否则，
        i. 将记录 { [[Specifier]]: specifier, [[Module]]: result.[[Value]] } 添加到 referrer.[[LoadedModules]]。
2. 如果 payload 是一个 GraphLoadingState 记录，则
    a. 执行 ContinueModuleLoading(payload, result)。
3. 否则，
    a. 执行 ContinueDynamicImport(payload, result)。
4. 返回 UNUSED。

### 16.2.1.10 GetModuleNamespace (module)
GetModuleNamespace 抽象操作接受参数 module（Module Record 的一个具体子类的实例），并返回一个模块命名空间对象或 EMPTY。它检索表示模块导出的模块命名空间对象，首次请求时懒惰创建，并将其存储在 module.[[Namespace]] 中以供将来检索。调用时执行以下步骤：

1. 断言：如果 module 是一个 Cyclic Module Record，则 module.[[Status]] 不是 NEW 或 UNLINKED。
2. 设 namespace 为 module.[[Namespace]]。
3. 如果 namespace 是 EMPTY，则
    a. 设 exportedNames 为 module.GetExportedNames()。
    b. 设 unambiguousNames 为一个新的空列表。
    c. 对于 exportedNames 的每个元素 name，执行
        i. 设 resolution 为 module.ResolveExport(name)。
        ii. 如果 resolution 是一个 ResolvedBinding 记录，将 name 添加到 unambiguousNames。
    d. 设 namespace 为 ModuleNamespaceCreate(module, unambiguousNames)。
4. 返回 namespace。

#### 注意
GetModuleNamespace 从不抛出异常。相反，不可解析的名称此时只是从命名空间中排除。除非它们都是不明确的 star 导出且未在任何地方明确请求，否则它们将在稍后导致实际的链接错误。

### 16.2.1.11 运行时语义：评估
#### Module : [empty]
1. 返回 undefined。

#### ModuleBody : ModuleItemList
1. 设 result 为 Completion(Evaluation of ModuleItemList)。
2. 如果 result 是正常完成并且 result.[[Value]] 是 EMPTY，则
    a. 返回 undefined。
3. 返回 ? result。

#### ModuleItemList : ModuleItemList ModuleItem
1. 设 sl 为 ? Evaluation of ModuleItemList。
2. 设 s 为 Completion(Evaluation of ModuleItem)。
3. 返回 ? UpdateEmpty(s, sl)。

#### 注意
ModuleItemList 的值是 ModuleItemList 中最后一个产生值的项的值。

#### ModuleItem : ImportDeclaration
1. 返回 EMPTY。

### 16.2.2 导入
#### 语法
```plaintext
ImportDeclaration :
    import ImportClause FromClause ;
    import ModuleSpecifier ;
ImportClause :
    ImportedDefaultBinding
    NameSpaceImport
    NamedImports
    ImportedDefaultBinding , NameSpaceImport
    ImportedDefaultBinding , NamedImports
ImportedDefaultBinding :
    ImportedBinding
NameSpaceImport :
    * as ImportedBinding
NamedImports :
    { }
    { ImportsList }
    { ImportsList , }
FromClause :
    from ModuleSpecifier
ImportsList :
    ImportSpecifier
    ImportsList , ImportSpecifier
ImportSpecifier :
    ImportedBinding
    ModuleExportName as ImportedBinding
ModuleSpecifier :
    StringLiteral
ImportedBinding :
    BindingIdentifier[~Yield, +Await]
```

### 16.2.2.1 静态语义：早期错误
#### ModuleItem : ImportDeclaration
如果 ImportDeclaration 的 BoundNames 包含任何重复条目，则这是一个语法错误。

### 16.2.2.2 静态语义：ImportEntries
ImportEntries 语法指导操作不接受任何参数并返回一个 ImportEntry 记录列表。它在以下产生式上逐块定义：

#### Module : [empty]
1. 返回一个新的空列表。

#### ModuleItemList : ModuleItemList ModuleItem
1. 设 entries1 为 ModuleItemList 的 ImportEntries。
2. 设 entries2 为 ModuleItem 的 ImportEntries。
3. 返回 entries1 和 entries2 的列表连接。

#### ModuleItem :
ExportDeclaration
StatementListItem
1. 返回一个新的空列表。

#### ImportDeclaration : import ImportClause FromClause ;
1. 设 module 为 FromClause 的 ModuleRequests 的唯一元素。
2. 返回 ImportClause 的 ImportEntriesForModule 参数为 module。

#### ImportDeclaration : import ModuleSpecifier ;
1. 返回一个新的空列表。

### 16.2.2.3 静态语义：ImportEntriesForModule
ImportEntriesForModule 语法指导操作接受参数 module（一个字符串）并返回一个 ImportEntry 记录列表。它在以下产生式上逐块定义：

#### ImportClause : ImportedDefaultBinding , NameSpaceImport
1. 设 entries1 为 ImportedDefaultBinding 的 ImportEntriesForModule 参数为 module。
2. 设 entries2 为 NameSpaceImport 的 ImportEntriesForModule 参数为 module。
3. 返回 entries1 和 entries2 的列表连接。

#### ImportClause : ImportedDefaultBinding , NamedImports
1. 设 entries1 为 ImportedDefaultBinding 的 ImportEntriesForModule 参数为 module。
2. 设 entries2 为 NamedImports 的 ImportEntriesForModule 参数为 module。
3. 返回 entries1 和 entries2 的列表连接。

#### ImportedDefaultBinding : ImportedBinding
1. 设 localName 为 ImportedBinding 的 BoundNames 的唯一元素。
2. 设 defaultEntry 为 ImportEntry 记录 { [[ModuleRequest]]: module, [[ImportName]]: "default", [[LocalName]]: localName }。
3. 返回 « defaultEntry »。

#### NameSpaceImport : * as ImportedBinding
1. 设 localName 为 ImportedBinding 的 StringValue。
2. 设 entry 为 ImportEntry 记录 { [[ModuleRequest]]: module, [[ImportName]]: NAMESPACE-OBJECT, [[LocalName]]: localName }。
3. 返回 « entry »。

#### NamedImports : { }
1. 返回一个新的空列表。

#### ImportsList : ImportsList , ImportSpecifier
1. 设 specs1 为 ImportsList 的 ImportEntriesForModule 参数为 module。
2. 设 specs2 为 ImportSpecifier 的 ImportEntriesForModule 参数为 module。
3. 返回 specs1 和 specs2 的列表连接。

#### ImportSpecifier : ImportedBinding
1. 设 localName 为 ImportedBinding 的 BoundNames 的唯一元素。
2. 设 entry 为 ImportEntry 记录 { [[ModuleRequest]]: module, [[ImportName]]: localName, [[LocalName]]: localName }。
3. 返回 « entry »。

#### ImportSpecifier : ModuleExportName as ImportedBinding
1. 设 importName 为 ModuleExportName 的 StringValue。
2. 设 localName 为 ImportedBinding 的 StringValue。
3. 设 entry 为 ImportEntry 记录 { [[ModuleRequest]]: module, [[ImportName]]

: importName, [[LocalName]]: localName }。
4. 返回 « entry »。

### 16.2.3 导出
#### 语法
```plaintext
ExportDeclaration :
    export ExportFromClause FromClause ;
    export NamedExports ;
    export VariableStatement[~Yield, +Await]
    export Declaration[~Yield, +Await]
    export default HoistableDeclaration[~Yield, +Await, +Default]
    export default ClassDeclaration[~Yield, +Await, +Default]
    export default [lookahead ∉ { function, async [no LineTerminator here] function, class }] AssignmentExpression[+In, ~Yield, +Await] ;
ExportFromClause :
    *
    * as ModuleExportName
    NamedExports
NamedExports :
    { }
    { ExportsList }
    { ExportsList , }
ExportsList :
    ExportSpecifier
    ExportsList , ExportSpecifier
ExportSpecifier :
    ModuleExportName
    ModuleExportName as ModuleExportName
```

### 16.2.3.1 静态语义：早期错误
#### ExportDeclaration : export NamedExports ;
如果 NamedExports 的 ReferencedBindings 包含任何字符串字面量，则这是一个语法错误。
对于 NamedExports 的 ReferencedBindings 中的每个 IdentifierName n：如果 n 的 StringValue 是保留字，或 n 的 StringValue 是 "implements"、"interface"、"let"、"package"、"private"、"protected"、"public" 或 "static" 之一，则这是一个语法错误。

#### 注意
上述规则意味着 NamedExports 的每个 ReferencedBindings 都被视为一个 IdentifierReference。

### 16.2.3.2 静态语义：ExportedBindings
ExportedBindings 语法指导操作不接受任何参数并返回一个字符串列表。

#### 注意
ExportedBindings 是显式与模块的 ExportedNames 关联的本地绑定名称。

它在以下产生式上逐块定义：

#### ModuleItemList : ModuleItemList ModuleItem
1. 设 names1 为 ModuleItemList 的 ExportedBindings。
2. 设 names2 为 ModuleItem 的 ExportedBindings。
3. 返回 names1 和 names2 的列表连接。

#### ModuleItem :
ImportDeclaration
StatementListItem
1. 返回一个新的空列表。

#### ExportDeclaration :
export ExportFromClause FromClause ;
1. 返回一个新的空列表。

#### ExportDeclaration : export NamedExports ;
1. 返回 NamedExports 的 ExportedBindings。

#### ExportDeclaration : export VariableStatement
1. 返回 VariableStatement 的 BoundNames。

#### ExportDeclaration : export Declaration
1. 返回 Declaration 的 BoundNames。

#### ExportDeclaration :
export default HoistableDeclaration
export default ClassDeclaration
export default AssignmentExpression ;
1. 返回此 ExportDeclaration 的 BoundNames。

#### NamedExports : { }
1. 返回一个新的空列表。

#### ExportsList : ExportsList , ExportSpecifier
1. 设 names1 为 ExportsList 的 ExportedBindings。
2. 设 names2 为 ExportSpecifier 的 ExportedBindings。
3. 返回 names1 和 names2 的列表连接。

#### ExportSpecifier : ModuleExportName
1. 返回一个列表，其唯一元素是 ModuleExportName 的 StringValue。

#### ExportSpecifier : ModuleExportName as ModuleExportName
1. 返回一个列表，其唯一元素是第一个 ModuleExportName 的 StringValue。

### 16.2.3.3 静态语义：ExportedNames
ExportedNames 语法指导操作不接受任何参数并返回一个字符串列表。

#### 注意
ExportedNames 是模块显式映射到其本地名称绑定的外部可见名称。

它在以下产生式上逐块定义：

#### ModuleItemList : ModuleItemList ModuleItem
1. 设 names1 为 ModuleItemList 的 ExportedNames。
2. 设 names2 为 ModuleItem 的 ExportedNames。
3. 返回 names1 和 names2 的列表连接。

#### ModuleItem : ExportDeclaration
1. 返回 ExportDeclaration 的 ExportedNames。

#### ModuleItem :
ImportDeclaration
StatementListItem
1. 返回一个新的空列表。

#### ExportDeclaration : export ExportFromClause FromClause ;
1. 返回 ExportFromClause 的 ExportedNames。

#### ExportFromClause : *
1. 返回一个新的空列表。

#### ExportFromClause : * as ModuleExportName
1. 返回一个列表，其唯一元素是 ModuleExportName 的 StringValue。

#### ExportFromClause : NamedExports
1. 返回 NamedExports 的 ExportedNames。

#### ExportDeclaration : export VariableStatement
1. 返回 VariableStatement 的 BoundNames。

#### ExportDeclaration : export Declaration
1. 返回 Declaration 的 BoundNames。

#### ExportDeclaration :
export default HoistableDeclaration
export default ClassDeclaration
export default AssignmentExpression ;
1. 返回 « "default" »。

#### NamedExports : { }
1. 返回一个新的空列表。

#### ExportsList : ExportsList , ExportSpecifier
1. 设 names1 为 ExportsList 的 ExportedNames。
2. 设 names2 为 ExportSpecifier 的 ExportedNames。
3. 返回 names1 和 names2 的列表连接。

#### ExportSpecifier : ModuleExportName
1. 返回一个列表，其唯一元素是 ModuleExportName 的 StringValue。

#### ExportSpecifier : ModuleExportName as ModuleExportName
1. 返回一个列表，其唯一元素是第二个 ModuleExportName 的 StringValue。

### 16.2.3.4 静态语义：ExportEntries
ExportEntries 语法指导操作不接受任何参数并返回一个 ExportEntry 记录列表。它在以下产生式上逐块定义：

#### Module : [empty]
1. 返回一个新的空列表。

#### ModuleItemList : ModuleItemList ModuleItem
1. 设 entries1 为 ModuleItemList 的 ExportEntries。
2. 设 entries2 为 ModuleItem 的 ExportEntries。
3. 返回 entries1 和 entries2 的列表连接。

#### ModuleItem :
ImportDeclaration
StatementListItem
1. 返回一个新的空列表。

#### ExportDeclaration : export ExportFromClause FromClause ;
1. 设 module 为 FromClause 的 ModuleRequests 的唯一元素。
2. 返回 ExportFromClause 的 ExportEntriesForModule 参数为 module。

#### ExportDeclaration : export NamedExports ;
1. 返回 NamedExports 的 ExportEntriesForModule 参数为 null。

#### ExportDeclaration : export VariableStatement
1. 设 entries 为一个新的空列表。
2. 设 names 为 VariableStatement 的 BoundNames。
3. 对于 names 的每个元素 name，执行
    a. 将 ExportEntry 记录 { [[ModuleRequest]]: null, [[ImportName]]: null, [[LocalName]]: name, [[ExportName]]: name } 添加到 entries。
4. 返回 entries。

#### ExportDeclaration : export Declaration
1. 设 entries 为一个新的空列表。
2. 设 names 为 Declaration 的 BoundNames。
3. 对于 names 的每个元素 name，执行
    a. 将 ExportEntry 记录 { [[ModuleRequest]]: null, [[ImportName]]: null, [[LocalName]]: name, [[ExportName]]: name } 添加到 entries。
4. 返回 entries。

#### ExportDeclaration : export default HoistableDeclaration
1. 设 names 为 HoistableDeclaration 的 BoundNames。
2. 设 localName 为 names 的唯一元素。
3. 返回一个列表，其唯一元素是新的 ExportEntry 记录 { [[ModuleRequest]]: null, [[ImportName]]: null, [[LocalName]]: localName, [[ExportName]]: "default" }。

#### ExportDeclaration : export default ClassDeclaration
1. 设 names 为 ClassDeclaration 的 BoundNames。
2. 设 localName 为 names 的唯一元素。
3. 返回一个列表，其唯一元素是新的 ExportEntry 记录 { [[ModuleRequest]]: null, [[ImportName]]: null, [[LocalName]]: localName, [[ExportName]]: "default" }。

#### ExportDeclaration : export default AssignmentExpression ;
1. 设 entry 为 ExportEntry 记录 { [[ModuleRequest]]: null, [[ImportName]]: null, [[LocalName]]: "*default*", [[ExportName]]: "default" }。
2. 返回 « entry »。

#### 注意
"*default*" 在此规范中用作匿名默认导出值的合成名称。有关详细信息，请参阅此说明。

### 16.2.3.5 静态语义：ExportEntriesForModule
ExportEntriesForModule 语法指导操作接受参数 module（一个字符串或 null）并返回一个 ExportEntry 记录列表。它在以下产生式上逐块定义：

#### ExportFromClause : *
1. 设 entry 为 ExportEntry 记录 { [[ModuleRequest]]: module, [[ImportName]]: ALL-BUT-DEFAULT, [[LocalName]]: null, [[ExportName]]: null }。
2. 返回 « entry »。

#### ExportFromClause : * as ModuleExportName
1. 设 exportName 为 ModuleExportName 的 StringValue。
2. 设 entry 为 ExportEntry 记录 { [[ModuleRequest]]: module, [[ImportName]]: ALL, [[LocalName]]: null, [[ExportName]]: exportName }。
3. 返回 « entry »。

#### NamedExports : { }
1. 返回一个新的空列表。

#### ExportsList : ExportsList , ExportSpecifier
1. 设 specs1 为 ExportsList 的 ExportEntriesForModule 参数为 module。
2. 设 specs2 为 ExportSpecifier 的 ExportEntriesForModule 参数为 module。
3. 返回 specs1 和 specs2 的列表连接。

#### ExportSpecifier : ModuleExportName
1. 设 sourceName 为 ModuleExportName 的 StringValue。
2. 如果 module 为 null，则
    a. 设 localName 为 source

Name。
    b. 设 importName 为 null。
3. 否则，
    a. 设 localName 为 null。
    b. 设 importName 为 sourceName。
4. 返回一个列表，其唯一元素是新的 ExportEntry 记录 { [[ModuleRequest]]: module, [[ImportName]]: importName, [[LocalName]]: localName, [[ExportName]]: sourceName }。

#### ExportSpecifier : ModuleExportName as ModuleExportName
1. 设 sourceName 为第一个 ModuleExportName 的 StringValue。
2. 设 exportName 为第二个 ModuleExportName 的 StringValue。
3. 如果 module 为 null，则
    a. 设 localName 为 sourceName。
    b. 设 importName 为 null。
4. 否则，
    a. 设 localName 为 null。
    b. 设 importName 为 sourceName。
5. 返回一个列表，其唯一元素是新的 ExportEntry 记录 { [[ModuleRequest]]: module, [[ImportName]]: importName, [[LocalName]]: localName, [[ExportName]]: exportName }。

### 16.2.3.6 静态语义：ReferencedBindings
ReferencedBindings 语法指导操作不接受任何参数并返回一个解析节点列表。它在以下产生式上逐块定义：

#### NamedExports : { }
1. 返回一个新的空列表。

#### ExportsList : ExportsList , ExportSpecifier
1. 设 names1 为 ExportsList 的 ReferencedBindings。
2. 设 names2 为 ExportSpecifier 的 ReferencedBindings。
3. 返回 names1 和 names2 的列表连接。

#### ExportSpecifier : ModuleExportName as ModuleExportName
1. 返回第一个 ModuleExportName 的 ReferencedBindings。

#### ModuleExportName : IdentifierName
1. 返回一个列表，其唯一元素是 IdentifierName。

#### ModuleExportName : StringLiteral
1. 返回一个列表，其唯一元素是 StringLiteral。

### 16.2.3.7 运行时语义：评估
#### ExportDeclaration :
export ExportFromClause FromClause ;
export NamedExports ;
1. 返回 EMPTY。

#### ExportDeclaration : export VariableStatement
1. 返回 ? Evaluation of VariableStatement。

#### ExportDeclaration : export Declaration
1. 返回 ? Evaluation of Declaration。

#### ExportDeclaration : export default HoistableDeclaration
1. 返回 ? Evaluation of HoistableDeclaration。

#### ExportDeclaration : export default ClassDeclaration
1. 设 value 为 ? BindingClassDeclarationEvaluation of ClassDeclaration。
2. 设 className 为 ClassDeclaration 的 BoundNames 的唯一元素。
3. 如果 className 是 "*default*"，
    a. 设 env 为正在运行的执行上下文的 LexicalEnvironment。
    b. 执行 ? InitializeBoundName("*default*", value, env)。
4. 返回 EMPTY。

#### ExportDeclaration : export default AssignmentExpression ;
1. 如果 IsAnonymousFunctionDefinition(AssignmentExpression) 为 true，则
    a. 设 value 为 ? NamedEvaluation of AssignmentExpression 参数为 "default"。
2. 否则，
    a. 设 rhs 为 ? Evaluation of AssignmentExpression。
    b. 设 value 为 ? GetValue(rhs)。
3. 设 env 为正在运行的执行上下文的 LexicalEnvironment。
4. 执行 ? InitializeBoundName("*default*", value, env)。
5. 返回 EMPTY。

### 17 错误处理和语言扩展

实现必须在相关 ECMAScript 语言构造被评估时报告大多数错误。早期错误是指可以在包含错误的脚本中任何构造被评估之前检测和报告的错误。早期错误的存在会阻止构造的评估。实现必须在 `ParseScript` 中解析脚本时报告脚本中的早期错误。模块中的早期错误在模块将被评估时报告，且该模块从未被初始化。`eval` 代码中的早期错误在调用 `eval` 时报告，并阻止 `eval` 代码的评估。所有不是早期错误的错误都是运行时错误。

实现必须将本规范的“静态语义：早期错误”子条款中列出的任何情况报告为早期错误。

实现不应将其他类型的错误视为早期错误，即使编译器可以证明在任何情况下构造都无法无错误地执行。在这种情况下，实现可以发出早期警告，但不应在相关构造实际执行之前报告错误。

实现应按规定报告所有错误，以下情况除外：

除 17.1 中限制的内容外，宿主或实现可以扩展脚本语法、模块语法和正则表达式模式或标志语法。为了允许这种扩展，所有允许抛出 `SyntaxError` 的操作（例如调用 `eval`、使用正则表达式字面量或使用 `Function` 或 `RegExp` 构造函数）在遇到宿主定义的脚本语法或正则表达式模式或标志语法扩展时，可以表现为宿主定义的行为，而不是抛出 `SyntaxError`。
除 17.1 中限制的内容外，宿主或实现可以提供本规范未描述的其他类型、值、对象、属性和函数。这可能导致构造（例如在全局范围内查找变量）表现为宿主定义的行为，而不是抛出错误（例如 `ReferenceError`）。

### 17.1 禁止扩展

实现不得以以下方式扩展本规范：

- 在严格模式代码中，使用语法构造函数定义的 ECMAScript 函数对象不得创建名为 `caller` 或 `arguments` 的自有属性。使用 `ArrowFunction`、`MethodDefinition`、`GeneratorDeclaration`、`GeneratorExpression`、`AsyncGeneratorDeclaration`、`AsyncGeneratorExpression`、`ClassDeclaration`、`ClassExpression`、`AsyncFunctionDeclaration`、`AsyncFunctionExpression` 或 `AsyncArrowFunction` 定义的函数对象，无论定义是否包含在严格模式代码中，也不得创建这些自有属性。内置函数、使用 `Function` 构造函数创建的严格函数、使用 `Generator` 构造函数创建的生成器函数、使用 `AsyncFunction` 构造函数创建的异步函数以及使用 `bind` 方法创建的函数也不得创建这些自有属性。
- 如果实现扩展任何函数对象以拥有名为 `caller` 的自有属性，则通过 `[[Get]]` 或 `[[GetOwnProperty]]` 观察该属性的值时，该值不得为严格函数对象。如果它是访问器属性，则该属性的 `[[Get]]` 特性的函数在被调用时绝不能返回严格函数。
- 映射或未映射的 `arguments` 对象都不得创建名为 `caller` 的自有属性。
- 除非 `ECMA-402` 另有规定，否则不得扩展内置方法的行为，例如名为 `toLocaleString` 的方法。
- 当 `[UnicodeMode]` 语法参数存在时，`22.2.1` 和 `B.1.2` 中的 `RegExp` 模式语法不得扩展以识别任何源字符 `A-Z` 或 `a-z` 作为 `IdentityEscape[+UnicodeMode]`。
- 语法语法不得以任何方式扩展，使得令牌 `:` 可以紧跟在由 `BindingIdentifier` 非终结符号匹配的源文本之后。
- 处理严格模式代码时，实现不得放宽 `12.9.3.1` 的早期错误规则。
- `TemplateEscapeSequence` 不得扩展以包含 `LegacyOctalEscapeSequence` 或 `NonOctalDecimalEscapeSequence`，如 `12.9.4` 所定义。
- 处理严格模式代码时，不得支持 `B.3.1`、`B.3.2`、`B.3.3` 和 `B.3.5` 中定义的扩展。
- 解析模块目标符号时，不得支持 `B.1.1` 中定义的词法语法扩展。
- `ImportCall` 不得扩展。

### 18 ECMAScript 标准内置对象

每当 ECMAScript 脚本或模块开始执行时，都会有一些内置对象可用。其中一个，全局对象，是执行程序的全局环境的一部分。其他对象可作为全局对象的初始属性或间接作为可访问内置对象的属性进行访问。

除非另有规定，可作为函数调用的内置对象是具有 `10.3` 所述特性的内置函数对象。除非另有规定，内置对象的 `[[Extensible]]` 内部槽的初始值为 `true`。每个内置函数对象都有一个 `[[Realm]]` 内部槽，其值是创建该对象的领域的领域记录。

许多内置对象是函数：它们可以带参数调用。其中一些是构造函数：它们是打算与 `new` 运算符一起使用的函数。对于每个内置函数，本规范描述了该函数所需的参数及其函数对象的属性。对于每个内置构造函数，本规范还描述了该构造函数的原型对象的属性以及由调用该构造函数的 `new` 表达式返回的特定对象实例的属性。

除非特定函数的描述中另有规定，如果给定内置函数或构造函数的参数少于该函数要求的参数，则该函数或构造函数的行为应完全等同于给定足够的额外参数，每个此类参数的值为 `undefined`。这些缺失的参数被视为“不存在”，规范算法可以以这种方式识别它们。在特定函数的描述中，术语“this 值”和“NewTarget”具有 `10.3` 中给出的含义。

除非特定函数的描述中另有规定，如果给定内置函数或构造函数的参数多于该函数允许的参数，则这些额外的参数会被调用时计算并随后被该函数忽略。然而，实现可以定义与这些参数相关的实现特定行为，只要这种行为不是仅基于存在额外参数而抛出的 `TypeError` 异常。

#### 注意 1
建议实现通过添加新函数而不是向现有函数添加新参数来增加内置函数的附加功能。

除非另有规定，每个内置函数和每个内置构造函数的 `[[Prototype]]` 内部槽的值为其初始表达式 `Function.prototype`（见 `20.2.3`）的值。

除非另有规定，每个内置原型对象的 `[[Prototype]]` 内部槽的值为其初始表达式 `Object.prototype`（见 `20.1.3`）的值，`Object.prototype` 对象本身除外。

如果本规范通过算法步骤定义了内置构造函数的行为，则这是其在 `[[Call]]` 和 `[[Construct]]` 两种情况下的行为。如果这种算法需要区分这两种情况，则它会检查 `NewTarget` 是否为 `undefined`，这表示 `[[Call]]` 调用。

除非特定函数的描述中另有规定，未标识为构造函数的内置函数对象不实现 `[[Construct]]` 内部方法。

未标识为构造函数的内置函数对象没有“prototype”属性，除非特定函数的描述中另有规定。

本规范中定义的每个内置函数都是通过调用 `CreateBuiltinFunction` 抽象操作（`10.3.4`）创建的。“length”和“name”参数的值是“length”和“name”属性的初始值，如下所述。`prefix` 参数的值也如下所述。

每个内置函数对象，包括构造函数，都有一个“length”属性，其值为非负整数。除非另有规定，此值为函数描述的小节标题中显示的必需参数的数量。不包括可选参数和剩余参数。

#### 注意 2
例如，作为 `Array` 原型对象的 `“map”` 属性的初始值的函数对象在小节标题 “Array.prototype.map (callbackFn [ , thisArg])” 下描述，显示两个命名参数 `callbackFn` 和 `thisArg`，其中后者是可选的；因此该函数对象的 `“length”` 属性的值为 `1𝔽`。

除非另有规定，内置函数对象的 `“length”` 属性具有属性 { `[[Writable]]: false`， `[[Enumerable]]: false`， `[[Configurable]]:

 true` }。

每个内置函数对象，包括构造函数，都有一个 `“name”` 属性，其值为字符串。除非另有规定，此值为本规范中给定函数的名称。被标识为匿名函数的函数使用空字符串作为 `“name”` 属性的值。对于作为对象属性指定的函数，名称值是访问函数的属性名称字符串。作为内置属性的 `get` 或 `set` 访问器函数指定的函数，在调用 `CreateBuiltinFunction` 时，“get” 或 “set” 作为前缀传递。

如果 `“name”` 属性的值是符号值并以 `“get ”` 或 `“set ”` 开头，并且为内置属性指定的 `get` 或 `set` 访问器函数，则在调用 `CreateBuiltinFunction` 时，该值去掉前缀传递给 `name` 参数，并将 `“get”` 或 `“set”`（分别）传递给 `prefix` 参数。

除非另有规定，内置函数对象的 `“name”` 属性具有属性 { `[[Writable]]: false`， `[[Enumerable]]: false`， `[[Configurable]]: true` }。

除非另有规定，第 19 至第 28 条款和附录 B.2 中描述的每个数据属性具有属性 { `[[Writable]]: true`， `[[Enumerable]]: false`， `[[Configurable]]: true` }。

除非另有规定，第 19 至第 28 条款和附录 B.2 中描述的每个访问器属性具有属性 { `[[Enumerable]]: false`， `[[Configurable]]: true` }。如果仅描述了 `get` 访问器函数，则 `set` 访问器函数的默认值为 `undefined`。如果仅描述了 `set` 访问器，则 `get` 访问器的默认值为 `undefined`。

### 19 全局对象

全局对象：

- 在控制进入任何执行上下文之前创建。
- 没有 `[[Construct]]` 内部方法；不能用作 `new` 运算符的构造函数。
- 没有 `[[Call]]` 内部方法；不能用作函数调用。
- 具有一个值为宿主定义的 `[[Prototype]]` 内部槽。
- 除了本规范定义的属性外，可能还具有宿主定义的属性。这可能包括一个值为全局对象本身的属性。

#### 19.1 全局对象的值属性

##### 19.1.1 globalThis

领域记录 `realm` 中全局对象的 `globalThis` 属性的初始值为 `realm.[[GlobalEnv]].[[GlobalThisValue]]`。

此属性的属性为 { `[[Writable]]: true`， `[[Enumerable]]: false`， `[[Configurable]]: true` }。

##### 19.1.2 Infinity

`Infinity` 的值为 `+∞𝔽`（见 `6.1.6.1`）。此属性的属性为 { `[[Writable]]: false`， `[[Enumerable]]: false`， `[[Configurable]]: false` }。

##### 19.1.3 NaN

`NaN` 的值为 `NaN`（见 `6.1.6.1`）。此属性的属性为 { `[[Writable]]: false`， `[[Enumerable]]: false`， `[[Configurable]]: false` }。

##### 19.1.4 undefined

`undefined` 的值为 `undefined`（见 `6.1.1`）。此属性的属性为 { `[[Writable]]: false`， `[[Enumerable]]: false`， `[[Configurable]]: false` }。

#### 19.2 全局对象的函数属性

##### 19.2.1 eval ( x )

此函数是 `%eval%` 内置对象。

调用时执行以下步骤：

1. 返回 `? PerformEval(x, false, false)`。

###### 19.2.1.1 PerformEval ( x, strictCaller, direct )

`PerformEval` 抽象操作接受参数 `x`（ECMAScript 语言值）、`strictCaller`（布尔值）和 `direct`（布尔值），返回一个包含 ECMAScript 语言值的正常完成或一个抛出完成。调用时执行以下步骤：

1. 断言：如果 `direct` 为 `false`，则 `strictCaller` 也为 `false`。
2. 如果 `x` 不是字符串，则返回 `x`。
3. 设 `evalRealm` 为当前领域记录。
4. 注意：在直接 `eval` 的情况下，`evalRealm` 是 `eval` 调用者和 `eval` 函数本身的领域。
5. 执行 `? HostEnsureCanCompileStrings(evalRealm, « », x, direct)`。
6. 设 `inFunction` 为 `false`。
7. 设 `inMethod` 为 `false`。
8. 设 `inDerivedConstructor` 为 `false`。
9. 设 `inClassFieldInitializer` 为 `false`。
10. 如果 `direct` 为 `true`，
    a. 设 `thisEnvRec` 为 `GetThisEnvironment()`。
    b. 如果 `thisEnvRec` 是函数环境记录，
        i. 设 `F` 为 `thisEnvRec.[[FunctionObject]]`。
        ii. 设 `inFunction` 为 `true`。
        iii. 设 `inMethod` 为 `thisEnvRec.HasSuperBinding()`。
        iv. 如果 `F.[[ConstructorKind]]` 是 `DERIVED`，设 `inDerivedConstructor` 为 `true`。
        v. 设 `classFieldInitializerName` 为 `F.[[ClassFieldInitializerName]]`。
        vi. 如果 `classFieldInitializerName` 不为空，设 `inClassFieldInitializer` 为 `true`。
11. 在实现定义的顺序中执行以下子步骤，可能交错解析和错误检测：
    a. 设 `script` 为 `ParseText(x, Script)`。
    b. 如果 `script` 是错误列表，抛出 `SyntaxError` 异常。
    c. 如果 `script` 不包含 `ScriptBody`，返回 `undefined`。
    d. 设 `body` 为 `script` 的 `ScriptBody`。
    e. 如果 `inFunction` 为 `false` 且 `body` 包含 `NewTarget`，抛出 `SyntaxError` 异常。
    f. 如果 `inMethod` 为 `false` 且 `body` 包含 `SuperProperty`，抛出 `SyntaxError` 异常。
    g. 如果 `inDerivedConstructor` 为 `false` 且 `body` 包含 `SuperCall`，抛出 `SyntaxError` 异常。
    h. 如果 `inClassFieldInitializer` 为 `true` 且 `body` 包含 `Arguments`，抛出 `SyntaxError` 异常。
12. 如果 `strictCaller` 为 `true`，设 `strictEval` 为 `true`。
13. 否则，设 `strictEval` 为 `ScriptIsStrict(script)`。
14. 设 `runningContext` 为正在运行的执行上下文。
15. 注意：如果 `direct` 为 `true`，`runningContext` 将是执行直接 `eval` 的执行上下文。如果 `direct` 为 `false`，`runningContext` 将是 `eval` 函数调用的执行上下文。
16. 如果 `direct` 为 `true`，
    a. 设 `lexEnv` 为 `NewDeclarativeEnvironment(runningContext 的 LexicalEnvironment)`。
    b. 设 `varEnv` 为 `runningContext 的 VariableEnvironment`。
    c. 设 `privateEnv` 为 `runningContext 的 PrivateEnvironment`。
17. 否则，
    a. 设 `lexEnv` 为 `NewDeclarativeEnvironment(evalRealm.[[GlobalEnv]])`。
    b. 设 `varEnv` 为 `evalRealm.[[GlobalEnv]]`。
    c. 设 `privateEnv` 为 `null`。
18. 如果 `strictEval` 为 `true`，将 `varEnv` 设为 `lexEnv`。
19. 如果 `runningContext` 尚未暂停，则暂停 `runningContext`。
20. 设 `evalContext` 为新的 ECMAScript 代码执行上下文。
21. 将 `evalContext` 的 `Function` 设为 `null`。
22. 将 `evalContext` 的 `Realm` 设为 `evalRealm`。
23. 将 `evalContext` 的 `ScriptOrModule` 设为 `runningContext` 的 `ScriptOrModule`。
24. 将 `evalContext` 的 `VariableEnvironment` 设为 `varEnv`。
25. 将 `evalContext` 的 `LexicalEnvironment` 设为 `lexEnv`。
26. 将 `evalContext` 的 `PrivateEnvironment` 设为 `privateEnv`。
27. 将 `evalContext` 压入执行上下文栈；`evalContext` 现在是正在运行的执行上下文。
28. 设 `result` 为 `Completion(EvalDeclarationInstantiation(body, varEnv, lexEnv, privateEnv, strictEval))`。
29. 如果 `result` 是正常完成，
    a. 将 `result`

 设为 `Completion(Evaluation of body)`。
30. 如果 `result` 是正常完成且 `result.[[Value]]` 为空，
    a. 将 `result` 设为 `NormalCompletion(undefined)`。
31. 暂停 `evalContext` 并将其从执行上下文栈中移除。
32. 恢复现在在执行上下文栈顶部的上下文作为正在运行的执行上下文。
33. 返回 `? result`。

#### 注意
`eval` 代码不能在调用 `eval` 的调用上下文的变量环境中实例化变量或函数绑定，如果调用上下文的代码或 `eval` 代码是严格模式代码。相反，这些绑定是在一个新的变量环境中实例化，该环境仅对 `eval` 代码可访问。`let`、`const` 或 `class` 声明引入的绑定总是在新的词法环境中实例化。

##### 19.2.1.2 HostEnsureCanCompileStrings ( calleeRealm, parameterStrings, bodyString, direct )

宿主定义的抽象操作 `HostEnsureCanCompileStrings` 接受参数 `calleeRealm`（领域记录）、`parameterStrings`（字符串列表）、`bodyString`（字符串）和 `direct`（布尔值），返回一个包含 `UNUSED` 的正常完成或一个抛出完成。它允许宿主环境阻止某些 ECMAScript 函数，允许开发者将字符串解释和评估为 ECMAScript 代码。

`parameterStrings` 表示在使用函数构造函数之一时，将连接在一起构建参数列表的字符串。`bodyString` 表示函数体或传递给 `eval` 调用的字符串。`direct` 表示评估是否为直接 `eval`。

`HostEnsureCanCompileStrings` 的默认实现是返回 `NormalCompletion(UNUSED)`。

##### 19.2.1.3 EvalDeclarationInstantiation ( body, varEnv, lexEnv, privateEnv, strict )

`EvalDeclarationInstantiation` 抽象操作接受参数 `body`（脚本体解析节点）、`varEnv`（环境记录）、`lexEnv`（声明性环境记录）、`privateEnv`（私有环境记录或 `null`）和 `strict`（布尔值），返回一个包含 `UNUSED` 的正常完成或一个抛出完成。调用时执行以下步骤：

1. 设 `varNames` 为 `body` 的 `VarDeclaredNames`。
2. 设 `varDeclarations` 为 `body` 的 `VarScopedDeclarations`。
3. 如果 `strict` 为 `false`，
    a. 如果 `varEnv` 是全局环境记录，
        i. 对于 `varNames` 的每个元素 `name`，
            1. 如果 `varEnv.HasLexicalDeclaration(name)` 为 `true`，抛出 `SyntaxError` 异常。
            2. 注意：`eval` 不会创建被全局词法声明遮蔽的全局 `var` 声明。
    b. 设 `thisEnv` 为 `lexEnv`。
    c. 断言：以下循环将终止。
    d. 重复，直到 `thisEnv` 和 `varEnv` 不是同一个环境记录，
        i. 如果 `thisEnv` 不是对象环境记录，
            1. 注意：`with` 语句的环境不能包含任何词法声明，因此不需要检查 `var/let` 提升冲突。
            2. 对于 `varNames` 的每个元素 `name`，
                a. 如果 `! thisEnv.HasBinding(name)` 为 `true`，
                    i. 抛出 `SyntaxError` 异常。
                    ii. 注意：附录 `B.3.4` 为上述步骤定义了替代语义。
                b. 注意：直接 `eval` 不会在同名词法声明之上提升 `var` 声明。
        ii. 设 `thisEnv` 为 `thisEnv.[[OuterEnv]]`。
4. 设 `privateIdentifiers` 为新的空列表。
5. 设 `pointer` 为 `privateEnv`。
6. 重复，直到 `pointer` 为 `null`，
    a. 对于 `pointer.[[Names]]` 的每个私有名称绑定，
        i. 如果 `privateIdentifiers` 不包含 `binding.[[Description]]`，将 `binding.[[Description]]` 追加到 `privateIdentifiers`。
    b. 设 `pointer` 为 `pointer.[[OuterPrivateEnvironment]]`。
7. 如果 `body` 的 `AllPrivateIdentifiersValid` 参数为 `privateIdentifiers` 为 `false`，抛出 `SyntaxError` 异常。
8. 设 `functionsToInitialize` 为新的空列表。
9. 设 `declaredFunctionNames` 为新的空列表。
10. 对于 `varDeclarations` 的每个元素 `d`，按列表顺序反向，
    a. 如果 `d` 不是 `VariableDeclaration`、`ForBinding` 或 `BindingIdentifier`，
        i. 断言：`d` 是 `FunctionDeclaration`、`GeneratorDeclaration`、`AsyncFunctionDeclaration` 或 `AsyncGeneratorDeclaration`。
        ii. 注意：如果有多个同名函数声明，则使用最后一个声明。
        iii. 设 `fn` 为 `d` 的 `BoundNames` 的唯一元素。
        iv. 如果 `declaredFunctionNames` 不包含 `fn`，
            1. 如果 `varEnv` 是全局环境记录，
                a. 设 `fnDefinable` 为 `? varEnv.CanDeclareGlobalFunction(fn)`。
                b. 如果 `fnDefinable` 为 `false`，抛出 `TypeError` 异常。
            2. 将 `fn` 追加到 `declaredFunctionNames`。
            3. 将 `d` 插入 `functionsToInitialize` 的第一个元素。
11. 设 `declaredVarNames` 为新的空列表。
12. 对于 `varDeclarations` 的每个元素 `d`，
    a. 如果 `d` 是 `VariableDeclaration`、`ForBinding` 或 `BindingIdentifier`，
        i. 对于 `d` 的 `BoundNames` 的每个字符串 `vn`，
            1. 如果 `declaredFunctionNames` 不包含 `vn`，
                a. 如果 `varEnv` 是全局环境记录，
                    i. 设 `vnDefinable` 为 `? varEnv.CanDeclareGlobalVar(vn)`。
                    ii. 如果 `vnDefinable` 为 `false`，抛出 `TypeError` 异常。
                b. 如果 `declaredVarNames` 不包含 `vn`，
                    i. 将 `vn` 追加到 `declaredVarNames`。
13. 注意：附录 `B.3.2.3` 在此点添加了额外步骤。
14. 注意：在此算法步骤之后，不会发生异常终止，除非 `varEnv` 是全局环境记录并且全局对象是代理外来对象。
15. 设 `lexDeclarations` 为 `body` 的 `LexicallyScopedDeclarations`。
16. 对于 `lexDeclarations` 的每个元素 `d`，
    a. 注意：词法声明的名称仅在此处实例化，但未初始化。
    b. 对于 `d` 的 `BoundNames` 的每个元素 `dn`，
        i. 如果 `d` 的 `IsConstantDeclaration` 为 `true`，
            1. 执行 `? lexEnv.CreateImmutableBinding(dn, true)`。
        ii. 否则，
            1. 执行 `? lexEnv.CreateMutableBinding(dn, false)`。
17. 对于 `functionsToInitialize` 的每个解析节点 `f`，
    a. 设 `fn` 为 `f` 的 `BoundNames` 的唯一元素。
    b. 设 `fo` 为带有参数 `lexEnv` 和 `privateEnv` 的 `InstantiateFunctionObject` 的 `f`。
    c. 如果 `varEnv` 是全局环境记录，
        i. 执行 `? varEnv.CreateGlobalFunctionBinding(fn, fo, true)`。
    d. 否则，
        i. 设 `bindingExists` 为 `! varEnv.HasBinding(fn)`。
        ii. 如果 `bindingExists` 为 `false`，
            1. 注意：由于前面的验证步骤 14，此调用不能返回异常完成。
            2. 执行 `! varEnv.CreateMutableBinding(fn, true)`。
            3. 执行 `! varEnv.InitializeBinding(fn, fo)`。
        iii. 否则，
            1. 执行 `! varEnv.SetMutableBinding(fn, fo, false)`。
18. 对于 `declaredVarNames` 的每个字符串 `vn`，
    a. 如果 `varEnv` 是全局环境记录，
        i. 执行 `? varEnv.CreateGlobalVarBinding(vn, true)`。
    b. 否则，
        i. 设 `bindingExists` 为 `! varEnv.HasBinding(vn)`。
        ii. 如果 `bindingExists` 为 `false`，
            1. 注意：由于前面的验证步骤 14，此调用不能返回异常完成。
            2. 执行 `! varEnv.CreateMutableBinding(vn, true)`。
            3.

 执行 `! varEnv.InitializeBinding(vn, undefined)`。
19. 返回 `UNUSED`。

#### 注意
本算法的替代版本描述在 `B.3.4`。

##### 19.2.2 isFinite ( number )

此函数是 `%isFinite%` 内置对象。

调用时执行以下步骤：

1. 设 `num` 为 `? ToNumber(number)`。
2. 如果 `num` 不是有限的，返回 `false`。
3. 否则，返回 `true`。

##### 19.2.3 isNaN ( number )

此函数是 `%isNaN%` 内置对象。

调用时执行以下步骤：

1. 设 `num` 为 `? ToNumber(number)`。
2. 如果 `num` 是 `NaN`，返回 `true`。
3. 否则，返回 `false`。

#### 注意
ECMAScript 代码测试值 `X` 是否为 `NaN` 的可靠方法是使用 `X !== X` 表达式。结果将是 `true`，当且仅当 `X` 是 `NaN`。

##### 19.2.4 parseFloat ( string )

此函数根据 `string` 参数的内容作为十进制字面量的解释生成一个数字值。

它是 `%parseFloat%` 内置对象。

调用时执行以下步骤：

1. 设 `inputString` 为 `? ToString(string)`。
2. 设 `trimmedString` 为 `! TrimString(inputString, START)`。
3. 设 `trimmed` 为 `StringToCodePoints(trimmedString)`。
4. 设 `trimmedPrefix` 为满足 `StrDecimalLiteral` 语法的 `trimmed` 的最长前缀，可能是 `trimmed` 本身。如果没有这样的前缀，返回 `NaN`。
5. 设 `parsedNumber` 为 `ParseText(trimmedPrefix, StrDecimalLiteral)`。
6. 断言：`parsedNumber` 是一个解析节点。
7. 返回 `parsedNumber` 的 `StringNumericValue`。

#### 注意
此函数可能仅将 `string` 的前导部分解释为数字值；它忽略任何不能解释为十进制字面量一部分的代码单元，并且没有任何指示这些代码单元已被忽略。

##### 19.2.5 parseInt ( string, radix )

此函数根据指定的基数，根据 `string` 的内容生成一个整数。忽略 `string` 中的前导空格。如果 `radix` 转换为 `0`（例如，当它未定义时），则假定为 `10`，除非数字表示以 `“0x”` 或 `“0X”` 开头，在这种情况下假定为 `16`。如果 `radix` 为 `16`，则数字表示可以选择性地以 `“0x”` 或 `“0X”` 开头。

它是 `%parseInt%` 内置对象。

调用时执行以下步骤：

1. 设 `inputString` 为 `? ToString(string)`。
2. 设 `S` 为 `! TrimString(inputString, START)`。
3. 设 `sign` 为 `1`。
4. 如果 `S` 不为空且 `S` 的第一个代码单元是代码单元 `0x002D`（连字符-减号），将 `sign` 设为 `-1`。
5. 如果 `S` 不为空且 `S` 的第一个代码单元是 `0x002B`（加号）或 `0x002D`（连字符-减号），将 `S` 设为从索引 `1` 开始的子字符串。
6. 设 `R` 为 `ℝ(? ToInt32(radix))`。
7. 设 `stripPrefix` 为 `true`。
8. 如果 `R ≠ 0`，
    a. 如果 `R < 2` 或 `R > 36`，返回 `NaN`。
    b. 如果 `R ≠ 16`，将 `stripPrefix` 设为 `false`。
9. 否则，
    a. 将 `R` 设为 `10`。
10. 如果 `stripPrefix` 为 `true`，
    a. 如果 `S` 的长度至少为 `2` 且 `S` 的前两个代码单元是 `“0x”` 或 `“0X”`，
        i. 将 `S` 设为从索引 `2` 开始的子字符串。
        ii. 将 `R` 设为 `16`。
11. 如果 `S` 包含不是基数 `R` 数字的代码单元，设 `end` 为 `S` 中第一个此类代码单元的索引；否则，设 `end` 为 `S` 的长度。
12. 设 `Z` 为从 `0` 到 `end` 的 `S` 的子字符串。
13. 如果 `Z` 为空，返回 `NaN`。
14. 设 `mathInt` 为用字母 `A` 到 `Z` 和 `a` 到 `z` 表示值 `10` 到 `35` 的基数 `R` 表示的 `Z` 所表示的整数值。（但是，如果 `R = 10` 且 `Z` 包含超过 `20` 个有效数字，则实现可以选择将第 `20` 个以后的每个有效数字替换为 `0` 数字；如果 `R` 不是 `2`、`4`、`8`、`10`、`16` 或 `32` 之一，则 `mathInt` 可能是表示 `Z` 在基数 `R` 表示的整数值的实现近似整数。）
15. 如果 `mathInt = 0`，
    a. 如果 `sign = -1`，返回 `-0𝔽`。
    b. 返回 `+0𝔽`。
16. 返回 `𝔽(sign × mathInt)`。

#### 注意
此函数可能仅将 `string` 的前导部分解释为整数值；它忽略任何不能解释为整数表示一部分的代码单元，并且没有任何指示这些代码单元已被忽略。

#### 19.2.6 URI 处理函数

统一资源标识符（URI）是标识资源（例如网页或文件）及其访问传输协议（例如 HTTP 或 FTP）的字符串。ECMAScript 语言本身不提供使用 URI 的任何支持，除了本文所述的编码和解码 URI 的函数。`encodeURI` 和 `decodeURI` 旨在处理完整的 URI；它们假设任何保留字符都有特殊意义（例如，作为分隔符），因此不会编码。`encodeURIComponent` 和 `decodeURIComponent` 旨在处理 URI 的各个组成部分；它们假设任何保留字符表示文本，必须编码以避免在组成部分作为完整 URI 的一部分时具有特殊意义。

#### 注意 1
保留字符集基于 RFC 2396，并未反映 RFC 3986 引入的更改。

#### 注意 2
许多 ECMAScript 实现提供了其他操作网页的函数和方法；这些函数超出了本标准的范围。

##### 19.2.6.1 decodeURI ( encodedURI )

此函数计算一个新的 URI，其中每个转义序列和 UTF-8 编码（可能由 `encodeURI` 函数引入的）都被其表示的代码点的 UTF-16 编码替换。由 `encodeURI` 无法引入的转义序列不会被替换。

它是 `%decodeURI%` 内置对象。

调用时执行以下步骤：

1. 设 `uriString` 为 `? ToString(encodedURI)`。
2. 设 `preserveEscapeSet` 为 `";/?:@&=+$,#"`。
3. 返回 `? Decode(uriString, preserveEscapeSet)`。

##### 19.2.6.2 decodeURIComponent ( encodedURIComponent )

此函数计算一个新的 URI，其中每个转义序列和 UTF-8 编码（可能由 `encodeURIComponent` 函数引入的）都被其表示的代码点的 UTF-16 编码替换。

它是 `%decodeURIComponent%` 内置对象。

调用时执行以下步骤：

1. 设 `componentString` 为 `? ToString(encodedURIComponent)`。
2. 设 `preserveEscapeSet` 为空字符串。
3. 返回 `? Decode(componentString, preserveEscapeSet)`。

##### 19.2.6.3 encodeURI ( uri )

此函数计算一个新的 UTF-16 编码的（见 `6.1.4`） URI，其中每个实例的某些代码点被一、两、三或四个转义序列（表示代码点的 UTF-8 编码）替换。

它是 `%encodeURI%` 内置对象。

调用时执行以下步骤：

1. 设 `uriString` 为 `? ToString(uri)`。
2. 设 `extraUnescaped` 为 `";/?:@&=+$,#"`。
3. 返回 `? Encode(uriString, extraUnescaped)`。

##### 19.2.6.4 encodeURIComponent ( uriComponent )

此函数计算一个新的 UTF-16 编码的（见 `6.1.4`） URI

，其中每个实例的某些代码点被一、两、三或四个转义序列（表示代码点的 UTF-8 编码）替换。

它是 `%encodeURIComponent%` 内置对象。

调用时执行以下步骤：

1. 设 `componentString` 为 `? ToString(uriComponent)`。
2. 设 `extraUnescaped` 为空字符串。
3. 返回 `? Encode(componentString, extraUnescaped)`。

##### 19.2.6.5 Encode ( string, extraUnescaped )

`Encode` 抽象操作接受参数 `string`（字符串）和 `extraUnescaped`（字符串），返回一个包含字符串的正常完成或一个抛出完成。它执行 URI 编码和转义，将字符串解释为 `6.1.4` 描述的 UTF-16 编码的代码点序列。如果某个字符在 RFC 2396 中被识别为未保留字符或出现在 `extraUnescaped` 中，则不会转义。调用时执行以下步骤：

1. 设 `len` 为 `string` 的长度。
2. 设 `R` 为空字符串。
3. 设 `alwaysUnescaped` 为 ASCII 单词字符和 `"-.!~*'()"` 的字符串连接。
4. 设 `unescapedSet` 为 `alwaysUnescaped` 和 `extraUnescaped` 的字符串连接。
5. 设 `k` 为 `0`。
6. 重复，直到 `k < len`，
    a. 设 `C` 为 `string` 中索引为 `k` 的代码单元。
    b. 如果 `unescapedSet` 包含 `C`，
        i. 将 `k` 设为 `k + 1`。
        ii. 将 `R` 设为 `R` 和 `C` 的字符串连接。
    c. 否则，
        i. 设 `cp` 为 `CodePointAt(string, k)`。
        ii. 如果 `cp.[[IsUnpairedSurrogate]]` 为 `true`，抛出 `URIError` 异常。
        iii. 将 `k` 设为 `k + cp.[[CodeUnitCount]]`。
        iv. 设 `Octets` 为通过应用 UTF-8 转换到 `cp.[[CodePoint]]` 获得的八位字节列表。
        v. 对于 `Octets` 的每个元素 `octet`，
            1. 设 `hex` 为以大写十六进制数格式化的 `octet` 的字符串表示。
            2. 将 `R` 设为 `R`、`“%”` 和 `StringPad(hex, 2, "0", START)` 的字符串连接。
7. 返回 `R`。

#### 注意
由于使用百分比编码表示单个八位字节，单个代码点可能表示为多个连续的转义序列（每个八位字节一个）。

##### 19.2.6.6 Decode ( string, preserveEscapeSet )

`Decode` 抽象操作接受参数 `string`（字符串）和 `preserveEscapeSet`（字符串），返回一个包含字符串的正常完成或一个抛出完成。它执行 URI 反转义和解码，保留任何与 `preserveEscapeSet` 中的基本拉丁字符相对应的转义序列。调用时执行以下步骤：

1. 设 `len` 为 `string` 的长度。
2. 设 `R` 为空字符串。
3. 设 `k` 为 `0`。
4. 重复，直到 `k < len`，
    a. 设 `C` 为 `string` 中索引为 `k` 的代码单元。
    b. 设 `S` 为 `C`。
    c. 如果 `C` 是代码单元 `0x0025`（百分号），
        i. 如果 `k + 3 > len`，抛出 `URIError` 异常。
        ii. 设 `escape` 为 `string` 中从 `k` 到 `k + 3` 的子字符串。
        iii. 设 `B` 为 `ParseHexOctet(string, k + 1)`。
        iv. 如果 `B` 不是整数，抛出 `URIError` 异常。
        v. 将 `k` 设为 `k + 2`。
        vi. 设 `n` 为 `B` 中前导 `1` 位的数量。
        vii. 如果 `n = 0`，
            1. 设 `asciiChar` 为其数值为 `B` 的代码单元。
            2. 如果 `preserveEscapeSet` 包含 `asciiChar`，将 `S` 设为 `escape`。否则，将 `S` 设为 `asciiChar`。
        viii. 否则，
            1. 如果 `n = 1` 或 `n > 4`，抛出 `URIError` 异常。
            2. 设 `Octets` 为 `« B »`。
            3. 设 `j` 为 `1`。
            4. 重复，直到 `j < n`，
                a. 将 `k` 设为 `k + 1`。
                b. 如果 `k + 3 > len`，抛出 `URIError` 异常。
                c. 如果 `string` 中索引为 `k` 的代码单元不是 `0x0025`（百分号），抛出 `URIError` 异常。
                d. 设 `continuationByte` 为 `ParseHexOctet(string, k + 1)`。
                e. 如果 `continuationByte` 不是整数，抛出 `URIError` 异常。
                f. 将 `continuationByte` 追加到 `Octets`。
                g. 将 `k` 设为 `k + 2`。
                h. 将 `j` 设为 `j + 1`。
            5. 断言：`Octets` 的长度为 `n`。
            6. 如果 `Octets` 不包含有效的 Unicode 代码点的 UTF-8 编码，抛出 `URIError` 异常。
            7. 设 `V` 为通过将 `Octets` 应用于 UTF-8 转换获得的代码点，即从八位字节列表到 21 位值。
            8. 将 `S` 设为 `UTF16EncodeCodePoint(V)`。
    d. 将 `R` 设为 `R` 和 `S` 的字符串连接。
    e. 将 `k` 设为 `k + 1`。
5. 返回 `R`。

#### 注意
RFC 3629 禁止解码无效的 UTF-8 八位字节序列。例如，无效序列 `0xC0 0x80` 不得解码为代码单元 `0x0000`。`Decode` 算法的实现在遇到此类无效序列时必须抛出 `URIError`。

##### 19.2.6.7 ParseHexOctet ( string, position )

`ParseHexOctet` 抽象操作接受参数 `string`（字符串）和 `position`（非负整数），返回一个非负整数或一个非空的 `SyntaxError` 对象列表。它解析 `string` 中指定位置的两个十六进制字符序列为无符号 8 位整数。调用时执行以下步骤：

1. 设 `len` 为 `string` 的长度。
2. 断言：`position + 2 ≤ len`。
3. 设 `hexDigits` 为 `string` 中从 `position` 到 `position + 2` 的子字符串。
4. 设 `parseResult` 为 `ParseText(hexDigits, HexDigits[~Sep])`。
5. 如果 `parseResult` 不是解析节点，返回 `parseResult`。
6. 设 `n` 为 `parseResult` 的 `MV`。
7. 断言：`n` 在 `0` 到 `255` 的闭区间内。
8. 返回 `n`。

### 20 基础对象

#### 20.1 对象对象

##### 20.1.1 Object 构造函数

Object 构造函数：

- 是 %Object%。
- 是全局对象的 "Object" 属性的初始值。
- 当作为构造函数调用时，会创建一个新的普通对象。
- 当作为函数而不是构造函数调用时，会执行类型转换。
- 可以用作类定义的 extends 子句的值。

##### 20.1.1.1 Object ( [ value ] )

此函数在被调用时执行以下步骤：

1. 如果 NewTarget 既不是 undefined 也不是当前活动的函数对象，
    a. 返回 `? OrdinaryCreateFromConstructor(NewTarget, "%Object.prototype%")`。
2. 如果 value 是 undefined 或 null，返回 `OrdinaryObjectCreate(%Object.prototype%)`。
3. 返回 `! ToObject(value)`。

##### 20.1.2 Object 构造函数的属性

Object 构造函数：

- 具有内部槽 [[Prototype]]，其值为 %Function.prototype%。
- 具有 "length" 属性，其值为 1𝔽。
- 具有以下附加属性：

###### 20.1.2.1 Object.assign ( target, ...sources )

此函数将一个或多个源对象的所有可枚举的自身属性的值复制到目标对象。

调用时执行以下步骤：

1. 设 `to` 为 `? ToObject(target)`。
2. 如果只传递了一个参数，返回 `to`。
3. 对于 `sources` 的每个元素 `nextSource`，执行以下步骤：
    a. 如果 `nextSource` 既不是 undefined 也不是 null，
        i. 设 `from` 为 `! ToObject(nextSource)`。
        ii. 设 `keys` 为 `? from.[[OwnPropertyKeys]]()`。
        iii. 对于 `keys` 的每个元素 `nextKey`，执行以下步骤：
            1. 设 `desc` 为 `? from.[[GetOwnProperty]](nextKey)`。
            2. 如果 `desc` 不是 undefined 且 `desc.[[Enumerable]]` 为 true，
                a. 设 `propValue` 为 `? Get(from, nextKey)`。
                b. 执行 `? Set(to, nextKey, propValue, true)`。
4. 返回 `to`。

此函数的 "length" 属性为 2𝔽。

###### 20.1.2.2 Object.create ( O, Properties )

此函数创建一个具有指定原型的新对象。

调用时执行以下步骤：

1. 如果 O 既不是对象也不是 null，抛出一个 TypeError 异常。
2. 设 `obj` 为 `OrdinaryObjectCreate(O)`。
3. 如果 `Properties` 不是 undefined，
    a. 返回 `? ObjectDefineProperties(obj, Properties)`。
4. 返回 `obj`。

###### 20.1.2.3 Object.defineProperties ( O, Properties )

此函数添加自身属性和/或更新对象的现有自身属性的属性。

调用时执行以下步骤：

1. 如果 O 不是对象，抛出一个 TypeError 异常。
2. 返回 `? ObjectDefineProperties(O, Properties)`。

###### 20.1.2.3.1 ObjectDefineProperties ( O, Properties )

`ObjectDefineProperties` 抽象操作接受参数 O（一个对象）和 Properties（一个 ECMAScript 语言值），返回包含一个对象的正常完成或一个抛出完成。调用时执行以下步骤：

1. 设 `props` 为 `? ToObject(Properties)`。
2. 设 `keys` 为 `? props.[[OwnPropertyKeys]]()`。
3. 设 `descriptors` 为一个新的空列表。
4. 对于 `keys` 的每个元素 `nextKey`，执行以下步骤：
    a. 设 `propDesc` 为 `? props.[[GetOwnProperty]](nextKey)`。
    b. 如果 `propDesc` 不是 undefined 且 `propDesc.[[Enumerable]]` 为 true，
        i. 设 `descObj` 为 `? Get(props, nextKey)`。
        ii. 设 `desc` 为 `? ToPropertyDescriptor(descObj)`。
        iii. 将记录 { [[Key]]: nextKey, [[Descriptor]]: desc } 追加到 `descriptors`。
5. 对于 `descriptors` 的每个元素 `property`，执行以下步骤：
    a. 执行 `? DefinePropertyOrThrow(O, property.[[Key]], property.[[Descriptor]])`。
6. 返回 `O`。

###### 20.1.2.4 Object.defineProperty ( O, P, Attributes )

此函数添加一个自身属性和/或更新对象的现有自身属性的属性。

调用时执行以下步骤：

1. 如果 O 不是对象，抛出一个 TypeError 异常。
2. 设 `key` 为 `? ToPropertyKey(P)`。
3. 设 `desc` 为 `? ToPropertyDescriptor(Attributes)`。
4. 执行 `? DefinePropertyOrThrow(O, key, desc)`。
5. 返回 `O`。

###### 20.1.2.5 Object.entries ( O )

此函数在调用时执行以下步骤：

1. 设 `obj` 为 `? ToObject(O)`。
2. 设 `entryList` 为 `? EnumerableOwnProperties(obj, KEY+VALUE)`。
3. 返回 `CreateArrayFromList(entryList)`。

###### 20.1.2.6 Object.freeze ( O )

此函数在调用时执行以下步骤：

1. 如果 O 不是对象，返回 O。
2. 设 `status` 为 `? SetIntegrityLevel(O, FROZEN)`。
3. 如果 `status` 为 false，抛出一个 TypeError 异常。
4. 返回 O。

###### 20.1.2.7 Object.fromEntries ( iterable )

此函数在调用时执行以下步骤：

1. 执行 `? RequireObjectCoercible(iterable)`。
2. 设 `obj` 为 `OrdinaryObjectCreate(%Object.prototype%)`。
3. 断言：`obj` 是一个没有自身属性的可扩展普通对象。
4. 设 `closure` 为一个新的抽象闭包，参数为 (key, value)，它捕获 `obj` 并在被调用时执行以下步骤：
    a. 设 `propertyKey` 为 `? ToPropertyKey(key)`。
    b. 执行 `! CreateDataPropertyOrThrow(obj, propertyKey, value)`。
    c. 返回 undefined。
5. 设 `adder` 为 `CreateBuiltinFunction(closure, 2, "", « »)`。
6. 返回 `? AddEntriesFromIterable(obj, iterable, adder)`。

#### 注意
为 `adder` 创建的函数永远不会直接暴露给 ECMAScript 代码。

###### 20.1.2.8 Object.getOwnPropertyDescriptor ( O, P )

此函数在调用时执行以下步骤：

1. 设 `obj` 为 `? ToObject(O)`。
2. 设 `key` 为 `? ToPropertyKey(P)`。
3. 设 `desc` 为 `? obj.[[GetOwnProperty]](key)`。
4. 返回 `FromPropertyDescriptor(desc)`。

###### 20.1.2.9 Object.getOwnPropertyDescriptors ( O )

此函数在调用时执行以下步骤：

1. 设 `obj` 为 `? ToObject(O)`。
2. 设 `ownKeys` 为 `? obj.[[OwnPropertyKeys]]()`。
3. 设 `descriptors` 为 `OrdinaryObjectCreate(%Object.prototype%)`。
4. 对于 `ownKeys` 的每个元素 `key`，执行以下步骤：
    a. 设 `desc` 为 `? obj.[[GetOwnProperty]](key)`。
    b. 设 `descriptor` 为 `FromPropertyDescriptor(desc)`。
    c. 如果 `descriptor` 不是 undefined，执行 `! CreateDataPropertyOrThrow(descriptors, key, descriptor)`。
5. 返回 `descriptors`。

###### 20.1.2.10 Object.getOwnPropertyNames ( O )

此函数在调用时执行以下步骤：

1. 返回 `CreateArrayFromList(? GetOwnPropertyKeys(O, STRING))`。

###### 20.1.2.11 Object.getOwnPropertySymbols ( O )

此函数在调用时执行以下步骤：

1. 返回 `CreateArrayFromList(? GetOwnPropertyKeys(O, SYMBOL))`。

###### 20.1.2.11.1 GetOwnPropertyKeys ( O, type )

`GetOwnPropertyKeys` 抽象操作接受参数 O（一个 ECMAScript 语言值）和 type（STRING 或 SYMBOL），返回一个包含属性键的列表的正常完成或一个抛出完成。调用时执行以下步骤：

1. 设 `obj` 为 `? ToObject(O)`。
2. 设 `keys` 为 `? obj.[[OwnPropertyKeys]]()`。
3. 设 `nameList` 为一个新的空列表。
4. 对于 `keys` 的每个元素 `nextKey`，执行以下步骤：
    a. 如果 `nextKey` 是一个 Symbol 且 `type` 是 SYMBOL，或如果 `nextKey` 是一个 String 且 `type` 是 STRING，
        i. 将 `nextKey` 追加到 `nameList`

。
5. 返回 `nameList`。

###### 20.1.2.12 Object.getPrototypeOf ( O )

此函数在调用时执行以下步骤：

1. 设 `obj` 为 `? ToObject(O)`。
2. 返回 `? obj.[[GetPrototypeOf]]()`。

###### 20.1.2.13 Object.groupBy ( items, callbackfn )

#### 注意
`callbackfn` 应该是一个接受两个参数的函数。`groupBy` 按升序对 `items` 中的每个元素调用 `callbackfn` 并构建一个新对象。每个由 `callbackfn` 返回的值会被强制转换为属性键。对于每个这样的属性键，结果对象有一个属性，其键是该属性键，值是一个数组，包含所有 `callbackfn` 返回值被强制转换为该键的元素。

`callbackfn` 以两个参数调用：元素的值和元素的索引。

`groupBy` 的返回值是一个不继承自 %Object.prototype% 的对象。

此函数在调用时执行以下步骤：

1. 设 `groups` 为 `? GroupBy(items, callbackfn, PROPERTY)`。
2. 设 `obj` 为 `OrdinaryObjectCreate(null)`。
3. 对于 `groups` 的每个记录 { [[Key]], [[Elements]] } `g`，执行以下步骤：
    a. 设 `elements` 为 `CreateArrayFromList(g.[[Elements]])`。
    b. 执行 `! CreateDataPropertyOrThrow(obj, g.[[Key]], elements)`。
4. 返回 `obj`。

###### 20.1.2.14 Object.hasOwn ( O, P )

此函数在调用时执行以下步骤：

1. 设 `obj` 为 `? ToObject(O)`。
2. 设 `key` 为 `? ToPropertyKey(P)`。
3. 返回 `? HasOwnProperty(obj, key)`。

###### 20.1.2.15 Object.is ( value1, value2 )

此函数在调用时执行以下步骤：

1. 返回 `SameValue(value1, value2)`。

###### 20.1.2.16 Object.isExtensible ( O )

此函数在调用时执行以下步骤：

1. 如果 O 不是对象，返回 false。
2. 返回 `? IsExtensible(O)`。

###### 20.1.2.17 Object.isFrozen ( O )

此函数在调用时执行以下步骤：

1. 如果 O 不是对象，返回 true。
2. 返回 `? TestIntegrityLevel(O, FROZEN)`。

###### 20.1.2.18 Object.isSealed ( O )

此函数在调用时执行以下步骤：

1. 如果 O 不是对象，返回 true。
2. 返回 `? TestIntegrityLevel(O, SEALED)`。

###### 20.1.2.19 Object.keys ( O )

此函数在调用时执行以下步骤：

1. 设 `obj` 为 `? ToObject(O)`。
2. 设 `keyList` 为 `? EnumerableOwnProperties(obj, KEY)`。
3. 返回 `CreateArrayFromList(keyList)`。

###### 20.1.2.20 Object.preventExtensions ( O )

此函数在调用时执行以下步骤：

1. 如果 O 不是对象，返回 O。
2. 设 `status` 为 `? O.[[PreventExtensions]]()`。
3. 如果 `status` 为 false，抛出一个 TypeError 异常。
4. 返回 O。

###### 20.1.2.21 Object.prototype

`Object.prototype` 的初始值是对象原型对象。

此属性具有 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } 属性。

###### 20.1.2.22 Object.seal ( O )

此函数在调用时执行以下步骤：

1. 如果 O 不是对象，返回 O。
2. 设 `status` 为 `? SetIntegrityLevel(O, SEALED)`。
3. 如果 `status` 为 false，抛出一个 TypeError 异常。
4. 返回 O。

###### 20.1.2.23 Object.setPrototypeOf ( O, proto )

此函数在调用时执行以下步骤：

1. 设 O 为 `? RequireObjectCoercible(O)`。
2. 如果 `proto` 不是对象且 `proto` 不是 null，抛出一个 TypeError 异常。
3. 如果 O 不是对象，返回 O。
4. 设 `status` 为 `? O.[[SetPrototypeOf]](proto)`。
5. 如果 `status` 为 false，抛出一个 TypeError 异常。
6. 返回 O。

###### 20.1.2.24 Object.values ( O )

此函数在调用时执行以下步骤：

1. 设 `obj` 为 `? ToObject(O)`。
2. 设 `valueList` 为 `? EnumerableOwnProperties(obj, VALUE)`。
3. 返回 `CreateArrayFromList(valueList)`。

##### 20.1.3 Object 原型对象的属性

Object 原型对象：

- 是 %Object.prototype%。
- 具有 [[Extensible]] 内部槽，其值为 true。
- 具有普通对象定义的内部方法，除了 [[SetPrototypeOf]] 方法，其定义如 `10.4.7.1` 所述（因此，它是一个不可变的原型异类对象）。
- 具有 [[Prototype]] 内部槽，其值为 null。

###### 20.1.3.1 Object.prototype.constructor

`Object.prototype.constructor` 的初始值是 %Object%。

###### 20.1.3.2 Object.prototype.hasOwnProperty ( V )

此方法在调用时执行以下步骤：

1. 设 `P` 为 `? ToPropertyKey(V)`。
2. 设 `O` 为 `? ToObject(this value)`。
3. 返回 `? HasOwnProperty(O, P)`。

#### 注意
步骤 1 和步骤 2 的顺序选择是为了确保即使 `this value` 是 undefined 或 null，也会继续抛出以前版本规范中步骤 1 会抛出的任何异常。

###### 20.1.3.3 Object.prototype.isPrototypeOf ( V )

此方法在调用时执行以下步骤：

1. 如果 V 不是对象，返回 false。
2. 设 `O` 为 `? ToObject(this value)`。
3. 重复，
    a. 设 `V` 为 `? V.[[GetPrototypeOf]]()`。
    b. 如果 V 是 null，返回 false。
    c. 如果 `SameValue(O, V)` 为 true，返回 true。

#### 注意
步骤 1 和步骤 2 的顺序保留了以前版本规范中针对 V 不是对象且 `this value` 是 undefined 或 null 的行为。

###### 20.1.3.4 Object.prototype.propertyIsEnumerable ( V )

此方法在调用时执行以下步骤：

1. 设 `P` 为 `? ToPropertyKey(V)`。
2. 设 `O` 为 `? ToObject(this value)`。
3. 设 `desc` 为 `? O.[[GetOwnProperty]](P)`。
4. 如果 `desc` 是 undefined，返回 false。
5. 返回 `desc.[[Enumerable]]`。

#### 注意 1
此方法不考虑原型链中的对象。

#### 注意 2
步骤 1 和步骤 2 的顺序选择是为了确保即使 `this value` 是 undefined 或 null，也会继续抛出以前版本规范中步骤 1 会抛出的任何异常。

###### 20.1.3.5 Object.prototype.toLocaleString ( [ reserved1 [ , reserved2 ] ] )

此方法在调用时执行以下步骤：

1. 设 `O` 为 `this value`。
2. 返回 `? Invoke(O, "toString")`。

此方法的可选参数未使用，但旨在与 ECMA-402 `toLocaleString` 方法使用的参数模式对应。不包含 ECMA-402 支持的实现不得将这些参数位置用于其他目的。

#### 注意 1
此方法为没有区域敏感 `toString` 行为的对象提供了通用的 `toLocaleString` 实现。`Array`、`Number`、`Date` 和 `%TypedArray%` 提供了它们自己的区域敏感 `toLocaleString` 方法。

#### 注意 2
ECMA-402 有意不提供此默认实现的替代方案。

###### 20.1.3.6 Object.prototype.toString ( )

此方法在调用时执行以下步骤：

1. 如果 `this value` 是 undefined，返回 `"[object Undefined]"`。
2. 如果 `this value` 是 null，返回 `"[object Null]"`。
3. 设 `O` 为 `! ToObject(this value)`。
4. 设 `isArray` 为 `? IsArray(O)`。
5. 如果 `isArray` 为 true，设 `builtinTag` 为 `"Array"`。
6. 否则，如果 O 具有内部槽 `[[ParameterMap]]`，设 `builtinTag` 为 `"Arguments"`。
7. 否则，如果 O 具有内部方法 `[[Call]]`，设 `builtinTag` 为 `"Function"`。
8. 否则，如果 O 具有内部槽 `[[ErrorData]]`，设 `builtinTag` 为 `"Error"`。
9. 否则，如果 O 具有内部槽 `[[BooleanData]]`，设 `builtinTag` 为 `"Boolean"`。


10. 否则，如果 O 具有内部槽 `[[NumberData]]`，设 `builtinTag` 为 `"Number"`。
11. 否则，如果 O 具有内部槽 `[[StringData]]`，设 `builtinTag` 为 `"String"`。
12. 否则，如果 O 具有内部槽 `[[DateValue]]`，设 `builtinTag` 为 `"Date"`。
13. 否则，如果 O 具有内部槽 `[[RegExpMatcher]]`，设 `builtinTag` 为 `"RegExp"`。
14. 否则，设 `builtinTag` 为 `"Object"`。
15. 设 `tag` 为 `? Get(O, @@toStringTag)`。
16. 如果 `tag` 不是字符串，设 `tag` 为 `builtinTag`。
17. 返回字符串连接 `"[object ", tag, "]"`。

#### 注意
历史上，此方法偶尔用于访问 [[Class]] 内部槽的字符串值，该内部槽在以前版本的规范中用作各种内置对象的名义类型标签。上述 `toString` 定义保留了使用 `toString` 作为特定类型的内置对象的测试的兼容性。这不提供其他类型的内置或程序定义对象的可靠类型测试机制。此外，程序可以使用 `@@toStringTag`，这样会使此类遗留类型测试的可靠性无效。

###### 20.1.3.7 Object.prototype.valueOf ( )

此方法在调用时执行以下步骤：

1. 返回 `? ToObject(this value)`。

##### 规范可选，遗留
###### 20.1.3.8 Object.prototype.__proto__

`Object.prototype.__proto__` 是一个具有 { [[Enumerable]]: false, [[Configurable]]: true } 属性的访问器属性。[[Get]] 和 [[Set]] 属性定义如下：

###### 20.1.3.8.1 get Object.prototype.__proto__

[[Get]] 属性的值是一个不需要参数的内置函数。调用时执行以下步骤：

1. 设 `O` 为 `? ToObject(this value)`。
2. 返回 `? O.[[GetPrototypeOf]]()`。

###### 20.1.3.8.2 set Object.prototype.__proto__

[[Set]] 属性的值是一个带有参数 `proto` 的内置函数。调用时执行以下步骤：

1. 设 `O` 为 `? RequireObjectCoercible(this value)`。
2. 如果 `proto` 不是对象且 `proto` 不是 null，返回 undefined。
3. 如果 O 不是对象，返回 undefined。
4. 设 `status` 为 `? O.[[SetPrototypeOf]](proto)`。
5. 如果 `status` 为 false，抛出一个 TypeError 异常。
6. 返回 undefined。

##### 规范可选，遗留
###### 20.1.3.9 遗留 Object.prototype 访问器方法
###### 20.1.3.9.1 Object.prototype.__defineGetter__ ( P, getter )

此方法在调用时执行以下步骤：

1. 设 `O` 为 `? ToObject(this value)`。
2. 如果 `getter` 不是可调用的，抛出一个 TypeError 异常。
3. 设 `desc` 为 `PropertyDescriptor { [[Get]]: getter, [[Enumerable]]: true, [[Configurable]]: true }`。
4. 设 `key` 为 `? ToPropertyKey(P)`。
5. 执行 `? DefinePropertyOrThrow(O, key, desc)`。
6. 返回 undefined。

###### 20.1.3.9.2 Object.prototype.__defineSetter__ ( P, setter )

此方法在调用时执行以下步骤：

1. 设 `O` 为 `? ToObject(this value)`。
2. 如果 `setter` 不是可调用的，抛出一个 TypeError 异常。
3. 设 `desc` 为 `PropertyDescriptor { [[Set]]: setter, [[Enumerable]]: true, [[Configurable]]: true }`。
4. 设 `key` 为 `? ToPropertyKey(P)`。
5. 执行 `? DefinePropertyOrThrow(O, key, desc)`。
6. 返回 undefined。

###### 20.1.3.9.3 Object.prototype.__lookupGetter__ ( P )

此方法在调用时执行以下步骤：

1. 设 `O` 为 `? ToObject(this value)`。
2. 设 `key` 为 `? ToPropertyKey(P)`。
3. 重复，
    a. 设 `desc` 为 `? O.[[GetOwnProperty]](key)`。
    b. 如果 `desc` 不是 undefined，
        i. 如果 `IsAccessorDescriptor(desc)` 为 true，返回 `desc.[[Get]]`。
        ii. 返回 undefined。
    c. 设 `O` 为 `? O.[[GetPrototypeOf]]()`。
    d. 如果 `O` 是 null，返回 undefined。

###### 20.1.3.9.4 Object.prototype.__lookupSetter__ ( P )

此方法在调用时执行以下步骤：

1. 设 `O` 为 `? ToObject(this value)`。
2. 设 `key` 为 `? ToPropertyKey(P)`。
3. 重复，
    a. 设 `desc` 为 `? O.[[GetOwnProperty]](key)`。
    b. 如果 `desc` 不是 undefined，
        i. 如果 `IsAccessorDescriptor(desc)` 为 true，返回 `desc.[[Set]]`。
        ii. 返回 undefined。
    c. 设 `O` 为 `? O.[[GetPrototypeOf]]()`。
    d. 如果 `O` 是 null，返回 undefined。

##### 20.1.4 Object 实例的属性

Object 实例没有超出从对象原型对象继承的属性。

### 20 基本对象

#### 20.2 函数对象

##### 20.2.1 函数构造器

函数构造器：

- 是 `%Function%`。
- 是全局对象的 "Function" 属性的初始值。
- 当作为函数而不是构造器调用时，会创建并初始化一个新的函数对象。因此，函数调用 `Function(...)` 等价于使用相同参数的对象创建表达式 `new Function(...)`。
- 可以用作类定义的 `extends` 子句的值。意图继承指定的 `Function` 行为的子类构造器必须包含对 `Function` 构造器的 `super` 调用，以创建并初始化具有内置函数行为所需的内部槽的子类实例。所有 ECMAScript 语法形式的函数对象定义都会创建 `Function` 的实例。除了内置的 `GeneratorFunction`、`AsyncFunction` 和 `AsyncGeneratorFunction` 子类，没有语法手段来创建 `Function` 子类的实例。

###### 20.2.1.1 Function ( ...parameterArgs, bodyArg )

最后一个参数（如果有的话）指定函数的主体（可执行代码）；任何前面的参数指定形式参数。

此函数在调用时执行以下步骤：

1. 设 `C` 为活动函数对象。
2. 如果 `bodyArg` 不存在，将 `bodyArg` 设置为空字符串。
3. 返回 `? CreateDynamicFunction(C, NewTarget, NORMAL, parameterArgs, bodyArg)`。

#### 注意

可以但不必要为每个要指定的形式参数提供一个参数。例如，以下三个表达式都产生相同的结果：

```javascript
new Function("a", "b", "c", "return a+b+c")
new Function("a, b, c", "return a+b+c")
new Function("a,b", "c", "return a+b+c")
```

###### 20.2.1.1.1 CreateDynamicFunction ( constructor, newTarget, kind, parameterArgs, bodyArg )

抽象操作 `CreateDynamicFunction` 接受参数 `constructor`（构造器）、`newTarget`（构造器）、`kind`（`NORMAL`、`GENERATOR`、`ASYNC` 或 `ASYNC-GENERATOR`）、`parameterArgs`（一个 ECMAScript 语言值的列表）和 `bodyArg`（一个 ECMAScript 语言值），并返回一个包含 ECMAScript 函数对象的正常完成或一个抛出完成。`constructor` 是执行此操作的构造函数。`newTarget` 是最初应用于 `new` 的构造函数。`parameterArgs` 和 `bodyArg` 反映了传递给构造函数的参数值。调用时执行以下步骤：

1. 如果 `newTarget` 是 `undefined`，将 `newTarget` 设置为 `constructor`。
2. 如果 `kind` 是 `NORMAL`，则：
   a. 设 `prefix` 为 "function"。
   b. 设 `exprSym` 为语法符号 `FunctionExpression`。
   c. 设 `bodySym` 为语法符号 `FunctionBody[~Yield, ~Await]`。
   d. 设 `parameterSym` 为语法符号 `FormalParameters[~Yield, ~Await]`。
   e. 设 `fallbackProto` 为 "%Function.prototype%"。
3. 否则，如果 `kind` 是 `GENERATOR`，则：
   a. 设 `prefix` 为 "function*"。
   b. 设 `exprSym` 为语法符号 `GeneratorExpression`。
   c. 设 `bodySym` 为语法符号 `GeneratorBody`。
   d. 设 `parameterSym` 为语法符号 `FormalParameters[+Yield, ~Await]`。
   e. 设 `fallbackProto` 为 "%GeneratorFunction.prototype%"。
4. 否则，如果 `kind` 是 `ASYNC`，则：
   a. 设 `prefix` 为 "async function"。
   b. 设 `exprSym` 为语法符号 `AsyncFunctionExpression`。
   c. 设 `bodySym` 为语法符号 `AsyncFunctionBody`。
   d. 设 `parameterSym` 为语法符号 `FormalParameters[~Yield, +Await]`。
   e. 设 `fallbackProto` 为 "%AsyncFunction.prototype%"。
5. 否则：
   a. 断言：`kind` 是 `ASYNC-GENERATOR`。
   b. 设 `prefix` 为 "async function*"。
   c. 设 `exprSym` 为语法符号 `AsyncGeneratorExpression`。
   d. 设 `bodySym` 为语法符号 `AsyncGeneratorBody`。
   e. 设 `parameterSym` 为语法符号 `FormalParameters[+Yield, +Await]`。
   f. 设 `fallbackProto` 为 "%AsyncGeneratorFunction.prototype%"。
6. 设 `argCount` 为 `parameterArgs` 中元素的数量。
7. 设 `parameterStrings` 为一个新的空列表。
8. 对 `parameterArgs` 的每个元素 `arg`，执行以下步骤：
   a. 将 `? ToString(arg)` 添加到 `parameterStrings`。
9. 设 `bodyString` 为 `? ToString(bodyArg)`。
10. 设 `currentRealm` 为当前的 `Realm Record`。
11. 执行 `? HostEnsureCanCompileStrings(currentRealm, parameterStrings, bodyString, false)`。
12. 设 `P` 为空字符串。
13. 如果 `argCount` > 0，则：
   a. 设置 `P` 为 `parameterStrings[0]`。
   b. 设 `k` 为 1。
   c. 重复，直到 `k` < `argCount`，
      i. 设 `nextArgString` 为 `parameterStrings[k]`。
      ii. 设置 `P` 为字符串连接 `P`、","（逗号）和 `nextArgString`。
      iii. 设置 `k` 为 `k + 1`。
14. 设 `bodyParseString` 为字符串连接 0x000A（换行符）、`bodyString` 和 0x000A（换行符）。
15. 设 `sourceString` 为字符串连接 `prefix`、" anonymous("、`P`、0x000A（换行符）、") {"、`bodyParseString` 和 "}"。
16. 设 `sourceText` 为 `StringToCodePoints(sourceString)`。
17. 设 `parameters` 为 `ParseText(P, parameterSym)`。
18. 如果 `parameters` 是错误列表，抛出一个 `SyntaxError` 异常。
19. 设 `body` 为 `ParseText(bodyParseString, bodySym)`。
20. 如果 `body` 是错误列表，抛出一个 `SyntaxError` 异常。
21. 注意：参数和主体分别解析，以确保每个单独有效。例如，`new Function("/*", "*/ ) {")` 不会评估为一个函数。
22. 注意：如果执行到这一步，`sourceText` 必须具有 `exprSym` 的语法（尽管反向推论不成立）。接下来的两步的目的是强制执行直接适用于 `exprSym` 的任何早期错误规则。
23. 设 `expr` 为 `ParseText(sourceText, exprSym)`。
24. 如果 `expr` 是错误列表，抛出一个 `SyntaxError` 异常。
25. 设 `proto` 为 `? GetPrototypeFromConstructor(newTarget, fallbackProto)`。
26. 设 `env` 为 `currentRealm.[[GlobalEnv]]`。
27. 设 `privateEnv` 为 null。
28. 设 `F` 为 `OrdinaryFunctionCreate(proto, sourceText, parameters, body, NON-LEXICAL-THIS, env, privateEnv)`。
29. 执行 `SetFunctionName(F, "anonymous")`。
30. 如果 `kind` 是 `GENERATOR`，则：
   a. 设 `prototype` 为 `OrdinaryObjectCreate(%GeneratorFunction.prototype.prototype%)`。
   b. 执行 `! DefinePropertyOrThrow(F, "prototype", PropertyDescriptor { [[Value]]: prototype, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false })`。
31. 否则，如果 `kind` 是 `ASYNC-GENERATOR`，则：
   a. 设 `prototype` 为 `OrdinaryObjectCreate(%AsyncGeneratorFunction.prototype.prototype%)`。
   b. 执行 `! DefinePropertyOrThrow(F, "prototype", PropertyDescriptor { [[Value]]: prototype, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false })`。
32. 否则，如果 `kind` 是 `NORMAL`，则：
   a. 执行 `MakeConstructor(F)`。
33. 注意：`kind` 是 `ASYNC` 的函数不可构造，并且没有 `[[Construct]]` 内部方法或 "prototype" 属性。
34. 返回 `F`。

#### 注意

`CreateDynamicFunction` 在它创建的任何 `kind` 不是 `ASYNC` 的函数上定义一个 "prototype" 属性，以提供可能将该函数用作构造函数的可能性。

##### 20.2.2

 函数构造器的属性

函数构造器：

- 本身是一个内置函数对象。
- 具有内部槽 `[[Prototype]]`，其值为 `%Function.prototype%`。
- 具有一个值为 `1𝔽` 的 "length" 属性。
- 具有以下属性：

###### 20.2.2.1 Function.prototype

`Function.prototype` 的值是函数原型对象。

此属性具有 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } 属性。

##### 20.2.3 函数原型对象的属性

函数原型对象：

- 是 `%Function.prototype%`。
- 本身是一个内置函数对象。
- 接受任何参数并在调用时返回 `undefined`。
- 没有 `[[Construct]]` 内部方法；它不能用作 `new` 操作符的构造函数。
- 具有 `[[Prototype]]` 内部槽，其值为 `%Object.prototype%`。
- 没有 "prototype" 属性。
- 具有一个值为 `+0𝔽` 的 "length" 属性。
- 具有一个值为空字符串的 "name" 属性。

#### 注意

函数原型对象被指定为函数对象，以确保与 ECMAScript 2015 规范之前创建的 ECMAScript 代码的兼容性。

###### 20.2.3.1 Function.prototype.apply ( thisArg, argArray )

此方法在调用时执行以下步骤：

1. 设 `func` 为 `this` 值。
2. 如果 `IsCallable(func)` 为 false，抛出一个 `TypeError` 异常。
3. 如果 `argArray` 是 `undefined` 或 `null`，则：
   a. 执行 `PrepareForTailCall()`。
   b. 返回 `? Call(func, thisArg)`。
4. 设 `argList` 为 `? CreateListFromArrayLike(argArray)`。
5. 执行 `PrepareForTailCall()`。
6. 返回 `? Call(func, thisArg, argList)`。

#### 注意 1

`thisArg` 值未经过修改直接作为 `this` 值传递。这是与第三版的变化，其中 `undefined` 或 `null` 的 `thisArg` 被替换为全局对象，并且对所有其他值应用 `ToObject`，并将该结果作为 `this` 值传递。尽管 `thisArg` 未经过修改传递，但非严格函数在进入函数时仍会执行这些转换。

#### 注意 2

如果 `func` 是箭头函数或绑定函数对象，则在步骤 6 中，函数 `[[Call]]` 会忽略 `thisArg`。

###### 20.2.3.2 Function.prototype.bind ( thisArg, ...args )

此方法在调用时执行以下步骤：

1. 设 `Target` 为 `this` 值。
2. 如果 `IsCallable(Target)` 为 false，抛出一个 `TypeError` 异常。
3. 设 `F` 为 `? BoundFunctionCreate(Target, thisArg, args)`。
4. 设 `L` 为 0。
5. 设 `targetHasLength` 为 `? HasOwnProperty(Target, "length")`。
6. 如果 `targetHasLength` 为 true，则：
   a. 设 `targetLen` 为 `? Get(Target, "length")`。
   b. 如果 `targetLen` 是一个 `Number`，则：
      i. 如果 `targetLen` 为 `+∞𝔽`，则：
         1. 设 `L` 为 `+∞`。
      ii. 否则，如果 `targetLen` 为 `-∞𝔽`，则：
         1. 设 `L` 为 0。
      iii. 否则：
         1. 设 `targetLenAsInt` 为 `! ToIntegerOrInfinity(targetLen)`。
         2. 断言：`targetLenAsInt` 是有限的。
         3. 设 `argCount` 为 `args` 中的元素数量。
         4. 设 `L` 为 `max(targetLenAsInt - argCount, 0)`。
7. 执行 `SetFunctionLength(F, L)`。
8. 设 `targetName` 为 `? Get(Target, "name")`。
9. 如果 `targetName` 不是字符串，将 `targetName` 设置为空字符串。
10. 执行 `SetFunctionName(F, targetName, "bound")`。
11. 返回 `F`。

#### 注意 1

使用 `Function.prototype.bind` 创建的函数对象是异质对象。它们也没有 "prototype" 属性。

#### 注意 2

如果 `Target` 是箭头函数或绑定函数对象，则传递给此方法的 `thisArg` 将不会被后续调用 `F` 使用。

###### 20.2.3.3 Function.prototype.call ( thisArg, ...args )

此方法在调用时执行以下步骤：

1. 设 `func` 为 `this` 值。
2. 如果 `IsCallable(func)` 为 false，抛出一个 `TypeError` 异常。
3. 执行 `PrepareForTailCall()`。
4. 返回 `? Call(func, thisArg, args)`。

#### 注意 1

`thisArg` 值未经过修改直接作为 `this` 值传递。这是与第三版的变化，其中 `undefined` 或 `null` 的 `thisArg` 被替换为全局对象，并且对所有其他值应用 `ToObject`，并将该结果作为 `this` 值传递。尽管 `thisArg` 未经过修改传递，但非严格函数在进入函数时仍会执行这些转换。

#### 注意 2

如果 `func` 是箭头函数或绑定函数对象，则在步骤 4 中，函数 `[[Call]]` 会忽略 `thisArg`。

###### 20.2.3.4 Function.prototype.constructor

`Function.prototype.constructor` 的初始值是 `%Function%`。

###### 20.2.3.5 Function.prototype.toString ( )

此方法在调用时执行以下步骤：

1. 设 `func` 为 `this` 值。
2. 如果 `func` 是对象，`func` 具有 `[[SourceText]]` 内部槽，`func.[[SourceText]]` 是 Unicode 代码点的序列，并且 `HostHasSourceTextAvailable(func)` 为 true，则：
   a. 返回 `CodePointsToString(func.[[SourceText]])`。
3. 如果 `func` 是内置函数对象，返回 `func` 的实现定义的字符串源代码表示。该表示必须具有 `NativeFunction` 的语法。此外，如果 `func` 具有 `[[InitialName]]` 内部槽并且 `func.[[InitialName]]` 是字符串，则返回的字符串中与 `NativeFunctionAccessoropt PropertyName` 匹配的部分必须是 `func.[[InitialName]]` 的值。
4. 如果 `func` 是对象并且 `IsCallable(func)` 为 true，返回 `func` 的实现定义的字符串源代码表示。该表示必须具有 `NativeFunction` 的语法。
5. 抛出一个 `TypeError` 异常。

#### NativeFunction 语法：

```javascript
function NativeFunctionAccessoropt PropertyName[~Yield, ~Await]opt ( FormalParameters[~Yield, ~Await] ) { [ native code ] }
```

#### NativeFunctionAccessor 语法：

```javascript
get
set
```

###### 20.2.3.6 Function.prototype [ @@hasInstance ] ( V )

此方法在调用时执行以下步骤：

1. 设 `F` 为 `this` 值。
2. 返回 `? OrdinaryHasInstance(F, V)`。

此属性具有 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } 属性。

#### 注意

这是大多数函数继承的 `@@hasInstance` 的默认实现。`@@hasInstance` 由 `instanceof` 操作符调用，以确定一个值是否是特定构造函数的实例。例如：

```javascript
v instanceof F
```

会被解析为：

```javascript
F[@@hasInstance](v)
```

构造函数可以通过在函数上暴露不同的 `@@hasInstance` 方法来控制哪些对象被 `instanceof` 识别为其实例。

此属性不可写且不可配置，以防止可能用于全局暴露绑定函数目标函数的篡改。

此方法的 "name" 属性的值为 "[Symbol.hasInstance]"。

##### 20.2.4 函数实例的属性

每个函数实例都是 ECMAScript 函数对象，并具有表 30 中列出的内部槽。使用 `Function.prototype.bind` 方法创建的函数对象具有表 31 中列出的内部槽。

函数实例具有以下属性：

###### 20.2.4.1 length

"length" 属性的值是一个整数，表示函数通常期望的参数数量。然而，语言允许函数被调用时使用不同数量的参数。函数在使用比其 "length" 属性指定的参数数量更多的参数调用时的行为取决于该函数。此属性具有 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true } 属性。

###### 20.2.4.2 name

"name" 属性的值是

描述函数的字符串。该名称没有语义意义，但通常是用在 ECMAScript 源文本中引用函数的变量或属性名称。此属性具有 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true } 属性。

没有通过此规范的上下文名称关联的匿名函数对象使用空字符串作为 "name" 属性的值。

###### 20.2.4.3 prototype

可以用作构造函数的函数实例具有一个 "prototype" 属性。每当创建这样的函数实例时，另一个普通对象也会被创建，并作为函数的 "prototype" 属性的初始值。除非另有规定，否则 "prototype" 属性的值用于初始化当该函数作为构造函数调用时创建的对象的 `[[Prototype]]` 内部槽。

此属性具有 { [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false } 属性。

#### 注意

使用 `Function.prototype.bind` 创建的函数对象，或通过评估 `MethodDefinition`（不是 `GeneratorMethod` 或 `AsyncGeneratorMethod`）或 `ArrowFunction` 创建的函数对象没有 "prototype" 属性。

##### 20.2.5 HostHasSourceTextAvailable ( func )

主机定义的抽象操作 `HostHasSourceTextAvailable` 接受参数 `func`（函数对象）并返回一个布尔值。它允许主机环境防止提供 `func` 的源文本。

`HostHasSourceTextAvailable` 的实现必须符合以下要求：

- 必须对其参数具有确定性。每次使用特定的 `func` 作为参数调用时，必须返回相同的结果。
- `HostHasSourceTextAvailable` 的默认实现是返回 true。

### 20.3 布尔对象

#### 20.3.1 布尔构造函数

布尔构造函数：

- 是 `%Boolean%`。
- 是全局对象的 `"Boolean"` 属性的初始值。
- 当作为构造函数调用时，会创建并初始化一个新的布尔对象。
- 当作为函数调用而不是构造函数时，会执行类型转换。
- 可以用作类定义的 `extends` 子句的值。子类构造函数若要继承指定的布尔行为，必须包含对布尔构造函数的 `super` 调用，以创建并初始化具有 `[[BooleanData]]` 内部槽的子类实例。

##### 20.3.1.1 Boolean ( value )

此函数在调用时执行以下步骤：

1. 令 `b` 为 `ToBoolean(value)`。
2. 如果 `NewTarget` 未定义，则返回 `b`。
3. 令 `O` 为 `? OrdinaryCreateFromConstructor(NewTarget, "%Boolean.prototype%", « [[BooleanData]] »)`。
4. 设置 `O.[[BooleanData]]` 为 `b`。
5. 返回 `O`。

#### 20.3.2 布尔构造函数的属性

布尔构造函数：

- 具有 `[[Prototype]]` 内部槽，其值为 `%Function.prototype%`。
- 具有以下属性：

##### 20.3.2.1 Boolean.prototype

`Boolean.prototype` 的初始值是布尔原型对象。

此属性具有 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } 的属性。

#### 20.3.3 布尔原型对象的属性

布尔原型对象：

- 是 `%Boolean.prototype%`。
- 是一个普通对象。
- 它本身是一个布尔对象；它具有 `[[BooleanData]]` 内部槽，其值为 `false`。
- 具有 `[[Prototype]]` 内部槽，其值为 `%Object.prototype%`。

##### 20.3.3.1 Boolean.prototype.constructor

`Boolean.prototype.constructor` 的初始值是 `%Boolean%`。

##### 20.3.3.2 Boolean.prototype.toString ( )

此方法在调用时执行以下步骤：

1. 令 `b` 为 `? ThisBooleanValue(this value)`。
2. 如果 `b` 为 `true`，则返回 `"true"`；否则返回 `"false"`。

##### 20.3.3.3 Boolean.prototype.valueOf ( )

此方法在调用时执行以下步骤：

1. 返回 `? ThisBooleanValue(this value)`。

###### 20.3.3.3.1 ThisBooleanValue ( value )

抽象操作 `ThisBooleanValue` 接受参数 `value`（一个 ECMAScript 语言值），并返回一个包含布尔值的正常完成或抛出完成。它在调用时执行以下步骤：

1. 如果 `value` 是布尔值，则返回 `value`。
2. 如果 `value` 是一个对象，并且 `value` 具有 `[[BooleanData]]` 内部槽，则：
   a. 令 `b` 为 `value.[[BooleanData]]`。
   b. 断言：`b` 是布尔值。
   c. 返回 `b`。
3. 抛出一个 `TypeError` 异常。

#### 20.3.4 布尔实例的属性

布尔实例是普通对象，继承自布尔原型对象的属性。布尔实例具有 `[[BooleanData]]` 内部槽。`[[BooleanData]]` 内部槽是此布尔对象表示的布尔值。

### 20.4 符号对象

#### 20.4.1 符号构造函数

符号构造函数：

- 是 `%Symbol%`。
- 是全局对象的 `"Symbol"` 属性的初始值。
- 当作为函数调用时，返回一个新的符号值。
- 不打算与 `new` 操作符一起使用。
- 不打算被子类化。
- 可以用作类定义的 `extends` 子句的值，但对其的 `super` 调用会导致异常。

##### 20.4.1.1 Symbol ( [ description ] )

此函数在调用时执行以下步骤：

1. 如果 `NewTarget` 未定义，则抛出一个 `TypeError` 异常。
2. 如果 `description` 未定义，则令 `descString` 为未定义。
3. 否则，令 `descString` 为 `? ToString(description)`。
4. 返回一个新的符号，其 `[[Description]]` 为 `descString`。

#### 20.4.2 符号构造函数的属性

符号构造函数：

- 具有 `[[Prototype]]` 内部槽，其值为 `%Function.prototype%`。
- 具有以下属性：

##### 20.4.2.1 Symbol.asyncIterator

`Symbol.asyncIterator` 的初始值是著名符号 `@@asyncIterator`（表 1）。

此属性具有 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } 的属性。

##### 20.4.2.2 Symbol.for ( key )

此函数在调用时执行以下步骤：

1. 令 `stringKey` 为 `? ToString(key)`。
2. 对于 `GlobalSymbolRegistry` 列表中的每个元素 `e`，执行：
   a. 如果 `e.[[Key]]` 是 `stringKey`，则返回 `e.[[Symbol]]`。
3. 断言：`GlobalSymbolRegistry` 当前不包含 `stringKey` 的条目。
4. 令 `newSymbol` 为一个新的符号，其 `[[Description]]` 为 `stringKey`。
5. 将记录 `{ [[Key]]: stringKey, [[Symbol]]: newSymbol }` 附加到 `GlobalSymbolRegistry` 列表。
6. 返回 `newSymbol`。

`GlobalSymbolRegistry` 是一个全局可用的仅追加列表。它由所有 realm 共享。在评估任何 ECMAScript 代码之前，它被初始化为一个新的空列表。`GlobalSymbolRegistry` 的元素是具有表 59 中定义结构的记录。

###### 表 59: `GlobalSymbolRegistry` 记录字段

| 字段名称 | 值     | 用途                     |
| -------- | ------ | ------------------------ |
| [[Key]]  | 字符串 | 用于全局标识符号的字符串 |
| [[Symbol]] | 符号  | 可以从任何 realm 检索的符号 |

##### 20.4.2.3 Symbol.hasInstance

`Symbol.hasInstance` 的初始值是著名符号 `@@hasInstance`（表 1）。

此属性具有 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } 的属性。

##### 20.4.2.4 Symbol.isConcatSpreadable

`Symbol.isConcatSpreadable` 的初始值是著名符号 `@@isConcatSpreadable`（表 1）。

此属性具有 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } 的属性。

##### 20.4.2.5 Symbol.iterator

`Symbol.iterator` 的初始值是著名符号 `@@iterator`（表 1）。

此属性具有 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } 的属性。

##### 20.4.2.6 Symbol.keyFor ( sym )

此函数在调用时执行以下步骤：

1. 如果 `sym` 不是符号，则抛出一个 `TypeError` 异常。
2. 返回 `KeyForSymbol(sym)`。

##### 20.4.2.7 Symbol.match

`Symbol.match` 的初始值是著名符号 `@@match`（表 1）。

此属性具有 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } 的属性。

##### 20.4.2.8 Symbol.matchAll

`Symbol.matchAll` 的初始值是著名符号 `@@matchAll`（表 1）。

此属性具有 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } 的属性。

##### 20.4.2.9 Symbol.prototype

`Symbol.prototype` 的初始值是符号原型对象。

此属性具有 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } 的属性。

##### 20.4.2.10 Symbol.replace

`Symbol.replace` 的初始值是著名符号 `@@replace`（表 1）。

此属性具有 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } 的属性。

##### 20.4.2.11 Symbol.search

`Symbol.search` 的初始值是著名符号 `@@search`（表 1）。

此属性具有 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } 的属性。

##### 20.4.2.12 Symbol.species

`Symbol.species` 的初始值是著名符号 `@@species`（表 1）。

此属性具有 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } 的属性。

#####

 20.4.2.13 Symbol.split

`Symbol.split` 的初始值是著名符号 `@@split`（表 1）。

此属性具有 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } 的属性。

##### 20.4.2.14 Symbol.toPrimitive

`Symbol.toPrimitive` 的初始值是著名符号 `@@toPrimitive`（表 1）。

此属性具有 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } 的属性。

##### 20.4.2.15 Symbol.toStringTag

`Symbol.toStringTag` 的初始值是著名符号 `@@toStringTag`（表 1）。

此属性具有 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } 的属性。

##### 20.4.2.16 Symbol.unscopables

`Symbol.unscopables` 的初始值是著名符号 `@@unscopables`（表 1）。

此属性具有 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } 的属性。

#### 20.4.3 符号原型对象的属性

符号原型对象：

- 是 `%Symbol.prototype%`。
- 是一个普通对象。
- 不是符号实例，并且没有 `[[SymbolData]]` 内部槽。
- 具有 `[[Prototype]]` 内部槽，其值为 `%Object.prototype%`。

##### 20.4.3.1 Symbol.prototype.constructor

`Symbol.prototype.constructor` 的初始值是 `%Symbol%`。

##### 20.4.3.2 get Symbol.prototype.description

`Symbol.prototype.description` 是一个访问器属性，其 set 访问器函数未定义。其 get 访问器函数在调用时执行以下步骤：

1. 令 `s` 为 `this` 值。
2. 令 `sym` 为 `? ThisSymbolValue(s)`。
3. 返回 `sym.[[Description]]`。

##### 20.4.3.3 Symbol.prototype.toString ( )

此方法在调用时执行以下步骤：

1. 令 `sym` 为 `? ThisSymbolValue(this value)`。
2. 返回 `SymbolDescriptiveString(sym)`。

###### 20.4.3.3.1 SymbolDescriptiveString ( sym )

抽象操作 `SymbolDescriptiveString` 接受参数 `sym`（一个符号）并返回一个字符串。它在调用时执行以下步骤：

1. 令 `desc` 为 `sym` 的 `[[Description]]` 值。
2. 如果 `desc` 未定义，将 `desc` 设置为空字符串。
3. 断言：`desc` 是一个字符串。
4. 返回字符串连接 `"Symbol("`、`desc` 和 `")"`。

##### 20.4.3.4 Symbol.prototype.valueOf ( )

此方法在调用时执行以下步骤：

1. 返回 `? ThisSymbolValue(this value)`。

###### 20.4.3.4.1 ThisSymbolValue ( value )

抽象操作 `ThisSymbolValue` 接受参数 `value`（一个 ECMAScript 语言值），并返回一个包含符号的正常完成或抛出完成。它在调用时执行以下步骤：

1. 如果 `value` 是符号，则返回 `value`。
2. 如果 `value` 是一个对象，并且 `value` 具有 `[[SymbolData]]` 内部槽，则：
   a. 令 `s` 为 `value.[[SymbolData]]`。
   b. 断言：`s` 是符号。
   c. 返回 `s`。
3. 抛出一个 `TypeError` 异常。

##### 20.4.3.5 Symbol.prototype [ @@toPrimitive ] ( hint )

此方法由 ECMAScript 语言操作符调用以将符号对象转换为原始值。

它在调用时执行以下步骤：

1. 返回 `? ThisSymbolValue(this value)`。

**注意**：此参数被忽略。

此属性具有 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true } 的属性。

此方法的 `"name"` 属性的值是 `"[Symbol.toPrimitive]"`。

##### 20.4.3.6 Symbol.prototype [ @@toStringTag ]

`@@toStringTag` 属性的初始值是字符串 `"Symbol"`。

此属性具有 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true } 的属性。

#### 20.4.4 符号实例的属性

符号实例是普通对象，继承自符号原型对象的属性。符号实例具有 `[[SymbolData]]` 内部槽。`[[SymbolData]]` 内部槽是此符号对象表示的符号值。

#### 20.4.5 符号的抽象操作

##### 20.4.5.1 KeyForSymbol ( sym )

抽象操作 `KeyForSymbol` 接受参数 `sym`（一个符号）并返回一个字符串或未定义。如果 `sym` 在 `GlobalSymbolRegistry`（参见 20.4.2.2）中，则返回用于注册 `sym` 的字符串。它在调用时执行以下步骤：

1. 对于 `GlobalSymbolRegistry` 列表中的每个元素 `e`，执行：
   a. 如果 `SameValue(e.[[Symbol]], sym)` 为 `true`，则返回 `e.[[Key]]`。
2. 断言：`GlobalSymbolRegistry` 当前不包含 `sym` 的条目。
3. 返回未定义。

### 20.5 错误对象

错误对象的实例在运行时错误发生时作为异常抛出。错误对象还可以作为用户定义异常类的基础对象。

当 ECMAScript 实现检测到运行时错误时，它会抛出一个新的原生错误对象（在 20.5.5 中定义）的实例或一个新的 `AggregateError` 对象（在 20.5.7 中定义）的实例。

#### 20.5.1 错误构造函数

错误构造函数：

- 是 `%Error%`。
- 是全局对象的 `"Error"` 属性的初始值。
- 当作为函数调用而不是构造函数时，会创建并初始化一个新的错误对象。因此，函数调用 `Error(…)` 等效于使用相同参数的对象创建表达式 `new Error(…)`。
- 可以用作类定义的 `extends` 子句的值。子类构造函数若要继承指定的错误行为，必须包含对错误构造函数的 `super` 调用，以创建并初始化具有 `[[ErrorData]]` 内部槽的子类实例。

##### 20.5.1.1 Error ( message [ , options ] )

此函数在调用时执行以下步骤：

1. 如果 `NewTarget` 未定义，令 `newTarget` 为活动函数对象；否则令 `newTarget` 为 `NewTarget`。
2. 令 `O` 为 `? OrdinaryCreateFromConstructor(newTarget, "%Error.prototype%", « [[ErrorData]] »)`。
3. 如果 `message` 不为未定义，则：
   a. 令 `msg` 为 `? ToString(message)`。
   b. 执行 `CreateNonEnumerableDataPropertyOrThrow(O, "message", msg)`。
4. 执行 `? InstallErrorCause(O, options)`。
5. 返回 `O`。

#### 20.5.2 错误构造函数的属性

错误构造函数：

- 具有 `[[Prototype]]` 内部槽，其值为 `%Function.prototype%`。
- 具有以下属性：

##### 20.5.2.1 Error.prototype

`Error.prototype` 的初始值是错误原型对象。

此属性具有 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } 的属性。

#### 20.5.3 错误原型对象的属性

错误原型对象：

- 是 `%Error.prototype%`。
- 是一个普通对象。
- 不是错误实例，并且没有 `[[ErrorData]]` 内部槽。
- 具有 `[[Prototype]]` 内部槽，其值为 `%Object.prototype%`。

##### 20.5.3.1 Error.prototype.constructor

`Error.prototype.constructor` 的初始值是 `%Error%`。

##### 20.5.3.2 Error.prototype.message

`Error.prototype.message` 的初始值是空字符串。

##### 20.5.3.3 Error.prototype.name

`Error.prototype.name` 的初始值是 `"Error"`。

##### 20.5.3.4 Error.prototype.toString ( )

此方法在调用时执行以下步骤：

1. 令 `O` 为 `this` 值。
2. 如果 `O` 不是对象，则抛出一个 `TypeError` 异常。
3. 令 `name` 为 `? Get(O, "name")`。
4. 如果 `name` 未定义，则设置 `name` 为 `"Error"`；否则设置 `name` 为 `? ToString(name)`。
5. 令 `msg` 为 `? Get(O, "message")`。
6. 如果 `msg` 未定义，则设置 `msg` 为空字符串；否则设置 `msg` 为 `? ToString(msg)`。
7. 如果

 `name` 是空字符串，则返回 `msg`。
8. 如果 `msg` 是空字符串，则返回 `name`。
9. 返回字符串连接 `name`、代码单元 `0x003A`（冒号）、代码单元 `0x0020`（空格）和 `msg`。

#### 20.5.4 错误实例的属性

错误实例是普通对象，继承自错误原型对象的属性，并且具有值为未定义的 `[[ErrorData]]` 内部槽。`[[ErrorData]]` 的唯一指定用途是通过 `Object.prototype.toString`（20.1.3.6）来识别错误、聚合错误或原生错误实例。

#### 20.5.5 此标准中使用的原生错误类型

当检测到运行时错误时，将抛出一个新的以下原生错误对象或聚合错误对象的实例。所有原生错误对象共享相同的结构，如 20.5.6 中所述。

##### 20.5.5.1 EvalError

`EvalError` 构造函数是 `%EvalError%`。

此异常当前未在本规范中使用。此对象保留以兼容以前版本的规范。

##### 20.5.5.2 RangeError

`RangeError` 构造函数是 `%RangeError%`。

表示不在允许值范围或集合内的值。

##### 20.5.5.3 ReferenceError

`ReferenceError` 构造函数是 `%ReferenceError%`。

表示检测到无效引用。

##### 20.5.5.4 SyntaxError

`SyntaxError` 构造函数是 `%SyntaxError%`。

表示发生了解析错误。

##### 20.5.5.5 TypeError

`TypeError` 构造函数是 `%TypeError%`。

当没有其他原生错误对象适合作为失败原因的指示时，使用 `TypeError` 表示操作不成功。

##### 20.5.5.6 URIError

`URIError` 构造函数是 `%URIError%`。

表示全局 URI 处理函数之一以与其定义不兼容的方式使用。

#### 20.5.6 原生错误对象结构

每个这些对象具有下面描述的结构，只是在构造函数名称和原型对象的 `"name"` 属性上有所不同。

对于每个错误对象，定义中引用的 `NativeError` 应替换为 20.5.5 中适当的错误对象名称。

##### 20.5.6.1 原生错误构造函数

每个原生错误构造函数：

- 当作为函数而不是构造函数调用时，创建并初始化一个新的原生错误对象。调用该对象作为函数等效于使用相同参数作为构造函数调用它。因此，函数调用 `NativeError(…)` 等效于对象创建表达式 `new NativeError(…)` 与相同参数。
- 可以用作类定义的 `extends` 子句的值。子类构造函数若要继承指定的原生错误行为，必须包含对原生错误构造函数的 `super` 调用，以创建并初始化具有 `[[ErrorData]]` 内部槽的子类实例。

###### 20.5.6.1.1 NativeError ( message [ , options ] )

每个原生错误函数在调用时执行以下步骤：

1. 如果 `NewTarget` 未定义，则令 `newTarget` 为活动函数对象；否则令 `newTarget` 为 `NewTarget`。
2. 令 `O` 为 `? OrdinaryCreateFromConstructor(newTarget, "%NativeError.prototype%", « [[ErrorData]] »)`。
3. 如果 `message` 不为未定义，则：
   a. 令 `msg` 为 `? ToString(message)`。
   b. 执行 `CreateNonEnumerableDataPropertyOrThrow(O, "message", msg)`。
4. 执行 `? InstallErrorCause(O, options)`。
5. 返回 `O`。

在步骤 2 中传递的字符串的实际值是 `%EvalError.prototype%`、`%RangeError.prototype%`、`%ReferenceError.prototype%`、`%SyntaxError.prototype%`、`%TypeError.prototype%` 或 `%URIError.prototype%` 之一，对应于定义的原生错误构造函数。

##### 20.5.6.2 原生错误构造函数的属性

每个原生错误构造函数：

- 具有 `[[Prototype]]` 内部槽，其值为 `%Error%`。
- 具有一个 `"name"` 属性，其值为字符串 `"NativeError"`。
- 具有以下属性：

###### 20.5.6.2.1 NativeError.prototype

`NativeError.prototype` 的初始值是原生错误原型对象（20.5.6.3）。每个原生错误构造函数具有不同的原型对象。

此属性具有 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } 的属性。

##### 20.5.6.3 原生错误原型对象的属性

每个原生错误原型对象：

- 是一个普通对象。
- 不是错误实例，并且没有 `[[ErrorData]]` 内部槽。
- 具有 `[[Prototype]]` 内部槽，其值为 `%Error.prototype%`。

###### 20.5.6.3.1 NativeError.prototype.constructor

给定原生错误构造函数的原型的 `"constructor"` 属性的初始值是构造函数本身。

###### 20.5.6.3.2 NativeError.prototype.message

给定原生错误构造函数的原型的 `"message"` 属性的初始值是空字符串。

###### 20.5.6.3.3 NativeError.prototype.name

给定原生错误构造函数的原型的 `"name"` 属性的初始值是由构造函数名称组成的字符串值（用作 `NativeError` 的名称）。

##### 20.5.6.4 原生错误实例的属性

原生错误实例是普通对象，继承自其原生错误原型对象的属性，并具有值为未定义的 `[[ErrorData]]` 内部槽。`[[ErrorData]]` 的唯一指定用途是通过 `Object.prototype.toString`（20.1.3.6）来识别错误、聚合错误或原生错误实例。

#### 20.5.7 聚合错误对象

##### 20.5.7.1 聚合错误构造函数

聚合错误构造函数：

- 是 `%AggregateError%`。
- 是全局对象的 `"AggregateError"` 属性的初始值。
- 当作为函数而不是构造函数调用时，会创建并初始化一个新的聚合错误对象。因此，函数调用 `AggregateError(…)` 等效于使用相同参数的对象创建表达式 `new AggregateError(…)`。
- 可以用作类定义的 `extends` 子句的值。子类构造函数若要继承指定的聚合错误行为，必须包含对聚合错误构造函数的 `super` 调用，以创建并初始化具有 `[[ErrorData]]` 内部槽的子类实例。

###### 20.5.7.1.1 AggregateError ( errors, message [ , options ] )

此函数在调用时执行以下步骤：

1. 如果 `NewTarget` 未定义，则令 `newTarget` 为活动函数对象；否则令 `newTarget` 为 `NewTarget`。
2. 令 `O` 为 `? OrdinaryCreateFromConstructor(newTarget, "%AggregateError.prototype%", « [[ErrorData]] »)`。
3. 如果 `message` 不为未定义，则：
   a. 令 `msg` 为 `? ToString(message)`。
   b. 执行 `CreateNonEnumerableDataPropertyOrThrow(O, "message", msg)`。
4. 执行 `? InstallErrorCause(O, options)`。
5. 令 `errorsList` 为 `? IteratorToList(? GetIterator(errors, SYNC))`。
6. 执行 `! DefinePropertyOrThrow(O, "errors", PropertyDescriptor { [[Configurable]]: true, [[Enumerable]]: false, [[Writable]]: true, [[Value]]: CreateArrayFromList(errorsList) })`。
7. 返回 `O`。

##### 20.5.7.2 聚合错误构造函数的属性

聚合错误构造函数：

- 具有 `[[Prototype]]` 内部槽，其值为 `%Error%`。
- 具有以下属性：

###### 20.5.7.2.1 AggregateError.prototype

`AggregateError.prototype` 的初始值是 `%AggregateError.prototype%`。

此属性具有 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } 的属性。

##### 20.5.7.3 聚合错误原型对象的属性

聚合错误原型对象：

- 是 `%AggregateError.prototype%`。
- 是一个普通对象。
- 不是错误实例或聚合错误实例，并且没有 `[[ErrorData]]` 内部槽。
- 具有 `[[Prototype]]` 内部槽，其值为 `%Error.prototype%`。

###### 20.5.7.3.1 AggregateError.prototype.constructor

`AggregateError.prototype.constructor` 的初始值是 `%AggregateError%`。

### 20.5.7.3.2 AggregateError.prototype.message
AggregateError.prototype.message 的初始值是空字符串。

### 20.5.7.3.3 AggregateError.prototype.name
AggregateError.prototype.name 的初始值是 "AggregateError"。

### 20.5.7.4 AggregateError 实例的属性
AggregateError 实例是普通对象，它们继承自其 AggregateError 原型对象并具有一个 [[ErrorData]] 内部插槽，其值为 undefined。[[ErrorData]] 的唯一指定用途是通过 Object.prototype.toString (20.1.3.6) 来识别 Error、AggregateError 或 NativeError 实例。

### 20.5.8 错误对象的抽象操作

#### 20.5.8.1 InstallErrorCause (O, options)
抽象操作 InstallErrorCause 接受参数 O（一个对象）和 options（一个 ECMAScript 语言值），并返回包含 UNUSED 的正常完成或抛出完成。当 options 存在 "cause" 属性时，它用于在 O 上创建一个 "cause" 属性。调用时执行以下步骤：

1. 如果 options 是一个对象并且 ? HasProperty(options, "cause") 为 true，那么
   a. 令 cause 为 ? Get(options, "cause")。
   b. 执行 CreateNonEnumerableDataPropertyOrThrow(O, "cause", cause)。
2. 返回 UNUSED。

### 21 数字和日期

#### 21.1 数字对象

##### 21.1.1 Number 构造函数
Number 构造函数：

- 是 %Number%。
- 是全局对象的 "Number" 属性的初始值。
- 当作为构造函数调用时，创建并初始化一个新的 Number 对象。
- 当作为函数而不是构造函数调用时，执行类型转换。
- 可以用作类定义的 extends 子句的值。打算继承指定 Number 行为的子类构造函数必须包含对 Number 构造函数的 super 调用，以便使用 [[NumberData]] 内部插槽创建并初始化子类实例。

##### 21.1.1.1 Number (value)
此函数在调用时执行以下步骤：

1. 如果存在 value，则
   a. 令 prim 为 ? ToNumeric(value)。
   b. 如果 prim 是 BigInt，令 n 为 𝔽(ℝ(prim))。
   c. 否则，令 n 为 prim。
2. 否则，
   a. 令 n 为 +0𝔽。
3. 如果 NewTarget 是 undefined，返回 n。
4. 令 O 为 ? OrdinaryCreateFromConstructor(NewTarget, "%Number.prototype%", « [[NumberData]] »)。
5. 将 O.[[NumberData]] 设置为 n。
6. 返回 O。

#### 21.1.2 Number 构造函数的属性
Number 构造函数：

- 有一个 [[Prototype]] 内部插槽，其值为 %Function.prototype%。
- 具有以下属性：

##### 21.1.2.1 Number.EPSILON
Number.EPSILON 的值是 1 和表示为 Number 值的最接近 1 的值之间差的大小，其值约为 2.2204460492503130808472633361816 × 10**-16。

该属性具有 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } 的属性特性。

##### 21.1.2.2 Number.isFinite (number)
此函数在调用时执行以下步骤：

1. 如果 number 不是 Number，返回 false。
2. 如果 number 不是有限的，返回 false。
3. 否则，返回 true。

##### 21.1.2.3 Number.isInteger (number)
此函数在调用时执行以下步骤：

1. 如果 number 是整数，返回 true。
2. 返回 false。

##### 21.1.2.4 Number.isNaN (number)
此函数在调用时执行以下步骤：

1. 如果 number 不是 Number，返回 false。
2. 如果 number 是 NaN，返回 true。
3. 否则，返回 false。

注意：此函数与全局 isNaN 函数 (19.2.3) 不同，它不会在确定是否为 NaN 之前将其参数转换为 Number。

##### 21.1.2.5 Number.isSafeInteger (number)
注意：整数 n 是“安全整数”当且仅当其 Number 值不与任何其他整数的 Number 值共享。

此函数在调用时执行以下步骤：

1. 如果 number 是整数，那么
   a. 如果 abs(ℝ(number)) ≤ 2**53 - 1，返回 true。
2. 返回 false。

##### 21.1.2.6 Number.MAX_SAFE_INTEGER
注意：由于 IEEE 754-2019 精度限制所需的舍入行为，所有大于 Number.MAX_SAFE_INTEGER 的整数的 Number 值至少与一个其他整数共享。因此，这样的大整数不是安全的，并且不能保证能精确表示为 Number 值，甚至不能彼此区分。例如，9007199254740992 和 9007199254740993 都评估为 Number 值 9007199254740992𝔽。

Number.MAX_SAFE_INTEGER 的值是 9007199254740991𝔽 (𝔽(2**53 - 1))。

该属性具有 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } 的属性特性。

##### 21.1.2.7 Number.MAX_VALUE
Number.MAX_VALUE 的值是 Number 类型的最大正有限值，其值约为 1.7976931348623157 × 10**308。

该属性具有 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } 的属性特性。

##### 21.1.2.8 Number.MIN_SAFE_INTEGER
注意：由于 IEEE 754-2019 精度限制所需的舍入行为，所有小于 Number.MIN_SAFE_INTEGER 的整数的 Number 值至少与一个其他整数共享。因此，这样的小整数不是安全的，并且不能保证能精确表示为 Number 值，甚至不能彼此区分。例如，-9007199254740992 和 -9007199254740993 都评估为 Number 值 -9007199254740992𝔽。

Number.MIN_SAFE_INTEGER 的值是 -9007199254740991𝔽 (𝔽(-(2**53 - 1)))。

该属性具有 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } 的属性特性。

##### 21.1.2.9 Number.MIN_VALUE
Number.MIN_VALUE 的值是 Number 类型的最小正值，其值约为 5 × 10**-324。

在 IEEE 754-2019 双精度二进制表示中，最小可能值是一个非标准化数。如果实现不支持非标准化值，Number.MIN_VALUE 的值必须是实现实际上可以表示的最小非零正值。

该属性具有 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } 的属性特性。

##### 21.1.2.10 Number.NaN
Number.NaN 的值是 NaN。

该属性具有 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } 的属性特性。

##### 21.1.2.11 Number.NEGATIVE_INFINITY
Number.NEGATIVE_INFINITY 的值是 -∞𝔽。

该属性具有 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } 的属性特性。

##### 21.1.2.12 Number.parseFloat (string)
"parseFloat" 属性的初始值是 %parseFloat%。

##### 21.1.2.13 Number.parseInt (string, radix)
"parseInt" 属性的初始值是 %parseInt%。

##### 21.1.2.14 Number.POSITIVE_INFINITY
Number.POSITIVE_INFINITY 的值是 +∞𝔽。

该属性具有 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } 的属性特性。

##### 21.1.2.15 Number.prototype
Number.prototype 的初始值是 Number 原型对象。

该属性具有 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } 的属性特性。

### 21.1.3 Number 原型对象的属性

Number 原型对象：

- 是 %Number.prototype%。
- 是一个普通对象。
- 本身是一个 Number 对象；它具有一个值为 +0𝔽 的 [[NumberData]] 内部插槽。
- 具有一个 [[Prototype]] 内部插槽，其值为 %Object.prototype%。

除非明确说明，否则下面定义的 Number 原型对象的方法不是通用的，传递给它们的 this 值必须是一个 Number 值或具有一个已初始化为 Number 值的 [[NumberData]] 内部插槽的对象。

在方法的规范中，术语“this Number value”指的是调用抽象操作 ThisNumberValue 并将方法调用的 this 值作为参数传递时返回的结果。

#### 21.1.3.1 Number.prototype.constructor
Number.prototype.constructor 的初始值是 %Number%。

#### 21.1.3.2 Number.prototype.toExponential (fractionDigits)
此方法返回一个字符串，其中包含以十进制指数表示法表示的 this Number 值，尾数的小数点前有一个数字，小数点后有 fractionDigits 个数字。如果 fractionDigits 未定义，则包含尽可能多的尾数数字，以唯一地指定 Number（就像 ToString 一样，但在这种情况下，Number 始终以指数表示法输出）。

调用时执行以下步骤：

1. 令 x 为 ? ThisNumberValue(this 值)。
2. 令 f 为 ? ToIntegerOrInfinity(fractionDigits)。
3. 断言：如果 fractionDigits 未定义，则 f 为 0。
4. 如果 x 不是有限的，返回 Number::toString(x, 10)。
5. 如果 f < 0 或 f > 100，抛出 RangeError 异常。
6. 将 x 设置为 ℝ(x)。
7. 令 s 为空字符串。
8. 如果 x < 0，则
   a. 将 s 设置为 "-"。
   b. 将 x 设置为 -x。
9. 如果 x = 0，则
   a. 令 m 为包含 f + 1 个 0x0030（数字零）代码单元的字符串值。
   b. 令 e 为 0。
10. 否则，
   a. 如果 fractionDigits 未定义，则
      i. 令 e 和 n 为整数，使得 10**f ≤ n < 10**(f + 1)，并且使 n × 10**(e - f) - x 尽可能接近零。如果有两个这样的 e 和 n，选择 n × 10**(e - f) 较大的那组 e 和 n。
   b. 否则，
      i. 令 e、n 和 ff 为整数，使得 ff ≥ 0，10**ff ≤ n < 10**(ff + 1)，𝔽(n × 10**(e - ff)) 是 𝔽(x)，并且 ff 尽可能小。注意，n 的十进制表示的位数是 ff + 1，n 不可被 10 整除，并且这些标准不一定唯一地确定 n 的最低有效位。
      ii. 将 f 设置为 ff。
   c. 令 m 为由 n 的十进制表示的数字组成的字符串值（按顺序排列，没有前导零）。
11. 如果 f ≠ 0，则
   a. 令 a 为 m 的第一个代码单元。
   b. 令 b 为 m 的其他 f 个代码单元。
   c. 将 m 设置为 a、"." 和 b 的字符串连接。
12. 如果 e = 0，则
   a. 令 c 为 "+"。
   b. 令 d 为 "0"。
13. 否则，
   a. 如果 e > 0，则
      i. 令 c 为 "+"。
   b. 否则，
      i. 断言：e < 0。
      ii. 令 c 为 "-"。
      iii. 将 e 设置为 -e。
   c. 令 d 为由 e 的十进制表示的数字组成的字符串值（按顺序排列，没有前导零）。
14. 将 m 设置为 m、"e"、c 和 d 的字符串连接。
15. 返回 s 和 m 的字符串连接。

注意：对于提供比上述规则所要求的更精确转换的实现，建议使用以下替代版本的步骤 10.b.i 作为指导：

i. 令 e、n 和 f 为整数，使得 f ≥ 0，10**f ≤ n < 10**(f + 1)，𝔽(n × 10**(e - f)) 是 𝔽(x)，并且 f 尽可能小。如果 n 有多种可能值，则选择 𝔽(n × 10**(e - f)) 最接近 𝔽(x) 的 n 值。如果有两个这样的 n 值，则选择偶数值。

#### 21.1.3.3 Number.prototype.toFixed (fractionDigits)
注意 1：此方法返回一个字符串，其中包含以十进制固定点表示法表示的 this Number 值，小数点后有 fractionDigits 位数字。如果 fractionDigits 未定义，则假定为 0。

调用时执行以下步骤：

1. 令 x 为 ? ThisNumberValue(this 值)。
2. 令 f 为 ? ToIntegerOrInfinity(fractionDigits)。
3. 断言：如果 fractionDigits 未定义，则 f 为 0。
4. 如果 f 不是有限的，抛出 RangeError 异常。
5. 如果 f < 0 或 f > 100，抛出 RangeError 异常。
6. 如果 x 不是有限的，返回 Number::toString(x, 10)。
7. 将 x 设置为 ℝ(x)。
8. 令 s 为空字符串。
9. 如果 x < 0，则
   a. 将 s 设置为 "-"。
   b. 将 x 设置为 -x。
10. 如果 x ≥ 10**21，则
    a. 令 m 为 ! ToString(𝔽(x))。
11. 否则，
    a. 令 n 为整数，使得 n / 10**f - x 尽可能接近零。如果有两个这样的 n，选择较大的 n。
    b. 如果 n = 0，令 m 为 "0"。否则，令 m 为由 n 的十进制表示的数字组成的字符串值（按顺序排列，没有前导零）。
    c. 如果 f ≠ 0，则
       i. 令 k 为 m 的长度。
       ii. 如果 k ≤ f，则
           1. 令 z 为包含 f + 1 - k 个 0x0030（数字零）代码单元的字符串值。
           2. 将 m 设置为 z 和 m 的字符串连接。
           3. 将 k 设置为 f + 1。
       iii. 令 a 为 m 的前 k - f 个代码单元。
       iv. 令 b 为 m 的其他 f 个代码单元。
       v. 将 m 设置为 a、"." 和 b 的字符串连接。
12. 返回 s 和 m 的字符串连接。

注意 2：toFixed 的输出可能比 toString 更精确，因为 toString 仅打印足够的有效数字来区分相邻的 Number 值。例如，

(1000000000000000128).toString() 返回 "1000000000000000100"，而
(1000000000000000128).toFixed(0) 返回 "1000000000000000128"。

#### 21.1.3.4 Number.prototype.toLocaleString ( [ reserved1 [ , reserved2 ] ] )
包括 ECMA-402 国际化 API 的 ECMAScript 实现必须按照 ECMA-402 规范实现此方法。如果 ECMAScript 实现不包括 ECMA-402 API，则使用以下规范来实现此方法：

此方法生成一个字符串值，表示根据主机环境当前区域设置格式化的 this Number 值。此方法是实现定义的，可以但不鼓励返回与 toString 相同的结果。

此方法的可选参数的含义在 ECMA-402 规范中定义；不包括 ECMA-402 支持的实现不得将这些参数位置用于其他用途。

#### 21.1.3.5 Number.prototype.toPrecision (precision)
此方法返回一个字符串，其中包含以十进制指数表示法表示的 this Number 值，尾数的小数点前有一个数字，尾数的小数点后有 precision - 1 位数字，或者以十进制固定点表示法表示的 this Number 值，具有 precision 位有效数字。如果 precision 未定义，则调用 ToString 代替。

调用时执行以下步骤：

1. 令 x 为 ? ThisNumberValue(this 值)。
2. 如果 precision 未定义，返回 ! ToString(x)。
3. 令 p 为 ? ToIntegerOrInfinity(precision)。
4. 如果 x 不是有限的，返回 Number::toString(x, 10)。
5. 如果 p < 1 或 p > 100，抛出 RangeError 异常。
6. 将 x 设置为 ℝ(x)。
7. 令 s 为空字符串。
8. 如果 x < 0，则
   a. 将 s 设置为代码单元 0x002D（连字符号）。
   b. 将 x

 设置为 -x。
9. 如果 x = 0，则
   a. 令 m 为包含 p 个 0x0030（数字零）代码单元的字符串值。
   b. 令 e 为 0。
10. 否则，
    a. 令 e 和 n 为整数，使得 10**(p - 1) ≤ n < 10**p，并且 n × 10**(e - p + 1) - x 尽可能接近零。如果有两个这样的 e 和 n，选择 n × 10**(e - p + 1) 较大的那组 e 和 n。
    b. 令 m 为由 n 的十进制表示的数字组成的字符串值（按顺序排列，没有前导零）。
    c. 如果 e < -6 或 e ≥ p，则
       i. 断言：e ≠ 0。
       ii. 如果 p ≠ 1，则
           1. 令 a 为 m 的第一个代码单元。
           2. 令 b 为 m 的其他 p - 1 个代码单元。
           3. 将 m 设置为 a、"." 和 b 的字符串连接。
       iii. 如果 e > 0，则
            1. 令 c 为代码单元 0x002B（加号）。
       iv. 否则，
            1. 断言：e < 0。
            2. 令 c 为代码单元 0x002D（连字符号）。
            3. 将 e 设置为 -e。
       v. 令 d 为由 e 的十进制表示的数字组成的字符串值（按顺序排列，没有前导零）。
       vi. 返回 s、m、代码单元 0x0065（小写字母 e）、c 和 d 的字符串连接。
11. 如果 e = p - 1，返回 s 和 m 的字符串连接。
12. 如果 e ≥ 0，则
    a. 将 m 设置为 m 的前 e + 1 个代码单元、代码单元 0x002E（句号）和 m 的剩余 p - (e + 1) 个代码单元的字符串连接。
13. 否则，
    a. 将 m 设置为代码单元 0x0030（数字零）、代码单元 0x002E（句号）、-(e + 1) 个 0x0030（数字零）代码单元和字符串 m 的字符串连接。
14. 返回 s 和 m 的字符串连接。

#### 21.1.3.6 Number.prototype.toString ( [radix] )
注意：可选的 radix 应为包含在 2𝔽 到 36𝔽 范围内的整数值。如果 radix 未定义，则使用 10𝔽 作为 radix 的值。

此方法调用时执行以下步骤：

1. 令 x 为 ? ThisNumberValue(this 值)。
2. 如果 radix 未定义，令 radixMV 为 10。
3. 否则，令 radixMV 为 ? ToIntegerOrInfinity(radix)。
4. 如果 radixMV 不在 2 到 36 的范围内，抛出 RangeError 异常。
5. 返回 Number::toString(x, radixMV)。

此方法不是通用的；如果其 this 值不是 Number 或 Number 对象，则抛出 TypeError 异常。因此，不能将其转移到其他类型的对象以用作方法。

此方法的 "length" 属性为 1𝔽。

#### 21.1.3.7 Number.prototype.valueOf ( )
1. 返回 ? ThisNumberValue(this 值)。

##### 21.1.3.7.1 ThisNumberValue (value)
抽象操作 ThisNumberValue 接受参数 value（一个 ECMAScript 语言值），并返回包含 Number 的正常完成或抛出完成。调用时执行以下步骤：

1. 如果 value 是 Number，返回 value。
2. 如果 value 是一个对象且具有 [[NumberData]] 内部插槽，则
   a. 令 n 为 value.[[NumberData]]。
   b. 断言：n 是一个 Number。
   c. 返回 n。
3. 抛出 TypeError 异常。

### 21.1.4 Number 实例的属性
Number 实例是普通对象，它们继承自 Number 原型对象的属性。Number 实例还具有一个 [[NumberData]] 内部插槽。[[NumberData]] 内部插槽是此 Number 对象表示的 Number 值。

### 21.2 BigInt 对象

#### 21.2.1 BigInt 构造函数
BigInt 构造函数：

- 是 %BigInt%。
- 是全局对象的 "BigInt" 属性的初始值。
- 当作为函数而不是构造函数调用时，执行类型转换。
- 不打算与 new 操作符一起使用或被子类化。它可以用作类定义的 extends 子句的值，但对 BigInt 构造函数的 super 调用将导致异常。

##### 21.2.1.1 BigInt (value)
此函数在调用时执行以下步骤：

1. 如果 NewTarget 不为 undefined，抛出 TypeError 异常。
2. 令 prim 为 ? ToPrimitive(value, NUMBER)。
3. 如果 prim 是 Number，返回 ? NumberToBigInt(prim)。
4. 否则，返回 ? ToBigInt(prim)。

###### 21.2.1.1.1 NumberToBigInt (number)
抽象操作 NumberToBigInt 接受参数 number（一个 Number）并返回包含 BigInt 的正常完成或抛出完成。调用时执行以下步骤：

1. 如果 number 不是整数 Number，抛出 RangeError 异常。
2. 返回 ℤ(ℝ(number))。

#### 21.2.2 BigInt 构造函数的属性
BigInt 构造函数：

- 有一个 [[Prototype]] 内部插槽，其值为 %Function.prototype%。
- 具有以下属性：

##### 21.2.2.1 BigInt.asIntN (bits, bigint)
此函数在调用时执行以下步骤：

1. 将 bits 设置为 ? ToIndex(bits)。
2. 将 bigint 设置为 ? ToBigInt(bigint)。
3. 令 mod 为 ℝ(bigint) 模 2**bits。
4. 如果 mod ≥ 2**(bits - 1)，返回 ℤ(mod - 2**bits)；否则，返回 ℤ(mod)。

##### 21.2.2.2 BigInt.asUintN (bits, bigint)
此函数在调用时执行以下步骤：

1. 将 bits 设置为 ? ToIndex(bits)。
2. 将 bigint 设置为 ? ToBigInt(bigint)。
3. 返回 ℤ(ℝ(bigint) 模 2**bits)。

##### 21.2.2.3 BigInt.prototype
BigInt.prototype 的初始值是 BigInt 原型对象。

该属性具有 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } 的属性特性。

#### 21.2.3 BigInt 原型对象的属性
BigInt 原型对象：

- 是 %BigInt.prototype%。
- 是一个普通对象。
- 不是 BigInt 对象；它没有 [[BigIntData]] 内部插槽。
- 具有一个 [[Prototype]] 内部插槽，其值为 %Object.prototype%。

在方法的规范中，术语“this BigInt value”指的是调用抽象操作 ThisBigIntValue 并将方法调用的 this 值作为参数传递时返回的结果。

##### 21.2.3.1 BigInt.prototype.constructor
BigInt.prototype.constructor 的初始值是 %BigInt%。

##### 21.2.3.2 BigInt.prototype.toLocaleString ([ reserved1 [, reserved2 ] ])
包括 ECMA-402 国际化 API 的 ECMAScript 实现必须按照 ECMA-402 规范实现此方法。如果 ECMAScript 实现不包括 ECMA-402 API，则使用以下规范来实现此方法：

此方法生成一个字符串值，表示根据主机环境当前区域设置格式化的 this BigInt 值。此方法是实现定义的，可以但不鼓励返回与 toString 相同的结果。

此方法的可选参数的含义在 ECMA-402 规范中定义；不包括 ECMA-402 支持的实现不得将这些参数位置用于其他用途。

##### 21.2.3.3 BigInt.prototype.toString ([radix])
注意：可选的 radix 应为包含在 2𝔽 到 36𝔽 范围内的整数值。如果 radix 未定义，则使用 10𝔽 作为 radix 的值。

此方法调用时执行以下步骤：

1. 令 x 为 ? ThisBigIntValue(this 值)。
2. 如果 radix 未定义，令 radixMV 为 10。
3. 否则，令 radixMV 为 ? ToIntegerOrInfinity(radix)。
4. 如果 radixMV 不在 2 到 36 的范围内，抛出 RangeError 异常。
5. 返回 BigInt::toString(x, radixMV)。

此方法不是通用的；如果其 this 值不是 BigInt 或 BigInt 对象，则抛出 TypeError 异常。因此，不能将其转移到其他类型的对象以用作方法。

##### 21.2.3.4 BigInt.prototype.valueOf ()
1. 返回 ? ThisBigIntValue(this 值)。

###### 21.2.3.4.1 ThisBigIntValue (value)
抽象操作 ThisBigIntValue 接受参数 value（一个 ECMAScript 语言值），并返回包含 BigInt 的正常完成或抛出完成。调用时执行以下步骤：

1. 如果 value 是 BigInt，返回 value。
2. 如果 value 是一个对象并且具有 [[BigIntData]] 内部插槽，则
   a. 断言：value.[[BigIntData]] 是 BigInt。
   b. 返回 value.[[BigIntData]]。
3. 抛出 TypeError 异常。

##### 21.2.3.5 BigInt.prototype [@@toStringTag]
@@toStringTag 属性的初始值是字符串 "BigInt"。

该属性具有 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true } 的属性特性。

#### 21.2.4 BigInt 实例的属性
BigInt 实例是普通对象，它们继承自 BigInt 原型对象的属性。BigInt 实例还具有一个 [[BigIntData]] 内部插槽。[[BigIntData]] 内部插槽是此 BigInt 对象表示的 BigInt 值。

### 21.3 Math 对象

Math 对象：

- 是 %Math%。
- 是全局对象的 "Math" 属性的初始值。
- 是一个普通对象。
- 具有一个 [[Prototype]] 内部插槽，其值为 %Object.prototype%。
- 不是函数对象。
- 没有 [[Construct]] 内部方法；不能与 new 操作符一起使用作为构造函数。
- 没有 [[Call]] 内部方法；不能作为函数调用。

注意：在本规范中，“x 的 Number 值”这个短语在 6.1.6.1 中有技术定义。

#### 21.3.1 Math 对象的值属性

##### 21.3.1.1 Math.E
自然对数的底数 e 的 Number 值，约为 2.7182818284590452354。

该属性具有 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } 的属性特性。

##### 21.3.1.2 Math.LN10
10 的自然对数的 Number 值，约为 2.302585092994046。

该属性具有 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } 的属性特性。

##### 21.3.1.3 Math.LN2
2 的自然对数的 Number 值，约为 0.6931471805599453。

该属性具有 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } 的属性特性。

##### 21.3.1.4 Math.LOG10E
e 的常用对数的 Number 值，自然对数的底数 e 的常用对数值，约为 0.4342944819032518。

该属性具有 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } 的属性特性。

注意：Math.LOG10E 的值约等于 Math.LN10 的倒数。

##### 21.3.1.5 Math.LOG2E
e 的二进制对数的 Number 值，自然对数的底数 e 的二进制对数值，约为 1.4426950408889634。

该属性具有 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } 的属性特性。

注意：Math.LOG2E 的值约等于 Math.LN2 的倒数。

##### 21.3.1.6 Math.PI
圆周率 π 的 Number 值，即圆的周长与直径的比值，约为 3.1415926535897932。

该属性具有 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } 的属性特性。

##### 21.3.1.7 Math.SQRT1_2
1/2 的平方根的 Number 值，约为 0.7071067811865476。

该属性具有 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } 的属性特性。

注意：Math.SQRT1_2 的值约等于 Math.SQRT2 的倒数。

##### 21.3.1.8 Math.SQRT2
2 的平方根的 Number 值，约为 1.4142135623730951。

该属性具有 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } 的属性特性。

##### 21.3.1.9 Math [@@toStringTag]
@@toStringTag 属性的初始值是字符串 "Math"。

该属性具有 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true } 的属性特性。

#### 21.3.2 Math 对象的函数属性

注意：函数 acos、acosh、asin、asinh、atan、atanh、atan2、cbrt、cos、cosh、exp、expm1、hypot、log、log1p、log2、log10、pow、random、sin、sinh、sqrt、tan 和 tanh 的行为在这里没有精确指定，除了对某些代表感兴趣的边界情况的参数值要求特定结果外。对于其他参数值，这些函数旨在计算熟悉的数学函数的近似结果，但在选择近似算法时允许一定的自由度。总体意图是实现者应能够在给定硬件平台上的 ECMAScript 中使用与该平台上 C 程序员可用的相同数学库。

尽管算法的选择由实现决定，但建议（但本标准未指定）实现使用 IEEE 754-2019 算术的近似算法，这些算法包含在 Sun Microsystems 的可自由分发的数学库 fdlibm 中（http://www.netlib.org/fdlibm）。

##### 21.3.2.1 Math.abs (x)
此函数返回 x 的绝对值；结果的大小与 x 相同，但符号为正。

调用时执行以下步骤：

1. 令 n 为 ? ToNumber(x)。
2. 如果 n 是 NaN，返回 NaN。
3. 如果 n 是 -0𝔽，返回 +0𝔽。
4. 如果 n 是 -∞𝔽，返回 +∞𝔽。
5. 如果 n < -0𝔽，返回 -n。
6. 返回 n。

##### 21.3.2.2 Math.acos (x)
此函数返回 x 的反余弦。结果以弧度表示，位于 +0𝔽 到 𝔽(π) 的闭区间内。

调用时执行以下步骤：

1. 令 n 为 ? ToNumber(x)。
2. 如果 n 是 NaN，n > 1𝔽 或 n < -1𝔽，返回 NaN。
3. 如果 n 是 1𝔽，返回 +0𝔽。
4. 返回一个表示 ℝ(n) 的反余弦结果的实现近似 Number 值。

##### 21.3.2.3 Math.acosh (x)
此函数返回 x 的反双曲余弦。

调用时执行以下步骤：

1. 令 n 为 ? ToNumber(x)。
2. 如果 n 是 NaN 或 +∞𝔽，返回 n。
3. 如果 n 是 1𝔽，返回 +0𝔽。
4. 如果 n < 1𝔽，返回 NaN。
5. 返回一个表示 ℝ(n) 的反双曲余弦结果的实现近似 Number 值。

##### 21.3.2.4 Math.asin (x)
此函数返回 x 的反正弦。结果以弧度表示，位于 𝔽(-π / 2) 到 𝔽(π / 2) 的闭区间内。

调用时执行以下步骤：

1. 令 n 为 ? ToNumber(x)。
2. 如果 n 是 NaN、+0𝔽 或 -0𝔽 之一，返回 n。
3. 如果 n > 1𝔽 或 n < -1𝔽，返回 NaN。
4. 返回一个表示 ℝ(n) 的反正弦结果的实现近似 Number 值。

##### 21.3.2.5 Math.asinh (x)
此函数返回 x 的反双曲正弦。

调用时执行以下步骤：

1. 令 n 为 ? ToNumber(x)。
2. 如果 n 不是有限的或 n 是 +0𝔽 或 -0𝔽 之一，返回 n。
3. 返回一个表示 ℝ(n) 的反双曲正弦结果的实现近似 Number 值。

##### 21.3.2.6 Math.atan (x)
此函数返回 x 的反正切。结果以弧度表示，位于 𝔽(-π / 2) 到 𝔽(π / 2) 的闭区间内。

调用时执行以下步骤：

1. 令 n 为 ? ToNumber(x)。
2. 如果 n 是 NaN、+0𝔽 或 -0𝔽 之一，返回 n。
3. 如果 n 是 +∞𝔽，返回一个表示 π / 2 的实现近似 Number 值。
4. 如果 n 是 -∞𝔽，返回一个表示 -π / 2 的实现近似 Number 值。
5. 返回一个表示 ℝ(n) 的反正切结果的实现近似 Number 值。

##### 21.3.2.7 Math.atanh (x)
此函数返回 x 的反双曲正切。

调用时执行以下步骤：

1. 令 n 为 ? ToNumber(x)。
2. 如果 n 是 NaN、+0𝔽 或 -0𝔽 之一，返回 n。
3. 如果 n > 1𝔽 或 n < -1𝔽，返回 NaN。
4. 如果 n 是 1𝔽，返回 +∞𝔽。
5. 如果 n 是 -1𝔽，返回 -∞𝔽。
6. 返回一个表示 ℝ(n) 的反双曲正切结果的实现近似 Number 值。

##### 21.3.2.8 Math.atan2 (y, x)
此函数返回参数 y

 和 x 的商 y / x 的反正切，其中 y 和 x 的符号用于确定结果的象限。注意，对于两个参数的反正切函数，参数名为 y 的参数在前，参数名为 x 的参数在后，这既是故意的，也是传统的。结果以弧度表示，位于 -π 到 +π 的闭区间内。

调用时执行以下步骤：

1. 令 ny 为 ? ToNumber(y)。
2. 令 nx 为 ? ToNumber(x)。
3. 如果 ny 是 NaN 或 nx 是 NaN，返回 NaN。
4. 如果 ny 是 +∞𝔽，则
   a. 如果 nx 是 +∞𝔽，返回一个表示 π / 4 的实现近似 Number 值。
   b. 如果 nx 是 -∞𝔽，返回一个表示 3π / 4 的实现近似 Number 值。
   c. 返回一个表示 π / 2 的实现近似 Number 值。
5. 如果 ny 是 -∞𝔽，则
   a. 如果 nx 是 +∞𝔽，返回一个表示 -π / 4 的实现近似 Number 值。
   b. 如果 nx 是 -∞𝔽，返回一个表示 -3π / 4 的实现近似 Number 值。
   c. 返回一个表示 -π / 2 的实现近似 Number 值。
6. 如果 ny 是 +0𝔽，则
   a. 如果 nx > +0𝔽 或 nx 是 +0𝔽，返回 +0𝔽。
   b. 返回一个表示 π 的实现近似 Number 值。
7. 如果 ny 是 -0𝔽，则
   a. 如果 nx > +0𝔽 或 nx 是 +0𝔽，返回 -0𝔽。
   b. 返回一个表示 -π 的实现近似 Number 值。
8. 断言：ny 是有限的且不是 +0𝔽 或 -0𝔽。
9. 如果 ny > +0𝔽，则
   a. 如果 nx 是 +∞𝔽，返回 +0𝔽。
   b. 如果 nx 是 -∞𝔽，返回一个表示 π 的实现近似 Number 值。
   c. 如果 nx 是 +0𝔽 或 -0𝔽 之一，返回一个表示 π / 2 的实现近似 Number 值。
10. 如果 ny < -0𝔽，则
    a. 如果 nx 是 +∞𝔽，返回 -0𝔽。
    b. 如果 nx 是 -∞𝔽，返回一个表示 -π 的实现近似 Number 值。
    c. 如果 nx 是 +0𝔽 或 -0𝔽 之一，返回一个表示 -π / 2 的实现近似 Number 值。
11. 断言：nx 是有限的且不是 +0𝔽 或 -0𝔽。
12. 令 r 为 abs(ℝ(ny) / ℝ(nx)) 的反正切。
13. 如果 nx < -0𝔽，则
    a. 如果 ny > +0𝔽，设置 r 为 π - r。
    b. 否则，设置 r 为 -π + r。
14. 否则，
    a. 如果 ny < -0𝔽，设置 r 为 -r。
15. 返回一个表示 r 的实现近似 Number 值。

##### 21.3.2.9 Math.cbrt (x)
此函数返回 x 的立方根。

调用时执行以下步骤：

1. 令 n 为 ? ToNumber(x)。
2. 如果 n 不是有限的或 n 是 +0𝔽 或 -0𝔽 之一，返回 n。
3. 返回一个表示 ℝ(n) 的立方根结果的实现近似 Number 值。

##### 21.3.2.10 Math.ceil (x)
此函数返回不小于 x 的最小（最接近 -∞）整数 Number 值。如果 x 已经是整数 Number，则结果是 x。

调用时执行以下步骤：

1. 令 n 为 ? ToNumber(x)。
2. 如果 n 不是有限的或 n 是 +0𝔽 或 -0𝔽 之一，返回 n。
3. 如果 n < -0𝔽 且 n > -1𝔽，返回 -0𝔽。
4. 如果 n 是整数 Number，返回 n。
5. 返回不小于 n 的最小（最接近 -∞）整数 Number 值。

注意：Math.ceil(x) 的值与 -Math.floor(-x) 的值相同。

##### 21.3.2.11 Math.clz32 (x)
此函数在调用时执行以下步骤：

1. 令 n 为 ? ToUint32(x)。
2. 令 p 为 n 的无符号 32 位二进制表示中的前导零位数。
3. 返回 𝔽(p)。

注意：如果 n 是 +0𝔽 或 -0𝔽，此方法返回 32𝔽。如果 n 的 32 位二进制编码的最高有效位是 1，此方法返回 +0𝔽。

##### 21.3.2.12 Math.cos (x)
此函数返回 x 的余弦。参数以弧度表示。

调用时执行以下步骤：

1. 令 n 为 ? ToNumber(x)。
2. 如果 n 不是有限的，返回 NaN。
3. 如果 n 是 +0𝔽 或 -0𝔽 之一，返回 1𝔽。
4. 返回一个表示 ℝ(n) 的余弦结果的实现近似 Number 值。

##### 21.3.2.13 Math.cosh (x)
此函数返回 x 的双曲余弦。

调用时执行以下步骤：

1. 令 n 为 ? ToNumber(x)。
2. 如果 n 是 NaN，返回 NaN。
3. 如果 n 是 +∞𝔽 或 -∞𝔽 之一，返回 +∞𝔽。
4. 如果 n 是 +0𝔽 或 -0𝔽 之一，返回 1𝔽。
5. 返回一个表示 ℝ(n) 的双曲余弦结果的实现近似 Number 值。

注意：Math.cosh(x) 的值与 (Math.exp(x) + Math.exp(-x)) / 2 的值相同。

##### 21.3.2.14 Math.exp (x)
此函数返回 x 的指数函数（e 的 x 次幂，其中 e 是自然对数的底数）。

调用时执行以下步骤：

1. 令 n 为 ? ToNumber(x)。
2. 如果 n 是 NaN 或 +∞𝔽 之一，返回 n。
3. 如果 n 是 +0𝔽 或 -0𝔽 之一，返回 1𝔽。
4. 如果 n 是 -∞𝔽，返回 +0𝔽。
5. 返回一个表示 ℝ(n) 的指数函数结果的实现近似 Number 值。

##### 21.3.2.15 Math.expm1 (x)
此函数返回从 x 的指数函数结果中减去 1 的结果（e 的 x 次幂减去 1，其中 e 是自然对数的底数）。该结果以一种即使 x 的值接近 0 也能保持准确的方式计算。

调用时执行以下步骤：

1. 令 n 为 ? ToNumber(x)。
2. 如果 n 是 NaN、+0𝔽、-0𝔽 或 +∞𝔽 之一，返回 n。
3. 如果 n 是 -∞𝔽，返回 -1𝔽。
4. 返回一个表示从 ℝ(n) 的指数函数结果中减去 1 的实现近似 Number 值。

##### 21.3.2.16 Math.floor (x)
此函数返回不大于 x 的最大（最接近 +∞）整数 Number 值。如果 x 已经是整数 Number，则结果是 x。

调用时执行以下步骤：

1. 令 n 为 ? ToNumber(x)。
2. 如果 n 不是有限的或 n 是 +0𝔽 或 -0𝔽 之一，返回 n。
3. 如果 n < 1𝔽 且 n > +0𝔽，返回 +0𝔽。
4. 如果 n 是整数 Number，返回 n。
5. 返回不大于 n 的最大（最接近 +∞）整数 Number 值。

注意：Math.floor(x) 的值与 -Math.ceil(-x) 的值相同。

##### 21.3.2.17 Math.fround (x)
此函数在调用时执行以下步骤：

1. 令 n 为 ? ToNumber(x)。
2. 如果 n 是 NaN，返回 NaN。
3. 如果 n 是 +0𝔽、-0𝔽、+∞𝔽 或 -∞𝔽 之一，返回 n。
4. 令 n32 为使用 roundTiesToEven 模式将 n 转换为 IEEE 754-2019 binary32 格式的结果。
5. 令 n64 为将 n32 转换为 IEEE 754-2019 binary64 格式的结果。
6. 返回与 n64 对应的 ECMAScript Number 值。

##### 21.

3.2.18 Math.hypot (...args)
给定零个或多个参数，此函数返回参数平方和的平方根。

调用时执行以下步骤：

1. 令 coerced 为一个新的空列表。
2. 对于 args 的每个元素 arg，执行
   a. 令 n 为 ? ToNumber(arg)。
   b. 将 n 附加到 coerced。
3. 对 coerced 的每个元素 number，执行
   a. 如果 number 是 +∞𝔽 或 -∞𝔽 之一，返回 +∞𝔽。
4. 令 onlyZero 为 true。
5. 对 coerced 的每个元素 number，执行
   a. 如果 number 是 NaN，返回 NaN。
   b. 如果 number 不是 +0𝔽 或 -0𝔽 之一，将 onlyZero 设置为 false。
6. 如果 onlyZero 为 true，返回 +0𝔽。
7. 返回一个表示 coerced 的每个元素的数学值的平方和的平方根的实现近似 Number 值。

此函数的 "length" 属性为 2𝔽。

注意：实现应注意避免在调用此函数时由于过度或不足而导致的精度损失，这在天真的实现中很容易发生。

##### 21.3.2.19 Math.imul (x, y)
此函数在调用时执行以下步骤：

1. 令 a 为 ℝ(? ToUint32(x))。
2. 令 b 为 ℝ(? ToUint32(y))。
3. 令 product 为 (a × b) 模 2**32。
4. 如果 product ≥ 2**31，返回 𝔽(product - 2**32)；否则返回 𝔽(product)。

##### 21.3.2.20 Math.log (x)
此函数返回 x 的自然对数。

调用时执行以下步骤：

1. 令 n 为 ? ToNumber(x)。
2. 如果 n 是 NaN 或 +∞𝔽 之一，返回 n。
3. 如果 n 是 1𝔽，返回 +0𝔽。
4. 如果 n 是 +0𝔽 或 -0𝔽 之一，返回 -∞𝔽。
5. 如果 n < -0𝔽，返回 NaN。
6. 返回一个表示 ℝ(n) 的自然对数结果的实现近似 Number 值。

##### 21.3.2.21 Math.log1p (x)
此函数返回 1 + x 的自然对数。该结果以一种即使 x 的值接近零也能保持准确的方式计算。

调用时执行以下步骤：

1. 令 n 为 ? ToNumber(x)。
2. 如果 n 是 NaN、+0𝔽、-0𝔽 或 +∞𝔽 之一，返回 n。
3. 如果 n 是 -1𝔽，返回 -∞𝔽。
4. 如果 n < -1𝔽，返回 NaN。
5. 返回一个表示 1 + ℝ(n) 的自然对数结果的实现近似 Number 值。

##### 21.3.2.22 Math.log10 (x)
此函数返回 x 的常用对数。

调用时执行以下步骤：

1. 令 n 为 ? ToNumber(x)。
2. 如果 n 是 NaN 或 +∞𝔽 之一，返回 n。
3. 如果 n 是 1𝔽，返回 +0𝔽。
4. 如果 n 是 +0𝔽 或 -0𝔽 之一，返回 -∞𝔽。
5. 如果 n < -0𝔽，返回 NaN。
6. 返回一个表示 ℝ(n) 的常用对数结果的实现近似 Number 值。

##### 21.3.2.23 Math.log2 (x)
此函数返回 x 的二进制对数。

调用时执行以下步骤：

1. 令 n 为 ? ToNumber(x)。
2. 如果 n 是 NaN 或 +∞𝔽 之一，返回 n。
3. 如果 n 是 1𝔽，返回 +0𝔽。
4. 如果 n 是 +0𝔽 或 -0𝔽 之一，返回 -∞𝔽。
5. 如果 n < -0𝔽，返回 NaN。
6. 返回一个表示 ℝ(n) 的二进制对数结果的实现近似 Number 值。

##### 21.3.2.24 Math.max (...args)
给定零个或多个参数，此函数调用 ToNumber 对每个参数进行处理，并返回结果值中最大的一个。

调用时执行以下步骤：

1. 令 coerced 为一个新的空列表。
2. 对于 args 的每个元素 arg，执行
   a. 令 n 为 ? ToNumber(arg)。
   b. 将 n 附加到 coerced。
3. 令 highest 为 -∞𝔽。
4. 对 coerced 的每个元素 number，执行
   a. 如果 number 是 NaN，返回 NaN。
   b. 如果 number 是 +0𝔽 且 highest 是 -0𝔽，将 highest 设置为 +0𝔽。
   c. 如果 number > highest，将 highest 设置为 number。
5. 返回 highest。

注意：使用 IsLessThan 算法来比较值以确定最大值，除了 +0𝔽 被认为比 -0𝔽 大。

此函数的 "length" 属性为 2𝔽。

##### 21.3.2.25 Math.min (...args)
给定零个或多个参数，此函数调用 ToNumber 对每个参数进行处理，并返回结果值中最小的一个。

调用时执行以下步骤：

1. 令 coerced 为一个新的空列表。
2. 对于 args 的每个元素 arg，执行
   a. 令 n 为 ? ToNumber(arg)。
   b. 将 n 附加到 coerced。
3. 令 lowest 为 +∞𝔽。
4. 对 coerced 的每个元素 number，执行
   a. 如果 number 是 NaN，返回 NaN。
   b. 如果 number 是 -0𝔽 且 lowest 是 +0𝔽，将 lowest 设置为 -0𝔽。
   c. 如果 number < lowest，将 lowest 设置为 number。
5. 返回 lowest。

注意：使用 IsLessThan 算法来比较值以确定最大值，除了 +0𝔽 被认为比 -0𝔽 大。

此函数的 "length" 属性为 2𝔽。

##### 21.3.2.26 Math.pow (base, exponent)
此函数在调用时执行以下步骤：

1. 将 base 设置为 ? ToNumber(base)。
2. 将 exponent 设置为 ? ToNumber(exponent)。
3. 返回 Number::exponentiate(base, exponent)。

##### 21.3.2.27 Math.random ()
此函数返回一个正符号的 Number 值，大于或等于 +0𝔽 但严格小于 1𝔽，使用实现定义的算法或策略以近似均匀分布在该范围内随机或伪随机选择。

为不同领域创建的每个 Math.random 函数必须从连续调用中生成不同的值序列。

##### 21.3.2.28 Math.round (x)
此函数返回最接近 x 且为整数的 Number 值。如果两个整数 Number 与 x 的距离相等，则结果是更接近 +∞ 的 Number 值。如果 x 已经是整数，结果是 x。

调用时执行以下步骤：

1. 令 n 为 ? ToNumber(x)。
2. 如果 n 不是有限的或 n 是整数 Number，返回 n。
3. 如果 n < 0.5𝔽 且 n > +0𝔽，返回 +0𝔽。
4. 如果 n < -0𝔽 且 n ≥ -0.5𝔽，返回 -0𝔽。
5. 返回最接近 n 的整数 Number，遇到平局时更接近 +∞ 的 Number 值。

注意 1：Math.round(3.5) 返回 4，但 Math.round(-3.5) 返回 -3。

注意 2：Math.round(x) 的值并不总是与 Math.floor(x + 0.5) 的值相同。当 x 是 -0𝔽 或 x 小于 +0𝔽 但大于或等于 -0.5𝔽 时，Math.round(x) 返回 -0𝔽，但 Math.floor(x + 0.5) 返回 +0𝔽。由于计算 x + 0.5 时的内部舍入，Math.round(x) 也可能与 Math.floor(x + 0.5) 的值不同。

##### 21.3.2.29 Math.sign (x)
此函数返回 x 的符号，指示 x 是正数、负数还是零。

调用时执行以下步骤：

1. 令 n 为 ? ToNumber(x)。
2. 如果 n 是 NaN、+0𝔽 或 -0𝔽 之一，返回 n。
3. 如果 n < -0𝔽，返回 -1𝔽。
4. 返回 1𝔽。

##### 21.3.2.30 Math.sin (x)
此函数返回 x 的正弦。参数以弧度表示。

调用

时执行以下步骤：

1. 令 n 为 ? ToNumber(x)。
2. 如果 n 是 NaN、+0𝔽 或 -0𝔽 之一，返回 n。
3. 如果 n 是 +∞𝔽 或 -∞𝔽 之一，返回 NaN。
4. 返回一个表示 ℝ(n) 的正弦结果的实现近似 Number 值。

##### 21.3.2.31 Math.sinh (x)
此函数返回 x 的双曲正弦。

调用时执行以下步骤：

1. 令 n 为 ? ToNumber(x)。
2. 如果 n 不是有限的或 n 是 +0𝔽 或 -0𝔽 之一，返回 n。
3. 返回一个表示 ℝ(n) 的双曲正弦结果的实现近似 Number 值。

注意：Math.sinh(x) 的值与 (Math.exp(x) - Math.exp(-x)) / 2 的值相同。

##### 21.3.2.32 Math.sqrt (x)
此函数返回 x 的平方根。

调用时执行以下步骤：

1. 令 n 为 ? ToNumber(x)。
2. 如果 n 是 NaN、+0𝔽、-0𝔽 或 +∞𝔽 之一，返回 n。
3. 如果 n < -0𝔽，返回 NaN。
4. 返回一个表示 ℝ(n) 的平方根结果的实现近似 Number 值。

##### 21.3.2.33 Math.tan (x)
此函数返回 x 的正切。参数以弧度表示。

调用时执行以下步骤：

1. 令 n 为 ? ToNumber(x)。
2. 如果 n 是 NaN、+0𝔽 或 -0𝔽 之一，返回 n。
3. 如果 n 是 +∞𝔽 或 -∞𝔽 之一，返回 NaN。
4. 返回一个表示 ℝ(n) 的正切结果的实现近似 Number 值。

##### 21.3.2.34 Math.tanh (x)
此函数返回 x 的双曲正切。

调用时执行以下步骤：

1. 令 n 为 ? ToNumber(x)。
2. 如果 n 是 NaN、+0𝔽 或 -0𝔽 之一，返回 n。
3. 如果 n 是 +∞𝔽，返回 1𝔽。
4. 如果 n 是 -∞𝔽，返回 -1𝔽。
5. 返回一个表示 ℝ(n) 的双曲正切结果的实现近似 Number 值。

注意：Math.tanh(x) 的值与 (Math.exp(x) - Math.exp(-x)) / (Math.exp(x) + Math.exp(-x)) 的值相同。

##### 21.3.2.35 Math.trunc (x)
此函数返回 x 的整数部分，去掉任何小数部分。如果 x 已经是整数，结果是 x。

调用时执行以下步骤：

1. 令 n 为 ? ToNumber(x)。
2. 如果 n 不是有限的或 n 是 +0𝔽 或 -0𝔽 之一，返回 n。
3. 如果 n < 1𝔽 且 n > +0𝔽，返回 +0𝔽。
4. 如果 n < -0𝔽 且 n > -1𝔽，返回 -0𝔽。
5. 返回最接近 n 的整数 Number，方向为 +0𝔽。

### 21.4 日期对象

#### 21.4.1 日期对象概述及抽象操作的定义

以下抽象操作作用于时间值（在 21.4.1.1 中定义）。请注意，在任何情况下，如果这些函数的任何参数是 NaN，结果将是 NaN。

##### 21.4.1.1 时间值和时间范围

ECMAScript 中的时间测量类似于 POSIX 中的时间测量，特别是共享了关于公历日历的定义、纪元时间为 1970 年 1 月 1 日零时（UTC），并且每一天都由正好 86,400 秒（每秒为 1000 毫秒）组成。

ECMAScript 的时间值是一个数字，要么是表示某一时刻的有限整数（以毫秒为精度），要么是表示没有特定时刻的 NaN。一个时间值如果是 24 × 60 × 60 × 1000 = 86,400,000 的倍数（即 86,400,000 × d，其中 d 为整数），则表示从纪元开始之后 d 天 UTC 天开始的时刻（d 为负表示纪元之前）。其他所有有限的时间值 t 相对于最近的时间值 s（这是一个这样的倍数）定义，并表示在同一个 UTC 天内比 s 多 (t - s) 毫秒的时刻。

时间值不考虑 UTC 闰秒——没有表示正闰秒内时刻的时间值，有一些时间值表示由于负闰秒而从 UTC 时间线中移除的时刻。然而，时间值的定义仍然在闰秒边界处与 UTC 逐段对齐，除闰秒之外没有差异。

一个数字可以精确表示从 -9,007,199,254,740,992 到 9,007,199,254,740,992 之间的所有整数（参见 21.1.2.8 和 21.1.2.6）。一个时间值支持略小的范围，从 -8,640,000,000,000,000 到 8,640,000,000,000,000 毫秒。这提供了相对于 1970 年 1 月 1 日零时（UTC）的时间值范围，从 -100,000,000 天到 100,000,000 天。

1970 年 1 月 1 日零时（UTC）的确切时刻由时间值 +0𝔽 表示。

注意：在公历日历中，闰年是那些既能被 4 整除并且要么能被 400 整除，要么不能被 100 整除的年份。

公历日历的 400 年周期包含 97 个闰年。这意味着每年的平均天数为 365.2425 天，即 31,556,952,000 毫秒。因此，一个数字能够精确表示以毫秒为精度的大约 -285,426 年到 285,426 年相对于 1970 年的时间值。本文规定的时间值支持的较小范围大约为 -273,790 年到 273,790 年相对于 1970 年的时间值。

##### 21.4.1.2 与时间相关的常量

这些常量由以下部分中的算法引用。

```plaintext
HoursPerDay = 24
MinutesPerHour = 60
SecondsPerMinute = 60
msPerSecond = 1000𝔽
msPerMinute = 60000𝔽 = msPerSecond × 𝔽(SecondsPerMinute)
msPerHour = 3600000𝔽 = msPerMinute × 𝔽(MinutesPerHour)
msPerDay = 86400000𝔽 = msPerHour × 𝔽(HoursPerDay)
```

##### 21.4.1.3 Day ( t )

抽象操作 Day 接受参数 t（一个有限的时间值）并返回一个整数。它返回 t 所在天的天数。调用时执行以下步骤：

1. 返回 𝔽(floor(ℝ(t / msPerDay)))。

##### 21.4.1.4 TimeWithinDay ( t )

抽象操作 TimeWithinDay 接受参数 t（一个有限的时间值）并返回一个区间从 +0𝔽（含）到 msPerDay（不含）之间的整数。它返回 t 所在天自开始以来的毫秒数。调用时执行以下步骤：

1. 返回 𝔽(ℝ(t) modulo ℝ(msPerDay))。

##### 21.4.1.5 DaysInYear ( y )

抽象操作 DaysInYear 接受参数 y（一个整数）并返回 365𝔽 或 366𝔽。它返回 y 年的天数。闰年有 366 天；其他年份有 365 天。调用时执行以下步骤：

1. 令 ry 为 ℝ(y)。
2. 如果 (ry modulo 400) = 0，返回 366𝔽。
3. 如果 (ry modulo 100) = 0，返回 365𝔽。
4. 如果 (ry modulo 4) = 0，返回 366𝔽。
5. 返回 365𝔽。

##### 21.4.1.6 DayFromYear ( y )

抽象操作 DayFromYear 接受参数 y（一个整数）并返回一个整数。它返回 y 年的第一天的天数。调用时执行以下步骤：

1. 令 ry 为 ℝ(y)。
2. 注意：在以下步骤中，numYears1、numYears4、numYears100 和 numYears400 分别表示在纪元与 y 年开始之间可以被 1、4、100 和 400 整除的年数。如果 y 在纪元之前，则此数字为负数。
3. 令 numYears1 为 (ry - 1970)。
4. 令 numYears4 为 floor((ry - 1969) / 4)。
5. 令 numYears100 为 floor((ry - 1901) / 100)。
6. 令 numYears400 为 floor((ry - 1601) / 400)。
7. 返回 𝔽(365 × numYears1 + numYears4 - numYears100 + numYears400)。

##### 21.4.1.7 TimeFromYear ( y )

抽象操作 TimeFromYear 接受参数 y（一个整数）并返回一个时间值。它返回 y 年开始的时间值。调用时执行以下步骤：

1. 返回 msPerDay × DayFromYear(y)。

##### 21.4.1.8 YearFromTime ( t )

抽象操作 YearFromTime 接受参数 t（一个有限的时间值）并返回一个整数。它返回 t 所在的年份。调用时执行以下步骤：

1. 返回最接近 +∞ 的最大整数 y，使得 TimeFromYear(y) ≤ t。

##### 21.4.1.9 DayWithinYear ( t )

抽象操作 DayWithinYear 接受参数 t（一个有限的时间值）并返回一个区间从 +0𝔽 到 365𝔽 的整数。调用时执行以下步骤：

1. 返回 Day(t) - DayFromYear(YearFromTime(t))。

##### 21.4.1.10 InLeapYear ( t )

抽象操作 InLeapYear 接受参数 t（一个有限的时间值）并返回 +0𝔽 或 1𝔽。如果 t 处于闰年内，返回 1𝔽；否则返回 +0𝔽。调用时执行以下步骤：

1. 如果 DaysInYear(YearFromTime(t)) 是 366𝔽，返回 1𝔽；否则返回 +0𝔽。

##### 21.4.1.11 MonthFromTime ( t )

抽象操作 MonthFromTime 接受参数 t（一个有限的时间值）并返回一个区间从 +0𝔽 到 11𝔽 的整数。它返回一个表示 t 所在月份的数字。月份值 +0𝔽 表示一月；1𝔽 表示二月；2𝔽 表示三月；3𝔽 表示四月；4𝔽 表示五月；5𝔽 表示六月；6𝔽 表示七月；7𝔽 表示八月；8𝔽 表示九月；9𝔽 表示十月；10𝔽 表示十一月；11𝔽 表示十二月。注意，MonthFromTime(+0𝔽) = +0𝔽，对应于 1970 年 1 月 1 日星期四。调用时执行以下步骤：

1. 令 inLeapYear 为 InLeapYear(t)。
2. 令 dayWithinYear 为 DayWithinYear(t)。
3. 如果 dayWithinYear < 31𝔽，返回 +0𝔽。
4. 如果 dayWithinYear < 59𝔽 + inLeapYear，返回 1𝔽。
5. 如果 dayWithinYear < 90𝔽 + inLeapYear，返回 2𝔽。
6. 如果 dayWithinYear < 120𝔽 + inLeapYear，返回 3𝔽。
7. 如果

 dayWithinYear < 151𝔽 + inLeapYear，返回 4𝔽。
8. 如果 dayWithinYear < 181𝔽 + inLeapYear，返回 5𝔽。
9. 如果 dayWithinYear < 212𝔽 + inLeapYear，返回 6𝔽。
10. 如果 dayWithinYear < 243𝔽 + inLeapYear，返回 7𝔽。
11. 如果 dayWithinYear < 273𝔽 + inLeapYear，返回 8𝔽。
12. 如果 dayWithinYear < 304𝔽 + inLeapYear，返回 9𝔽。
13. 如果 dayWithinYear < 334𝔽 + inLeapYear，返回 10𝔽。
14. 断言：dayWithinYear < 365𝔽 + inLeapYear。
15. 返回 11𝔽。

##### 21.4.1.12 DateFromTime ( t )

抽象操作 DateFromTime 接受参数 t（一个有限的时间值）并返回一个区间从 1𝔽 到 31𝔽 的整数。它返回 t 所在月份的日期。调用时执行以下步骤：

1. 令 inLeapYear 为 InLeapYear(t)。
2. 令 dayWithinYear 为 DayWithinYear(t)。
3. 令 month 为 MonthFromTime(t)。
4. 如果 month 是 +0𝔽，返回 dayWithinYear + 1𝔽。
5. 如果 month 是 1𝔽，返回 dayWithinYear - 30𝔽。
6. 如果 month 是 2𝔽，返回 dayWithinYear - 58𝔽 - inLeapYear。
7. 如果 month 是 3𝔽，返回 dayWithinYear - 89𝔽 - inLeapYear。
8. 如果 month 是 4𝔽，返回 dayWithinYear - 119𝔽 - inLeapYear。
9. 如果 month 是 5𝔽，返回 dayWithinYear - 150𝔽 - inLeapYear。
10. 如果 month 是 6𝔽，返回 dayWithinYear - 180𝔽 - inLeapYear。
11. 如果 month 是 7𝔽，返回 dayWithinYear - 211𝔽 - inLeapYear。
12. 如果 month 是 8𝔽，返回 dayWithinYear - 242𝔽 - inLeapYear。
13. 如果 month 是 9𝔽，返回 dayWithinYear - 272𝔽 - inLeapYear。
14. 如果 month 是 10𝔽，返回 dayWithinYear - 303𝔽 - inLeapYear。
15. 断言：month 是 11𝔽。
16. 返回 dayWithinYear - 333𝔽 - inLeapYear。

##### 21.4.1.13 WeekDay ( t )

抽象操作 WeekDay 接受参数 t（一个有限的时间值）并返回一个区间从 +0𝔽 到 6𝔽 的整数。它返回一个表示 t 所在星期几的数字。星期值 +0𝔽 表示星期日；1𝔽 表示星期一；2𝔽 表示星期二；3𝔽 表示星期三；4𝔽 表示星期四；5𝔽 表示星期五；6𝔽 表示星期六。注意，WeekDay(+0𝔽) = 4𝔽，对应于 1970 年 1 月 1 日星期四。调用时执行以下步骤：

1. 返回 𝔽(ℝ(Day(t) + 4𝔽) modulo 7)。

##### 21.4.1.14 HourFromTime ( t )

抽象操作 HourFromTime 接受参数 t（一个有限的时间值）并返回一个区间从 +0𝔽 到 23𝔽 的整数。它返回 t 所在天的小时。调用时执行以下步骤：

1. 返回 𝔽(floor(ℝ(t / msPerHour)) modulo HoursPerDay)。

##### 21.4.1.15 MinFromTime ( t )

抽象操作 MinFromTime 接受参数 t（一个有限的时间值）并返回一个区间从 +0𝔽 到 59𝔽 的整数。它返回 t 所在小时的分钟。调用时执行以下步骤：

1. 返回 𝔽(floor(ℝ(t / msPerMinute)) modulo MinutesPerHour)。

##### 21.4.1.16 SecFromTime ( t )

抽象操作 SecFromTime 接受参数 t（一个有限的时间值）并返回一个区间从 +0𝔽 到 59𝔽 的整数。它返回 t 所在分钟的秒数。调用时执行以下步骤：

1. 返回 𝔽(floor(ℝ(t / msPerSecond)) modulo SecondsPerMinute)。

##### 21.4.1.17 msFromTime ( t )

抽象操作 msFromTime 接受参数 t（一个有限的时间值）并返回一个区间从 +0𝔽 到 999𝔽 的整数。它返回 t 所在秒的毫秒数。调用时执行以下步骤：

1. 返回 𝔽(ℝ(t) modulo ℝ(msPerSecond))。

##### 21.4.1.18 GetUTCEpochNanoseconds (year, month, day, hour, minute, second, millisecond, microsecond, nanosecond)

抽象操作 GetUTCEpochNanoseconds 接受参数 year（整数）、month（区间为 1 到 12 的整数）、day（区间为 1 到 31 的整数）、hour（区间为 0 到 23 的整数）、minute（区间为 0 到 59 的整数）、second（区间为 0 到 59 的整数）、millisecond（区间为 0 到 999 的整数）、microsecond（区间为 0 到 999 的整数）和 nanosecond（区间为 0 到 999 的整数），并返回一个 BigInt。返回值表示自纪元以来的纳秒数，对应于给定的 ISO 8601 日历日期和 UTC 的墙上时间。调用时执行以下步骤：

1. 令 date 为 MakeDay(𝔽(year), 𝔽(month - 1), 𝔽(day))。
2. 令 time 为 MakeTime(𝔽(hour), 𝔽(minute), 𝔽(second), 𝔽(millisecond))。
3. 令 ms 为 MakeDate(date, time)。
4. 断言：ms 是一个整数。
5. 返回 ℤ(ℝ(ms) × 10**6 + microsecond × 10**3 + nanosecond)。

##### 21.4.1.19 时区标识符

ECMAScript 中的时区由时区标识符表示，这些标识符是完全由区间从 0x0000 到 0x007F 的代码单元组成的字符串。ECMAScript 实现支持的时区可以是可用的命名时区，由 AvailableNamedTimeZoneIdentifiers 返回的时区标识符记录的 [[Identifier]] 字段表示，或者是偏移时区，由 IsTimeZoneOffsetString 返回 true 的字符串表示。

主要时区标识符是可用命名时区的首选标识符。非主要时区标识符是可用命名时区的标识符，但不是主要时区标识符。可用命名时区标识符可以是主要时区标识符或非主要时区标识符。每个可用命名时区标识符都与一个可用命名时区完全对应。每个可用命名时区都与一个主要时区标识符和零个或多个非主要时区标识符对应。

ECMAScript 实现必须支持标识符为 "UTC" 的可用命名时区，该标识符必须是 UTC 时区的主要时区标识符。此外，实现可以支持任意数量的其他可用命名时区。

符合 ECMA-402 国际化 API 规范中描述的时区要求的实现称为时区感知实现。时区感知实现必须支持与 IANA 时区数据库的区域和链接名称相对应的可用命名时区，并且只能是这些名称。在时区感知实现中，主要时区标识符是 IANA 时区数据库中的区域名称，非主要时区标识符是链接名称，除非 ECMA-402 规范中 AvailableNamedTimeZoneIdentifiers 明确覆盖。即使不支持整个 IANA 时区数据库的实现，仍建议使用 IANA 时区数据库名称作为表示时区的标识符。

### 21.4.1.20 获取命名时区纪元纳秒数（GetNamedTimeZoneEpochNanoseconds）

实现定义的抽象操作 `GetNamedTimeZoneEpochNanoseconds` 接受参数 `timeZoneIdentifier`（字符串）、`year`（整数）、`month`（区间为1到12的整数）、`day`（区间为1到31的整数）、`hour`（区间为0到23的整数）、`minute`（区间为0到59的整数）、`second`（区间为0到59的整数）、`millisecond`（区间为0到999的整数）、`microsecond`（区间为0到999的整数）和 `nanosecond`（区间为0到999的整数），并返回一个 `BigInt` 列表。返回的每个值表示自纪元以来的纳秒数，对应于给定的 ISO 8601 日历日期和命名时区标识符为 `timeZoneIdentifier` 的墙上时间。

当输入表示由于负时区转换而重复出现的本地时间（例如，当夏令时结束或时区偏移由于时区规则更改而减小时），返回的列表将有多个元素，并按数值升序排列。当输入表示由于正时区转换而跳过的本地时间（例如，当夏令时开始或时区偏移由于时区规则更改而增加时），返回的列表将为空。否则，返回的列表将有一个元素。

用于不包含任何时区的本地政治规则的 ECMAScript 实现的 `GetNamedTimeZoneEpochNanoseconds` 的默认实现，调用时执行以下步骤：

1. 断言：`timeZoneIdentifier` 为 "UTC"。
2. 令 `epochNanoseconds` 为 `GetUTCEpochNanoseconds(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond)`。
3. 返回 « `epochNanoseconds` »。

**注释：**
要求时区感知实现（并建议所有其他实现）使用 IANA 时区数据库的信息 https://www.iana.org/time-zones/。

2017年11月5日凌晨1:30在 America/New_York 重复两次，因此 `GetNamedTimeZoneEpochNanoseconds("America/New_York", 2017, 11, 5, 1, 30, 0, 0, 0, 0)` 将返回一个长度为2的列表，其中第一个元素表示 05:30 UTC（对应于 UTC 偏移 -04:00 的美国东部夏令时间 01:30），第二个元素表示 06:30 UTC（对应于 UTC 偏移 -05:00 的美国东部标准时间 01:30）。

2017年3月12日凌晨2:30在 America/New_York 不存在，因此 `GetNamedTimeZoneEpochNanoseconds("America/New_York", 2017, 3, 12, 2, 30, 0, 0, 0, 0)` 将返回一个空列表。

### 21.4.1.21 获取命名时区偏移纳秒数（GetNamedTimeZoneOffsetNanoseconds）

实现定义的抽象操作 `GetNamedTimeZoneOffsetNanoseconds` 接受参数 `timeZoneIdentifier`（字符串）和 `epochNanoseconds`（`BigInt`），并返回一个整数。

返回的整数表示命名时区标识符 `timeZoneIdentifier` 在与 `epochNanoseconds` 相对应的时刻相对于纪元的 UTC 偏移，以纳秒为单位。

用于不包含任何时区的本地政治规则的 ECMAScript 实现的 `GetNamedTimeZoneOffsetNanoseconds` 的默认实现，调用时执行以下步骤：

1. 断言：`timeZoneIdentifier` 为 "UTC"。
2. 返回 0。

**注释：**
时区偏移值可以为正数或负数。

### 21.4.1.22 时区标识符记录（Time Zone Identifier Record）

时区标识符记录是用于描述可用命名时区标识符及其对应的主要时区标识符的记录。

时区标识符记录包含表60中列出的字段。

| 字段名         | 值          | 含义                                       |
| -------------- | ----------- | ------------------------------------------ |
| [[Identifier]] | 一个字符串  | 该实现支持的可用命名时区标识符             |
| [[PrimaryIdentifier]] | 一个字符串  | [[Identifier]] 解析为的主要时区标识符     |

**注释：**
如果 [[Identifier]] 是主要时区标识符，则 [[Identifier]] 是 [[PrimaryIdentifier]]。

### 21.4.1.23 可用命名时区标识符（AvailableNamedTimeZoneIdentifiers）

实现定义的抽象操作 `AvailableNamedTimeZoneIdentifiers` 不接受任何参数，并返回一个时区标识符记录列表。结果描述了该实现中的所有可用命名时区标识符，以及每个可用命名时区标识符对应的主要时区标识符。列表按照每个时区标识符记录的 [[Identifier]] 字段排序。

时区感知实现，包括所有实现 ECMA-402 国际化 API 的实现，必须按照 ECMA-402 规范实现 `AvailableNamedTimeZoneIdentifiers` 抽象操作。对于不时区感知的实现，`AvailableNamedTimeZoneIdentifiers` 执行以下步骤：

1. 如果实现不包含任何时区的本地政治规则，则
   a. 返回 « 时区标识符记录 { [[Identifier]]: "UTC", [[PrimaryIdentifier]]: "UTC" } »。
2. 令 `identifiers` 为按字典序排序的唯一可用命名时区标识符列表。
3. 令 `result` 为一个新的空列表。
4. 对于 `identifiers` 中的每个元素 `identifier`，执行
   a. 令 `primary` 为 `identifier`。
   b. 如果 `identifier` 是该实现中的非主要时区标识符并且 `identifier` 不是 "UTC"，则
      i. 将 `primary` 设置为与 `identifier` 相关联的主要时区标识符。
      ii. **注释：**实现可能需要迭代解析 `identifier` 以获得主要时区标识符。
   c. 令 `record` 为时区标识符记录 { [[Identifier]]: `identifier`, [[PrimaryIdentifier]]: `primary` }。
   d. 将 `record` 添加到 `result`。
5. 断言：`result` 包含时区标识符记录 `r`，其中 `r.[[Identifier]]` 是 "UTC" 并且 `r.[[PrimaryIdentifier]]` 是 "UTC"。
6. 返回 `result`。

### 21.4.1.24 系统时区标识符（SystemTimeZoneIdentifier）

实现定义的抽象操作 `SystemTimeZoneIdentifier` 不接受任何参数并返回一个字符串。它返回一个表示主机环境当前时区的字符串，该字符串要么表示 `IsTimeZoneOffsetString` 返回 `true` 的 UTC 偏移，要么是主要时区标识符。调用时执行以下步骤：

1. 如果实现仅支持 UTC 时区，则返回 "UTC"。
2. 令 `systemTimeZoneString` 为表示主机环境当前时区的字符串，要么是主要时区标识符，要么是偏移时区标识符。
3. 返回 `systemTimeZoneString`。

**注释：**
为了确保实现通常在 Date 对象的方法中提供的功能级别，建议 `SystemTimeZoneIdentifier` 返回与主机环境的时区设置对应的 IANA 时区名称（如果存在的话）。`GetNamedTimeZoneEpochNanoseconds` 和 `GetNamedTimeZoneOffsetNanoseconds` 必须反映该时区的标准时间和夏令时的本地政治规则（如果存在）。

例如，如果主机环境是用户选择美国东部时间为其时区的系统上的浏览器，`SystemTimeZoneIdentifier` 返回 "America/New_York"。

### 21.4.1.25 本地时间（LocalTime）

抽象操作 `LocalTime` 接受参数 `t`（一个有限的时间值）并返回一个整数。它将 `t` 从 UTC 转换为本地时间。应使用 `t` 时有效的标准时间和夏令时的本地政治规则来确定结果。调用时执行以下步骤：

1. 令 `systemTimeZoneIdentifier` 为 `SystemTimeZoneIdentifier()`。
2. 如果 `IsTimeZoneOffsetString(systemTimeZoneIdentifier)` 为 `true`，则
   a. 令 `offsetNs` 为 `ParseTimeZoneOffsetString(systemTimeZoneIdentifier)`。
3. 否则，
   a. 令 `offsetNs` 为 `GetNamedTimeZoneOffsetNanoseconds(systemTimeZoneIdentifier, ℤ(ℝ(t) × 10**6))`。
4. 令 `offsetMs` 为 `truncate(offsetNs / 10**6)`。
5. 返回 `t + 𝔽(offsetMs)`。

**注释 1：**
如果实现中没有提供 `t` 的本地政治规则，结果是 `t`，因为 `SystemTimeZoneIdentifier` 返回 "UTC"，`

GetNamedTimeZoneOffsetNanoseconds` 返回 0。

**注释 2：**
要求时区感知实现（并建议所有其他实现）使用 IANA 时区数据库的信息 https://www.iana.org/time-zones/。

**注释 3：**
两个不同的输入时间值 `tUTC` 在负时区转换时被转换为相同的本地时间 `tlocal`，当存在重复时间（例如夏令时结束或时区调整减小时）。

`LocalTime(UTC(tlocal))` 不一定总是等于 `tlocal`。相应地，`UTC(LocalTime(tUTC))` 也不一定总是等于 `tUTC`。

### 21.4.1.26 UTC（UTC）

抽象操作 `UTC` 接受参数 `t`（一个数字）并返回一个时间值。它将 `t` 从本地时间转换为 UTC 时间值。应使用 `t` 时有效的标准时间和夏令时的本地政治规则来确定结果。调用时执行以下步骤：

1. 如果 `t` 不是有限值，返回 NaN。
2. 令 `systemTimeZoneIdentifier` 为 `SystemTimeZoneIdentifier()`。
3. 如果 `IsTimeZoneOffsetString(systemTimeZoneIdentifier)` 为 `true`，则
   a. 令 `offsetNs` 为 `ParseTimeZoneOffsetString(systemTimeZoneIdentifier)`。
4. 否则，
   a. 令 `possibleInstants` 为 `GetNamedTimeZoneEpochNanoseconds(systemTimeZoneIdentifier, ℝ(YearFromTime(t)), ℝ(MonthFromTime(t)) + 1, ℝ(DateFromTime(t)), ℝ(HourFromTime(t)), ℝ(MinFromTime(t)), ℝ(SecFromTime(t)), ℝ(msFromTime(t)), 0, 0)`。
   b. **注释：** 以下步骤确保当 `t` 表示在负时区转换时重复多次的本地时间（例如夏令时结束或时区偏移由于时区规则更改而减小时）或在正时区转换时跳过的本地时间（例如夏令时开始或时区偏移由于时区规则更改而增加时），`t` 使用转换前的时区偏移进行解释。
   c. 如果 `possibleInstants` 不为空，则
      i. 令 `disambiguatedInstant` 为 `possibleInstants[0]`。
   d. 否则，
      i. **注释：** `t` 表示在正时区转换时跳过的本地时间（例如由于夏令时开始或时区规则更改而增加 UTC 偏移）。
      ii. 令 `possibleInstantsBefore` 为 `GetNamedTimeZoneEpochNanoseconds(systemTimeZoneIdentifier, ℝ(YearFromTime(tBefore)), ℝ(MonthFromTime(tBefore)) + 1, ℝ(DateFromTime(tBefore)), ℝ(HourFromTime(tBefore)), ℝ(MinFromTime(tBefore)), ℝ(SecFromTime(tBefore)), ℝ(msFromTime(tBefore)), 0, 0)`，其中 `tBefore` 是最大整数 `< t` 的值，对于该值 `possibleInstantsBefore` 不是空的（即 `tBefore` 表示转换前的最后一个本地时间）。
      iii. 令 `disambiguatedInstant` 为 `possibleInstantsBefore` 的最后一个元素。
   e. 令 `offsetNs` 为 `GetNamedTimeZoneOffsetNanoseconds(systemTimeZoneIdentifier, disambiguatedInstant)`。
5. 令 `offsetMs` 为 `truncate(offsetNs / 10**6)`。
6. 返回 `t - 𝔽(offsetMs)`。

输入 `t` 名义上是一个时间值，但可以是任何数字值。算法不得限制 `t` 的时间值范围，以便支持对应于时间值范围边界的输入，无论本地 UTC 偏移如何。例如，最大时间值为 8.64 × 10**15，对应于 "+275760-09-13T00:00:00Z"。在本地时区偏移在该时刻比 UTC 提前1小时的环境中，它由 8.64 × 10**15 + 3.6 × 10**6 表示，对应于 "+275760-09-13T01:00:00+01:00"。

如果实现中没有提供 `t` 的本地政治规则，结果是 `t`，因为 `SystemTimeZoneIdentifier` 返回 "UTC"，`GetNamedTimeZoneOffsetNanoseconds` 返回 0。

**注释 1：**
要求时区感知实现（并建议所有其他实现）使用 IANA 时区数据库的信息 https://www.iana.org/time-zones/。

2017年11月5日凌晨1:30在 America/New_York 重复两次（回拨），但它必须解释为 1:30 AM UTC-04 而不是 1:30 AM UTC-05。在 `UTC(TimeClip(MakeDate(MakeDay(2017, 10, 5), MakeTime(1, 30, 0, 0))))` 中，`offsetMs` 的值为 -4 × `msPerHour`。

2017年3月12日凌晨2:30在 America/New_York 不存在，但它必须解释为 2:30 AM UTC-05（相当于 3:30 AM UTC-04）。在 `UTC(TimeClip(MakeDate(MakeDay(2017, 2, 12), MakeTime(2, 30, 0, 0))))` 中，`offsetMs` 的值为 -5 × `msPerHour`。

**注释 2：**
`UTC(LocalTime(tUTC))` 不一定总是等于 `tUTC`。相应地，`LocalTime(UTC(tlocal))` 也不一定总是等于 `tlocal`。

### 21.4.1.27 创建时间（MakeTime）

抽象操作 `MakeTime` 接受参数 `hour`（一个数字）、`min`（一个数字）、`sec`（一个数字）和 `ms`（一个数字），并返回一个数字。它计算毫秒数。调用时执行以下步骤：

1. 如果 `hour` 不是有限值，`min` 不是有限值，`sec` 不是有限值，或者 `ms` 不是有限值，返回 NaN。
2. 令 `h` 为 `𝔽(! ToIntegerOrInfinity(hour))`。
3. 令 `m` 为 `𝔽(! ToIntegerOrInfinity(min))`。
4. 令 `s` 为 `𝔽(! ToIntegerOrInfinity(sec))`。
5. 令 `milli` 为 `𝔽(! ToIntegerOrInfinity(ms))`。
6. 返回 `((h × msPerHour + m × msPerMinute) + s × msPerSecond) + milli`。

**注释：**
`MakeTime` 中的运算是浮点运算，不是结合律的，因此必须按正确的顺序执行运算。

### 21.4.1.28 创建日期（MakeDay）

抽象操作 `MakeDay` 接受参数 `year`（一个数字）、`month`（一个数字）和 `date`（一个数字），并返回一个数字。它计算天数。调用时执行以下步骤：

1. 如果 `year` 不是有限值，`month` 不是有限值，或者 `date` 不是有限值，返回 NaN。
2. 令 `y` 为 `𝔽(! ToIntegerOrInfinity(year))`。
3. 令 `m` 为 `𝔽(! ToIntegerOrInfinity(month))`。
4. 令 `dt` 为 `𝔽(! ToIntegerOrInfinity(date))`。
5. 令 `ym` 为 `y + 𝔽(floor(ℝ(m) / 12))`。
6. 如果 `ym` 不是有限值，返回 NaN。
7. 令 `mn` 为 `𝔽(ℝ(m) modulo 12)`。
8. 找到一个有限时间值 `t`，使得 `YearFromTime(t)` 为 `ym`，`MonthFromTime(t)` 为 `mn`，且 `DateFromTime(t)` 为 `1𝔽`；但如果这不可能（因为某些参数超出范围），返回 NaN。
9. 返回 `Day(t) + dt - 1𝔽`。

### 21.4.1.29 创建日期时间（MakeDate）

抽象操作 `MakeDate` 接受参数 `day`（一个数字）和 `time`（一个数字），并返回一个数字。它计算毫秒数。调用时执行以下步骤：

1. 如果 `day` 不是有限值或 `time` 不是有限值，返回 NaN。
2. 令 `tv` 为 `day × msPerDay + time`。
3. 如果 `tv` 不是有限值，返回 NaN。
4. 返回 `tv`。

### 21.4.1.30 创建完整年份（MakeFullYear）

抽象操作 `MakeFullYear` 接受参数 `year`（一个数字），并返回一个整数或 NaN。它返回与 `year` 的整数部分相关联的完整年份，将区间从 0 到 99 的任何

值解释为自 1900 年开始的年份计数。为与前格里高利历对齐，“完整年份”定义为自 0 年（公元前1年）开始的完整年份数。调用时执行以下步骤：

1. 如果 `year` 为 NaN，返回 NaN。
2. 令 `truncated` 为 `! ToIntegerOrInfinity(year)`。
3. 如果 `truncated` 在区间 0 到 99 之间，返回 `1900𝔽 + 𝔽(truncated)`。
4. 返回 `𝔽(truncated)`。

### 21.4.1.31 时间剪辑（TimeClip）

抽象操作 `TimeClip` 接受参数 `time`（一个数字），并返回一个数字。它计算毫秒数。调用时执行以下步骤：

1. 如果 `time` 不是有限值，返回 NaN。
2. 如果 `abs(ℝ(time)) > 8.64 × 10**15`，返回 NaN。
3. 返回 `𝔽(! ToIntegerOrInfinity(time))`。

### 21.4.1.32 日期时间字符串格式

ECMAScript 定义了一种简化的基于 ISO 8601 日历日期扩展格式的日期时间字符串互换格式。格式如下：YYYY-MM-DDTHH:mm:ss.sssZ

其中各元素如下：

- **YYYY**：前格里高利历中的年份，表示为四位十进制数字，范围从 0000 到 9999，或者扩展年份的形式为 "+" 或 "-" 后跟六位十进制数字。
- **-**：在字符串中出现两次的连字符。
- **MM**：年份中的月份，表示为两位十进制数字，从 01（1 月）到 12（12 月）。
- **DD**：月份中的日期，表示为两位十进制数字，从 01 到 31。
- **T**：在字符串中按字面出现，用于表示时间元素的开始。
- **HH**：自午夜起的完整小时数，表示为两位十进制数字，从 00 到 24。
- **:**：在字符串中按字面出现两次的冒号。
- **mm**：自小时开始的完整分钟数，表示为两位十进制数字，从 00 到 59。
- **ss**：自分钟开始的完整秒数，表示为两位十进制数字，从 00 到 59。
- **.**：在字符串中按字面出现的点。
- **sss**：自秒开始的完整毫秒数，表示为三位十进制数字。
- **Z**：UTC 偏移表示，指定为 "Z"（表示没有偏移的 UTC）或 "+" 或 "-" 后跟时间表达式 HH:mm（时区偏移字符串格式的子集，用于表示比 UTC 提前或滞后的本地时间）。

该格式包括仅包含日期的形式：

- YYYY
- YYYY-MM
- YYYY-MM-DD

它还包括以下时间形式的“日期-时间”形式，后面可以附加可选的 UTC 偏移表示：

- THH:mm
- THH:mm:ss
- THH:mm:ss.sss

包含超出范围或不符合规范元素的字符串不是此格式的有效实例。

**注释 1：**
由于每一天都以午夜开始和结束，00:00 和 24:00 这两个符号可用于区分与同一天关联的两个午夜。这意味着以下两个符号指的是完全相同的时间点：1995-02-04T24:00 和 1995-02-05T00:00。后一种形式作为“日历日的结束”的解释与 ISO 8601 一致，尽管该规范保留其用于描述时间间隔而不允许其在单一时间点的表示中。

**注释 2：**
没有国际标准规定 CET、EST 等民用时区的缩写，有时同一个缩写甚至用于两个完全不同的时区。因此，ISO 8601 和此格式都指定时区偏移的数字表示。

### 21.4.1.32.1 扩展年份

涵盖自 1970 年 1 月 1 日起大约 273,790 年的完整时间值范围（21.4.1.1）需要表示 0 之前或 9999 之后的年份。ISO 8601 允许扩展年份表示，但仅在信息交换的合作伙伴之间的协议下。在简化的 ECMAScript 格式中，这种扩展年份表示应有 6 位数字，并且总是以 + 或 - 符号作为前缀。年份 0 被认为是正数，必须以 + 符号作为前缀。年份 0 表示为 -000000 是无效的。与扩展年份相匹配并表示超出时间值范围的时刻的字符串被视为不可识别的 `Date.parse`，并导致该函数返回 NaN，而不回退到特定实现的行为或启发式方法。

**注释：**
扩展年份的日期时间值示例：

- -271821-04-20T00:00:00Z 表示公元前 271822 年 4 月 20 日
- -000001-01-01T00:00:00Z 表示公元前 2 年 1 月 1 日
- +000000-01-01T00:00:00Z 表示公元前 1 年 1 月 1 日
- +000001-01-01T00:00:00Z 表示公元 1 年 1 月 1 日
- +001970-01-01T00:00:00Z 表示公元 1970 年 1 月 1 日
- +002009-12-15T00:00:00Z 表示公元 2009 年 12 月 15 日
- +275760-09-13T00:00:00Z 表示公元 275760 年 9 月 13 日

### 21.4.1.33 时区偏移字符串格式

ECMAScript 定义了一种用于 UTC 偏移的字符串互换格式，源自 ISO 8601。该格式通过以下语法描述。该语法中使用的 Unicode 代码点列于表 61 中。

**表 61：时区偏移字符串代码点**
| 代码点 | Unicode 名称 | 缩写 |
|--------|---------------|------|
| U+2212 | 减号符号     | <MINUS> |

**语法**
```
UTCOffset ::=
    TemporalSign Hour
    TemporalSign Hour HourSubcomponents[+Extended]
    TemporalSign Hour HourSubcomponents[~Extended]

TemporalSign ::=
    ASCIISign
    <MINUS>

ASCIISign ::= one of
    + -

Hour ::=
    0 DecimalDigit
    1 DecimalDigit
    20
    21
    22
    23

HourSubcomponents[Extended] ::=
    TimeSeparator[?Extended] MinuteSecond
    TimeSeparator[?Extended] MinuteSecond TimeSeparator[?Extended] MinuteSecond TemporalDecimalFractionopt

TimeSeparator[Extended] ::=
    [+Extended] :
    [~Extended] [empty]

MinuteSecond ::=
    0 DecimalDigit
    1 DecimalDigit
    2 DecimalDigit
    3 DecimalDigit
    4 DecimalDigit
    5 DecimalDigit

TemporalDecimalFraction ::=
    TemporalDecimalSeparator DecimalDigit
    TemporalDecimalSeparator DecimalDigit DecimalDigit
    TemporalDecimalSeparator DecimalDigit DecimalDigit DecimalDigit
    TemporalDecimalSeparator DecimalDigit DecimalDigit DecimalDigit DecimalDigit
    TemporalDecimalSeparator DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit
    TemporalDecimalSeparator DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit
    TemporalDecimalSeparator DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit
    TemporalDecimalSeparator DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit
    TemporalDecimalSeparator DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit

TemporalDecimalSeparator ::= one of
    . ,
```

### 21.4.1.33.1 IsTimeZoneOffsetString (offsetString)

抽象操作 `IsTimeZoneOffsetString` 接受参数 `offsetString`（一个字符串）并返回一个布尔值。返回值表示 `offsetString` 是否符合 `UTCOffset` 语法。调用时执行以下步骤：

1. 令 `parseResult` 为 `ParseText(offsetString, UTCOffset)`。
2. 如果 `parseResult` 是一个错误列表，返回 `false`。
3. 返回 `true`。

### 21.4.1.33.2 ParseTimeZoneOffsetString (offsetString)

抽象操作 `ParseTimeZoneOffsetString` 接受参数 `offsetString`（一个字符串）并返回一个整数。返回值是 UTC 偏移，以纳秒为单位，对应于字符串 `offsetString`。调用时执行以下步骤：

1. 令 `parseResult` 为 `ParseText(offsetString, UTCOffset)`。
2. 断言：`parseResult` 不是错误列表。
3. 断言：`parseResult` 包含一个 `TemporalSign` 解析节点。
4. 令 `parsedSign` 为 `parseResult` 中包含的 `TemporalSign` 解析节点匹配的源文本。
5. 如果 `parsedSign` 是单个代码点 U+002D（连字符）或 U+2212（减号符号），则
   a. 令 `sign` 为 -1。
6. 否则，
   a. 令 `sign` 为 1。
7. **注释：** 以下对 `StringToNumber` 的应用不会丢失精度，因为每个解析值都保证是足够短的十进制数字字符串。
8. 断言：`parseResult` 包含一个 `Hour` 解析节点。
9. 令 `parsedHours` 为 `parseResult` 中包含的 `Hour` 解析节点匹配的源文本。
10. 令 `hours` 为 ℝ(`StringToNumber(CodePointsToString(parsedHours))`)。
11. 如果 `parseResult` 不包含 `MinuteSecond` 解析节点，则
    a. 令 `minutes` 为 0

。
12. 否则，
    a. 令 `parsedMinutes` 为 `parseResult` 中包含的第一个 `MinuteSecond` 解析节点匹配的源文本。
    b. 令 `minutes` 为 ℝ(`StringToNumber(CodePointsToString(parsedMinutes))`)。
13. 如果 `parseResult` 不包含两个 `MinuteSecond` 解析节点，则
    a. 令 `seconds` 为 0。
14. 否则，
    a. 令 `parsedSeconds` 为 `parseResult` 中包含的第二个 `MinuteSecond` 解析节点匹配的源文本。
    b. 令 `seconds` 为 ℝ(`StringToNumber(CodePointsToString(parsedSeconds))`)。
15. 如果 `parseResult` 不包含 `TemporalDecimalFraction` 解析节点，则
    a. 令 `nanoseconds` 为 0。
16. 否则，
    a. 令 `parsedFraction` 为 `parseResult` 中包含的 `TemporalDecimalFraction` 解析节点匹配的源文本。
    b. 令 `fraction` 为 `CodePointsToString(parsedFraction)` 和 "000000000" 的字符串连接。
    c. 令 `nanosecondsString` 为 `fraction` 的子字符串，从第 1 位到第 10 位。
    d. 令 `nanoseconds` 为 ℝ(`StringToNumber(nanosecondsString)`)。
17. 返回 `sign` × (((`hours` × 60 + `minutes`) × 60 + `seconds`) × 10^9 + `nanoseconds`)。

### 21.4.2 Date 构造函数

Date 构造函数：

- 是 %Date%。
- 是全局对象的 "Date" 属性的初始值。
- 作为构造函数调用时，会创建并初始化一个新的 Date 对象。
- 作为函数调用时，会返回一个表示当前时间（UTC）的字符串。
- 是一个行为根据其参数数量和类型而变化的函数。
- 可以用作类定义的 `extends` 子句的值。子类构造函数如果想继承指定的 Date 行为，必须包含对 Date 构造函数的 `super` 调用，以创建并初始化具有 [[DateValue]] 内部槽的子类实例。

#### 21.4.2.1 Date ( ...values )
当调用此函数时，执行以下步骤：

1. 如果 `NewTarget` 是 `undefined`，则：
   1. 令 `now` 为标识当前时间的时间值（UTC）。
   2. 返回 `ToDateString(now)`。
2. 令 `numberOfArgs` 为 `values` 中元素的数量。
3. 如果 `numberOfArgs` 为 0，则：
   1. 令 `dv` 为标识当前时间的时间值（UTC）。
4. 否则如果 `numberOfArgs` 为 1，则：
   1. 令 `value` 为 `values[0]`。
   2. 如果 `value` 是一个对象且具有 [[DateValue]] 内部槽，则：
      1. 令 `tv` 为 `value.[[DateValue]]`。
   3. 否则：
      1. 令 `v` 为 `? ToPrimitive(value)`。
      2. 如果 `v` 是字符串，则：
         1. 断言：因为 `v` 是字符串，下一步不会返回异常完成。
         2. 令 `tv` 为按完全与 `parse` 方法（21.4.3.2）相同的方式解析 `v` 作为日期的结果。
      3. 否则：
         1. 令 `tv` 为 `? ToNumber(v)`。
   4. 令 `dv` 为 `TimeClip(tv)`。
5. 否则：
   1. 断言：`numberOfArgs ≥ 2`。
   2. 令 `y` 为 `? ToNumber(values[0])`。
   3. 令 `m` 为 `? ToNumber(values[1])`。
   4. 如果 `numberOfArgs > 2`，则令 `dt` 为 `? ToNumber(values[2])`；否则令 `dt` 为 `1𝔽`。
   5. 如果 `numberOfArgs > 3`，则令 `h` 为 `? ToNumber(values[3])`；否则令 `h` 为 `+0𝔽`。
   6. 如果 `numberOfArgs > 4`，则令 `min` 为 `? ToNumber(values[4])`；否则令 `min` 为 `+0𝔽`。
   7. 如果 `numberOfArgs > 5`，则令 `s` 为 `? ToNumber(values[5])`；否则令 `s` 为 `+0𝔽`。
   8. 如果 `numberOfArgs > 6`，则令 `milli` 为 `? ToNumber(values[6])`；否则令 `milli` 为 `+0𝔽`。
   9. 令 `yr` 为 `MakeFullYear(y)`。
   10. 令 `finalDate` 为 `MakeDate(MakeDay(yr, m, dt), MakeTime(h, min, s, milli))`。
   11. 令 `dv` 为 `TimeClip(UTC(finalDate))`。
6. 令 `O` 为 `? OrdinaryCreateFromConstructor(NewTarget, "%Date.prototype%", « [[DateValue]] »)`。
7. 将 `O.[[DateValue]]` 设置为 `dv`。
8. 返回 `O`。

### 21.4.3 Date 构造函数的属性

Date 构造函数：

- 具有一个 [[Prototype]] 内部槽，其值为 %Function.prototype%。
- 具有一个 "length" 属性，其值为 `7𝔽`。
- 具有以下属性：

#### 21.4.3.1 Date.now ( )
此函数返回调用它时标识 UTC 日期和时间的时间值。

#### 21.4.3.2 Date.parse ( string )
此函数对其参数应用 `ToString` 操作。如果 `ToString` 导致异常完成，则立即返回完成记录。否则，此函数将结果字符串解释为日期和时间；它返回一个数值，对应于日期和时间的 UTC 时间值。字符串可以被解释为本地时间、UTC 时间或其他时区的时间，具体取决于字符串的内容。函数首先尝试根据日期时间字符串格式（21.4.1.32）描述的格式解析字符串，包括扩展年份。如果字符串不符合该格式，函数可以回退到任何特定实现的启发式方法或特定实现的日期格式。无法识别的字符串或包含超出范围的格式元素值的字符串应导致此函数返回 NaN。

如果字符串符合日期时间字符串格式，则替代值将代替缺失的格式元素。当 MM 或 DD 元素缺失时，使用 "01"。当 HH、mm 或 ss 元素缺失时，使用 "00"。当 sss 元素缺失时，使用 "000"。当 UTC 偏移表示缺失时，仅包含日期的形式将被解释为 UTC 时间，日期时间形式将被解释为本地时间。

如果 `x` 是任何在特定 ECMAScript 实现中毫秒数为零的 Date，则以下所有表达式在该实现中应产生相同的数值，如果所有引用的属性都具有其初始值：

- `x.valueOf()`
- `Date.parse(x.toString())`
- `Date.parse(x.toUTCString())`
- `Date.parse(x.toISOString())`

然而，表达式 `Date.parse(x.toLocaleString())` 不要求产生与前面三个表达式相同的数值，并且通常，当给定任何不符合日期时间字符串格式（21.4.1.32）的字符串值时，该函数返回的值是实现定义的，这些值在该实现中不能由 `toString` 或 `toUTCString` 方法生成。

#### 21.4.3.3 Date.prototype
`Date.prototype` 的初始值是 Date 原型对象。

此属性具有 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } 属性。

#### 21.4.3.4 Date.UTC ( year [ , month [ , date [ , hours [ , minutes [ , seconds [ , ms ] ] ] ] ] ] )
此函数在调用时执行以下步骤：

1. 令 `y` 为 `? ToNumber(year)`。
2. 如果提供了 `month`，则令 `m` 为 `? ToNumber(month)`；否则令 `m` 为 `+0𝔽`。
3. 如果提供了 `date`，则令 `dt` 为 `? ToNumber(date)`；否则令 `dt` 为 `1𝔽`。
4. 如果提供了 `hours`，则令 `h` 为 `? ToNumber(hours)`；否则令 `h` 为 `+0𝔽`。
5. 如果提供了 `minutes`，则令 `min` 为 `? ToNumber(minutes)`；否则令 `min` 为 `+0𝔽`。
6. 如果提供了 `seconds`，则令 `s` 为 `? ToNumber(seconds)`；否则令 `s` 为 `+0𝔽`。
7. 如果提供了 `ms`，则令 `milli` 为 `? ToNumber(ms)`；否则令 `milli` 为 `+0𝔽`。
8. 令 `yr` 为 `MakeFullYear(y)`。
9. 返回 `TimeClip(MakeDate(MakeDay(yr, m, dt), MakeTime(h, min, s, milli)))`。

此函数的 "length" 属性为 `7𝔽`。

**注意：**
此函数与 Date 构造函数有两个不同之处：它返回一个表示时间值的数值，而不是创建一个 Date 对象，并且它以 UTC 解释参数，而不是以本地时间解释参数。

### 21.4.4 Date 原型对象的属性

Date 原型对象：

- 是 %Date.prototype%。
- 本身是一个普通对象。
- 不是 Date 实例，没有 [[DateValue]] 内部槽。
- 具有一个 [[Prototype]] 内部槽，其值为 %Object.prototype%。

除非明确定义，否则下面定义的 Date 原型对象的方法不是泛型的，传递给它们的 `this` 值必须是一个具有已初始化为时间值的 [[DateValue]] 内部槽的对象。

#### 21.4.4.1 Date.prototype.constructor
`Date.prototype.constructor` 的初始值是 %Date%。

#### 21.4.4.2 Date.prototype.getDate ( )
此方法在调用时执行以下步骤：

1. 令 `dateObject` 为 `this`

 值。
2. 执行 `? RequireInternalSlot(dateObject, [[DateValue]])`。
3. 令 `t` 为 `dateObject.[[DateValue]]`。
4. 如果 `t` 是 NaN，则返回 NaN。
5. 返回 `DateFromTime(LocalTime(t))`。

#### 21.4.4.3 Date.prototype.getDay ( )
此方法在调用时执行以下步骤：

1. 令 `dateObject` 为 `this` 值。
2. 执行 `? RequireInternalSlot(dateObject, [[DateValue]])`。
3. 令 `t` 为 `dateObject.[[DateValue]]`。
4. 如果 `t` 是 NaN，则返回 NaN。
5. 返回 `WeekDay(LocalTime(t))`。

#### 21.4.4.4 Date.prototype.getFullYear ( )
此方法在调用时执行以下步骤：

1. 令 `dateObject` 为 `this` 值。
2. 执行 `? RequireInternalSlot(dateObject, [[DateValue]])`。
3. 令 `t` 为 `dateObject.[[DateValue]]`。
4. 如果 `t` 是 NaN，则返回 NaN。
5. 返回 `YearFromTime(LocalTime(t))`。

#### 21.4.4.5 Date.prototype.getHours ( )
此方法在调用时执行以下步骤：

1. 令 `dateObject` 为 `this` 值。
2. 执行 `? RequireInternalSlot(dateObject, [[DateValue]])`。
3. 令 `t` 为 `dateObject.[[DateValue]]`。
4. 如果 `t` 是 NaN，则返回 NaN。
5. 返回 `HourFromTime(LocalTime(t))`。

#### 21.4.4.6 Date.prototype.getMilliseconds ( )
此方法在调用时执行以下步骤：

1. 令 `dateObject` 为 `this` 值。
2. 执行 `? RequireInternalSlot(dateObject, [[DateValue]])`。
3. 令 `t` 为 `dateObject.[[DateValue]]`。
4. 如果 `t` 是 NaN，则返回 NaN。
5. 返回 `msFromTime(LocalTime(t))`。

#### 21.4.4.7 Date.prototype.getMinutes ( )
此方法在调用时执行以下步骤：

1. 令 `dateObject` 为 `this` 值。
2. 执行 `? RequireInternalSlot(dateObject, [[DateValue]])`。
3. 令 `t` 为 `dateObject.[[DateValue]]`。
4. 如果 `t` 是 NaN，则返回 NaN。
5. 返回 `MinFromTime(LocalTime(t))`。

#### 21.4.4.8 Date.prototype.getMonth ( )
此方法在调用时执行以下步骤：

1. 令 `dateObject` 为 `this` 值。
2. 执行 `? RequireInternalSlot(dateObject, [[DateValue]])`。
3. 令 `t` 为 `dateObject.[[DateValue]]`。
4. 如果 `t` 是 NaN，则返回 NaN。
5. 返回 `MonthFromTime(LocalTime(t))`。

#### 21.4.4.9 Date.prototype.getSeconds ( )
此方法在调用时执行以下步骤：

1. 令 `dateObject` 为 `this` 值。
2. 执行 `? RequireInternalSlot(dateObject, [[DateValue]])`。
3. 令 `t` 为 `dateObject.[[DateValue]]`。
4. 如果 `t` 是 NaN，则返回 NaN。
5. 返回 `SecFromTime(LocalTime(t))`。

#### 21.4.4.10 Date.prototype.getTime ( )
此方法在调用时执行以下步骤：

1. 令 `dateObject` 为 `this` 值。
2. 执行 `? RequireInternalSlot(dateObject, [[DateValue]])`。
3. 返回 `dateObject.[[DateValue]]`。

#### 21.4.4.11 Date.prototype.getTimezoneOffset ( )
此方法在调用时执行以下步骤：

1. 令 `dateObject` 为 `this` 值。
2. 执行 `? RequireInternalSlot(dateObject, [[DateValue]])`。
3. 令 `t` 为 `dateObject.[[DateValue]]`。
4. 如果 `t` 是 NaN，则返回 NaN。
5. 返回 `(t - LocalTime(t)) / msPerMinute`。

#### 21.4.4.12 Date.prototype.getUTCDate ( )
此方法在调用时执行以下步骤：

1. 令 `dateObject` 为 `this` 值。
2. 执行 `? RequireInternalSlot(dateObject, [[DateValue]])`。
3. 令 `t` 为 `dateObject.[[DateValue]]`。
4. 如果 `t` 是 NaN，则返回 NaN。
5. 返回 `DateFromTime(t)`。

#### 21.4.4.13 Date.prototype.getUTCDay ( )
此方法在调用时执行以下步骤：

1. 令 `dateObject` 为 `this` 值。
2. 执行 `? RequireInternalSlot(dateObject, [[DateValue]])`。
3. 令 `t` 为 `dateObject.[[DateValue]]`。
4. 如果 `t` 是 NaN，则返回 NaN。
5. 返回 `WeekDay(t)`。

#### 21.4.4.14 Date.prototype.getUTCFullYear ( )
此方法在调用时执行以下步骤：

1. 令 `dateObject` 为 `this` 值。
2. 执行 `? RequireInternalSlot(dateObject, [[DateValue]])`。
3. 令 `t` 为 `dateObject.[[DateValue]]`。
4. 如果 `t` 是 NaN，则返回 NaN。
5. 返回 `YearFromTime(t)`。

#### 21.4.4.15 Date.prototype.getUTCHours ( )
此方法在调用时执行以下步骤：

1. 令 `dateObject` 为 `this` 值。
2. 执行 `? RequireInternalSlot(dateObject, [[DateValue]])`。
3. 令 `t` 为 `dateObject.[[DateValue]]`。
4. 如果 `t` 是 NaN，则返回 NaN。
5. 返回 `HourFromTime(t)`。

#### 21.4.4.16 Date.prototype.getUTCMilliseconds ( )
此方法在调用时执行以下步骤：

1. 令 `dateObject` 为 `this` 值。
2. 执行 `? RequireInternalSlot(dateObject, [[DateValue]])`。
3. 令 `t` 为 `dateObject.[[DateValue]]`。
4. 如果 `t` 是 NaN，则返回 NaN。
5. 返回 `msFromTime(t)`。

#### 21.4.4.17 Date.prototype.getUTCMinutes ( )
此方法在调用时执行以下步骤：

1. 令 `dateObject` 为 `this` 值。
2. 执行 `? RequireInternalSlot(dateObject, [[DateValue]])`。
3. 令 `t` 为 `dateObject.[[DateValue]]`。
4. 如果 `t` 是 NaN，则返回 NaN。
5. 返回 `MinFromTime(t)`。

#### 21.4.4.18 Date.prototype.getUTCMonth ( )
此方法在调用时执行以下步骤：

1. 令 `dateObject` 为 `this` 值。
2. 执行 `? RequireInternalSlot(dateObject, [[DateValue]])`。
3. 令 `t` 为 `dateObject.[[DateValue]]`。
4. 如果 `t` 是 NaN，则返回 NaN。
5. 返回 `MonthFromTime(t)`。

#### 21.4.4.19 Date.prototype.getUTCSeconds ( )
此方法在调用时执行以下步骤：

1. 令 `dateObject` 为 `this` 值。
2. 执行 `? RequireInternalSlot(dateObject, [[DateValue]])`。
3. 令 `t` 为 `dateObject.[[DateValue]]`。
4. 如果 `t` 是 NaN，则返回 NaN。
5. 返回 `SecFromTime(t)`。

#### 21.4.4.20 Date.prototype.setDate ( date )
此方法在调用时执行以下步骤：

1. 令 `dateObject` 为 `this` 值。
2. 执行 `? RequireInternalSlot(dateObject, [[DateValue]])`。
3. 令 `t` 为 `dateObject.[[DateValue]]`。
4. 令 `dt` 为 `? ToNumber(date)`。
5. 如果 `t` 是 NaN，则返回 NaN。
6. 将 `t` 设置为 `LocalTime(t)`。
7. 令 `newDate` 为 `MakeDate(MakeDay(YearFromTime(t), MonthFromTime(t), dt), TimeWithinDay(t))`。
8. 令 `u` 为 `TimeClip(UTC(newDate))`。
9. 将 `dateObject.[[DateValue]]` 设置为 `u`。
10. 返回 `u`。

#### 21.4.4.21 Date.prototype.setFullYear ( year [ , month [ , date ] ] )
此方法在调用时执行以下步骤：

1. 令 `dateObject` 为 `this` 值。
2. 执行 `? RequireInternalSlot(dateObject, [[DateValue]])`。
3. 令 `

t` 为 `dateObject.[[DateValue]]`。
4. 令 `y` 为 `? ToNumber(year)`。
5. 如果 `t` 是 NaN，则将 `t` 设置为 `+0𝔽`；否则，将 `t` 设置为 `LocalTime(t)`。
6. 如果 `month` 未提供，则令 `m` 为 `MonthFromTime(t)`；否则，令 `m` 为 `? ToNumber(month)`。
7. 如果 `date` 未提供，则令 `dt` 为 `DateFromTime(t)`；否则，令 `dt` 为 `? ToNumber(date)`。
8. 令 `newDate` 为 `MakeDate(MakeDay(y, m, dt), TimeWithinDay(t))`。
9. 令 `u` 为 `TimeClip(UTC(newDate))`。
10. 将 `dateObject.[[DateValue]]` 设置为 `u`。
11. 返回 `u`。

此方法的 "length" 属性为 `3𝔽`。

**注意：**
如果 `month` 未提供，此方法的行为如同 `month` 提供了 `getMonth()` 的值。如果 `date` 未提供，其行为如同 `date` 提供了 `getDate()` 的值。

#### 21.4.4.22 Date.prototype.setHours ( hour [ , min [ , sec [ , ms ] ] ] )
此方法在调用时执行以下步骤：

1. 令 `dateObject` 为 `this` 值。
2. 执行 `? RequireInternalSlot(dateObject, [[DateValue]])`。
3. 令 `t` 为 `dateObject.[[DateValue]]`。
4. 令 `h` 为 `? ToNumber(hour)`。
5. 如果 `min` 提供了，则令 `m` 为 `? ToNumber(min)`。
6. 如果 `sec` 提供了，则令 `s` 为 `? ToNumber(sec)`。
7. 如果 `ms` 提供了，则令 `milli` 为 `? ToNumber(ms)`。
8. 如果 `t` 是 NaN，则返回 NaN。
9. 将 `t` 设置为 `LocalTime(t)`。
10. 如果 `min` 未提供，则令 `m` 为 `MinFromTime(t)`。
11. 如果 `sec` 未提供，则令 `s` 为 `SecFromTime(t)`。
12. 如果 `ms` 未提供，则令 `milli` 为 `msFromTime(t)`。
13. 令 `date` 为 `MakeDate(Day(t), MakeTime(h, m, s, milli))`。
14. 令 `u` 为 `TimeClip(UTC(date))`。
15. 将 `dateObject.[[DateValue]]` 设置为 `u`。
16. 返回 `u`。

此方法的 "length" 属性为 `4𝔽`。

**注意：**
如果 `min` 未提供，此方法的行为如同 `min` 提供了 `getMinutes()` 的值。如果 `sec` 未提供，其行为如同 `sec` 提供了 `getSeconds()` 的值。如果 `ms` 未提供，其行为如同 `ms` 提供了 `getMilliseconds()` 的值。

#### 21.4.4.23 Date.prototype.setMilliseconds ( ms )
此方法在调用时执行以下步骤：

1. 令 `dateObject` 为 `this` 值。
2. 执行 `? RequireInternalSlot(dateObject, [[DateValue]])`。
3. 令 `t` 为 `dateObject.[[DateValue]]`。
4. 将 `ms` 设置为 `? ToNumber(ms)`。
5. 如果 `t` 是 NaN，则返回 NaN。
6. 将 `t` 设置为 `LocalTime(t)`。
7. 令 `time` 为 `MakeTime(HourFromTime(t), MinFromTime(t), SecFromTime(t), ms)`。
8. 令 `u` 为 `TimeClip(UTC(MakeDate(Day(t), time)))`。
9. 将 `dateObject.[[DateValue]]` 设置为 `u`。
10. 返回 `u`。

#### 21.4.4.24 Date.prototype.setMinutes ( min [ , sec [ , ms ] ] )
此方法在调用时执行以下步骤：

1. 令 `dateObject` 为 `this` 值。
2. 执行 `? RequireInternalSlot(dateObject, [[DateValue]])`。
3. 令 `t` 为 `dateObject.[[DateValue]]`。
4. 令 `m` 为 `? ToNumber(min)`。
5. 如果 `sec` 提供了，则令 `s` 为 `? ToNumber(sec)`。
6. 如果 `ms` 提供了，则令 `milli` 为 `? ToNumber(ms)`。
7. 如果 `t` 是 NaN，则返回 NaN。
8. 将 `t` 设置为 `LocalTime(t)`。
9. 如果 `sec` 未提供，则令 `s` 为 `SecFromTime(t)`。
10. 如果 `ms` 未提供，则令 `milli` 为 `msFromTime(t)`。
11. 令 `date` 为 `MakeDate(Day(t), MakeTime(HourFromTime(t), m, s, milli))`。
12. 令 `u` 为 `TimeClip(UTC(date))`。
13. 将 `dateObject.[[DateValue]]` 设置为 `u`。
14. 返回 `u`。

此方法的 "length" 属性为 `3𝔽`。

**注意：**
如果 `sec` 未提供，此方法的行为如同 `sec` 提供了 `getSeconds()` 的值。如果 `ms` 未提供，其行为如同 `ms` 提供了 `getMilliseconds()` 的值。

#### 21.4.4.25 Date.prototype.setMonth ( month [ , date ] )
此方法在调用时执行以下步骤：

1. 令 `dateObject` 为 `this` 值。
2. 执行 `? RequireInternalSlot(dateObject, [[DateValue]])`。
3. 令 `t` 为 `dateObject.[[DateValue]]`。
4. 令 `m` 为 `? ToNumber(month)`。
5. 如果 `date` 提供了，则令 `dt` 为 `? ToNumber(date)`。
6. 如果 `t` 是 NaN，则返回 NaN。
7. 将 `t` 设置为 `LocalTime(t)`。
8. 如果 `date` 未提供，则令 `dt` 为 `DateFromTime(t)`。
9. 令 `newDate` 为 `MakeDate(MakeDay(YearFromTime(t), m, dt), TimeWithinDay(t))`。
10. 令 `u` 为 `TimeClip(UTC(newDate))`。
11. 将 `dateObject.[[DateValue]]` 设置为 `u`。
12. 返回 `u`。

此方法的 "length" 属性为 `2𝔽`。

**注意：**
如果 `date` 未提供，此方法的行为如同 `date` 提供了 `getDate()` 的值。

#### 21.4.4.26 Date.prototype.setSeconds ( sec [ , ms ] )
此方法在调用时执行以下步骤：

1. 令 `dateObject` 为 `this` 值。
2. 执行 `? RequireInternalSlot(dateObject, [[DateValue]])`。
3. 令 `t` 为 `dateObject.[[DateValue]]`。
4. 令 `s` 为 `? ToNumber(sec)`。
5. 如果 `ms` 提供了，则令 `milli` 为 `? ToNumber(ms)`。
6. 如果 `t` 是 NaN，则返回 NaN。
7. 将 `t` 设置为 `LocalTime(t)`。
8. 如果 `ms` 未提供，则令 `milli` 为 `msFromTime(t)`。
9. 令 `date` 为 `MakeDate(Day(t), MakeTime(HourFromTime(t), MinFromTime(t), s, milli))`。
10. 令 `u` 为 `TimeClip(UTC(date))`。
11. 将 `dateObject.[[DateValue]]` 设置为 `u`。
12. 返回 `u`。

此方法的 "length" 属性为 `2𝔽`。

**注意：**
如果 `ms` 未提供，此方法的行为如同 `ms` 提供了 `getMilliseconds()` 的值。

#### 21.4.4.27 Date.prototype.setTime ( time )
此方法在调用时执行以下步骤：

1. 令 `dateObject` 为 `this` 值。
2. 执行 `? RequireInternalSlot(dateObject, [[DateValue]])`。
3. 令 `t` 为 `? ToNumber(time)`。
4. 令 `v` 为 `TimeClip(t)`。
5. 将 `dateObject.[[DateValue]]` 设置为 `v`。
6. 返回 `v`。

#### 21.4.4.28 Date.prototype.setUTCDate ( date )
此方法在调用时执行以下步骤：

1. 令 `dateObject` 为 `this` 值。
2. 执行 `? RequireInternalSlot(dateObject, [[DateValue]])`。
3. 令 `t` 为 `dateObject.[[DateValue]]`。
4. 令 `dt` 为 `? ToNumber(date)`。
5. 如果 `t` 是 NaN，则返回 NaN。
6. 令 `newDate

` 为 `MakeDate(MakeDay(YearFromTime(t), MonthFromTime(t), dt), TimeWithinDay(t))`。
7. 令 `v` 为 `TimeClip(newDate)`。
8. 将 `dateObject.[[DateValue]]` 设置为 `v`。
9. 返回 `v`。

#### 21.4.4.29 Date.prototype.setUTCFullYear ( year [ , month [ , date ] ] )
此方法在调用时执行以下步骤：

1. 令 `dateObject` 为 `this` 值。
2. 执行 `? RequireInternalSlot(dateObject, [[DateValue]])`。
3. 令 `t` 为 `dateObject.[[DateValue]]`。
4. 如果 `t` 是 NaN，则将 `t` 设置为 `+0𝔽`。
5. 令 `y` 为 `? ToNumber(year)`。
6. 如果 `month` 未提供，则令 `m` 为 `MonthFromTime(t)`；否则，令 `m` 为 `? ToNumber(month)`。
7. 如果 `date` 未提供，则令 `dt` 为 `DateFromTime(t)`；否则，令 `dt` 为 `? ToNumber(date)`。
8. 令 `newDate` 为 `MakeDate(MakeDay(y, m, dt), TimeWithinDay(t))`。
9. 令 `v` 为 `TimeClip(newDate)`。
10. 将 `dateObject.[[DateValue]]` 设置为 `v`。
11. 返回 `v`。

此方法的 "length" 属性为 `3𝔽`。

**注意：**
如果 `month` 未提供，此方法的行为如同 `month` 提供了 `getUTCMonth()` 的值。如果 `date` 未提供，其行为如同 `date` 提供了 `getUTCDate()` 的值。

#### 21.4.4.30 Date.prototype.setUTCHours ( hour [ , min [ , sec [ , ms ] ] ] )
此方法在调用时执行以下步骤：

1. 令 `dateObject` 为 `this` 值。
2. 执行 `? RequireInternalSlot(dateObject, [[DateValue]])`。
3. 令 `t` 为 `dateObject.[[DateValue]]`。
4. 令 `h` 为 `? ToNumber(hour)`。
5. 如果 `min` 提供了，则令 `m` 为 `? ToNumber(min)`。
6. 如果 `sec` 提供了，则令 `s` 为 `? ToNumber(sec)`。
7. 如果 `ms` 提供了，则令 `milli` 为 `? ToNumber(ms)`。
8. 如果 `t` 是 NaN，则返回 NaN。
9. 如果 `min` 未提供，则令 `m` 为 `MinFromTime(t)`。
10. 如果 `sec` 未提供，则令 `s` 为 `SecFromTime(t)`。
11. 如果 `ms` 未提供，则令 `milli` 为 `msFromTime(t)`。
12. 令 `date` 为 `MakeDate(Day(t), MakeTime(h, m, s, milli))`。
13. 令 `v` 为 `TimeClip(date)`。
14. 将 `dateObject.[[DateValue]]` 设置为 `v`。
15. 返回 `v`。

此方法的 "length" 属性为 `4𝔽`。

**注意：**
如果 `min` 未提供，此方法的行为如同 `min` 提供了 `getUTCMinutes()` 的值。如果 `sec` 未提供，其行为如同 `sec` 提供了 `getUTCSeconds()` 的值。如果 `ms` 未提供，其行为如同 `ms` 提供了 `getUTCMilliseconds()` 的值。

#### 21.4.4.31 Date.prototype.setUTCMilliseconds ( ms )
此方法在调用时执行以下步骤：

1. 令 `dateObject` 为 `this` 值。
2. 执行 `? RequireInternalSlot(dateObject, [[DateValue]])`。
3. 令 `t` 为 `dateObject.[[DateValue]]`。
4. 将 `ms` 设置为 `? ToNumber(ms)`。
5. 如果 `t` 是 NaN，则返回 NaN。
6. 令 `time` 为 `MakeTime(HourFromTime(t), MinFromTime(t), SecFromTime(t), ms)`。
7. 令 `v` 为 `TimeClip(MakeDate(Day(t), time))`。
8. 将 `dateObject.[[DateValue]]` 设置为 `v`。
9. 返回 `v`。

### 21.4.4.32 Date.prototype.setUTCMinutes ( min [ , sec [ , ms ] ] )
当调用此方法时，执行以下步骤：

1. 令 `dateObject` 为 `this` 值。
2. 执行 `? RequireInternalSlot(dateObject, [[DateValue]])`。
3. 令 `t` 为 `dateObject.[[DateValue]]`。
4. 令 `m` 为 `? ToNumber(min)`。
5. 如果 `sec` 存在，令 `s` 为 `? ToNumber(sec)`。
6. 如果 `ms` 存在，令 `milli` 为 `? ToNumber(ms)`。
7. 如果 `t` 是 NaN，则返回 NaN。
8. 如果 `sec` 不存在，令 `s` 为 `SecFromTime(t)`。
9. 如果 `ms` 不存在，令 `milli` 为 `msFromTime(t)`。
10. 令 `date` 为 `MakeDate(Day(t), MakeTime(HourFromTime(t), m, s, milli))`。
11. 令 `v` 为 `TimeClip(date)`。
12. 将 `dateObject.[[DateValue]]` 设置为 `v`。
13. 返回 `v`。

此方法的 "length" 属性为 `3𝔽`。

**注意：**
如果 `sec` 不存在，此方法的行为如同 `sec` 存在并具有 `getUTCSeconds()` 的值。如果 `ms` 不存在，此方法的行为如同 `ms` 存在并具有 `getUTCMilliseconds()` 的值。

### 21.4.4.33 Date.prototype.setUTCMonth ( month [ , date ] )
当调用此方法时，执行以下步骤：

1. 令 `dateObject` 为 `this` 值。
2. 执行 `? RequireInternalSlot(dateObject, [[DateValue]])`。
3. 令 `t` 为 `dateObject.[[DateValue]]`。
4. 令 `m` 为 `? ToNumber(month)`。
5. 如果 `date` 存在，令 `dt` 为 `? ToNumber(date)`。
6. 如果 `t` 是 NaN，则返回 NaN。
7. 如果 `date` 不存在，令 `dt` 为 `DateFromTime(t)`。
8. 令 `newDate` 为 `MakeDate(MakeDay(YearFromTime(t), m, dt), TimeWithinDay(t))`。
9. 令 `v` 为 `TimeClip(newDate)`。
10. 将 `dateObject.[[DateValue]]` 设置为 `v`。
11. 返回 `v`。

此方法的 "length" 属性为 `2𝔽`。

**注意：**
如果 `date` 不存在，此方法的行为如同 `date` 存在并具有 `getUTCDate()` 的值。

### 21.4.4.34 Date.prototype.setUTCSeconds ( sec [ , ms ] )
当调用此方法时，执行以下步骤：

1. 令 `dateObject` 为 `this` 值。
2. 执行 `? RequireInternalSlot(dateObject, [[DateValue]])`。
3. 令 `t` 为 `dateObject.[[DateValue]]`。
4. 令 `s` 为 `? ToNumber(sec)`。
5. 如果 `ms` 存在，令 `milli` 为 `? ToNumber(ms)`。
6. 如果 `t` 是 NaN，则返回 NaN。
7. 如果 `ms` 不存在，令 `milli` 为 `msFromTime(t)`。
8. 令 `date` 为 `MakeDate(Day(t), MakeTime(HourFromTime(t), MinFromTime(t), s, milli))`。
9. 令 `v` 为 `TimeClip(date)`。
10. 将 `dateObject.[[DateValue]]` 设置为 `v`。
11. 返回 `v`。

此方法的 "length" 属性为 `2𝔽`。

**注意：**
如果 `ms` 不存在，此方法的行为如同 `ms` 存在并具有 `getUTCMilliseconds()` 的值。

### 21.4.4.35 Date.prototype.toDateString ( )
当调用此方法时，执行以下步骤：

1. 令 `dateObject` 为 `this` 值。
2. 执行 `? RequireInternalSlot(dateObject, [[DateValue]])`。
3. 令 `tv` 为 `dateObject.[[DateValue]]`。
4. 如果 `tv` 是 NaN，则返回 "Invalid Date"。
5. 令 `t` 为 `LocalTime(tv)`。
6. 返回 `DateString(t)`。

### 21.4.4.36 Date.prototype.toISOString ( )
当调用此方法时，执行以下步骤：

1. 令 `dateObject` 为 `this` 值。
2. 执行 `? RequireInternalSlot(dateObject, [[DateValue]])`。
3. 令 `tv` 为 `dateObject.[[DateValue]]`。
4. 如果 `tv` 是 NaN，则抛出 `RangeError` 异常。
5. 断言：`tv` 是一个整数。
6. 如果 `tv` 对应的年份无法在日期时间字符串格式中表示，则抛出 `RangeError` 异常。
7. 返回在 UTC 时间尺度上 `tv` 的日期时间字符串格式的字符串表示，包括所有格式元素和 UTC 偏移表示 "Z"。

### 21.4.4.37 Date.prototype.toJSON ( key )
此方法提供 Date 的字符串表示，用于 `JSON.stringify` (25.5.2)。

当调用此方法时，执行以下步骤：

1. 令 `O` 为 `? ToObject(this 值)`。
2. 令 `tv` 为 `? ToPrimitive(O, NUMBER)`。
3. 如果 `tv` 是一个数值且 `tv` 不是有限的，则返回 `null`。
4. 返回 `? Invoke(O, "toISOString")`。

**注意 1**
该参数被忽略。

**注意 2**
此方法有意被设计为通用的；它不要求其 `this` 值是 Date。因此，它可以被转移到其他类型的对象上作为方法使用。然而，它确实要求任何这样的对象具有 `toISOString` 方法。

### 21.4.4.38 Date.prototype.toLocaleDateString ( [ reserved1 [ , reserved2 ] ] )
包含 ECMA-402 国际化 API 的 ECMAScript 实现必须按 ECMA-402 规范指定实现此方法。如果 ECMAScript 实现不包含 ECMA-402 API，则使用以下规范：

此方法返回一个字符串值。字符串的内容是实现定义的，但旨在表示当前时区中 Date 的“日期”部分，以便捷的人类可读形式对应于主机环境的当前区域设置的约定。

此方法的可选参数的含义在 ECMA-402 规范中定义；不包含 ECMA-402 支持的实现不得在这些参数位置使用其他内容。

### 21.4.4.39 Date.prototype.toLocaleString ( [ reserved1 [ , reserved2 ] ] )
包含 ECMA-402 国际化 API 的 ECMAScript 实现必须按 ECMA-402 规范指定实现此方法。如果 ECMAScript 实现不包含 ECMA-402 API，则使用以下规范：

此方法返回一个字符串值。字符串的内容是实现定义的，但旨在表示当前时区中 Date 的便捷、人类可读形式对应于主机环境的当前区域设置的约定。

此方法的可选参数的含义在 ECMA-402 规范中定义；不包含 ECMA-402 支持的实现不得在这些参数位置使用其他内容。

### 21.4.4.40 Date.prototype.toLocaleTimeString ( [ reserved1 [ , reserved2 ] ] )
包含 ECMA-402 国际化 API 的 ECMAScript 实现必须按 ECMA-402 规范指定实现此方法。如果 ECMAScript 实现不包含 ECMA-402 API，则使用以下规范：

此方法返回一个字符串值。字符串的内容是实现定义的，但旨在表示当前时区中 Date 的“时间”部分，以便捷的人类可读形式对应于主机环境的当前区域设置的约定。

此方法的可选参数的含义在 ECMA-402 规范中定义；不包含 ECMA-402 支持的实现不得在这些参数位置使用其他内容。

### 21.4.4.41 Date.prototype.toString ( )
当调用此方法时，执行以下步骤：

1. 令 `dateObject` 为 `this` 值。
2. 执行 `? RequireInternalSlot(dateObject, [[DateValue]])`。
3. 令 `tv` 为 `dateObject.[[DateValue]]`。
4. 返回 `ToDateString(tv)`。

**注意 1**
对于任何 `[[DateValue]]` 恰好能被 1000 整除的 Date `d`，`Date.parse(d.toString())` 的结果应等于 `d.valueOf()`。参见 21.4.3.2。

**注意 2**
此方法不是通用的；如果其 `this` 值不是 Date，则抛出 TypeError 异常。因此，它不能被转移到其他类型的对象上作为方法使用。

### 21.4.4.41.1 TimeString ( tv )

抽象操作 `TimeString` 接受参数 `tv`（一个数值，但不是 NaN），并返回一个字符串。当调用时，执行以下步骤：

1. 令 `hour` 为 `ToZeroPaddedDecimalString(ℝ(HourFromTime(tv)), 2)`。
2. 令 `minute` 为 `ToZeroPaddedDecimalString(ℝ(MinFromTime(tv)), 2)`。
3. 令 `second` 为 `ToZeroPaddedDecimalString(ℝ(SecFromTime(tv)), 2)`。
4. 返回 `hour`、":"、`minute`、":"、`second`、代码单元 0x0020 (空格)，和 "GMT" 的字符串连接。

### 21.4.4.41.2 DateString ( tv )

抽象操作 `DateString` 接受参数 `tv`（一个数值，但不是 NaN），并返回一个字符串。当调用时，执行以下步骤：

1. 令 `weekday` 为表 62 中与数字 `WeekDay(tv)` 对应的条目的名称。
2. 令 `month` 为表 63 中与数字 `MonthFromTime(tv)` 对应的条目的名称。
3. 令 `day` 为 `ToZeroPaddedDecimalString(ℝ(DateFromTime(tv)), 2)`。
4. 令 `yv` 为 `YearFromTime(tv)`。
5. 如果 `yv` 为 +0𝔽 或者 `yv` 大于 +0𝔽，令 `yearSign` 为空字符串；否则，令 `yearSign` 为 "-"。
6. 令 `paddedYear` 为 `ToZeroPaddedDecimalString(abs(ℝ(yv)), 4)`。
7. 返回 `weekday`、代码单元 0x0020 (空格)、`month`、代码单元 0x0020 (空格)、`day`、代码单元 0x0020 (空格)、`yearSign` 和 `paddedYear` 的字符串连接。

表 62：星期几的名称
| 数字 | 名称 |
| ---- | ---- |
| +0𝔽 | "Sun" |
| 1𝔽  | "Mon" |
| 2𝔽  | "Tue" |
| 3𝔽  | "Wed" |
| 4𝔽  | "Thu" |
| 5𝔽  | "Fri" |
| 6𝔽  | "Sat" |

表 63：月份的名称
| 数字 | 名称 |
| ---- | ---- |
| +0𝔽 | "Jan" |
| 1𝔽  | "Feb" |
| 2𝔽  | "Mar" |
| 3𝔽  | "Apr" |
| 4𝔽  | "May" |
| 5𝔽  | "Jun" |
| 6𝔽  | "Jul" |
| 7𝔽  | "Aug" |
| 8𝔽  | "Sep" |
| 9𝔽  | "Oct" |
| 10𝔽 | "Nov" |
| 11𝔽 | "Dec" |

### 21.4.4.41.3 TimeZoneString ( tv )

抽象操作 `TimeZoneString` 接受参数 `tv`（一个整数数值），并返回一个字符串。当调用时，执行以下步骤：

1. 令 `systemTimeZoneIdentifier` 为 `SystemTimeZoneIdentifier()`。
2. 如果 `IsTimeZoneOffsetString(systemTimeZoneIdentifier)` 为真，则：
   1. 令 `offsetNs` 为 `ParseTimeZoneOffsetString(systemTimeZoneIdentifier)`。
3. 否则：
   1. 令 `offsetNs` 为 `GetNamedTimeZoneOffsetNanoseconds(systemTimeZoneIdentifier, ℤ(ℝ(tv) × 10**6))`。
4. 令 `offset` 为 `𝔽(truncate(offsetNs / 10**6))`。
5. 如果 `offset` 为 +0𝔽 或者 `offset` 大于 +0𝔽，则：
   1. 令 `offsetSign` 为 "+"。
   2. 令 `absOffset` 为 `offset`。
6. 否则：
   1. 令 `offsetSign` 为 "-"。
   2. 令 `absOffset` 为 `-offset`。
7. 令 `offsetMin` 为 `ToZeroPaddedDecimalString(ℝ(MinFromTime(absOffset)), 2)`。
8. 令 `offsetHour` 为 `ToZeroPaddedDecimalString(ℝ(HourFromTime(absOffset)), 2)`。
9. 令 `tzName` 为一个实现定义的字符串，该字符串可以是空字符串，也可以是代码单元 0x0020 (空格)、代码单元 0x0028 (左括号)、实现定义的时区名称和代码单元 0x0029 (右括号) 的字符串连接。
10. 返回 `offsetSign`、`offsetHour`、`offsetMin` 和 `tzName` 的字符串连接。

### 21.4.4.41.4 ToDateString ( tv )

抽象操作 `ToDateString` 接受参数 `tv`（一个整数数值或 NaN），并返回一个字符串。当调用时，执行以下步骤：

1. 如果 `tv` 是 NaN，则返回 "Invalid Date"。
2. 令 `t` 为 `LocalTime(tv)`。
3. 返回 `DateString(t)`、代码单元 0x0020 (空格)、`TimeString(t)` 和 `TimeZoneString(tv)` 的字符串连接。

### 21.4.4.42 Date.prototype.toTimeString ( )

当调用此方法时，执行以下步骤：

1. 令 `dateObject` 为 `this` 值。
2. 执行 `? RequireInternalSlot(dateObject, [[DateValue]])`。
3. 令 `tv` 为 `dateObject.[[DateValue]]`。
4. 如果 `tv` 是 NaN，则返回 "Invalid Date"。
5. 令 `t` 为 `LocalTime(tv)`。
6. 返回 `TimeString(t)` 和 `TimeZoneString(tv)` 的字符串连接。

### 21.4.4.43 Date.prototype.toUTCString ( )

此方法返回一个字符串值，表示与 `this` 值对应的时间点。字符串的格式基于 RFC 7231 中的 "HTTP-date"，推广以支持 ECMAScript Dates 支持的所有时间范围。

当调用此方法时，执行以下步骤：

1. 令 `dateObject` 为 `this` 值。
2. 执行 `? RequireInternalSlot(dateObject, [[DateValue]])`。
3. 令 `tv` 为 `dateObject.[[DateValue]]`。
4. 如果 `tv` 是 NaN，则返回 "Invalid Date"。
5. 令 `weekday` 为表 62 中与数字 `WeekDay(tv)` 对应的条目的名称。
6. 令 `month` 为表 63 中与数字 `MonthFromTime(tv)` 对应的条目的名称。
7. 令 `day` 为 `ToZeroPaddedDecimalString(ℝ(DateFromTime(tv)), 2)`。
8. 令 `yv` 为 `YearFromTime(tv)`。
9. 如果 `yv` 为 +0𝔽 或者 `yv` 大于 +0𝔽，令 `yearSign` 为空字符串；否则，令 `yearSign` 为 "-"。
10. 令 `paddedYear` 为 `ToZeroPaddedDecimalString(abs(ℝ(yv)), 4)`。
11. 返回 `weekday`、","、代码单元 0x0020 (空格)、`day`、代码单元 0x0020 (空格)、`month`、代码单元 0x0020 (空格)、`yearSign`、`paddedYear`、代码单元 0x0020 (空格) 和 `TimeString(tv)` 的字符串连接。

### 21.4.4.44 Date.prototype.valueOf ( )

当调用此方法时，执行以下步骤：

1. 令 `dateObject` 为 `this` 值。
2. 执行 `? RequireInternalSlot(dateObject, [[DateValue]])`。
3. 返回 `dateObject.[[DateValue]]`。

### 21.4.4.45 Date.prototype [ @@toPrimitive ] ( hint )

此方法由 ECMAScript 语言运算符调用，将 Date 转换为原始值。`hint` 的允许值是 "default"、"number" 和 "string"。Dates 是内置 ECMAScript 对象中独特的，它们将 "default" 视为等同于 "string"，所有其他内置 ECMAScript 对象将 "default" 视为等同于 "number"。

当调用此方法时，执行以下步骤：

1. 令 `O` 为 `this` 值。
2. 如果 `O` 不是对象，则抛出 TypeError 异常。
3. 如果 `hint` 是 "string" 或 "default"，则：
   1. 令 `tryFirst` 为 `STRING`。
4. 否则如果

 `hint` 是 "number"，则：
   1. 令 `tryFirst` 为 `NUMBER`。
5. 否则：
   1. 抛出 TypeError 异常。
6. 返回 `? OrdinaryToPrimitive(O, tryFirst)`。

此属性具有属性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }。

此方法的 "name" 属性的值为 "[Symbol.toPrimitive]"。

### 21.4.5 Date 实例的属性

Date 实例是普通对象，继承自 Date 原型对象的属性。Date 实例还具有一个 `[[DateValue]]` 内部插槽。`[[DateValue]]` 内部插槽是该 Date 表示的时间值。

### 22 文本处理

#### 22.1 字符串对象

##### 22.1.1 字符串构造函数

字符串构造函数：

- 是 `%String%`。
- 是全局对象的 `String` 属性的初始值。
- 当作为构造函数调用时，会创建并初始化一个新的字符串对象。
- 当作为函数而不是构造函数调用时，会执行类型转换。
- 可以用作类定义的 `extends` 子句的值。打算继承指定字符串行为的子类构造函数必须包含对字符串构造函数的 `super` 调用，以创建并初始化具有 `[[StringData]]` 内部插槽的子类实例。

###### 22.1.1.1 String ( value )

当调用此函数时，执行以下步骤：

1. 如果 `value` 不存在，则
   a. 令 `s` 为空字符串。
2. 否则，
   a. 如果 `NewTarget` 是未定义的并且 `value` 是一个符号，则返回 `SymbolDescriptiveString(value)`。
   b. 令 `s` 为 `? ToString(value)`。
3. 如果 `NewTarget` 是未定义的，返回 `s`。
4. 返回 `StringCreate(s, ? GetPrototypeFromConstructor(NewTarget, "%String.prototype%"))`。

##### 22.1.2 字符串构造函数的属性

字符串构造函数：

- 具有一个 `[[Prototype]]` 内部插槽，其值为 `%Function.prototype%`。
- 具有以下属性：

###### 22.1.2.1 String.fromCharCode ( ...codeUnits )

此函数可以用任何数量的参数调用，这些参数形成剩余参数 `codeUnits`。

当调用时，执行以下步骤：

1. 令 `result` 为空字符串。
2. 对于 `codeUnits` 的每个元素 `next`，执行
   a. 令 `nextCU` 为数值为 `ℝ(? ToUint16(next))` 的代码单元。
   b. 将 `result` 设置为 `result` 和 `nextCU` 的字符串连接。
3. 返回 `result`。

此函数的 "length" 属性为 `1𝔽`。

###### 22.1.2.2 String.fromCodePoint ( ...codePoints )

此函数可以用任何数量的参数调用，这些参数形成剩余参数 `codePoints`。

当调用时，执行以下步骤：

1. 令 `result` 为空字符串。
2. 对于 `codePoints` 的每个元素 `next`，执行
   a. 令 `nextCP` 为 `? ToNumber(next)`。
   b. 如果 `nextCP` 不是整数数值，抛出 `RangeError` 异常。
   c. 如果 `ℝ(nextCP) < 0` 或 `ℝ(nextCP) > 0x10FFFF`，抛出 `RangeError` 异常。
   d. 将 `result` 设置为 `result` 和 `UTF16EncodeCodePoint(ℝ(nextCP))` 的字符串连接。
3. 断言：如果 `codePoints` 为空，则 `result` 是空字符串。
4. 返回 `result`。

此函数的 "length" 属性为 `1𝔽`。

###### 22.1.2.3 String.prototype

`String.prototype` 的初始值是字符串原型对象。

此属性的属性为 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }。

###### 22.1.2.4 String.raw ( template, ...substitutions )

此函数可以用可变数量的参数调用。第一个参数是 `template`，其余参数形成列表 `substitutions`。

当调用时，执行以下步骤：

1. 令 `substitutionCount` 为 `substitutions` 中元素的数量。
2. 令 `cooked` 为 `? ToObject(template)`。
3. 令 `literals` 为 `? ToObject(? Get(cooked, "raw"))`。
4. 令 `literalCount` 为 `? LengthOfArrayLike(literals)`。
5. 如果 `literalCount` 小于或等于 0，返回空字符串。
6. 令 `R` 为空字符串。
7. 令 `nextIndex` 为 0。
8. 重复，
   a. 令 `nextLiteralVal` 为 `? Get(literals, ! ToString(𝔽(nextIndex)))`。
   b. 令 `nextLiteral` 为 `? ToString(nextLiteralVal)`。
   c. 将 `R` 设置为 `R` 和 `nextLiteral` 的字符串连接。
   d. 如果 `nextIndex + 1 = literalCount`，返回 `R`。
   e. 如果 `nextIndex` 小于 `substitutionCount`，则
      i. 令 `nextSubVal` 为 `substitutions[nextIndex]`。
      ii. 令 `nextSub` 为 `? ToString(nextSubVal)`。
      iii. 将 `R` 设置为 `R` 和 `nextSub` 的字符串连接。
   f. 将 `nextIndex` 设置为 `nextIndex + 1`。

注：此函数旨在用作标记模板的标记函数（13.3.11）。当作为标记函数调用时，第一个参数将是一个格式良好的模板对象，剩余参数将包含替换值。

### 22 文本处理

#### 22.1 字符串对象

##### 22.1.3 字符串原型对象的属性

字符串原型对象：

- 是 `%String.prototype%`。
- 是一个特殊字符串对象，具有为此类对象指定的内部方法。
- 具有一个 `[[StringData]]` 内部插槽，其值为空字符串。
- 具有一个 `length` 属性，其初始值为 `+0𝔽`，其属性为 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }。
- 具有一个 `[[Prototype]]` 内部插槽，其值为 `%Object.prototype%`。
- 除非明确说明，否则以下定义的字符串原型对象的方法不是通用的，传递给它们的 `this` 值必须是字符串值或具有初始化为字符串值的 `[[StringData]]` 内部插槽的对象。

###### 22.1.3.1 String.prototype.at ( index )

1. 令 `O` 为 `? RequireObjectCoercible(this value)`。
2. 令 `S` 为 `? ToString(O)`。
3. 令 `len` 为 `S` 的长度。
4. 令 `relativeIndex` 为 `? ToIntegerOrInfinity(index)`。
5. 如果 `relativeIndex >= 0`，则
   a. 令 `k` 为 `relativeIndex`。
6. 否则，
   a. 令 `k` 为 `len + relativeIndex`。
7. 如果 `k < 0` 或 `k >= len`，返回 `undefined`。
8. 返回 `S` 的从 `k` 到 `k + 1` 的子字符串。

###### 22.1.3.2 String.prototype.charAt ( pos )

注1：此方法返回一个包含字符串中 `pos` 索引处代码单元的单个元素字符串。如果该索引处没有元素，则结果为空字符串。结果是字符串值，而不是字符串对象。

如果 `pos` 是一个整数数值，则 `x.charAt(pos)` 的结果等同于 `x.substring(pos, pos + 1)` 的结果。

当调用此方法时，执行以下步骤：

1. 令 `O` 为 `? RequireObjectCoercible(this value)`。
2. 令 `S` 为 `? ToString(O)`。
3. 令 `position` 为 `? ToIntegerOrInfinity(pos)`。
4. 令 `size` 为 `S` 的长度。
5. 如果 `position < 0` 或 `position >= size`，返回空字符串。
6. 返回 `S` 的从 `position` 到 `position + 1` 的子字符串。

注2：此方法是故意设计为通用的；它不要求其 `this` 值是字符串对象。因此，它可以转移到其他类型的对象中用作方法。

###### 22.1.3.3 String.prototype.charCodeAt ( pos )

注1：此方法返回一个数值（小于 `2**16` 的非负整数），该数值是将此对象转换为字符串后在 `pos` 索引处的代码单元的数值。如果该索引处没有元素，则结果为 `NaN`。

当调用此方法时，执行以下步骤：

1. 令 `O` 为 `? RequireObjectCoercible(this value)`。
2. 令 `S` 为 `? ToString(O)`。
3. 令 `position` 为 `? ToIntegerOrInfinity(pos)`。
4. 令 `size` 为 `S` 的长度。
5. 如果 `position < 0` 或 `position >= size`，返回 `NaN`。
6. 返回字符串 `S` 中 `position` 索引处代码单元的数值。

注2：此方法是故意设计为通用的；它不要求其 `this` 值是字符串对象。因此，它可以转移到其他类型的对象中用作方法。

###### 22.1.3.4 String.prototype.codePointAt ( pos )

注1：此方法返回一个小于或等于 `0x10FFFF𝔽` 的非负整数数值，该数值是将此对象转换为字符串后在 `pos` 索引处的 UTF-16 编码码点的数值。如果该索引处没有元素，则结果为 `undefined`。如果 `pos` 处不是有效的 UTF-16 代理对的开始，则结果为 `pos` 处的代码单元。

当调用此方法时，执行以下步骤：

1. 令 `O` 为 `? RequireObjectCoercible(this value)`。
2. 令 `S` 为 `? ToString(O)`。
3. 令 `position` 为 `? ToIntegerOrInfinity(pos)`。
4. 令 `size` 为 `S` 的长度。
5. 如果 `position < 0` 或 `position >= size`，返回 `undefined`。
6. 令 `cp` 为 `CodePointAt(S, position)`。
7. 返回 `𝔽(cp.[[CodePoint]])`。

注2：此方法是故意设计为通用的；它不要求其 `this` 值是字符串对象。因此，它可以转移到其他类型的对象中用作方法。

###### 22.1.3.5 String.prototype.concat ( ...args )

注1：当调用此方法时，它返回由 `this` 值（转换为字符串）的代码单元和每个参数转换为字符串的代码单元组成的字符串值。结果是字符串值，而不是字符串对象。

当调用此方法时，执行以下步骤：

1. 令 `O` 为 `? RequireObjectCoercible(this value)`。
2. 令 `S` 为 `? ToString(O)`。
3. 令 `R` 为 `S`。
4. 对于 `args` 的每个元素 `next`，执行
   a. 令 `nextString` 为 `? ToString(next)`。
   b. 将 `R` 设置为 `R` 和 `nextString` 的字符串连接。
5. 返回 `R`。

此方法的 "length" 属性为 `1𝔽`。

注2：此方法是故意设计为通用的；它不要求其 `this` 值是字符串对象。因此，它可以转移到其他类型的对象中用作方法。

###### 22.1.3.6 String.prototype.constructor

`String.prototype.constructor` 的初始值是 `%String%`。

###### 22.1.3.7 String.prototype.endsWith ( searchString [ , endPosition ] )

当调用此方法时，执行以下步骤：

1. 令 `O` 为 `? RequireObjectCoercible(this value)`。
2. 令 `S` 为 `? ToString(O)`。
3. 令 `isRegExp` 为 `? IsRegExp(searchString)`。
4. 如果 `isRegExp` 为 `true`，抛出 `TypeError` 异常。
5. 令 `searchStr` 为 `? ToString(searchString)`。
6. 令 `len` 为 `S` 的长度。
7. 如果 `endPosition` 未定义，令 `pos` 为 `len`；否则令 `pos` 为 `? ToIntegerOrInfinity(endPosition)`。
8. 令 `end` 为 `pos` 在 `0` 和 `len` 之间的夹取结果。
9. 令 `searchLength` 为 `searchStr` 的长度。
10. 如果 `searchLength` 为 `0`，返回 `true`。
11. 令 `start` 为 `end - searchLength`。
12. 如果 `start < 0`，返回 `false`。
13. 令 `substring` 为 `S` 的从 `start` 到 `end` 的子字符串。
14. 如果 `substring` 是 `searchStr`，返回 `true`。
15. 返回 `false`。

注1：如果 `searchString` 转换为字符串的代码单元序列与此对象（转换为字符串）从 `endPosition - length(this)` 开始的相应代码单元相同，则此方法返回 `true`。否则返回 `false`。

注2：如果第一个参数是正则表达式，则抛出异常，目的是允许将来版本定义允许此类参数值的扩展。

注3：此方法是故意设计为通用的；它不要求其 `this` 值是字符串对象。因此，它可以转移到其他类型的对象中用作方法。

#### 22.1.3.8 String.prototype.includes ( searchString [ , position ] )

此方法在被调用时执行以下步骤：

1. 令 `O` 为 `? RequireObjectCoercible(this value)`。
2. 令 `S` 为 `? ToString(O)`。
3. 令 `isRegExp` 为 `? IsRegExp(searchString)`。
4. 如果 `isRegExp` 为 `true`，抛出 `TypeError` 异常。
5. 令 `searchStr` 为 `? ToString(searchString)`。
6. 令 `pos` 为 `? ToIntegerOrInfinity(position)`。
7. 断言：如果 `position` 未定义，则 `pos` 为 `0`。
8. 令 `len` 为 `S` 的长度。
9. 令 `start` 为 `pos` 在 `0` 和 `len` 之间的夹取结果。
10. 令 `index` 为 `StringIndexOf(S, searchStr, start)`。
11. 如果 `index` 为 `NOT-FOUND`，返回 `false`。
12. 返回 `true`。

注1：如果 `searchString` 作为子字符串出现在将此对象转换为字符串的结果中，且一个或多个索引大于或等于 `position`，则此函数返回 `true`；否则返回 `false`。如果 `position` 未定义，则假定为 `0`，以便搜索整个字符串。

注2：如果第一个参数是正则表达式，则抛出异常，以允许将来的版本定义允许此类参数值的扩展。

注3：此方法是故意设计为通用的；它不要求其 `this` 值是字符串对象。因此，它可以转移到其他类型的对象中用作方法。

#### 22.1.3.9 String.prototype.indexOf ( searchString [ , position ] )

注1：如果 `searchString` 作为子字符串出现在将此对象转换为字符串的结果中，且一个或多个索引大于或等于 `position`，则返回最小的此类索引；否则返回 `-1𝔽`。如果 `position` 未定义，则假定为 `+0𝔽`，以便搜索整个字符串。

此方法在被调用时执行以下步骤：

1. 令 `O` 为 `? RequireObjectCoercible(this value)`。
2. 令 `S` 为 `? ToString(O)`。
3. 令 `searchStr` 为 `? ToString(searchString)`。
4. 令 `pos` 为 `? ToIntegerOrInfinity(position)`。
5. 断言：如果 `position` 未定义，则 `pos` 为 `0`。
6. 令 `len` 为 `S` 的长度。
7. 令 `start` 为 `pos` 在 `0` 和 `len` 之间的夹取结果。
8. 令 `result` 为 `StringIndexOf(S, searchStr, start)`。
9. 如果 `result` 为 `NOT-FOUND`，返回 `-1𝔽`。
10. 返回 `𝔽(result)`。

注2：此方法是故意设计为通用的；它不要求其 `this` 值是字符串对象。因此，它可以转移到其他类型的对象中用作方法。

#### 22.1.3.10 String.prototype.isWellFormed ( )

此方法在被调用时执行以下步骤：

1. 令 `O` 为 `? RequireObjectCoercible(this value)`。
2. 令 `S` 为 `? ToString(O)`。
3. 返回 `IsStringWellFormedUnicode(S)`。

#### 22.1.3.11 String.prototype.lastIndexOf ( searchString [ , position ] )

注1：如果 `searchString` 作为子字符串出现在将此对象转换为字符串的结果中，且一个或多个索引小于或等于 `position`，则返回最大的此类索引；否则返回 `-1𝔽`。如果 `position` 未定义，则假定为字符串值的长度，以便搜索整个字符串。

此方法在被调用时执行以下步骤：

1. 令 `O` 为 `? RequireObjectCoercible(this value)`。
2. 令 `S` 为 `? ToString(O)`。
3. 令 `searchStr` 为 `? ToString(searchString)`。
4. 令 `numPos` 为 `? ToNumber(position)`。
5. 断言：如果 `position` 未定义，则 `numPos` 为 `NaN`。
6. 如果 `numPos` 为 `NaN`，令 `pos` 为 `+∞`；否则，令 `pos` 为 `! ToIntegerOrInfinity(numPos)`。
7. 令 `len` 为 `S` 的长度。
8. 令 `searchLen` 为 `searchStr` 的长度。
9. 令 `start` 为 `pos` 在 `0` 和 `len - searchLen` 之间的夹取结果。
10. 令 `result` 为 `StringLastIndexOf(S, searchStr, start)`。
11. 如果 `result` 为 `NOT-FOUND`，返回 `-1𝔽`。
12. 返回 `𝔽(result)`。

注2：此方法是故意设计为通用的；它不要求其 `this` 值是字符串对象。因此，它可以转移到其他类型的对象中用作方法。

#### 22.1.3.12 String.prototype.localeCompare ( that [ , reserved1 [ , reserved2 ] ] )

包含 ECMA-402 国际化 API 的 ECMAScript 实现必须按照 ECMA-402 规范实现此方法。如果 ECMAScript 实现不包括 ECMA-402 API，则使用以下此方法的规范：

此方法返回一个 `NaN` 以外的数值，表示 `this` 值（转换为字符串 `S`）与 `that`（转换为字符串 `thatValue`）的实现定义的区域敏感字符串比较的结果。结果旨在对应于主机环境当前区域的字符串值的排序顺序，当 `S` 排在 `thatValue` 之前时为负数，当 `S` 排在 `thatValue` 之后时为正数，在所有其他情况下为零（表示 `S` 和 `thatValue` 之间没有相对顺序）。

在进行比较之前，此方法执行以下步骤来准备字符串：

1. 令 `O` 为 `? RequireObjectCoercible(this value)`。
2. 令 `S` 为 `? ToString(O)`。
3. 令 `thatValue` 为 `? ToString(that)`。

此方法的第二个和第三个参数的含义在 ECMA-402 规范中定义；不包括 ECMA-402 支持的实现不得对这些参数位置赋予任何其他解释。

实际返回值是实现定义的，以允许在其中编码附加信息，但此方法在作为两个参数的方法考虑时，必须是定义所有字符串集合的全排序的稳定比较器。此方法还必须识别并遵守 Unicode 标准的规范等效性，包括在比较规范等效的可区分字符串时返回 `+0𝔽`。

注1：此方法本身不适合作为 `Array.prototype.sort` 的参数，因为后者需要一个两个参数的函数。

注2：此方法可以依赖于 ECMAScript 环境从主机环境获得的任何语言和/或区域敏感的比较功能，并且旨在根据主机环境当前区域的约定进行比较。然而，无论比较能力如何，此方法必须识别并遵守 Unicode 标准的规范等效性，例如，以下比较必须都返回 `+0𝔽`：

```javascript
// Å ANGSTROM SIGN vs.
// Å LATIN CAPITAL LETTER A + COMBINING RING ABOVE
"\u212B".localeCompare("A\u030A")

// Ω OHM SIGN vs.
// Ω GREEK CAPITAL LETTER OMEGA
"\u2126".localeCompare("\u03A9")

// ṩ LATIN SMALL LETTER S WITH DOT BELOW AND DOT ABOVE vs.
// ṩ LATIN SMALL LETTER S + COMBINING DOT ABOVE + COMBINING DOT BELOW
"\u1E69".localeCompare("s\u0307\u0323")

// ḍ̇ LATIN SMALL LETTER D WITH DOT ABOVE + COMBINING DOT BELOW vs.
// ḍ̇ LATIN SMALL LETTER D WITH DOT BELOW + COMBINING DOT ABOVE
"\u1E0B\u0323".localeCompare("\u1E0D\u0307")

// 가 HANGUL CHOSEONG KIYEOK + HANGUL JUNGSEONG A vs.
// 가 HANGUL SYLLABLE GA
"\u1100\u1161".localeCompare("\uAC00")
```

有关规范等效性的定义和讨论，请参见 Unicode 标准第 2 章和第 3 章，以及 Unicode 标准附录 #15《Unicode 规范化形式》和 Unicode 技术说明 #5《应用程序中的规范等效性》。另请参见 Unicode 技术标准 #10《Unicode 排序算法》。

建议此方法不应遵守 Unicode 兼容等效性或 Unicode 标准第 3 章第 3.7 节定义的兼容分解。

注3：此方法是故

意设计为通用的；它不要求其 `this` 值是字符串对象。因此，它可以转移到其他类型的对象中用作方法。

#### 22.1.3.13 String.prototype.match ( regexp )

此方法在被调用时执行以下步骤：

1. 令 `O` 为 `? RequireObjectCoercible(this value)`。
2. 如果 `regexp` 既不是 `undefined` 也不是 `null`，则
   a. 令 `matcher` 为 `? GetMethod(regexp, @@match)`。
   b. 如果 `matcher` 不是 `undefined`，则
      i. 返回 `? Call(matcher, regexp, « O »)`。
3. 令 `S` 为 `? ToString(O)`。
4. 令 `rx` 为 `? RegExpCreate(regexp, undefined)`。
5. 返回 `? Invoke(rx, @@match, « S »)`。

注：此方法是故意设计为通用的；它不要求其 `this` 值是字符串对象。因此，它可以转移到其他类型的对象中用作方法。

#### 22.1.3.14 String.prototype.matchAll ( regexp )

此方法执行将表示此值的字符串与 `regexp` 进行正则表达式匹配，并返回一个迭代器。每个迭代结果的值是包含匹配结果的数组，或如果字符串不匹配则为 `null`。

当调用此方法时，执行以下步骤：

1. 令 `O` 为 `? RequireObjectCoercible(this value)`。
2. 如果 `regexp` 既不是 `undefined` 也不是 `null`，则
   a. 令 `isRegExp` 为 `? IsRegExp(regexp)`。
   b. 如果 `isRegExp` 为 `true`，则
      i. 令 `flags` 为 `? Get(regexp, "flags")`。
      ii. 执行 `? RequireObjectCoercible(flags)`。
      iii. 如果 `? ToString(flags)` 不包含 `g`，抛出 `TypeError` 异常。
   c. 令 `matcher` 为 `? GetMethod(regexp, @@matchAll)`。
   d. 如果 `matcher` 不是 `undefined`，则
      i. 返回 `? Call(matcher, regexp, « O »)`。
3. 令 `S` 为 `? ToString(O)`。
4. 令 `rx` 为 `? RegExpCreate(regexp, "g")`。
5. 返回 `? Invoke(rx, @@matchAll, « S »)`。

注1：此方法是故意设计为通用的，它不要求其 `this` 值是字符串对象。因此，它可以转移到其他类型的对象中用作方法。

注2：类似于 `String.prototype.split`，`String.prototype.matchAll` 的设计通常是不会修改其输入的。

#### 22.1.3.15 String.prototype.normalize ( [ form ] )

此方法在被调用时执行以下步骤：

1. 令 `O` 为 `? RequireObjectCoercible(this value)`。
2. 令 `S` 为 `? ToString(O)`。
3. 如果 `form` 未定义，令 `f` 为 `NFC`。
4. 否则，令 `f` 为 `? ToString(form)`。
5. 如果 `f` 不是 `NFC`、`NFD`、`NFKC` 或 `NFKD` 之一，抛出 `RangeError` 异常。
6. 令 `ns` 为按照最新的 Unicode 标准《规范化形式》规范化 `S` 到由 `f` 命名的规范化形式的字符串值。
7. 返回 `ns`。

注：此方法是故意设计为通用的；它不要求其 `this` 值是字符串对象。因此，它可以转移到其他类型的对象中用作方法。

#### 22.1.3.16 String.prototype.padEnd ( maxLength [ , fillString ] )
此方法在被调用时执行以下步骤：

1. 令 `O` 为 `? RequireObjectCoercible(this value)`。
2. 返回 `? StringPaddingBuiltinsImpl(O, maxLength, fillString, END)`。

#### 22.1.3.17 String.prototype.padStart ( maxLength [ , fillString ] )
此方法在被调用时执行以下步骤：

1. 令 `O` 为 `? RequireObjectCoercible(this value)`。
2. 返回 `? StringPaddingBuiltinsImpl(O, maxLength, fillString, START)`。

#### 22.1.3.17.1 StringPaddingBuiltinsImpl ( O, maxLength, fillString, placement )
抽象操作 `StringPaddingBuiltinsImpl` 接受参数 `O`（ECMAScript 语言值）、`maxLength`（ECMAScript 语言值）、`fillString`（ECMAScript 语言值）和 `placement`（START 或 END），并返回包含字符串的正常完成或抛出完成。调用时执行以下步骤：

1. 令 `S` 为 `? ToString(O)`。
2. 令 `intMaxLength` 为 ℝ(`? ToLength(maxLength)`)。
3. 令 `stringLength` 为 `S` 的长度。
4. 如果 `intMaxLength` ≤ `stringLength`，返回 `S`。
5. 如果 `fillString` 未定义，将 `fillString` 设置为仅包含代码单元 `0x0020`（空格）的字符串值。
6. 否则，将 `fillString` 设置为 `? ToString(fillString)`。
7. 返回 `StringPad(S, intMaxLength, fillString, placement)`。

#### 22.1.3.17.2 StringPad ( S, maxLength, fillString, placement )
抽象操作 `StringPad` 接受参数 `S`（字符串）、`maxLength`（非负整数）、`fillString`（字符串）和 `placement`（START 或 END），并返回一个字符串。调用时执行以下步骤：

1. 令 `stringLength` 为 `S` 的长度。
2. 如果 `maxLength` ≤ `stringLength`，返回 `S`。
3. 如果 `fillString` 是空字符串，返回 `S`。
4. 令 `fillLen` 为 `maxLength - stringLength`。
5. 令 `truncatedStringFiller` 为由 `fillString` 截断为 `fillLen` 长度的重复连接组成的字符串值。
6. 如果 `placement` 是 START，返回 `truncatedStringFiller` 和 `S` 的字符串连接。
7. 否则，返回 `S` 和 `truncatedStringFiller` 的字符串连接。

注1：参数 `maxLength` 将被夹取，以使其不小于 `S` 的长度。

注2：参数 `fillString` 默认为 `" "`（由代码单元 `0x0020`（空格）组成的字符串值）。

#### 22.1.3.17.3 ToZeroPaddedDecimalString ( n, minLength )
抽象操作 `ToZeroPaddedDecimalString` 接受参数 `n`（非负整数）和 `minLength`（非负整数），并返回一个字符串。调用时执行以下步骤：

1. 令 `S` 为 `n` 的字符串表示形式，格式化为十进制数字。
2. 返回 `StringPad(S, minLength, "0", START)`。

#### 22.1.3.18 String.prototype.repeat ( count )
此方法在被调用时执行以下步骤：

1. 令 `O` 为 `? RequireObjectCoercible(this value)`。
2. 令 `S` 为 `? ToString(O)`。
3. 令 `n` 为 `? ToIntegerOrInfinity(count)`。
4. 如果 `n < 0` 或 `n = +∞`，抛出 `RangeError` 异常。
5. 如果 `n = 0`，返回空字符串。
6. 返回由 `n` 个 `S` 副本连接在一起形成的字符串值。

注1：此方法创建由此值的代码单元（转换为字符串）重复 `count` 次组成的字符串值。

注2：此方法是故意设计为通用的；它不要求其 `this` 值是字符串对象。因此，它可以转移到其他类型的对象中用作方法。

#### 22.1.3.19 String.prototype.replace ( searchValue, replaceValue )
此方法在被调用时执行以下步骤：

1. 令 `O` 为 `? RequireObjectCoercible(this value)`。
2. 如果 `searchValue` 既不是 `undefined` 也不是 `null`，则
   a. 令 `replacer` 为 `? GetMethod(searchValue, @@replace)`。
   b. 如果 `replacer` 不是 `undefined`，则
      i. 返回 `? Call(replacer, searchValue, « O, replaceValue »)`。
3. 令 `string` 为 `? ToString(O)`。
4. 令 `searchString` 为 `? ToString(searchValue)`。
5. 令 `functionalReplace` 为 `IsCallable(replaceValue)`。
6. 如果 `functionalReplace` 为 `false`，则
   a. 将 `replaceValue` 设置为 `? ToString(replaceValue)`。
7. 令 `searchLength` 为 `searchString` 的长度。
8. 令 `position` 为 `StringIndexOf(string, searchString, 0)`。
9. 如果 `position` 为 `NOT-FOUND`，返回 `string`。
10. 令 `preceding` 为从 `0` 到 `position` 的 `string` 子字符串。
11. 令 `following` 为从 `position + searchLength` 开始的 `string` 子字符串。
12. 如果 `functionalReplace` 为 `true`，则
   a. 令 `replacement` 为 `? ToString(? Call(replaceValue, undefined, « searchString, 𝔽(position), string »))`。
13. 否则，
   a. 断言：`replaceValue` 是字符串。
   b. 令 `captures` 为一个新的空列表。
   c. 令 `replacement` 为 `! GetSubstitution(searchString, string, position, captures, undefined, replaceValue)`。
14. 返回 `preceding`、`replacement` 和 `following` 的字符串连接。

注：此方法是故意设计为通用的；它不要求其 `this` 值是字符串对象。因此，它可以转移到其他类型的对象中用作方法。

#### 22.1.3.19.1 GetSubstitution ( matched, str, position, captures, namedCaptures, replacementTemplate )
抽象操作 `GetSubstitution` 接受参数 `matched`（字符串）、`str`（字符串）、`position`（非负整数）、`captures`（字符串或未定义的列表）、`namedCaptures`（对象或未定义）和 `replacementTemplate`（字符串），并返回包含字符串的正常完成或抛出完成。对于此抽象操作，小数位是代码单元，位于 `0x0030`（数字零）到 `0x0039`（数字九）的区间内。调用时执行以下步骤：

1. 令 `stringLength` 为 `str` 的长度。
2. 断言：`position ≤ stringLength`。
3. 令 `result` 为空字符串。
4. 令 `templateRemainder` 为 `replacementTemplate`。
5. 重复，直到 `templateRemainder` 为空字符串，
   a. 注：以下步骤将隔离 `ref`（`templateRemainder` 的前缀），确定 `refReplacement`（其替换），然后将该替换附加到 `result`。
   b. 如果 `templateRemainder` 以 `$$` 开头，则
      i. 令 `ref` 为 `$$`。
      ii. 令 `refReplacement` 为 `$`。
   c. 否则如果 `templateRemainder` 以 `$` 开头，则
      i. 令 `ref` 为 `$`。
      ii. 令 `refReplacement` 为从 `0` 到 `position` 的 `str` 子字符串。
   d. 否则如果 `templateRemainder` 以 `&` 开头，则
      i. 令 `ref` 为 `&`。
      ii. 令 `refReplacement` 为 `matched`。
   e. 否则如果 `templateRemainder` 以 `$'`（`0x0024`（美元符号）后跟 `0x0027`（撇号））开头，则
      i. 令 `ref` 为 `$'`。
      ii. 令 `matchLength` 为 `matched` 的长度。
      iii. 令 `tailPos` 为 `position + matchLength`。
      iv. 令 `refReplacement` 为从 `min(tailPos, stringLength)` 开始的 `str` 子字符串。
      v. 注：只有在此抽象操作是由 `%RegExp.prototype%` 的本质 `@@replace` 方法调用的，并且对象的 `

exec` 属性不是 `%RegExp.prototype.exec%` 本质时，`tailPos` 才能超过 `stringLength`。
   f. 否则如果 `templateRemainder` 以 `$` 开头，并且后跟 1 个或多个小数位，则
      i. 如果 `templateRemainder` 以 `$` 开头并后跟 2 个或更多小数位，令 `digitCount` 为 2。否则，令 `digitCount` 为 1。
      ii. 令 `digits` 为 `templateRemainder` 的从 `1` 到 `1 + digitCount` 的子字符串。
      iii. 令 `index` 为 ℝ(`StringToNumber(digits)`)。
      iv. 断言：`0 ≤ index ≤ 99`。
      v. 令 `captureLen` 为 `captures` 中元素的数量。
      vi. 如果 `index > captureLen` 并且 `digitCount = 2`，则
         1. 注：当两位数的替换模式指定的索引超过捕获组的数量时，它被视为后跟一个文字数字的一位数替换模式。
         2. 将 `digitCount` 设置为 1。
         3. 将 `digits` 设置为 `digits` 的从 `0` 到 `1` 的子字符串。
         4. 将 `index` 设置为 ℝ(`StringToNumber(digits)`)。
      vii. 令 `ref` 为 `templateRemainder` 的从 `0` 到 `1 + digitCount` 的子字符串。
      viii. 如果 `1 ≤ index ≤ captureLen`，则
         1. 令 `capture` 为 `captures[index - 1]`。
         2. 如果 `capture` 是未定义的，则
            a. 令 `refReplacement` 为空字符串。
         3. 否则，
            a. 令 `refReplacement` 为 `capture`。
      ix. 否则，
         1. 令 `refReplacement` 为 `ref`。
   g. 否则如果 `templateRemainder` 以 `$<` 开头，则
      i. 令 `gtPos` 为 `StringIndexOf(templateRemainder, ">", 0)`。
      ii. 如果 `gtPos` 是 `NOT-FOUND` 或 `namedCaptures` 是未定义，则
         1. 令 `ref` 为 `$<`。
         2. 令 `refReplacement` 为 `ref`。
      iii. 否则，
         1. 令 `ref` 为 `templateRemainder` 的从 `0` 到 `gtPos + 1` 的子字符串。
         2. 令 `groupName` 为 `templateRemainder` 的从 `2` 到 `gtPos` 的子字符串。
         3. 断言：`namedCaptures` 是对象。
         4. 令 `capture` 为 `? Get(namedCaptures, groupName)`。
         5. 如果 `capture` 是未定义的，则
            a. 令 `refReplacement` 为空字符串。
         6. 否则，
            a. 令 `refReplacement` 为 `? ToString(capture)`。
   h. 否则，
      i. 令 `ref` 为 `templateRemainder` 的从 `0` 到 `1` 的子字符串。
      ii. 令 `refReplacement` 为 `ref`。
   i. 令 `refLength` 为 `ref` 的长度。
   j. 将 `templateRemainder` 设置为 `templateRemainder` 的从 `refLength` 的子字符串。
   k. 将 `result` 设置为 `result` 和 `refReplacement` 的字符串连接。
6. 返回 `result`。

#### 22.1.3.20 String.prototype.replaceAll ( searchValue, replaceValue )
此方法在被调用时执行以下步骤：

1. 令 `O` 为 `? RequireObjectCoercible(this value)`。
2. 如果 `searchValue` 既不是 `undefined` 也不是 `null`，则
   a. 令 `isRegExp` 为 `? IsRegExp(searchValue)`。
   b. 如果 `isRegExp` 为 `true`，则
      i. 令 `flags` 为 `? Get(searchValue, "flags")`。
      ii. 执行 `? RequireObjectCoercible(flags)`。
      iii. 如果 `? ToString(flags)` 不包含 `g`，抛出 `TypeError` 异常。
   c. 令 `replacer` 为 `? GetMethod(searchValue, @@replace)`。
   d. 如果 `replacer` 不是 `undefined`，则
      i. 返回 `? Call(replacer, searchValue, « O, replaceValue »)`。
3. 令 `string` 为 `? ToString(O)`。
4. 令 `searchString` 为 `? ToString(searchValue)`。
5. 令 `functionalReplace` 为 `IsCallable(replaceValue)`。
6. 如果 `functionalReplace` 为 `false`，则
   a. 将 `replaceValue` 设置为 `? ToString(replaceValue)`。
7. 令 `searchLength` 为 `searchString` 的长度。
8. 令 `advanceBy` 为 `max(1, searchLength)`。
9. 令 `matchPositions` 为一个新的空列表。
10. 令 `position` 为 `StringIndexOf(string, searchString, 0)`。
11. 重复，直到 `position` 为 `NOT-FOUND`，
    a. 将 `position` 附加到 `matchPositions`。
    b. 将 `position` 设置为 `StringIndexOf(string, searchString, position + advanceBy)`。
12. 令 `endOfLastMatch` 为 `0`。
13. 令 `result` 为空字符串。
14. 对于 `matchPositions` 中的每个元素 `p`，执行以下步骤：
    a. 令 `preserved` 为从 `endOfLastMatch` 到 `p` 的 `string` 子字符串。
    b. 如果 `functionalReplace` 为 `true`，则
       i. 令 `replacement` 为 `? ToString(? Call(replaceValue, undefined, « searchString, 𝔽(p), string »))`。
    c. 否则，
       i. 断言：`replaceValue` 是字符串。
       ii. 令 `captures` 为一个新的空列表。
       iii. 令 `replacement` 为 `! GetSubstitution(searchString, string, p, captures, undefined, replaceValue)`。
    d. 将 `result` 设置为 `result`、`preserved` 和 `replacement` 的字符串连接。
    e. 将 `endOfLastMatch` 设置为 `p + searchLength`。
15. 如果 `endOfLastMatch` 小于 `string` 的长度，则
    a. 将 `result` 设置为 `result` 和从 `endOfLastMatch` 开始的 `string` 子字符串的字符串连接。
16. 返回 `result`。

#### 22.1.3.21 String.prototype.search ( regexp )
此方法在被调用时执行以下步骤：

1. 令 `O` 为 `? RequireObjectCoercible(this value)`。
2. 如果 `regexp` 既不是 `undefined` 也不是 `null`，则
   a. 令 `searcher` 为 `? GetMethod(regexp, @@search)`。
   b. 如果 `searcher` 不是 `undefined`，则
      i. 返回 `? Call(searcher, regexp, « O »)`。
3. 令 `string` 为 `? ToString(O)`。
4. 令 `rx` 为 `? RegExpCreate(regexp, undefined)`。
5. 返回 `? Invoke(rx, @@search, « string »)`。

注：此方法是故意设计为通用的；它不要求其 `this` 值是字符串对象。因此，它可以转移到其他类型的对象中用作方法。

#### 22.1.3.22 String.prototype.slice ( start, end )
此方法返回将此对象转换为字符串后的子字符串，该子字符串从索引 `start` 开始，一直到但不包括索引 `end`（或直到字符串的末尾，如果 `end` 未定义）。如果 `start` 为负，则将其视为 `sourceLength + start`，其中 `sourceLength` 为字符串的长度。如果 `end` 为负，则将其视为 `sourceLength + end`，其中 `sourceLength` 为字符串的长度。结果是字符串值，而不是字符串对象。

此方法在被调用时执行以下步骤：

1. 令 `O` 为 `? RequireObjectCoercible(this value)`。
2. 令 `S` 为 `? ToString(O)`。
3. 令 `len` 为 `S` 的长度。
4. 令 `intStart` 为 `? ToIntegerOrInfinity(start)`。
5. 如果 `intStart = -∞`，令 `from` 为 `0`。
6. 否则如果 `intStart < 0`，令 `from` 为 `max(len + intStart, 0)`。
7. 否则，令 `from` 为 `min(intStart, len)`。
8

. 如果 `end` 未定义，令 `intEnd` 为 `len`；否则，令 `intEnd` 为 `? ToIntegerOrInfinity(end)`。
9. 如果 `intEnd = -∞`，令 `to` 为 `0`。
10. 否则如果 `intEnd < 0`，令 `to` 为 `max(len + intEnd, 0)`。
11. 否则，令 `to` 为 `min(intEnd, len)`。
12. 如果 `from ≥ to`，返回空字符串。
13. 返回 `S` 的从 `from` 到 `to` 的子字符串。

注：此方法是故意设计为通用的；它不要求其 `this` 值是字符串对象。因此，它可以转移到其他类型的对象中用作方法。

#### 22.1.3.23 String.prototype.split ( separator, limit )
此方法返回一个数组，其中存储了将此对象转换为字符串的子字符串。子字符串是通过从左到右搜索 `separator` 的出现位置来确定的；这些出现位置不属于返回的任何字符串，但用来划分字符串值。`separator` 的值可以是任意长度的字符串，也可以是具有 `@@split` 方法的对象，如正则表达式。

此方法在被调用时执行以下步骤：

1. 令 `O` 为 `? RequireObjectCoercible(this value)`。
2. 如果 `separator` 既不是 `undefined` 也不是 `null`，则
   a. 令 `splitter` 为 `? GetMethod(separator, @@split)`。
   b. 如果 `splitter` 不是 `undefined`，则
      i. 返回 `? Call(splitter, separator, « O, limit »)`。
3. 令 `S` 为 `? ToString(O)`。
4. 如果 `limit` 未定义，令 `lim` 为 `2**32 - 1`；否则，令 `lim` 为 ℝ(`? ToUint32(limit)`)。
5. 令 `R` 为 `? ToString(separator)`。
6. 如果 `lim = 0`，则
   a. 返回 `CreateArrayFromList(« »)`。
7. 如果 `separator` 未定义，则
   a. 返回 `CreateArrayFromList(« S »)`。
8. 令 `separatorLength` 为 `R` 的长度。
9. 如果 `separatorLength = 0`，则
   a. 令 `head` 为 `S` 的从 `0` 到 `lim` 的子字符串。
   b. 令 `codeUnits` 为由 `head` 的元素组成的代码单元列表。
   c. 返回 `CreateArrayFromList(codeUnits)`。
10. 如果 `S` 是空字符串，返回 `CreateArrayFromList(« S »)`。
11. 令 `substrings` 为一个新的空列表。
12. 令 `i` 为 `0`。
13. 令 `j` 为 `StringIndexOf(S, R, 0)`。
14. 重复，直到 `j` 是 `NOT-FOUND`，
    a. 令 `T` 为从 `i` 到 `j` 的 `S` 的子字符串。
    b. 将 `T` 附加到 `substrings`。
    c. 如果 `substrings` 中的元素数量为 `lim`，返回 `CreateArrayFromList(substrings)`。
    d. 将 `i` 设置为 `j + separatorLength`。
    e. 将 `j` 设置为 `StringIndexOf(S, R, i)`。
15. 令 `T` 为从 `i` 开始的 `S` 的子字符串。
16. 将 `T` 附加到 `substrings`。
17. 返回 `CreateArrayFromList(substrings)`。

注1：`separator` 的值可以是空字符串。在这种情况下，`separator` 不匹配输入字符串开头或结尾的空子字符串，也不匹配上一个 `separator` 匹配后结束位置的空子字符串。如果 `separator` 是空字符串，则字符串被分割为单个代码单元元素；结果数组的长度等于字符串的长度，每个子字符串包含一个代码单元。

如果此值是（或转换为）空字符串，则结果取决于 `separator` 是否可以匹配空字符串。如果可以匹配，结果数组不包含任何元素。否则，结果数组包含一个元素，即空字符串。

如果 `separator` 未定义，则结果数组仅包含一个字符串，即此值（转换为字符串）。如果 `limit` 未定义，则输出数组被截断，以包含不超过 `limit` 个元素。

注2：此方法是故意设计为通用的；它不要求其 `this` 值是字符串对象。因此，它可以转移到其他类型的对象中用作方法。

#### 22.1.3.24 String.prototype.startsWith ( searchString [ , position ] )
此方法在被调用时执行以下步骤：

1. 令 `O` 为 `? RequireObjectCoercible(this value)`。
2. 令 `S` 为 `? ToString(O)`。
3. 令 `isRegExp` 为 `? IsRegExp(searchString)`。
4. 如果 `isRegExp` 为 `true`，抛出 `TypeError` 异常。
5. 令 `searchStr` 为 `? ToString(searchString)`。
6. 令 `len` 为 `S` 的长度。
7. 如果 `position` 未定义，令 `pos` 为 `0`；否则，令 `pos` 为 `? ToIntegerOrInfinity(position)`。
8. 令 `start` 为 `pos` 在 `0` 和 `len` 之间夹取的结果。
9. 令 `searchLength` 为 `searchStr` 的长度。
10. 如果 `searchLength = 0`，返回 `true`。
11. 令 `end` 为 `start + searchLength`。
12. 如果 `end > len`，返回 `false`。
13. 令 `substring` 为从 `start` 到 `end` 的 `S` 的子字符串。
14. 如果 `substring` 是 `searchStr`，返回 `true`。
15. 返回 `false`。

注1：如果 `searchString` 的代码单元序列转换为字符串后与此对象转换为字符串后的对应代码单元相同，并且从索引 `position` 开始，则此方法返回 `true`。否则，返回 `false`。

注2：抛出异常如果第一个参数是正则表达式，是为了允许未来的版本定义扩展，以允许这样的参数值。

注3：此方法是故意设计为通用的；它不要求其 `this` 值是字符串对象。因此，它可以转移到其他类型的对象中用作方法。


### 22.1.3.25 String.prototype.substring ( start, end )
该方法返回将此对象转换为字符串的结果的子字符串，从索引 `start` 开始，一直到但不包括字符串的索引 `end`（或直到字符串的末尾，如果 `end` 未定义）。结果是一个字符串值，而不是一个字符串对象。

如果任一参数是 NaN 或负数，则将其替换为零；如果任一参数严格大于字符串的长度，则将其替换为字符串的长度。

如果 `start` 严格大于 `end`，则它们会交换。

此方法在被调用时执行以下步骤：

1. 令 `O` 为 `? RequireObjectCoercible(this value)`。
2. 令 `S` 为 `? ToString(O)`。
3. 令 `len` 为 `S` 的长度。
4. 令 `intStart` 为 `? ToIntegerOrInfinity(start)`。
5. 如果 `end` 未定义，令 `intEnd` 为 `len`；否则，令 `intEnd` 为 `? ToIntegerOrInfinity(end)`。
6. 令 `finalStart` 为 `intStart` 在 `0` 和 `len` 之间夹取的结果。
7. 令 `finalEnd` 为 `intEnd` 在 `0` 和 `len` 之间夹取的结果。
8. 令 `from` 为 `finalStart` 和 `finalEnd` 中的较小值。
9. 令 `to` 为 `finalStart` 和 `finalEnd` 中的较大值。
10. 返回 `S` 的从 `from` 到 `to` 的子字符串。

注：此方法是故意设计为通用的；它不要求其 `this` 值是字符串对象。因此，它可以转移到其他类型的对象中用作方法。

### 22.1.3.26 String.prototype.toLocaleLowerCase ( [ reserved1 [ , reserved2 ] ] )
包含 ECMA-402 国际化 API 的 ECMAScript 实现必须按照 ECMA-402 规范实现此方法。如果 ECMAScript 实现不包含 ECMA-402 API，则使用以下规范实现此方法：

该方法将字符串值解释为一系列 UTF-16 编码的代码点，如 6.1.4 所述。

它的工作方式与 `toLowerCase` 完全相同，只不过它旨在产生与宿主环境当前区域的约定相对应的区域敏感结果。只有在少数情况下（例如土耳其语），该语言的规则与常规 Unicode 大小写映射冲突时，才会有差异。

此方法的可选参数的含义在 ECMA-402 规范中定义；不包含 ECMA-402 支持的实现不得将这些参数位置用于其他用途。

注：此方法是故意设计为通用的；它不要求其 `this` 值是字符串对象。因此，它可以转移到其他类型的对象中用作方法。

### 22.1.3.27 String.prototype.toLocaleUpperCase ( [ reserved1 [ , reserved2 ] ] )
包含 ECMA-402 国际化 API 的 ECMAScript 实现必须按照 ECMA-402 规范实现此方法。如果 ECMAScript 实现不包含 ECMA-402 API，则使用以下规范实现此方法：

该方法将字符串值解释为一系列 UTF-16 编码的代码点，如 6.1.4 所述。

它的工作方式与 `toUpperCase` 完全相同，只不过它旨在产生与宿主环境当前区域的约定相对应的区域敏感结果。只有在少数情况下（例如土耳其语），该语言的规则与常规 Unicode 大小写映射冲突时，才会有差异。

此方法的可选参数的含义在 ECMA-402 规范中定义；不包含 ECMA-402 支持的实现不得将这些参数位置用于其他用途。

注：此方法是故意设计为通用的；它不要求其 `this` 值是字符串对象。因此，它可以转移到其他类型的对象中用作方法。

### 22.1.3.28 String.prototype.toLowerCase ( )
该方法将字符串值解释为一系列 UTF-16 编码的代码点，如 6.1.4 所述。

此方法在被调用时执行以下步骤：

1. 令 `O` 为 `? RequireObjectCoercible(this value)`。
2. 令 `S` 为 `? ToString(O)`。
3. 令 `sText` 为 `StringToCodePoints(S)`。
4. 令 `lowerText` 为根据 Unicode 默认大小写转换算法对 `sText` 进行小写转换的结果。
5. 令 `L` 为 `CodePointsToString(lowerText)`。
6. 返回 `L`。

结果必须根据 Unicode 字符数据库中的区域不敏感大小写映射派生（这明确包括文件 `UnicodeData.txt`，还包括随附的文件 `SpecialCasing.txt` 中的所有区域不敏感映射）。

注1：某些代码点的大小写映射可能会生成多个代码点。在这种情况下，结果字符串的长度可能与源字符串不同。由于 `toUpperCase` 和 `toLowerCase` 都具有上下文敏感行为，这些方法并不对称。换句话说，`s.toUpperCase().toLowerCase()` 不一定等于 `s.toLowerCase()`。

注2：此方法是故意设计为通用的；它不要求其 `this` 值是字符串对象。因此，它可以转移到其他类型的对象中用作方法。

### 22.1.3.29 String.prototype.toString ( )
此方法在被调用时执行以下步骤：

1. 返回 `? ThisStringValue(this value)`。

注：对于字符串对象，此方法返回与 `valueOf` 方法相同的结果。

### 22.1.3.30 String.prototype.toUpperCase ( )
该方法将字符串值解释为一系列 UTF-16 编码的代码点，如 6.1.4 所述。

它的行为方式与 `String.prototype.toLowerCase` 完全相同，只不过字符串是使用 Unicode 默认大小写转换的 `toUppercase` 算法进行映射的。

注：此方法是故意设计为通用的；它不要求其 `this` 值是字符串对象。因此，它可以转移到其他类型的对象中用作方法。

### 22.1.3.31 String.prototype.toWellFormed ( )
此方法返回该对象的字符串表示，其中所有不成对的前导代理和尾部代理都被替换为 `U+FFFD`（替换字符）。

此方法在被调用时执行以下步骤：

1. 令 `O` 为 `? RequireObjectCoercible(this value)`。
2. 令 `S` 为 `? ToString(O)`。
3. 令 `strLen` 为 `S` 的长度。
4. 令 `k` 为 `0`。
5. 令 `result` 为空字符串。
6. 重复执行，直到 `k` < `strLen`，
   a. 令 `cp` 为 `CodePointAt(S, k)`。
   b. 如果 `cp.[[IsUnpairedSurrogate]]` 为 `true`，则
      i. 将 `result` 设置为 `result` 和 `0xFFFD`（替换字符）的字符串连接。
   c. 否则，
      i. 将 `result` 设置为 `result` 和 `UTF16EncodeCodePoint(cp.[[CodePoint]])` 的字符串连接。
   d. 将 `k` 设置为 `k + cp.[[CodeUnitCount]]`。
7. 返回 `result`。

### 22.1.3.32 String.prototype.trim ( )
此方法将字符串值解释为一系列 UTF-16 编码的代码点，如 6.1.4 所述。

此方法在被调用时执行以下步骤：

1. 令 `S` 为此值。
2. 返回 `? TrimString(S, START+END)`。

注：此方法是故意设计为通用的；它不要求其 `this` 值是字符串对象。因此，它可以转移到其他种类的对象中用作方法。

### 22.1.3.32.1 TrimString ( string, where )
抽象操作 `TrimString` 接受参数 `string`（一个 ECMAScript 语言值）和 `where`（START、END 或 START+END），并返回包含字符串的正常完成或抛出完成。它将字符串解释为一系列 UTF-16 编码的代码点，如 6.1.4 所述。此方法在被调用时执行以下步骤：

1. 令 `str` 为 `? RequireObjectCoercible(string)`。
2. 令 `S` 为 `? ToString(str)`。
3. 如果 `where` 是 `START`，则
   a. 令 `T` 为移除了前导空白的 `S` 的字符串值。
4. 否则，如果 `where` 是 `END`，则
   a. 令 `T` 为移除了尾部空白的 `S` 的字符串值。
5. 否则，
   a. 断言：`where` 是 `START+END`。
   b. 令 `T` 为移除了前导和尾部空白的 `S` 的字符串值。
6. 返回 `T`。

空白的定义是 `WhiteSpace` 和 `LineTerminator` 的并集。当确定一个 Unicode 代码点是否在 Unicode 常规类别 “Space_Separator”（“Zs”）中时，代码单元序列被解释为 UTF-16 编码的代码点序列，如 6.1.4 所述。

### 22.1.3.33 String.prototype.trimEnd ( )
此方法将字符串值解释为一系列 UTF-16 编码的代码点，如 6.1.4 所述。

此方法在被调用时执行以下步骤：

1. 令 `S` 为此值。
2. 返回 `? TrimString(S, END)`。

注：此方法是故意设计为通用的；它不要求其 `this` 值是字符串对象。因此，它可以转移到其他种类的对象中用作方法。

### 22.1.3.34 String.prototype.trimStart ( )
此方法将字符串值解释为一系列 UTF-16 编码的代码点，如 6.1.4 所述。

此方法在被调用时执行以下步骤：

1. 令 `S` 为此值。
2. 返回 `? TrimString(S, START)`。

注：此方法是故意设计为通用的；它不要求其 `this` 值是字符串对象。因此，它可以转移到其他种类的对象中用作方法。

### 22.1.3.35 String.prototype.valueOf ( )
此方法在被调用时执行以下步骤：

1. 返回 `? ThisStringValue(this value)`。

### 22.1.3.35.1 ThisStringValue ( value )
抽象操作 `ThisStringValue` 接受参数 `value`（一个 ECMAScript 语言值），并返回包含字符串的正常完成或抛出完成。此方法在被调用时执行以下步骤：

1. 如果 `value` 是字符串，返回 `value`。
2. 如果 `value` 是对象且 `value` 具有 `[[StringData]]` 内部槽，则
   a. 令 `s` 为 `value.[[StringData]]`。
   b. 断言：`s` 是一个字符串。
   c. 返回 `s`。
3. 抛出 `TypeError` 异常。

### 22.1.3.36 String.prototype [ @@iterator ] ( )
此方法返回一个迭代器对象（27.1.1.2），该对象迭代字符串值的代码点，每个代码点作为字符串值返回。

此方法在被调用时执行以下步骤：

1. 令 `O` 为 `? RequireObjectCoercible(this value)`。
2. 令 `s` 为 `? ToString(O)`。
3. 令 `closure` 为一个新的抽象闭包，没有参数，捕获 `s` 并在被调用时执行以下步骤：
   a. 令 `len` 为 `s` 的长度。
   b. 令 `position` 为 `0`。
   c. 重复执行，直到 `position` < `len`，
      i. 令 `cp` 为 `CodePointAt(s, position)`。
      ii. 令 `nextIndex` 为 `position + cp.[[CodeUnitCount]]`。
      iii. 令 `resultString` 为 `s` 从 `position` 到 `nextIndex` 的子字符串。
      iv. 设置 `position` 为 `nextIndex`。
      v. 执行 `? GeneratorYield(CreateIterResultObject(resultString, false))`。
   d. 返回 `undefined`。
4. 返回 `CreateIteratorFromClosure(closure, "%StringIteratorPrototype%", %StringIteratorPrototype%)`。

此方法的 "name" 属性的值是 "[Symbol.iterator]"。

### 22.1.4 String 实例的属性
String 实例是特殊的字符串对象，具有为此类对象指定的内部方法。String 实例从 String 原型对象继承属性。String 实例也有一个 `[[StringData]]` 内部槽。`[[StringData]]` 内部槽是此字符串对象表示的字符串值。

String 实例具有一个 "length" 属性，以及一组具有整数索引名称的可枚举属性。

#### 22.1.4.1 length
该属性表示此字符串对象表示的字符串值中的元素数量。

一旦字符串对象初始化，此属性不可更改。它具有属性 `{ [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }`。

### 22.1.5 字符串迭代器对象
字符串迭代器是表示对某些特定字符串实例对象的特定迭代的对象。字符串迭代器对象没有命名构造函数。相反，通过调用字符串实例对象的某些方法创建字符串迭代器对象。

#### 22.1.5.1 %StringIteratorPrototype% 对象
%StringIteratorPrototype% 对象：

- 具有所有字符串迭代器对象继承的属性。
- 是一个普通对象。
- 具有 `[[Prototype]]` 内部槽，其值为 %IteratorPrototype%。
- 具有以下属性：

##### 22.1.5.1.1 %StringIteratorPrototype%.next ( )
1. 返回 `? GeneratorResume(this value, EMPTY, "%StringIteratorPrototype%")`。

##### 22.1.5.1.2 %StringIteratorPrototype% [ @@toStringTag ]
@@toStringTag 属性的初始值是字符串值 "String Iterator"。

该属性具有 `{ [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }` 属性。

### 22.2 RegExp（正则表达式）对象
RegExp 对象包含一个正则表达式及其关联的标志。

注：正则表达式的形式和功能仿照 Perl 5 编程语言中的正则表达式设施。

22.2.1 模式
RegExp 构造函数将以下语法应用于输入模式字符串。如果语法无法将字符串解释为模式的扩展，则会发生错误。

语法
Pattern[UnicodeMode, UnicodeSetsMode, NamedCaptureGroups] ::
Disjunction[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]
Disjunction[UnicodeMode, UnicodeSetsMode, NamedCaptureGroups] ::
Alternative[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]
Alternative[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] | Disjunction[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]
Alternative[UnicodeMode, UnicodeSetsMode, NamedCaptureGroups] ::
[empty]
Alternative[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] Term[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]
Term[UnicodeMode, UnicodeSetsMode, NamedCaptureGroups] ::
Assertion[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]
Atom[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]
Atom[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] Quantifier
Assertion[UnicodeMode, UnicodeSetsMode, NamedCaptureGroups] ::
^
$
\b
\B
(?= Disjunction[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] )
(?! Disjunction[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] )
(?<= Disjunction[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] )
(?<! Disjunction[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] )
Quantifier ::
QuantifierPrefix
QuantifierPrefix ?
QuantifierPrefix ::
*
+
?
{ DecimalDigits[~Sep] }
{ DecimalDigits[~Sep] ,}
{ DecimalDigits[~Sep] , DecimalDigits[~Sep] }
Atom[UnicodeMode, UnicodeSetsMode, NamedCaptureGroups] ::
PatternCharacter
.
\ AtomEscape[?UnicodeMode, ?NamedCaptureGroups]
CharacterClass[?UnicodeMode, ?UnicodeSetsMode]
( GroupSpecifier[?UnicodeMode]opt Disjunction[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] )
(?: Disjunction[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] )
SyntaxCharacter :: one of
^ $ \ . * + ? ( ) [ ] { } |
PatternCharacter ::
SourceCharacter but not SyntaxCharacter
AtomEscape[UnicodeMode, NamedCaptureGroups] ::
DecimalEscape
CharacterClassEscape[?UnicodeMode]
CharacterEscape[?UnicodeMode]
[+NamedCaptureGroups] k GroupName[?UnicodeMode]
CharacterEscape[UnicodeMode] ::
ControlEscape
c AsciiLetter
0 [lookahead ∉ DecimalDigit]
HexEscapeSequence
RegExpUnicodeEscapeSequence[?UnicodeMode]
IdentityEscape[?UnicodeMode]
ControlEscape :: one of
f n r t v
GroupSpecifier[UnicodeMode] ::
? GroupName[?UnicodeMode]
GroupName[UnicodeMode] ::
< RegExpIdentifierName[?UnicodeMode] >
RegExpIdentifierName[UnicodeMode] ::
RegExpIdentifierStart[?UnicodeMode]
RegExpIdentifierName[?UnicodeMode] RegExpIdentifierPart[?UnicodeMode]
RegExpIdentifierStart[UnicodeMode] ::
IdentifierStartChar
\ RegExpUnicodeEscapeSequence[+UnicodeMode]
[~UnicodeMode] UnicodeLeadSurrogate UnicodeTrailSurrogate
RegExpIdentifierPart[UnicodeMode] ::
IdentifierPartChar
\ RegExpUnicodeEscapeSequence[+UnicodeMode]
[~UnicodeMode] UnicodeLeadSurrogate UnicodeTrailSurrogate
RegExpUnicodeEscapeSequence[UnicodeMode] ::
[+UnicodeMode] u HexLeadSurrogate \u HexTrailSurrogate
[+UnicodeMode] u HexLeadSurrogate
[+UnicodeMode] u HexTrailSurrogate
[+UnicodeMode] u HexNonSurrogate
[~UnicodeMode] u Hex4Digits
[+UnicodeMode] u{ CodePoint }
UnicodeLeadSurrogate ::
any Unicode code point in the inclusive interval from U+D800 to U+DBFF
UnicodeTrailSurrogate ::
any Unicode code point in the inclusive interval from U+DC00 to U+DFFF
Each \u HexTrailSurrogate for which the choice of associated u HexLeadSurrogate is ambiguous shall be associated with the nearest possible u HexLeadSurrogate that would otherwise have no corresponding \u HexTrailSurrogate.

HexLeadSurrogate ::
Hex4Digits but only if the MV of Hex4Digits is in the inclusive interval from 0xD800 to 0xDBFF
HexTrailSurrogate ::
Hex4Digits but only if the MV of Hex4Digits is in the inclusive interval from 0xDC00 to 0xDFFF
HexNonSurrogate ::
Hex4Digits but only if the MV of Hex4Digits is not in the inclusive interval from 0xD800 to 0xDFFF
IdentityEscape[UnicodeMode] ::
[+UnicodeMode] SyntaxCharacter
[+UnicodeMode] /
[~UnicodeMode] SourceCharacter but not UnicodeIDContinue
DecimalEscape ::
NonZeroDigit DecimalDigits[~Sep]opt [lookahead ∉ DecimalDigit]
CharacterClassEscape[UnicodeMode] ::
d
D
s
S
w
W
[+UnicodeMode] p{ UnicodePropertyValueExpression }
[+UnicodeMode] P{ UnicodePropertyValueExpression }
UnicodePropertyValueExpression ::
UnicodePropertyName = UnicodePropertyValue
LoneUnicodePropertyNameOrValue
UnicodePropertyName ::
UnicodePropertyNameCharacters
UnicodePropertyNameCharacters ::
UnicodePropertyNameCharacter UnicodePropertyNameCharactersopt
UnicodePropertyValue ::
UnicodePropertyValueCharacters
LoneUnicodePropertyNameOrValue ::
UnicodePropertyValueCharacters
UnicodePropertyValueCharacters ::
UnicodePropertyValueCharacter UnicodePropertyValueCharactersopt
UnicodePropertyValueCharacter ::
UnicodePropertyNameCharacter
DecimalDigit
UnicodePropertyNameCharacter ::
AsciiLetter
_
CharacterClass[UnicodeMode, UnicodeSetsMode] ::
[ [lookahead ≠ ^] ClassContents[?UnicodeMode, ?UnicodeSetsMode] ]
[^ ClassContents[?UnicodeMode, ?UnicodeSetsMode] ]
ClassContents[UnicodeMode, UnicodeSetsMode] ::
[empty]
[~UnicodeSetsMode] NonemptyClassRanges[?UnicodeMode]
[+UnicodeSetsMode] ClassSetExpression
NonemptyClassRanges[UnicodeMode] ::
ClassAtom[?UnicodeMode]
ClassAtom[?UnicodeMode] NonemptyClassRangesNoDash[?UnicodeMode]
ClassAtom[?UnicodeMode] - ClassAtom[?UnicodeMode] ClassContents[?UnicodeMode, ~UnicodeSetsMode]
NonemptyClassRangesNoDash[UnicodeMode] ::
ClassAtom[?UnicodeMode]
ClassAtomNoDash[?UnicodeMode] NonemptyClassRangesNoDash[?UnicodeMode]
ClassAtomNoDash[?UnicodeMode] - ClassAtom[?UnicodeMode] ClassContents[?UnicodeMode, ~UnicodeSetsMode]
ClassAtom[UnicodeMode] ::
-
ClassAtomNoDash[?UnicodeMode]
ClassAtomNoDash[UnicodeMode] ::
SourceCharacter but not one of \ or ] or -
\ ClassEscape[?UnicodeMode]
ClassEscape[UnicodeMode] ::
b
[+UnicodeMode] -
CharacterClassEscape[?UnicodeMode]
CharacterEscape[?UnicodeMode]
ClassSetExpression ::
ClassUnion
ClassIntersection
ClassSubtraction
ClassUnion ::
ClassSetRange ClassUnionopt
ClassSetOperand ClassUnionopt
ClassIntersection ::
ClassSetOperand && [lookahead ≠ &] ClassSetOperand
ClassIntersection && [lookahead ≠ &] ClassSetOperand
ClassSubtraction ::
ClassSetOperand -- ClassSetOperand
ClassSubtraction -- ClassSetOperand
ClassSetRange ::
ClassSetCharacter - ClassSetCharacter
ClassSetOperand ::
NestedClass
ClassStringDisjunction
ClassSetCharacter
NestedClass ::
[ [lookahead ≠ ^] ClassContents[+UnicodeMode, +UnicodeSetsMode] ]
[^ ClassContents[+UnicodeMode, +UnicodeSetsMode] ]
\ CharacterClassEscape[+UnicodeMode]
NOTE 1
The first two lines here are equivalent to CharacterClass.

ClassStringDisjunction ::
\q{ ClassStringDisjunctionContents }
ClassStringDisjunctionContents ::
ClassString
ClassString | ClassStringDisjunctionContents
ClassString ::
[empty]
NonEmptyClassString
NonEmptyClassString ::
ClassSetCharacter NonEmptyClassStringopt
ClassSetCharacter ::
[lookahead ∉ ClassSetReservedDoublePunctuator] SourceCharacter but not ClassSetSyntaxCharacter
\ CharacterEscape[+UnicodeMode]
\ ClassSetReservedPunctuator
\b
ClassSetReservedDoublePunctuator :: one of
&& !! ## $$ %% ** ++ ,, .. :: ;; << == >> ?? @@ ^^ `` ~~
ClassSetSyntaxCharacter :: one of
( ) [ ] { } / - \ |
ClassSetReservedPunctuator :: one of
& - ! # % , : ; < = > @ ` ~
NOTE 2
A number of productions in this section are given alternative definitions in section B.1.2.

22.2.1.1 静态语义：早期错误
注意
本节在 B.1.2.1 中进行了修订。

Pattern :: Disjunction
如果 CountLeftCapturingParensWithin(Pattern) ≥ 2**32 - 1，则为语法错误。
如果 Pattern 包含两个或多个 GroupSpecifiers，其 GroupSpecifier 的 CapturingGroupName 相同，则为语法错误。
QuantifierPrefix :: { DecimalDigits , DecimalDigits }
如果第一个 DecimalDigits 的 MV 严格大于第二个 DecimalDigits 的 MV，则为语法错误。
AtomEscape :: k GroupName
如果 GroupSpecifiersThatMatch(Group

Name) 为空，则为语法错误。
AtomEscape :: DecimalEscape
如果 DecimalEscape 的 CapturingGroupNumber 严格大于包含 AtomEscape 的 Pattern 中的 CountLeftCapturingParensWithin，则为语法错误。
NonemptyClassRanges :: ClassAtom - ClassAtom ClassContents
如果第一个 ClassAtom 的 IsCharacterClass 为 true 或第二个 ClassAtom 的 IsCharacterClass 为 true，则为语法错误。
如果第一个 ClassAtom 的 IsCharacterClass 为 false，第二个 ClassAtom 的 IsCharacterClass 为 false，并且第一个 ClassAtom 的 CharacterValue 严格大于第二个 ClassAtom 的 CharacterValue，则为语法错误。
NonemptyClassRangesNoDash :: ClassAtomNoDash - ClassAtom ClassContents
如果 ClassAtomNoDash 的 IsCharacterClass 为 true 或 ClassAtom 的 IsCharacterClass 为 true，则为语法错误。
如果 ClassAtomNoDash 的 IsCharacterClass 为 false，ClassAtom 的 IsCharacterClass 为 false，并且 ClassAtomNoDash 的 CharacterValue 严格大于 ClassAtom 的 CharacterValue，则为语法错误。
RegExpIdentifierStart :: \ RegExpUnicodeEscapeSequence
如果 RegExpUnicodeEscapeSequence 的 CharacterValue 不是由 IdentifierStartChar 词法语法生成的某个代码点的数值，则为语法错误。
RegExpIdentifierStart :: UnicodeLeadSurrogate UnicodeTrailSurrogate
如果 RegExpIdentifierStart 的 RegExpIdentifierCodePoint 未由 UnicodeIDStart 词法语法生成，则为语法错误。
RegExpIdentifierPart :: \ RegExpUnicodeEscapeSequence
如果 RegExpUnicodeEscapeSequence 的 CharacterValue 不是由 IdentifierPartChar 词法语法生成的某个代码点的数值，则为语法错误。
RegExpIdentifierPart :: UnicodeLeadSurrogate UnicodeTrailSurrogate
如果 RegExpIdentifierPart 的 RegExpIdentifierCodePoint 未由 UnicodeIDContinue 词法语法生成，则为语法错误。
UnicodePropertyValueExpression :: UnicodePropertyName = UnicodePropertyValue
如果由 UnicodePropertyName 匹配的源文本不是表 66 中“属性名称和别名”列中列出的 Unicode 属性名称或属性别名，则为语法错误。
如果由 UnicodePropertyValue 匹配的源文本不是 PropertyValueAliases.txt 中给定的由 UnicodePropertyName 匹配的 Unicode 属性或属性别名的属性值或属性值别名，则为语法错误。
UnicodePropertyValueExpression :: LoneUnicodePropertyNameOrValue
如果由 LoneUnicodePropertyNameOrValue 匹配的源文本不是 PropertyValueAliases.txt 中列出的 General_Category (gc) 属性的 Unicode 属性值或属性值别名，也不是表 67 中“属性名称和别名”列中列出的二进制属性或二进制属性别名，也不是表 68 中“属性名称”列中列出的字符串的二进制属性，则为语法错误。
如果封闭模式没有 [UnicodeSetsMode] 参数，并且由 LoneUnicodePropertyNameOrValue 匹配的源文本是表 68 中“属性名称”列中列出的字符串的二进制属性，则为语法错误。
CharacterClassEscape :: P{ UnicodePropertyValueExpression }
如果 UnicodePropertyValueExpression 的 MayContainStrings 为 true，则为语法错误。
CharacterClass :: [^ ClassContents ]
如果 ClassContents 的 MayContainStrings 为 true，则为语法错误。
NestedClass :: [^ ClassContents ]
如果 ClassContents 的 MayContainStrings 为 true，则为语法错误。
ClassSetRange :: ClassSetCharacter - ClassSetCharacter
如果第一个 ClassSetCharacter 的 CharacterValue 严格大于第二个 ClassSetCharacter 的 CharacterValue，则为语法错误。

### 22.2.1.2 静态语义：CountLeftCapturingParensWithin（节点）

抽象操作 CountLeftCapturingParensWithin 接受参数节点（一个解析节点）并返回一个非负整数。它返回节点中左括号捕获组的数量。左括号捕获组是由 Atom :: ( GroupSpecifieropt Disjunction ) 生成的任何 ( 模式字符。

**注意**  
本节在 B.1.2.2 中进行了修订。

调用时执行以下步骤：

1. 断言：节点是 RegExp 模式语法中的一个生成实例。
2. 返回节点中包含的 Atom :: ( GroupSpecifieropt Disjunction ) 解析节点的数量。

### 22.2.1.3 静态语义：CountLeftCapturingParensBefore（节点）

抽象操作 CountLeftCapturingParensBefore 接受参数节点（一个解析节点）并返回一个非负整数。它返回在封闭模式内，节点左侧出现的左括号捕获组的数量。

**注意**  
本节在 B.1.2.2 中进行了修订。

调用时执行以下步骤：

1. 断言：节点是 RegExp 模式语法中的一个生成实例。
2. 令模式为包含节点的 Pattern。
3. 返回在模式中包含的，在节点之前出现或包含节点的 Atom :: ( GroupSpecifieropt Disjunction ) 解析节点的数量。

### 22.2.1.4 静态语义：CapturingGroupNumber

语法导向操作 CapturingGroupNumber 不接受参数并返回一个正整数。

**注意**  
本节在 B.1.2.1 中进行了修订。

它在以下生成上逐段定义：

**DecimalEscape :: NonZeroDigit**
1. 返回 NonZeroDigit 的 MV。

**DecimalEscape :: NonZeroDigit DecimalDigits**
1. 令 n 为 DecimalDigits 中代码点的数量。
2. 返回（NonZeroDigit 的 MV × 10^n 加上 DecimalDigits 的 MV）。

NonZeroDigit 和 DecimalDigits 的 MV 定义在 12.9.3 中。

### 22.2.1.5 静态语义：IsCharacterClass

语法导向操作 IsCharacterClass 不接受参数并返回一个布尔值。

**注意**  
本节在 B.1.2.3 中进行了修订。

它在以下生成上逐段定义：

**ClassAtom ::**
-
**ClassAtomNoDash ::**
SourceCharacter 但不包括 \ 或 ] 或 -

**ClassEscape ::**
b
-
CharacterEscape
1. 返回 false。

**ClassEscape :: CharacterClassEscape**
1. 返回 true。

### 22.2.1.6 静态语义：CharacterValue

语法导向操作 CharacterValue 不接受参数并返回一个非负整数。

**注意 1**  
本节在 B.1.2.4 中进行了修订。

它在以下生成上逐段定义：

**ClassAtom :: -**
1. 返回 U+002D（连字符）的数值。

**ClassAtomNoDash :: SourceCharacter 但不包括 \ 或 ] 或 -**
1. 令 ch 为由 SourceCharacter 匹配的代码点。
2. 返回 ch 的数值。

**ClassEscape :: b**
1. 返回 U+0008（退格）的数值。

**ClassEscape :: -**
1. 返回 U+002D（连字符）的数值。

**CharacterEscape :: ControlEscape**
1. 根据表 64 返回数值。

表 64：ControlEscape 代码点值

| ControlEscape | 数值 | 代码点 | Unicode 名称 | 符号 |
|---------------|------|--------|--------------|------|
| t             | 9    | U+0009 | 字符制表符   | <HT> |
| n             | 10   | U+000A | 换行符       | <LF> |
| v             | 11   | U+000B | 行制表符     | <VT> |
| f             | 12   | U+000C | 走纸换页符   | <FF> |
| r             | 13   | U+000D | 回车符       | <CR> |

**CharacterEscape :: c AsciiLetter**
1. 令 ch 为由 AsciiLetter 匹配的代码点。
2. 令 i 为 ch 的数值。
3. 返回 i 除以 32 的余数。

**CharacterEscape :: 0 [lookahead ∉ DecimalDigit]**
1. 返回 U+0000（空字符）的数值。

**注意 2**  
\0 表示 <NUL> 字符，后面不能跟随十进制数字。

**CharacterEscape :: HexEscapeSequence**
1. 返回 HexEscapeSequence 的 MV。

**RegExpUnicodeEscapeSequence :: u HexLeadSurrogate \u HexTrailSurrogate**
1. 令 lead 为 HexLeadSurrogate 的 CharacterValue。
2. 令 trail 为 HexTrailSurrogate 的 CharacterValue。
3. 令 cp 为 UTF16SurrogatePairToCodePoint(lead, trail)。
4. 返回 cp 的数值。

**RegExpUnicodeEscapeSequence :: u Hex4Digits**
1. 返回 Hex4Digits 的 MV。

**RegExpUnicodeEscapeSequence :: u{ CodePoint }**
1. 返回 CodePoint 的 MV。

**HexLeadSurrogate :: Hex4Digits**
**HexTrailSurrogate :: Hex4Digits**
**HexNonSurrogate :: Hex4Digits**
1. 返回 Hex4Digits 的 MV。

**CharacterEscape :: IdentityEscape**
1. 令 ch 为 IdentityEscape 匹配的代码点。
2. 返回 ch 的数值。

**ClassSetCharacter :: SourceCharacter 但不包括 ClassSetSyntaxCharacter**
1. 令 ch 为 SourceCharacter 匹配的代码点。
2. 返回 ch 的数值。

**ClassSetCharacter :: \ ClassSetReservedPunctuator**
1. 令 ch 为 ClassSetReservedPunctuator 匹配的代码点。
2. 返回 ch 的数值。

**ClassSetCharacter :: \b**
1. 返回 U+0008（退格）的数值。

### 22.2.1.7 静态语义：MayContainStrings

语法导向操作 MayContainStrings 不接受参数并返回一个布尔值。它在以下生成上逐段定义：

**CharacterClassEscape ::**
d
D
s
S
w
W
P{ UnicodePropertyValueExpression }

**UnicodePropertyValueExpression :: UnicodePropertyName = UnicodePropertyValue**
**NestedClass ::**
[^ ClassContents ]

**ClassContents ::**
[empty]
NonemptyClassRanges

**ClassSetOperand ::**
ClassSetCharacter
1. 返回 false。

**UnicodePropertyValueExpression :: LoneUnicodePropertyNameOrValue**
1. 如果由 LoneUnicodePropertyNameOrValue 匹配的源文本是表 68 中“属性名称”列中列出的字符串的二进制属性，则返回 true。
2. 返回 false。

**ClassUnion :: ClassSetRange ClassUnionopt**
1. 如果 ClassUnion 存在，则返回 ClassUnion 的 MayContainStrings。
2. 返回 false。

**ClassUnion :: ClassSetOperand ClassUnionopt**
1. 如果 ClassSetOperand 的 MayContainStrings 为 true，则返回 true。
2. 如果 ClassUnion 存在，则返回 ClassUnion 的 MayContainStrings。
3. 返回 false。

**ClassIntersection :: ClassSetOperand && ClassSetOperand**
1. 如果第一个 ClassSetOperand 的 MayContainStrings 为 false，则返回 false。
2. 如果第二个 ClassSetOperand 的 MayContainStrings 为 false，则返回 false。
3. 返回 true。

**ClassIntersection :: ClassIntersection && ClassSetOperand**
1. 如果 ClassIntersection 的 MayContainStrings 为 false，则返回 false。
2. 如果 ClassSetOperand 的 MayContainStrings 为 false，则返回 false。
3. 返回 true。

**ClassSubtraction :: ClassSetOperand -- ClassSetOperand**
1. 返回第一个 ClassSetOperand 的 MayContainStrings。

**ClassSubtraction :: ClassSubtraction -- ClassSetOperand**
1. 返回 ClassSubtraction 的 MayContainStrings。

**ClassStringDisjunctionContents :: ClassString | ClassStringDisjunctionContents**
1. 如果 ClassString 的 MayContainStrings 为 true，则返回 true。
2. 返回 ClassStringDisjunctionContents 的 MayContainStrings。

**ClassString :: [empty]**
1. 返回 true。

**ClassString :: NonEmptyClassString**
1. 返回 NonEmptyClassString 的 MayContainStrings。

**NonEmptyClassString :: ClassSetCharacter NonEmptyClassStringopt**
1. 如果 NonEmptyClassString 存在，则返回 true。
2. 返回 false。

### 22.2.1.8 静态语义：GroupSpecifiersThatMatch（thisGroupName）

抽象操作 GroupSpecifiersThatMatch 接受参数 thisGroupName（一个 GroupName 解析节点）并返回一个 GroupSpecifier 解析节点的列表。调用时执行以下步骤：

1. 令 name 为 thisGroupName 的 CapturingGroupName。
2. 令模式为包含 thisGroupName 的 Pattern。
3. 令结果为一个新的空列表。
4. 对于模式中包含的每个 GroupSpecifier gs，执行以下操作：
   a. 如果 gs 的 CapturingGroupName 是 name，则
      i. 将 gs 添加到结果中。
5. 返回结果。

### 22.2.1.9 静态语义：CapturingGroupName

语法导向操作 CapturingGroupName 不接受参数并返回一个字符串。它在以下生成

上逐段定义：

**GroupName :: < RegExpIdentifierName >**
1. 令 idTextUnescaped 为 RegExpIdentifierName 的 RegExpIdentifierCodePoints。
2. 返回 CodePointsToString(idTextUnescaped)。

### 22.2.1.10 静态语义：RegExpIdentifierCodePoints

语法导向操作 RegExpIdentifierCodePoints 不接受参数并返回一个代码点列表。它在以下生成上逐段定义：

**RegExpIdentifierName :: RegExpIdentifierStart**
1. 令 cp 为 RegExpIdentifierStart 的 RegExpIdentifierCodePoint。
2. 返回 « cp »。

**RegExpIdentifierName :: RegExpIdentifierName RegExpIdentifierPart**
1. 令 cps 为派生的 RegExpIdentifierName 的 RegExpIdentifierCodePoints。
2. 令 cp 为 RegExpIdentifierPart 的 RegExpIdentifierCodePoint。
3. 返回 cps 和 « cp » 的列表连接。

### 22.2.1.11 静态语义：RegExpIdentifierCodePoint

语法导向操作 RegExpIdentifierCodePoint 不接受参数并返回一个代码点。它在以下生成上逐段定义：

**RegExpIdentifierStart :: IdentifierStartChar**
1. 返回 IdentifierStartChar 匹配的代码点。

**RegExpIdentifierPart :: IdentifierPartChar**
1. 返回 IdentifierPartChar 匹配的代码点。

**RegExpIdentifierStart :: \ RegExpUnicodeEscapeSequence**
**RegExpIdentifierPart :: \ RegExpUnicodeEscapeSequence**
1. 返回数值为 RegExpUnicodeEscapeSequence 的 CharacterValue 的代码点。

**RegExpIdentifierStart :: UnicodeLeadSurrogate UnicodeTrailSurrogate**
**RegExpIdentifierPart :: UnicodeLeadSurrogate UnicodeTrailSurrogate**
1. 令 lead 为数值等于由 UnicodeLeadSurrogate 匹配的代码点的代码单元。
2. 令 trail 为数值等于由 UnicodeTrailSurrogate 匹配的代码点的代码单元。
3. 返回 UTF16SurrogatePairToCodePoint(lead, trail)。

### 22.2.2 模式语义

一个正则表达式模式会通过如下描述的过程转换为一个抽象闭包。鼓励实现使用比下面列出更高效的算法，只要结果相同。抽象闭包用于作为 RegExp 对象的 [[RegExpMatcher]] 内部槽的值。

如果模式的关联标志既不包含 `u` 也不包含 `v`，那么它是一个 BMP 模式。否则，它是一个 Unicode 模式。BMP 模式匹配的是被解释为由基本多文种平面（BMP）范围内的 Unicode 代码点组成的 16 位值序列的字符串。Unicode 模式匹配的是被解释为由使用 UTF-16 编码的 Unicode 代码点组成的字符串。在描述 BMP 模式的行为时，“字符”指的是单个 16 位的 Unicode BMP 代码点。在描述 Unicode 模式的行为时，“字符”指的是一个 UTF-16 编码的代码点（6.1.4）。在任一上下文中，“字符值”指的是相应未编码代码点的数值。

模式的语法和语义被定义为，如果模式的源文本是一个 SourceCharacter 值的列表，其中每个 SourceCharacter 对应于一个 Unicode 代码点。如果 BMP 模式包含非 BMP 的 SourceCharacter，则整个模式使用 UTF-16 编码，并使用该编码的各个代码单元作为列表的元素。

**注意**  
例如，考虑一个表示为单个非 BMP 字符 U+1D11E（音乐符号 G 谱号）的模式。解释为 Unicode 模式时，它将是一个包含单个代码点 U+1D11E 的单个元素（字符）列表。然而，解释为 BMP 模式时，它首先使用 UTF-16 编码，生成一个包含代码单元 0xD834 和 0xDD1E 的两个元素列表。

模式作为 ECMAScript 字符串值传递给 RegExp 构造函数，其中非 BMP 字符使用 UTF-16 编码。例如，表示为字符串值的单个字符音乐符号 G 谱号的模式是一个长度为 2 的字符串，其元素是代码单元 0xD834 和 0xDD1E。因此，无需进一步转换该字符串即可将其处理为由两个模式字符组成的 BMP 模式。然而，要将其处理为 Unicode 模式，必须使用 UTF16SurrogatePairToCodePoint 生成一个包含单个模式字符，即代码点 U+1D11E 的列表。

实现可能不会实际执行这种从或到 UTF-16 的转换，但本规范的语义要求模式匹配的结果如同执行了这些转换。

### 22.2.2.1 符号
以下描述使用了内部数据结构：

- **CharSetElement** 是以下两种实体之一：
  - 如果 rer.[[UnicodeSets]] 为 false，则 CharSetElement 是按照上述模式语义定义的字符。
  - 如果 rer.[[UnicodeSets]] 为 true，则 CharSetElement 是一个序列，其元素是按照上述模式语义定义的字符。这包括空序列、一个字符的序列和多个字符的序列。为方便起见，当处理这种类型的 CharSetElement 时，单个字符可以与一个字符的序列互换使用。
- **CharSet** 是一个 CharSetElements 的数学集合。
- **CaptureRange** 是一个记录 { [[StartIndex]], [[EndIndex]] }，表示捕获的字符范围，其中 [[StartIndex]] 是表示范围起始位置（包括）的整数，[[EndIndex]] 是表示范围结束位置（不包括）的整数。对于任何 CaptureRange，这些索引必须满足 [[StartIndex]] ≤ [[EndIndex]] 的不变量。
- **MatchState** 是一个记录 { [[Input]], [[EndIndex]], [[Captures]] }，其中 [[Input]] 是表示被匹配字符串的字符列表，[[EndIndex]] 是一个整数，[[Captures]] 是一个值列表，每个左括号捕获组对应一个值。状态用于表示正则表达式匹配算法中的部分匹配状态。[[EndIndex]] 是到目前为止模式匹配的最后一个输入字符的索引加 1，而 [[Captures]] 保存括号捕获的结果。[[Captures]] 的第 n 个元素是表示第 n 组括号捕获的字符范围的 CaptureRange，或未定义（如果第 n 组括号捕获尚未到达）。由于回溯，在匹配过程中可能会同时使用多个状态。
- **MatchResult** 是一个 MatchState 或表示匹配失败的特殊标记 FAILURE。
- **MatcherContinuation** 是一个抽象闭包，接受一个 MatchState 参数并返回一个 MatchResult 结果。MatcherContinuation 尝试从其 MatchState 参数给定的中间状态开始，匹配模式的剩余部分（由闭包捕获的值指定）与 Input。如果匹配成功，MatcherContinuation 返回其达到的最终 MatchState；如果匹配失败，MatcherContinuation 返回 FAILURE。
- **Matcher** 是一个抽象闭包，接受两个参数：一个 MatchState 和一个 MatcherContinuation，并返回一个 MatchResult 结果。Matcher 尝试从其 MatchState 参数给定的中间状态开始，匹配模式的中间子模式（由闭包捕获的值指定）与 MatchState 的 [[Input]]。MatcherContinuation 参数应是一个匹配模式其余部分的闭包。在将模式的子模式与新 MatchState 匹配以获得一个新的 MatchState 后，Matcher 然后调用 MatcherContinuation 以测试模式的其余部分是否也可以匹配。如果可以，Matcher 返回 MatcherContinuation 返回的 MatchState；如果不能，Matcher 可以在其选择点尝试不同的选择，重复调用 MatcherContinuation 直到成功或所有可能性都用尽为止。

### 22.2.2.1.1 正则表达式记录
正则表达式记录是一个用于存储编译期间和可能在匹配期间需要的正则表达式信息的记录值。

它包含以下字段：

| 字段名称 | 值 | 含义 |
|---------|----|------|
| [[IgnoreCase]] | 布尔值 | 表示 "i" 是否出现在正则表达式的标志中 |
| [[Multiline]] | 布尔值 | 表示 "m" 是否出现在正则表达式的标志中 |
| [[DotAll]] | 布尔值 | 表示 "s" 是否出现在正则表达式的标志中 |
| [[Unicode]] | 布尔值 | 表示 "u" 是否出现在正则表达式的标志中 |
| [[UnicodeSets]] | 布尔值 | 表示 "v" 是否出现在正则表达式的标志中 |
| [[CapturingGroupsCount]] | 非负整数 | 正则表达式模式中左括号捕获组的数量 |

### 22.2.2.2 运行时语义：CompilePattern
语法导向操作 CompilePattern 接受参数 rer（一个正则表达式记录）并返回一个抽象闭包，该闭包接受一个字符列表和一个非负整数，并返回一个 MatchResult。它在以下生成上逐段定义：

**Pattern :: Disjunction**
1. 令 m 为使用 rer 和 FORWARD 参数的 Disjunction 的 CompileSubpattern。
2. 返回一个新的抽象闭包，带有参数（Input, index），捕获 rer 和 m，并在调用时执行以下步骤：
   a. 断言：Input 是一个字符列表。
   b. 断言：0 ≤ index ≤ Input 中元素的数量。
   c. 令 c 为一个新的 MatcherContinuation，带有参数（y），不捕获任何东西，并在调用时执行以下步骤：
      i. 断言：y 是一个 MatchState。
      ii. 返回 y。
   d. 令 cap 为一个包含 rer.[[CapturingGroupsCount]] 个未定义值的列表，索引从 1 到 rer.[[CapturingGroupsCount]]。
   e. 令 x 为 MatchState { [[Input]]: Input, [[EndIndex]]: index, [[Captures]]: cap }。
   f. 返回 m(x, c)。

**注意**  
模式编译为一个抽象闭包值。RegExpBuiltinExec 然后可以将此过程应用于一个字符列表和该列表中的一个偏移量，以确定模式是否会从该列表中恰好该偏移量处开始匹配，以及如果匹配，捕获括号的值是什么。22.2.2 中的算法设计为，使得编译模式可能抛出 SyntaxError 异常；另一方面，一旦模式成功编译，将结果抽象闭包应用于字符列表以查找匹配不会抛出异常（除了任何可以在任何地方发生的实现定义的异常，如内存不足）。

### 22.2.2.3 运行时语义：CompileSubpattern
语法导向操作 CompileSubpattern 接受参数 rer（一个正则表达式记录）和方向（FORWARD 或 BACKWARD），并返回一个 Matcher。

**注意 1**  
本节在 B.1.2.5 中进行了修订。

它在以下生成上逐段定义：

**Disjunction :: Alternative | Disjunction**
1. 令 m1 为使用 rer 和 direction 参数的 Alternative 的 CompileSubpattern。
2

. 令 m2 为使用 rer 和 direction 参数的 Disjunction 的 CompileSubpattern。
3. 返回 MatchTwoAlternatives(m1, m2)。

**注意 2**  
正则表达式运算符 | 分隔两个备选项。模式首先尝试匹配左侧的 Alternative（然后是正则表达式的续集）；如果失败，则尝试匹配右侧的 Disjunction（然后是正则表达式的续集）。如果左侧的 Alternative、右侧的 Disjunction 和续集都有选择点，则续集中的所有选择在转向左侧 Alternative 的下一个选择之前都被尝试。如果左侧 Alternative 的选择耗尽，则尝试右侧 Disjunction 而不是左侧 Alternative。模式中由 | 跳过的部分内部的任何捕获括号生成未定义的值而不是字符串。因此，例如，

```javascript
/a|ab/.exec("abc")
```
返回结果 "a" 而不是 "ab"。此外，

```javascript
/((a)|(ab))((c)|(bc))/.exec("abc")
```
返回数组

```javascript
["abc", "a", "a", undefined, "bc", undefined, "bc"]
```
而不是

```javascript
["abc", "ab", undefined, "ab", "c", "c", undefined]
```
尝试两种选择的顺序与 direction 的值无关。

**Alternative :: [empty]**
1. 返回 EmptyMatcher()。

**Alternative :: Alternative Term**
1. 令 m1 为使用 rer 和 direction 参数的 Alternative 的 CompileSubpattern。
2. 令 m2 为使用 rer 和 direction 参数的 Term 的 CompileSubpattern。
3. 返回 MatchSequence(m1, m2, direction)。

**注意 3**  
连续的 Term 尝试同时匹配 Input 的连续部分。当 direction 为 FORWARD 时，如果左侧的 Alternative、右侧的 Term 和正则表达式的续集都有选择点，则续集中的所有选择在转向右侧 Term 的下一个选择之前都被尝试，右侧 Term 中的所有选择在转向左侧 Alternative 的下一个选择之前都被尝试。当 direction 为 BACKWARD 时，Alternative 和 Term 的求值顺序被颠倒。

**Term :: Assertion**
1. 返回使用 rer 参数的 Assertion 的 CompileAssertion。

**注意 4**  
生成的 Matcher 与 direction 无关。

**Term :: Atom**
1. 返回使用 rer 和 direction 参数的 Atom 的 CompileAtom。

**Term :: Atom Quantifier**
1. 令 m 为使用 rer 和 direction 参数的 Atom 的 CompileAtom。
2. 令 q 为 Quantifier 的 CompileQuantifier。
3. 断言：q.[[Min]] ≤ q.[[Max]]。
4. 令 parenIndex 为 CountLeftCapturingParensBefore(Term)。
5. 令 parenCount 为 CountLeftCapturingParensWithin(Atom)。
6. 返回一个新的 Matcher，带有参数（x, c），捕获 m, q, parenIndex 和 parenCount，并在调用时执行以下步骤：
   a. 断言：x 是一个 MatchState。
   b. 断言：c 是一个 MatcherContinuation。
   c. 返回 RepeatMatcher(m, q.[[Min]], q.[[Max]], q.[[Greedy]], x, c, parenIndex, parenCount)。

### 22.2.2.3.1 RepeatMatcher（m, min, max, greedy, x, c, parenIndex, parenCount）
抽象操作 RepeatMatcher 接受参数 m（一个 Matcher）、min（一个非负整数）、max（一个非负整数或 +∞）、greedy（一个布尔值）、x（一个 MatchState）、c（一个 MatcherContinuation）、parenIndex（一个非负整数）和 parenCount（一个非负整数），并返回一个 MatchResult。调用时执行以下步骤：

1. 如果 max = 0，返回 c(x)。
2. 令 d 为一个新的 MatcherContinuation，带有参数（y），捕获 m, min, max, greedy, x, c, parenIndex 和 parenCount，并在调用时执行以下步骤：
   a. 断言：y 是一个 MatchState。
   b. 如果 min = 0 且 y.[[EndIndex]] = x.[[EndIndex]]，返回 FAILURE。
   c. 如果 min = 0，令 min2 为 0；否则令 min2 为 min - 1。
   d. 如果 max = +∞，令 max2 为 +∞；否则令 max2 为 max - 1。
   e. 返回 RepeatMatcher(m, min2, max2, greedy, y, c, parenIndex, parenCount)。
3. 令 cap 为 x.[[Captures]] 的副本。
4. 对于从 parenIndex + 1 到 parenIndex + parenCount 的每个整数 k，将 cap[k] 设置为未定义。
5. 令 Input 为 x.[[Input]]。
6. 令 e 为 x.[[EndIndex]]。
7. 令 xr 为 MatchState { [[Input]]: Input, [[EndIndex]]: e, [[Captures]]: cap }。
8. 如果 min ≠ 0，返回 m(xr, d)。
9. 如果 greedy 为 false，则
   a. 令 z 为 c(x)。
   b. 如果 z 不是 FAILURE，返回 z。
   c. 返回 m(xr, d)。
10. 令 z 为 m(xr, d)。
11. 如果 z 不是 FAILURE，返回 z。
12. 返回 c(x)。

**注意 1**  
紧跟着 Quantifier 的 Atom 按照 Quantifier 指定的次数重复。Quantifier 可以是非贪婪的，在这种情况下，Atom 模式尽可能少地重复，同时仍然匹配续集；或者它可以是贪婪的，在这种情况下，Atom 模式尽可能多地重复，同时仍然匹配续集。重复的是 Atom 模式，而不是它匹配的输入字符序列，因此 Atom 的不同重复可以匹配不同的输入子串。

**注意 2**  
如果 Atom 和正则表达式的续集都有选择点，则首先尽可能多地（或者尽可能少地，如果是非贪婪）匹配 Atom。续集中的所有选择在转向 Atom 的最后一次重复的下一个选择之前都被尝试。Atom 的最后一次（第 n 次）重复中的所有选择在转向倒数第二次（第 n - 1 次）重复的下一个选择之前都被尝试；此时可能会发现可以更多或更少地重复 Atom；这些都被耗尽（再次从尽可能少或尽可能多开始）然后转向倒数第二次（第 n - 1 次）重复的下一个选择，依此类推。

比较

```javascript
/a[a-z]{2,4}/.exec("abcdefghi")
```
返回 "abcde" 和

```javascript
/a[a-z]{2,4}?/.exec("abcdefghi")
```
返回 "abc"。

再考虑

```javascript
/(aa|aabaac|ba|b|c)*/.exec("aabaac")
```
根据上述选择点排序，返回数组

```javascript
["aaba", "ba"]
```
而不是：

```javascript
["aabaac", "aabaac"]
["aabaac", "c"]
```
上面的选择点排序可以用于编写一个计算两个数的最大公约数的正则表达式（以一元表示法表示）。以下示例计算 10 和 15 的最大公约数：

```javascript
"aaaaaaaaaa,aaaaaaaaaaaaaaa".replace(/^(a+)\1*,\1+$/, "$1")
```
它返回一元表示法的最大公约数 "aaaaa"。

**注意 3**  
RepeatMatcher 的步骤 4 在每次重复 Atom 时清除 Atom 的捕获。我们可以在正则表达式中看到其行为：

```javascript
/(z)((a+)?(b+)?(c))*/.exec("zaacbbbcac")
```
返回数组

```javascript
["zaacbbbcac", "z", "ac", "a", undefined, "c"]
```
而不是

```javascript
["zaacbbbcac", "z", "ac", "a", "bbb", "c"]
```
因为外层 * 的每次迭代都清除量化 Atom 中包含的所有捕获字符串，在这种情况下包括编号为 2、3、4 和 5 的捕获字符串。

**注意 4**  
RepeatMatcher 的步骤 2.b 规定，一旦满足最小重复次数，任何匹配空字符序列的 Atom 的进一步扩展都不再考虑。这防止正则表达式引擎在以下模式上陷入无限循环：

```javascript
/(a*)*/.exec("b")
```
或稍微复杂一些的：

```javascript
/(a*)b\1+/.exec("baaaac")
```
返回数组

```javascript
["b", ""]
```

### 22.2.2.3.2 EmptyMatcher（）

抽象操作 EmptyMatcher 不接受参数并返回一个 Matcher。调用时执行以下步骤：

1. 返回一个新的 Matcher，带有参数（x, c），不捕获任何东西，并在调用时执行以下步骤：
   a. 断言：x 是一个 MatchState。
   b. 断言：c 是一个 MatcherContinuation。
   c. 返回 c(x)。

### 22.2.2.3.3 MatchTwoAlternatives（m1, m2）

抽象操作 MatchTwoAlternatives 接受参数 m1（一个 Matcher）和 m2（一个 Matcher），并返回一个 Matcher。调用时执行以下步骤：

1. 返回一个新的 Matcher，带有参数（x, c），捕获 m1 和 m2，并在调用时执行以下步骤：
   a. 断言：x 是一个 MatchState。
   b. 断言：c 是一个 MatcherContinuation。
   c. 令 r 为 m1(x, c)。
   d. 如果 r 不是 FAILURE，返回 r。
   e. 返回 m2(x, c)。

### 22.2.2.3.4 MatchSequence（m1, m2, direction）

抽象操作 MatchSequence 接受参数 m1（一个 Matcher）、m2（一个 Matcher）和 direction（FORWARD 或 BACKWARD），并返回一个 Matcher。调用时执行以下步骤：

1. 如果 direction 是 FORWARD，则
   a. 返回一个新的 Matcher，带有参数（x, c），捕获 m1 和 m2，并在调用时执行以下步骤：
      i. 断言：x 是一个 MatchState。
      ii. 断言：c 是一个 MatcherContinuation。
      iii. 令 d 为一个新的 MatcherContinuation，带有参数（y），捕获 c 和 m2，并在调用时执行以下步骤：
         1. 断言：y 是一个 MatchState。
         2. 返回 m2(y, c)。
      iv. 返回 m1(x, d)。
2. 否则，
   a. 断言：direction 是 BACKWARD。
   b. 返回一个新的 Matcher，带有参数（x, c），捕获 m1 和 m2，并在调用时执行以下步骤：
      i. 断言：x 是一个 MatchState。
      ii. 断言：c 是一个 MatcherContinuation。
      iii. 令 d 为一个新的 MatcherContinuation，带有参数（y），捕获 c 和 m1，并在调用时执行以下步骤：
         1. 断言：y 是一个 MatchState。
         2. 返回 m1(y, c)。
      iv. 返回 m2(x, d)。

### 22.2.2.4 运行时语义：CompileAssertion

语法导向操作 CompileAssertion 接受参数 rer（一个正则表达式记录），并返回一个 Matcher。

**注意 1**
本节在 B.1.2.6 中进行了修订。

它在以下生成上逐段定义：

**Assertion :: ^**
1. 返回一个新的 Matcher，带有参数（x, c），捕获 rer，并在调用时执行以下步骤：
   a. 断言：x 是一个 MatchState。
   b. 断言：c 是一个 MatcherContinuation。
   c. 令 Input 为 x.[[Input]]。
   d. 令 e 为 x.[[EndIndex]]。
   e. 如果 e = 0，或者 rer.[[Multiline]] 为 true 并且字符 Input[e - 1] 匹配 LineTerminator，则
      i. 返回 c(x)。
   f. 返回 FAILURE。

**注意 2**
即使模式使用 y 标志，^ 也只能匹配在 Input 的开头，或者（如果 rer.[[Multiline]] 为 true）在行的开头。

**Assertion :: $**
1. 返回一个新的 Matcher，带有参数（x, c），捕获 rer，并在调用时执行以下步骤：
   a. 断言：x 是一个 MatchState。
   b. 断言：c 是一个 MatcherContinuation。
   c. 令 Input 为 x.[[Input]]。
   d. 令 e 为 x.[[EndIndex]]。
   e. 令 InputLength 为 Input 中元素的数量。
   f. 如果 e = InputLength，或者 rer.[[Multiline]] 为 true 并且字符 Input[e] 匹配 LineTerminator，则
      i. 返回 c(x)。
   g. 返回 FAILURE。

**Assertion :: \b**
1. 返回一个新的 Matcher，带有参数（x, c），捕获 rer，并在调用时执行以下步骤：
   a. 断言：x 是一个 MatchState。
   b. 断言：c 是一个 MatcherContinuation。
   c. 令 Input 为 x.[[Input]]。
   d. 令 e 为 x.[[EndIndex]]。
   e. 令 a 为 IsWordChar(rer, Input, e - 1)。
   f. 令 b 为 IsWordChar(rer, Input, e)。
   g. 如果 a 为 true 并且 b 为 false，或者 a 为 false 并且 b 为 true，返回 c(x)。
   h. 返回 FAILURE。

**Assertion :: \B**
1. 返回一个新的 Matcher，带有参数（x, c），捕获 rer，并在调用时执行以下步骤：
   a. 断言：x 是一个 MatchState。
   b. 断言：c 是一个 MatcherContinuation。
   c. 令 Input 为 x.[[Input]]。
   d. 令 e 为 x.[[EndIndex]]。
   e. 令 a 为 IsWordChar(rer, Input, e - 1)。
   f. 令 b 为 IsWordChar(rer, Input, e)。
   g. 如果 a 为 true 并且 b 为 true，或者 a 为 false 并且 b 为 false，返回 c(x)。
   h. 返回 FAILURE。

**Assertion :: (?= Disjunction)**
1. 令 m 为使用 rer 和 FORWARD 参数的 Disjunction 的 CompileSubpattern。
2. 返回一个新的 Matcher，带有参数（x, c），捕获 m，并在调用时执行以下步骤：
   a. 断言：x 是一个 MatchState。
   b. 断言：c 是一个 MatcherContinuation。
   c. 令 d 为一个新的 MatcherContinuation，带有参数（y），不捕获任何东西，并在调用时执行以下步骤：
      i. 断言：y 是一个 MatchState。
      ii. 返回 y。
   d. 令 r 为 m(x, d)。
   e. 如果 r 是 FAILURE，返回 FAILURE。
   f. 断言：r 是一个 MatchState。
   g. 令 cap 为 r.[[Captures]]。
   h. 令 Input 为 x.[[Input]]。
   i. 令 xe 为 x.[[EndIndex]]。
   j. 令 z 为 MatchState { [[Input]]: Input, [[EndIndex]]: xe, [[Captures]]: cap }。
   k. 返回 c(z)。

**注意 3**
形式 (?= Disjunction) 指定一个零宽度的正向先行断言。为了成功，Disjunction 内的模式必须在当前位置匹配，但当前位置在匹配续集之前不会前移。如果 Disjunction 能够在当前位置以多种方式匹配，则只尝试第一种方式。与其他正则表达式运算符不同，(?= 形式中没有回溯（这种不寻常的行为继承自 Perl）。这只有在 Disjunction 包含捕获括号并且模式的续集包含对这些捕获的反向引用时才重要。

例如，

```javascript
/(?=(a+))/.exec("baaabac")
```
匹配第一个 b 之后的空字符串，因此返回数组：

```javascript
["", "aaa"]
```
为了说明缺乏回溯进入先行断言，请考虑：

```javascript
/(?=(a+))a*b\1/.exec("baaabac")
```
此表达式返回

```javascript
["aba", "a"]
```
而不是：

```javascript
["aaaba", "a"]
```

**Assertion :: (?! Disjunction)**
1. 令 m 为使用 rer 和 FORWARD 参数的 Disjunction 的 CompileSubpattern。
2. 返回一个新的 Matcher，带有参数（x, c），捕获 m，并在调用时执行以下步骤：
   a. 断言：x 是一个 MatchState。
   b. 断言：c 是一个 MatcherContinuation。
   c. 令 d 为一个新的 MatcherContinuation，带有参数（y），不捕获任何东西，并在调用时执行以下步骤：
      i. 断言：y 是一个 MatchState。
      ii. 返回 y。
   d. 令 r 为 m(x, d)。
   e. 如果 r 不是 FAILURE，返回 FAILURE。
   f. 返回 c(x)。

**注意 4**
形式 (?! Disjunction) 指定一个零宽度的负向先行断言。为了成功，Disjunction 内的模式必须在当前位置匹配失败。当前位置在匹配续集之前不会前移。Disjunction 可以包含捕获括号，但对它们的反向引用只有在 Disjunction 内部才有意义。从模式的其他地方对这些捕获括号的反向引用总是返回未定义，因为负

向先行断言必须失败才能使模式成功。例如，

```javascript
/(.*?)a(?!(a+)b\2c)\2(.*)/.exec("baaabaac")
```
寻找一个 a，其后不是某个正数 n 的 a，b，另一个 n 的 a（由第一个 \2 指定）和一个 c。第二个 \2 在负向先行断言之外，因此匹配未定义，因此总是成功。整个表达式返回数组：

```javascript
["baaabaac", "ba", undefined, "abaac"]
```

**Assertion :: (?<= Disjunction)**
1. 令 m 为使用 rer 和 BACKWARD 参数的 Disjunction 的 CompileSubpattern。
2. 返回一个新的 Matcher，带有参数（x, c），捕获 m，并在调用时执行以下步骤：
   a. 断言：x 是一个 MatchState。
   b. 断言：c 是一个 MatcherContinuation。
   c. 令 d 为一个新的 MatcherContinuation，带有参数（y），不捕获任何东西，并在调用时执行以下步骤：
      i. 断言：y 是一个 MatchState。
      ii. 返回 y。
   d. 令 r 为 m(x, d)。
   e. 如果 r 是 FAILURE，返回 FAILURE。
   f. 断言：r 是一个 MatchState。
   g. 令 cap 为 r.[[Captures]]。
   h. 令 Input 为 x.[[Input]]。
   i. 令 xe 为 x.[[EndIndex]]。
   j. 令 z 为 MatchState { [[Input]]: Input, [[EndIndex]]: xe, [[Captures]]: cap }。
   k. 返回 c(z)。

**Assertion :: (?<! Disjunction)**
1. 令 m 为使用 rer 和 BACKWARD 参数的 Disjunction 的 CompileSubpattern。
2. 返回一个新的 Matcher，带有参数（x, c），捕获 m，并在调用时执行以下步骤：
   a. 断言：x 是一个 MatchState。
   b. 断言：c 是一个 MatcherContinuation。
   c. 令 d 为一个新的 MatcherContinuation，带有参数（y），不捕获任何东西，并在调用时执行以下步骤：
      i. 断言：y 是一个 MatchState。
      ii. 返回 y。
   d. 令 r 为 m(x, d)。
   e. 如果 r 不是 FAILURE，返回 FAILURE。
   f. 返回 c(x)。

### 22.2.2.4.1 IsWordChar（rer, Input, e）

抽象操作 IsWordChar 接受参数 rer（一个正则表达式记录）、Input（一个字符列表）和 e（一个整数），并返回一个布尔值。调用时执行以下步骤：

1. 令 InputLength 为 Input 中元素的数量。
2. 如果 e = -1 或 e = InputLength，返回 false。
3. 令 c 为字符 Input[e]。
4. 如果 WordCharacters(rer) 包含 c，返回 true。
5. 返回 false。

### 22.2.2.5 运行时语义：CompileQuantifier

语法导向操作 CompileQuantifier 不接受参数，并返回一个记录，包含字段 [[Min]]（一个非负整数）、[[Max]]（一个非负整数或 +∞）和 [[Greedy]]（一个布尔值）。它在以下生成上逐段定义：

**Quantifier :: QuantifierPrefix**
1. 令 qp 为 QuantifierPrefix 的 CompileQuantifierPrefix。
2. 返回记录 { [[Min]]: qp.[[Min]], [[Max]]: qp.[[Max]], [[Greedy]]: true }。

**Quantifier :: QuantifierPrefix ?**
1. 令 qp 为 QuantifierPrefix 的 CompileQuantifierPrefix。
2. 返回记录 { [[Min]]: qp.[[Min]], [[Max]]: qp.[[Max]], [[Greedy]]: false }。

### 22.2.2.6 运行时语义：CompileQuantifierPrefix

语法导向操作 CompileQuantifierPrefix 不接受参数，并返回一个记录，包含字段 [[Min]]（一个非负整数）和 [[Max]]（一个非负整数或 +∞）。它在以下生成上逐段定义：

**QuantifierPrefix :: ***  
1. 返回记录 { [[Min]]: 0, [[Max]]: +∞ }。

**QuantifierPrefix :: +**  
1. 返回记录 { [[Min]]: 1, [[Max]]: +∞ }。

**QuantifierPrefix :: ?**  
1. 返回记录 { [[Min]]: 0, [[Max]]: 1 }。

**QuantifierPrefix :: { DecimalDigits }**  
1. 令 i 为 DecimalDigits 的 MV（见 12.9.3）。
2. 返回记录 { [[Min]]: i, [[Max]]: i }。

**QuantifierPrefix :: { DecimalDigits ,}**  
1. 令 i 为 DecimalDigits 的 MV。
2. 返回记录 { [[Min]]: i, [[Max]]: +∞ }。

**QuantifierPrefix :: { DecimalDigits , DecimalDigits }**  
1. 令 i 为第一个 DecimalDigits 的 MV。
2. 令 j 为第二个 DecimalDigits 的 MV。
3. 返回记录 { [[Min]]: i, [[Max]]: j }。

### 22.2.2.7 运行时语义：CompileAtom

语法导向操作 CompileAtom 接受参数 rer（一个正则表达式记录）和 direction（FORWARD 或 BACKWARD），并返回一个 Matcher。

**注意 1**  
本节在 B.1.2.7 中进行了修订。

它在以下生成上逐段定义：

**Atom :: PatternCharacter**
1. 令 ch 为 PatternCharacter 匹配的字符。
2. 令 A 为包含字符 ch 的单元素字符集。
3. 返回 CharacterSetMatcher(rer, A, false, direction)。

**Atom :: .**
1. 令 A 为 AllCharacters(rer)。
2. 如果 rer.[[DotAll]] 不为 true，则
   a. 从 A 中移除所有对应于 LineTerminator 生成右侧代码点的字符。
3. 返回 CharacterSetMatcher(rer, A, false, direction)。

**Atom :: CharacterClass**
1. 令 cc 为 CharacterClass 的 CompileCharacterClass，参数为 rer。
2. 令 cs 为 cc.[[CharSet]]。
3. 如果 rer.[[UnicodeSets]] 为 false，或者 cs 的每个 CharSetElement 都由单个字符组成（包括 cs 为空时），返回 CharacterSetMatcher(rer, cs, cc.[[Invert]], direction)。
4. 断言：cc.[[Invert]] 为 false。
5. 令 lm 为空的 Matcher 列表。
6. 对于 cs 中每个包含多个字符的 CharSetElement，按长度递减顺序迭代，执行以下步骤：
   a. 令 cs2 为包含 s 的最后一个代码点的单元素字符集。
   b. 令 m2 为 CharacterSetMatcher(rer, cs2, false, direction)。
   c. 对于 s 中的每个代码点 c1，从倒数第二个代码点开始向后迭代，执行以下步骤：
      i. 令 cs1 为包含 c1 的单元素字符集。
      ii. 令 m1 为 CharacterSetMatcher(rer, cs1, false, direction)。
      iii. 将 m2 设置为 MatchSequence(m1, m2, direction)。
   d. 将 m2 附加到 lm。
7. 令 singles 为包含 cs 中每个由单个字符组成的 CharSetElement 的字符集。
8. 将 CharacterSetMatcher(rer, singles, false, direction) 附加到 lm。
9. 如果 cs 包含空字符序列，则将 EmptyMatcher() 附加到 lm。
10. 令 m2 为 lm 中的最后一个 Matcher。
11. 对于 lm 中的每个 Matcher m1，从倒数第二个元素开始向后迭代，执行以下步骤：
    a. 将 m2 设置为 MatchTwoAlternatives(m1, m2)。
12. 返回 m2。

**Atom :: ( GroupSpecifieropt Disjunction )**
1. 令 m 为使用 rer 和 direction 参数的 Disjunction 的 CompileSubpattern。
2. 令 parenIndex 为 CountLeftCapturingParensBefore(Atom)。
3. 返回一个新的 Matcher，带有参数（x, c），捕获 direction, m 和 parenIndex，并在调用时执行以下步骤：
   a. 断言：x 是一个 MatchState。
   b. 断言：c 是一个 MatcherContinuation。
   c. 令 d 为一个新的 MatcherContinuation，带有参数（y），捕获 x, c, direction 和 parenIndex，并在调用时执行以下步骤：
      i. 断言：y 是一个 MatchState。
      ii. 令 cap 为 y.[[Captures]] 的副本。
      iii. 令 Input 为 x.[[Input]]。
      iv. 令 xe 为 x.[[EndIndex]]。
      v. 令 ye 为 y.[[EndIndex]]。
      vi. 如果 direction 为 FORWARD，则
         1. 断言：xe ≤ ye。
         2. 令 r 为 CaptureRange { [[StartIndex]]: xe, [[EndIndex]]: ye }。
      vii. 否则，
         1. 断言：direction 为 BACKWARD。
         2. 断言：ye ≤ xe。
         3. 令 r 为 CaptureRange { [[StartIndex]]: ye, [[EndIndex]]: xe }。
      viii. 将 cap[parenIndex + 1] 设置为 r。
      ix. 令 z 为 MatchState { [[Input]]: Input, [[EndIndex]]: ye, [[Captures]]: cap }。
      x. 返回 c(z)。
   d. 返回 m(x, d)。

**注意 2**  
形式 ( Disjunction ) 的括号既用于将 Disjunction 模式的组件组合在一起，又用于保存匹配结果。结果可以用于反向引用（\ 后跟一个非零十进制数）、在替换字符串中引用，或作为正则表达式匹配抽象闭包的一部分返回。要禁止括号的捕获行为，请使用形式 (?: Disjunction )。

**Atom :: (?: Disjunction )**
1. 返回使用 rer 和 direction 参数的 Disjunction 的 CompileSubpattern。

**AtomEscape :: DecimalEscape**
1. 令 n 为 DecimalEscape 的 CapturingGroupNumber。
2. 断言：n ≤ rer.[[CapturingGroupsCount]]。
3. 返回 BackreferenceMatcher(rer, n, direction)。

**注意 3**  
形式 \ 后跟一个非零十进制数 n 的转义序列匹配第 n 组捕获括号的结果（22.2.2.1）。如果正则表达式的捕获括号少于 n，则会出错。如果正则表达式有 n 个或更多捕获括号，但第 n 个未定义，因为它没有捕获任何东西，则反向引用总是成功。

**AtomEscape :: CharacterEscape**
1. 令 cv 为 CharacterEscape 的 CharacterValue。
2. 令 ch 为字符值为 cv 的字符。
3. 令 A 为包含字符 ch 的单元素字符集。
4. 返回 CharacterSetMatcher(rer, A, false, direction)。

**AtomEscape :: CharacterClassEscape**
1. 令 cs 为使用 rer 参数的 CharacterClassEscape 的 CompileToCharSet。
2. 如果 rer.[[UnicodeSets]] 为 false，或者 cs 的每个 CharSetElement 都由单个字符组成（包括 cs 为空时），返回 CharacterSetMatcher(rer, cs, false, direction)。
3. 令 lm 为空的 Matcher 列表。
4. 对于 cs 中每个包含多个字符的 CharSetElement，按长度递减顺序迭代，执行以下步骤：
   a. 令 cs2 为包含 s 的最后一个代码点的单元素字符集。
   b. 令 m2 为 CharacterSetMatcher(rer, cs2, false, direction)。
   c. 对于 s 中的每个代码点 c1，从倒数第二个代码点开始向后迭代，执行以下步骤：
      i. 令 cs1 为包含 c1 的单元素字符集。
      ii. 令 m1 为 CharacterSetMatcher(rer, cs1, false, direction)。
      iii. 将 m2 设置为 MatchSequence(m1, m2, direction)。
   d. 将 m2 附加到 lm。
5. 令 singles 为包含 cs 中每个由单个字符组成的 CharSetElement 的字符集。
6. 将 CharacterSetMatcher(rer, singles, false, direction) 附加到 lm。
7. 如果 cs 包含空字符序列，则将 EmptyMatcher() 附加到 lm。
8. 令 m2 为 lm 中的最后一个 Matcher。
9. 对于 lm 中的每个 Matcher m1，从倒数第二个元素开始向后迭代，执行以下步骤：
    a. 将 m2 设置为 MatchTwoAlternatives(m1, m2)。
10. 返回 m2。

**AtomEscape :: k GroupName**
1. 令 matchingGroupSpecifiers 为 GroupSpecifiersThatMatch(GroupName)。
2. 断言：matchingGroupSpecifiers 包含一个 GroupSpecifier。
3. 令 groupSpecifier 为 matchingGroupSpecifiers 的唯一元素。
4. 令 parenIndex 为 CountLeftCapturingParensBefore(groupSpecifier)。
5. 返回 BackreferenceMatcher(rer, parenIndex, direction)。

### 22.2.2.7.1 CharacterSetMatcher（rer, A, invert, direction）

抽象操作 CharacterSetMatcher 接受参数 rer（一个正则表达式记录）、A（一个字符集）、invert（一个布尔值）和 direction（FORWARD 或 BACKWARD），并返回一个 Matcher。调用时执行以下步骤：

1. 如果 rer.[[UnicodeSets]] 为 true，则
   a. 断言：invert 为 false。
   b. 断言：A 的每个 CharSetElement 都由单个字符组成。
2. 返回一个新的 Matcher，带有参数（x, c），捕获 rer, A, invert 和 direction，并在调用时执行以下步骤：
   a. 断言：x 是一个 MatchState。
   b. 断言：c 是一个 MatcherContinuation。
   c. 令 Input 为 x.[[Input]]。
   d. 令 e 为 x.[[EndIndex]]。
   e. 如果 direction 为 FORWARD，令 f 为 e + 1。
   f. 否则

，令 f 为 e - 1。
   g. 令 InputLength 为 Input 中元素的数量。
   h. 如果 f < 0 或 f > InputLength，返回 FAILURE。
   i. 令 index 为 min(e, f)。
   j. 令 ch 为字符 Input[index]。
   k. 令 cc 为 Canonicalize(rer, ch)。
   l. 如果 A 中存在一个 CharSetElement，其中包含一个字符 a，使得 Canonicalize(rer, a) 是 cc，令 found 为 true。否则，令 found 为 false。
   m. 如果 invert 为 false 且 found 为 false，返回 FAILURE。
   n. 如果 invert 为 true 且 found 为 true，返回 FAILURE。
   o. 令 cap 为 x.[[Captures]]。
   p. 令 y 为 MatchState { [[Input]]: Input, [[EndIndex]]: f, [[Captures]]: cap }。
   q. 返回 c(y)。

### 22.2.2.7.2 BackreferenceMatcher（rer, n, direction）

抽象操作 BackreferenceMatcher 接受参数 rer（一个正则表达式记录）、n（一个正整数）和 direction（FORWARD 或 BACKWARD），并返回一个 Matcher。调用时执行以下步骤：

1. 断言：n ≥ 1。
2. 返回一个新的 Matcher，带有参数（x, c），捕获 rer, n 和 direction，并在调用时执行以下步骤：
   a. 断言：x 是一个 MatchState。
   b. 断言：c 是一个 MatcherContinuation。
   c. 令 Input 为 x.[[Input]]。
   d. 令 cap 为 x.[[Captures]]。
   e. 令 r 为 cap[n]。
   f. 如果 r 未定义，返回 c(x)。
   g. 令 e 为 x.[[EndIndex]]。
   h. 令 rs 为 r.[[StartIndex]]。
   i. 令 re 为 r.[[EndIndex]]。
   j. 令 len 为 re - rs。
   k. 如果 direction 为 FORWARD，令 f 为 e + len。
   l. 否则，令 f 为 e - len。
   m. 令 InputLength 为 Input 中元素的数量。
   n. 如果 f < 0 或 f > InputLength，返回 FAILURE。
   o. 令 g 为 min(e, f)。
   p. 如果存在整数 i 在从 0（含）到 len（不含）的区间内，使得 Canonicalize(rer, Input[rs + i]) 不等于 Canonicalize(rer, Input[g + i])，返回 FAILURE。
   q. 令 y 为 MatchState { [[Input]]: Input, [[EndIndex]]: f, [[Captures]]: cap }。
   r. 返回 c(y)。

### 22.2.2.7.3 Canonicalize（rer, ch）

抽象操作 Canonicalize 接受参数 rer（一个正则表达式记录）和 ch（一个字符），并返回一个字符。调用时执行以下步骤：

1. 如果 HasEitherUnicodeFlag(rer) 为 true 且 rer.[[IgnoreCase]] 为 true，则
   a. 如果 Unicode 字符数据库的 CaseFolding.txt 文件为 ch 提供了一个简单或常见的大小写折叠映射，则返回应用该映射到 ch 的结果。
   b. 返回 ch。
2. 如果 rer.[[IgnoreCase]] 为 false，返回 ch。
3. 断言：ch 是一个 UTF-16 代码单元。
4. 令 cp 为代码点，其数值为 ch 的数值。
5. 令 u 为按照 Unicode 默认大小写转换算法将 cp 转为大写后的结果。
6. 令 uStr 为 CodePointsToString(u)。
7. 如果 uStr 的长度不等于 1，返回 ch。
8. 令 cu 为 uStr 的唯一代码单元元素。
9. 如果 ch 的数值 ≥ 128 且 cu 的数值 < 128，返回 ch。
10. 返回 cu。

**注意**  
在 HasEitherUnicodeFlag(rer) 为 true 时进行不区分大小写的匹配时，所有字符都隐式地使用 Unicode 标准提供的简单映射进行大小写折叠，立即在比较之前应用。简单映射总是映射到单个代码点，所以它不会将 ß (U+00DF) 映射到 ss 或 SS。然而，它可能会将基本拉丁块之外的代码点映射到其中的代码点。例如，ſ (U+017F) 映射到 s (U+0073)，K (U+212A) 映射到 k (U+006B)。包含这些代码点的字符串会被正则表达式 /[a-z]/ui 匹配。

在 HasEitherUnicodeFlag(rer) 为 false 时进行不区分大小写的匹配时，映射基于 Unicode 默认大小写转换算法 toUppercase 而不是 toCasefold，这导致一些细微的差异。例如，Ω (U+2126) 被 toUppercase 映射到其自身，但被 toCasefold 映射到 ω (U+03C9) 和 Ω (U+03A9)，所以 "\u2126" 被 /[ω]/ui 和 /[\u03A9]/ui 匹配，但不被 /[ω]/i 或 /[\u03A9]/i 匹配。此外，没有基本拉丁块之外的代码点被映射到其中的代码点，所以字符串 "\u017F ſ" 和 "\u212A K" 不被 /[a-z]/i 匹配。

### 22.2.2.8 运行时语义：CompileCharacterClass

语法导向操作 CompileCharacterClass 接受参数 rer（一个正则表达式记录），并返回一个记录，包含字段 [[CharSet]]（一个字符集）和 [[Invert]]（一个布尔值）。它在以下生成上逐段定义：

**CharacterClass :: [ ClassContents ]**
1. 令 A 为使用 rer 参数的 ClassContents 的 CompileToCharSet。
2. 返回记录 { [[CharSet]]: A, [[Invert]]: false }。

**CharacterClass :: [^ ClassContents ]**
1. 令 A 为使用 rer 参数的 ClassContents 的 CompileToCharSet。
2. 如果 rer.[[UnicodeSets]] 为 true，则
   a. 返回记录 { [[CharSet]]: CharacterComplement(rer, A), [[Invert]]: false }。
3. 返回记录 { [[CharSet]]: A, [[Invert]]: true }。

### 22.2.2.9 运行时语义：CompileToCharSet

语法导向操作 CompileToCharSet 接受参数 rer（一个正则表达式记录），并返回一个字符集。

**注意 1**  
本节在 B.1.2.8 中进行了修订。

它在以下生成上逐段定义：

**ClassContents :: [empty]**
1. 返回空字符集。

**NonemptyClassRanges :: ClassAtom NonemptyClassRangesNoDash**
1. 令 A 为使用 rer 参数的 ClassAtom 的 CompileToCharSet。
2. 令 B 为使用 rer 参数的 NonemptyClassRangesNoDash 的 CompileToCharSet。
3. 返回字符集 A 和 B 的并集。

**NonemptyClassRanges :: ClassAtom - ClassAtom ClassContents**
1. 令 A 为使用 rer 参数的第一个 ClassAtom 的 CompileToCharSet。
2. 令 B 为使用 rer 参数的第二个 ClassAtom 的 CompileToCharSet。
3. 令 C 为使用 rer 参数的 ClassContents 的 CompileToCharSet。
4. 令 D 为 CharacterRange(A, B)。
5. 返回 D 和 C 的并集。

**NonemptyClassRangesNoDash :: ClassAtomNoDash NonemptyClassRangesNoDash**
1. 令 A 为使用 rer 参数的 ClassAtomNoDash 的 CompileToCharSet。
2. 令 B 为使用 rer 参数的 NonemptyClassRangesNoDash 的 CompileToCharSet。
3. 返回字符集 A 和 B 的并集。

**NonemptyClassRangesNoDash :: ClassAtomNoDash - ClassAtom ClassContents**
1. 令 A 为使用 rer 参数的 ClassAtomNoDash 的 CompileToCharSet。
2. 令 B 为使用 rer 参数的 ClassAtom 的 CompileToCharSet。
3. 令 C 为使用 rer 参数的 ClassContents 的 CompileToCharSet。
4. 令 D 为 CharacterRange(A, B)。
5. 返回 D 和 C 的并集。

**注意 2**  
ClassContents 可以扩展为单个 ClassAtom 和/或由破折号分隔的两个 ClassAtom 的范围。在后一种情况下，ClassContents 包括从第一个 ClassAtom 到第二个 ClassAtom 之间的所有字符（含）；如果任何一个 ClassAtom 不表示单个字符（例如，如果一个是 \w），或者第一个 ClassAtom 的字符值严格大于第二个 ClassAtom 的字符值，则会发生错误。

**注意 3**  
即使模式忽略大小写，范围两端的大小写在确定哪些字符属于范围时也很重要。因此，例如，模式 /[E-F]/i 只匹配字母 E、F、e 和 f，而模式 /[E-f]/i 匹配 Unicode 基本拉丁块中的所有大写和小写字母以及符号 [、\、]、^

、_ 和 `。

**注意 4**  
- 字符可以按字面意义解释，也可以表示范围。如果它是 ClassContents 的第一个或最后一个字符，范围规范的开始或结束限制，或紧随范围规范之后，则按字面意义解释。

**ClassAtom :: -**
1. 返回包含单个字符 - U+002D（连字符-减号）的字符集。

**ClassAtomNoDash :: SourceCharacter but not one of \ or ] or -**
1. 返回包含由 SourceCharacter 匹配的字符的字符集。

**ClassEscape ::**
b
-
CharacterEscape
1. 令 cv 为此 ClassEscape 的 CharacterValue。
2. 令 c 为字符值为 cv 的字符。
3. 返回包含单个字符 c 的字符集。

**注意 5**  
ClassAtom 可以使用正则表达式其余部分中允许的任何转义序列，除了 \b、\B 和反向引用。在 CharacterClass 中，\b 表示退格字符，而 \B 和反向引用会引发错误。在 ClassAtom 中使用反向引用会导致错误。

**CharacterClassEscape :: d**
1. 返回包含字符 0、1、2、3、4、5、6、7、8 和 9 的十元素字符集。

**CharacterClassEscape :: D**
1. 令 S 为 CharacterClassEscape :: d 返回的字符集。
2. 返回 CharacterComplement(rer, S)。

**CharacterClassEscape :: s**
1. 返回包含所有对应于 WhiteSpace 或 LineTerminator 生成右侧代码点的字符的字符集。

**CharacterClassEscape :: S**
1. 令 S 为 CharacterClassEscape :: s 返回的字符集。
2. 返回 CharacterComplement(rer, S)。

**CharacterClassEscape :: w**
1. 返回 MaybeSimpleCaseFolding(rer, WordCharacters(rer))。

**CharacterClassEscape :: W**
1. 令 S 为 CharacterClassEscape :: w 返回的字符集。
2. 返回 CharacterComplement(rer, S)。

**CharacterClassEscape :: p{ UnicodePropertyValueExpression }**
1. 返回使用 rer 参数的 UnicodePropertyValueExpression 的 CompileToCharSet。

**CharacterClassEscape :: P{ UnicodePropertyValueExpression }**
1. 令 S 为使用 rer 参数的 UnicodePropertyValueExpression 的 CompileToCharSet。
2. 断言：S 仅包含单个代码点。
3. 返回 CharacterComplement(rer, S)。

**UnicodePropertyValueExpression :: UnicodePropertyName = UnicodePropertyValue**
1. 令 ps 为 UnicodePropertyName 匹配的源文本。
2. 令 p 为 UnicodeMatchProperty(rer, ps)。
3. 断言：p 是 Table 66 “属性名称和别名”列中列出的 Unicode 属性名称或属性别名。
4. 令 vs 为 UnicodePropertyValue 匹配的源文本。
5. 令 v 为 UnicodeMatchPropertyValue(p, vs)。
6. 令 A 为包含所有 Unicode 代码点的字符集，其字符数据库定义包括属性 p 和值 v。
7. 返回 MaybeSimpleCaseFolding(rer, A)。

**UnicodePropertyValueExpression :: LoneUnicodePropertyNameOrValue**
1. 令 s 为 LoneUnicodePropertyNameOrValue 匹配的源文本。
2. 如果 General_Category (gc) 属性的 UnicodeMatchPropertyValue(General_Category, s) 是 PropertyValueAliases.txt 中列出的 Unicode 属性值或属性值别名，则
   a. 返回包含所有 Unicode 代码点的字符集，其字符数据库定义包括属性 “General_Category”，值为 s。
3. 令 p 为 UnicodeMatchProperty(rer, s)。
4. 断言：p 是 Table 67 “属性名称和别名”列中列出的二进制 Unicode 属性或属性别名，或 Table 68 “属性名称”列中列出的二进制 Unicode 属性。
5. 令 A 为包含所有字符集元素的字符集，其字符数据库定义包括属性 p，值为 “True”。
6. 返回 MaybeSimpleCaseFolding(rer, A)。

**ClassUnion :: ClassSetRange ClassUnionopt**
1. 令 A 为使用 rer 参数的 ClassSetRange 的 CompileToCharSet。
2. 如果 ClassUnion 存在，则
   a. 令 B 为使用 rer 参数的 ClassUnion 的 CompileToCharSet。
   b. 返回字符集 A 和 B 的并集。
3. 返回 A。

**ClassUnion :: ClassSetOperand ClassUnionopt**
1. 令 A 为使用 rer 参数的 ClassSetOperand 的 CompileToCharSet。
2. 如果 ClassUnion 存在，则
   a. 令 B 为使用 rer 参数的 ClassUnion 的 CompileToCharSet。
   b. 返回字符集 A 和 B 的并集。
3. 返回 A。

**ClassIntersection :: ClassSetOperand && ClassSetOperand**
1. 令 A 为使用 rer 参数的第一个 ClassSetOperand 的 CompileToCharSet。
2. 令 B 为使用 rer 参数的第二个 ClassSetOperand 的 CompileToCharSet。
3. 返回字符集 A 和 B 的交集。

**ClassIntersection :: ClassIntersection && ClassSetOperand**
1. 令 A 为使用 rer 参数的 ClassIntersection 的 CompileToCharSet。
2. 令 B 为使用 rer 参数的 ClassSetOperand 的 CompileToCharSet。
3. 返回字符集 A 和 B 的交集。

**ClassSubtraction :: ClassSetOperand -- ClassSetOperand**
1. 令 A 为使用 rer 参数的第一个 ClassSetOperand 的 CompileToCharSet。
2. 令 B 为使用 rer 参数的第二个 ClassSetOperand 的 CompileToCharSet。
3. 返回包含 A 中不属于 B 的字符集元素的字符集。

**ClassSubtraction :: ClassSubtraction -- ClassSetOperand**
1. 令 A 为使用 rer 参数的 ClassSubtraction 的 CompileToCharSet。
2. 令 B 为使用 rer 参数的 ClassSetOperand 的 CompileToCharSet。
3. 返回包含 A 中不属于 B 的字符集元素的字符集。

**ClassSetRange :: ClassSetCharacter - ClassSetCharacter**
1. 令 A 为使用 rer 参数的第一个 ClassSetCharacter 的 CompileToCharSet。
2. 令 B 为使用 rer 参数的第二个 ClassSetCharacter 的 CompileToCharSet。
3. 返回 MaybeSimpleCaseFolding(rer, CharacterRange(A, B))。

**注意 6**  
结果通常由两个或多个范围组成。当 UnicodeSets 为 true 且 IgnoreCase 为 true 时，MaybeSimpleCaseFolding(rer, [Ā-č]) 将只包括该范围的奇数代码点。

**ClassSetOperand :: ClassSetCharacter**
1. 令 A 为使用 rer 参数的 ClassSetCharacter 的 CompileToCharSet。
2. 返回 MaybeSimpleCaseFolding(rer, A)。

**ClassSetOperand :: ClassStringDisjunction**
1. 令 A 为使用 rer 参数的 ClassStringDisjunction 的 CompileToCharSet。
2. 返回 MaybeSimpleCaseFolding(rer, A)。

**ClassSetOperand :: NestedClass**
1. 返回使用 rer 参数的 NestedClass 的 CompileToCharSet。

**NestedClass :: [ ClassContents ]**
1. 返回使用 rer 参数的 ClassContents 的 CompileToCharSet。

**NestedClass :: [^ ClassContents ]**
1. 令 A 为使用 rer 参数的 ClassContents 的 CompileToCharSet。
2. 返回 CharacterComplement(rer, A)。

**NestedClass :: \ CharacterClassEscape**
1. 返回使用 rer 参数的 CharacterClassEscape 的 CompileToCharSet。

**ClassStringDisjunction :: \q{ ClassStringDisjunctionContents }**
1. 返回使用 rer 参数的 ClassStringDisjunctionContents 的 CompileToCharSet。

**ClassStringDisjunctionContents :: ClassString**
1. 令 s 为使用 rer 参数的 ClassString 的 CompileClassSetString。
2. 返回包含单个字符串 s 的字符集。

**ClassStringDisjunctionContents :: ClassString | ClassStringDisjunctionContents**
1. 令 s 为使用 rer 参数的 ClassString 的 CompileClassSetString。
2. 令 A 为包含单个字符串 s 的字符集。
3. 令 B 为使用 rer 参数的 ClassStringDisjunctionContents 的 CompileToCharSet。
4. 返回字符集 A 和 B 的并集。

**ClassSetCharacter ::**
SourceCharacter but not ClassSetSyntaxCharacter
\ CharacterEscape
\ ClassSetReservedPunctuator
1. 令 cv 为此 ClassSetCharacter 的 CharacterValue。
2. 令 c 为字符值为 cv 的字符。
3. 返回包含单个字符 c 的字符集。

**ClassSetCharacter :: \b**
1. 返回包含单个字符 U+0008（退格）的字符集。

### 22.2.2.9.1 CharacterRange（A, B）

抽象操作 CharacterRange 接受参数 A（一个字符集）和 B（一个字符集），并返回一个字符集。调用时执行以下步骤：

1. 断言：A 和 B 各包含一个字符。
2. 令 a 为字符集 A 中的一个字符。
3. 令 b 为字符集 B 中的一个字符。
4. 令 i 为字符 a 的字符值。
5. 令 j 为字符 b 的字符值。
6. 断言：i ≤ j。
7. 返回包含字符值在 i 和 j 之间（含）的所有字符的字符集。

### 22.2.2.9.2 HasEitherUnicodeFlag（rer）

抽象操作 HasEitherUnicodeFlag 接受参数 rer（一个正则表达式记录），并返回一个布尔值

。调用时执行以下步骤：

1. 如果 rer.[[Unicode]] 为 true 或 rer.[[UnicodeSets]] 为 true，则
   a. 返回 true。
2. 返回 false。

### 22.2.2.9.3 WordCharacters（rer）

抽象操作 WordCharacters 接受参数 rer（一个正则表达式记录），并返回一个字符集。它返回一个字符集，包含对于 \b、\B、\w 和 \W 而言被视为“单词字符”的字符。调用时执行以下步骤：

1. 令 basicWordChars 为包含所有 ASCII 单词字符的字符集。
2. 令 extraWordChars 为包含所有字符 c 的字符集，使得 c 不在 basicWordChars 中，但 Canonicalize(rer, c) 在 basicWordChars 中。
3. 断言：除非 HasEitherUnicodeFlag(rer) 为 true 且 rer.[[IgnoreCase]] 为 true，否则 extraWordChars 为空。
4. 返回 basicWordChars 和 extraWordChars 的并集。

### 22.2.2.9.4 AllCharacters（rer）

抽象操作 AllCharacters 接受参数 rer（一个正则表达式记录），并返回一个字符集。根据正则表达式标志返回“所有字符”的集合。调用时执行以下步骤：

1. 如果 rer.[[UnicodeSets]] 为 true 且 rer.[[IgnoreCase]] 为 true，则
   a. 返回字符集，包含所有 Unicode 代码点 c，这些代码点没有简单大小写折叠映射（即，scf(c)=c）。
2. 否则，如果 HasEitherUnicodeFlag(rer) 为 true，则
   a. 返回包含所有代码点值的字符集。
3. 否则，
   a. 返回包含所有代码单元值的字符集。

### 22.2.2.9.5 MaybeSimpleCaseFolding（rer, A）

抽象操作 MaybeSimpleCaseFolding 接受参数 rer（一个正则表达式记录）和 A（一个字符集），并返回一个字符集。如果 rer.[[UnicodeSets]] 为 false 或 rer.[[IgnoreCase]] 为 false，则返回 A。否则，它使用 Unicode 字符数据库的 CaseFolding.txt 文件中的简单大小写折叠（scf(cp)）定义，将 A 的每个 CharSetElement 逐字符映射到规范形式，并返回生成的字符集。调用时执行以下步骤：

1. 如果 rer.[[UnicodeSets]] 为 false 或 rer.[[IgnoreCase]] 为 false，返回 A。
2. 令 B 为一个新的空字符集。
3. 对于 A 的每个 CharSetElement s，执行以下步骤：
   a. 令 t 为一个空字符序列。
   b. 对于 s 中的每个单一代码点 cp，执行以下步骤：
      i. 将 scf(cp) 附加到 t。
   c. 将 t 添加到 B。
4. 返回 B。

### 22.2.2.9.6 CharacterComplement（rer, S）

抽象操作 CharacterComplement 接受参数 rer（一个正则表达式记录）和 S（一个字符集），并返回一个字符集。调用时执行以下步骤：

1. 令 A 为 AllCharacters(rer)。
2. 返回包含 A 的字符集元素但不包含 S 的字符集元素的字符集。

### 22.2.2.9.7 UnicodeMatchProperty（rer, p）

抽象操作 UnicodeMatchProperty 接受参数 rer（一个正则表达式记录）和 p（ECMAScript 源文本），并返回一个 Unicode 属性名称。调用时执行以下步骤：

1. 如果 rer.[[UnicodeSets]] 为 true 且 p 是 Table 68 “属性名称”列中列出的 Unicode 属性名称，则
   a. 返回 Unicode 代码点 p 的列表。
2. 断言：p 是 Table 66 或 Table 67 “属性名称和别名”列中列出的 Unicode 属性名称或属性别名。
3. 令 c 为对应行中“规范属性名称”列给出的 p 的规范属性名称。
4. 返回 Unicode 代码点 c 的列表。

实现必须支持 Table 66、Table 67 和 Table 68 中列出的 Unicode 属性名称和别名。为了确保互操作性，实现不得支持任何其他属性名称或别名。

**注意 1**  
例如，Script_Extensions（属性名称）和 scx（属性别名）是有效的，但 script_extensions 或 Scx 不是。

**注意 2**  
列出的属性组成了 UTS18 RL1.2 要求的超集。

**注意 3**  
这些表中的条目拼写（包括大小写）与 Unicode 字符数据库中 PropertyAliases.txt 文件中使用的拼写一致。该文件中的精确拼写保证是稳定的。

### 表 66：非二进制 Unicode 属性别名及其规范属性名称

| 属性名称和别名    | 规范属性名称      |
|------------------|------------------|
| General_Category | General_Category |
| gc               |                  |
| Script           | Script           |
| sc               |                  |
| Script_Extensions| Script_Extensions|
| scx              |                  |

### 表 67：二进制 Unicode 属性别名及其规范属性名称

| 属性名称和别名           | 规范属性名称               |
|-------------------------|-------------------------|
| ASCII                   | ASCII                   |
| ASCII_Hex_Digit         | ASCII_Hex_Digit         |
| AHex                    |                         |
| Alphabetic              | Alphabetic              |
| Alpha                   |                         |
| Any                     | Any                     |
| Assigned                | Assigned                |
| Bidi_Control            | Bidi_Control            |
| Bidi_C                  |                         |
| Bidi_Mirrored           | Bidi_Mirrored           |
| Bidi_M                  |                         |
| Case_Ignorable          | Case_Ignorable          |
| CI                      |                         |
| Cased                   | Cased                   |
| Changes_When_Casefolded | Changes_When_Casefolded |
| CWCF                    |                         |
| Changes_When_Casemapped | Changes_When_Casemapped |
| CWCM                    |                         |
| Changes_When_Lowercased | Changes_When_Lowercased |
| CWL                     |                         |
| Changes_When_NFKC_Casefolded | Changes_When_NFKC_Casefolded |
| CWKCF                   |                         |
| Changes_When_Titlecased | Changes_When_Titlecased |
| CWT                     |                         |
| Changes_When_Uppercased | Changes_When_Uppercased |
| CWU                     |                         |
| Dash                    | Dash                    |
| Default_Ignorable_Code_Point | Default_Ignorable_Code_Point |
| DI                      |                         |
| Deprecated              | Deprecated              |
| Dep                     |                         |
| Diacritic               | Diacritic               |
| Dia                     |                         |
| Emoji                   | Emoji                   |
| Emoji_Component         | Emoji_Component         |
| EComp                   |                         |
| Emoji_Modifier          | Emoji_Modifier          |
| EMod                    |                         |
| Emoji_Modifier_Base     | Emoji_Modifier_Base     |
| EBase                   |                         |
| Emoji_Presentation      | Emoji_Presentation      |
| EPres                   |                         |
| Extended_Pictographic   | Extended_Pictographic   |
| ExtPict                 |                         |
| Extender                | Extender                |
| Ext                     |                         |
| Grapheme_Base           | Grapheme_Base           |
| Gr_Base                 |                         |
| Grapheme_Extend         | Grapheme_Extend         |
| Gr_Ext                  |                         |
| Hex_Digit               | Hex_Digit               |
| Hex                     |                         |
| IDS_Binary_Operator     | IDS_Binary_Operator     |
| IDSB                    |                         |
| IDS_Trinary_Operator    | IDS_Trinary_Operator    |
| IDST                    |                         |
| ID_Continue             | ID_Continue             |
| IDC                     |                         |
| ID_Start                | ID_Start                |
| IDS                     |                         |
| Ideographic             | Ideographic             |
| Ideo                    |                         |
| Join_Control            | Join_Control            |
| Join_C                  |                         |
| Logical_Order_Exception | Logical_Order_Exception |
| LOE                     |                         |
| Lowercase               | Lowercase               |
| Lower                   |                         |
| Math                    | Math                    |
| Noncharacter_Code_Point | Noncharacter_Code_Point |
| NChar                   |                         |
| Pattern_Syntax          | Pattern_Syntax          |
| Pat_Syn                 |                         |
| Pattern_White_Space     | Pattern_White_Space     |
| Pat_WS                  |                         |
| Quotation_Mark          | Quotation_Mark          |
| QMark                   |                         |
| Radical                 | Radical                 |
| Regional_Indicator      | Regional_Indicator      |
| RI                      |                         |
| Sentence_Terminal       | Sentence_Terminal       |
| STerm                   |                         |
| Soft_Dotted             | Soft_Dotted             |
| SD                      |                         |
| Terminal_Punctuation    | Terminal_Punctuation    |
| Term                    |                         |
| Unified_Ideograph       | Unified_Ideograph       |
| UIdeo                   |                         |
| Uppercase               | Uppercase               |
| Upper                   |                         |
| Variation_Selector      | Variation_Selector      |
| VS                      |                         |
| White_Space             | White_Space             |
| space                   |                         |
| XID_Continue            | XID_Continue            |
| XIDC                    |                         |
| XID_Start               | XID

_Start               |
| XIDS                    |                         |

### 表 68：字符串的二进制 Unicode 属性

| 属性名称                        |
|-------------------------------|
| Basic_Emoji                   |
| Emoji_Keycap_Sequence         |
| RGI_Emoji_Modifier_Sequence   |
| RGI_Emoji_Flag_Sequence       |
| RGI_Emoji_Tag_Sequence        |
| RGI_Emoji_ZWJ_Sequence        |
| RGI_Emoji                     |

### 22.2.2.9.8 UnicodeMatchPropertyValue（p, v）

抽象操作 UnicodeMatchPropertyValue 接受参数 p（ECMAScript 源文本）和 v（ECMAScript 源文本），并返回一个 Unicode 属性值。调用时执行以下步骤：

1. 断言：p 是 Table 66 “规范属性名称”列中列出的规范的、未别名的 Unicode 属性名称。
2. 断言：v 是 PropertyValueAliases.txt 中列出的 Unicode 属性 p 的属性值或属性值别名。
3. 令 value 为对应行中“规范属性值”列给出的 v 的规范属性值。
4. 返回 Unicode 代码点 value 的列表。

实现必须支持表 66 中列出的属性的 PropertyValueAliases.txt 中列出的 Unicode 属性值和属性值别名。为了确保互操作性，实现不得支持任何其他属性值或属性值别名。

**注意 1**  
例如，Xpeo 和 Old_Persian 是有效的 Script_Extensions 值，但 xpeo 和 Old Persian 不是。

**注意 2**  
此算法与 UAX44 中列出的符号值匹配规则有所不同：不忽略大小写、空格、U+002D（连字符-减号）和 U+005F（低线），且不支持 Is 前缀。

### 22.2.2.10 运行时语义：CompileClassSetString

语法导向操作 CompileClassSetString 接受参数 rer（一个正则表达式记录），并返回一个字符序列。它在以下生成上逐段定义：

**ClassString :: [empty]**
1. 返回一个空字符序列。

**ClassString :: NonEmptyClassString**
1. 返回使用 rer 参数的 NonEmptyClassString 的 CompileClassSetString。

**NonEmptyClassString :: ClassSetCharacter NonEmptyClassStringopt**
1. 令 cs 为使用 rer 参数的 ClassSetCharacter 的 CompileToCharSet。
2. 令 s1 为单个 CharSetElement cs 的字符序列。
3. 如果 NonEmptyClassString 存在，则
   a. 令 s2 为使用 rer 参数的 NonEmptyClassString 的 CompileClassSetString。
   b. 返回 s1 和 s2 的连接。
4. 返回 s1。

### 22.2.3 创建 RegExp 的抽象操作

#### 22.2.3.1 RegExpCreate (P, F)
抽象操作 RegExpCreate 接受参数 P（一个 ECMAScript 语言值）和 F（一个字符串或未定义），并返回一个包含对象的正常完成或抛出完成。调用时执行以下步骤：

1. 令 obj 为 `! RegExpAlloc(%RegExp%)`。
2. 返回 `? RegExpInitialize(obj, P, F)`。

#### 22.2.3.2 RegExpAlloc (newTarget)
抽象操作 RegExpAlloc 接受参数 newTarget（一个构造函数），并返回一个包含对象的正常完成或抛出完成。调用时执行以下步骤：

1. 令 obj 为 `? OrdinaryCreateFromConstructor(newTarget, "%RegExp.prototype%", « [[OriginalSource]], [[OriginalFlags]], [[RegExpRecord]], [[RegExpMatcher]] »)`。
2. 执行 `! DefinePropertyOrThrow(obj, "lastIndex", PropertyDescriptor { [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false })`。
3. 返回 obj。

#### 22.2.3.3 RegExpInitialize (obj, pattern, flags)
抽象操作 RegExpInitialize 接受参数 obj（一个对象）、pattern（一个 ECMAScript 语言值）和 flags（一个 ECMAScript 语言值），并返回一个包含对象的正常完成或抛出完成。调用时执行以下步骤：

1. 如果 pattern 是 undefined，令 P 为空字符串。
2. 否则，令 P 为 `? ToString(pattern)`。
3. 如果 flags 是 undefined，令 F 为空字符串。
4. 否则，令 F 为 `? ToString(flags)`。
5. 如果 F 包含 “d”、“g”、“i”、“m”、“s”、“u”、“v” 或 “y” 之外的任何代码单元，或 F 中的任何代码单元出现多次，则抛出一个 SyntaxError 异常。
6. 如果 F 包含 “i”，令 i 为 true；否则令 i 为 false。
7. 如果 F 包含 “m”，令 m 为 true；否则令 m 为 false。
8. 如果 F 包含 “s”，令 s 为 true；否则令 s 为 false。
9. 如果 F 包含 “u”，令 u 为 true；否则令 u 为 false。
10. 如果 F 包含 “v”，令 v 为 true；否则令 v 为 false。
11. 如果 u 为 true 或 v 为 true，则
    a. 令 patternText 为 StringToCodePoints(P)。
12. 否则，
    a. 令 patternText 为解释 P 的每个 16 位元素为 Unicode BMP 代码点的结果。UTF-16 解码不应用于这些元素。
13. 令 parseResult 为 ParsePattern(patternText, u, v)。
14. 如果 parseResult 是一个非空的 SyntaxError 对象列表，抛出一个 SyntaxError 异常。
15. 断言：parseResult 是一个 Pattern 解析节点。
16. 将 obj.[[OriginalSource]] 设置为 P。
17. 将 obj.[[OriginalFlags]] 设置为 F。
18. 令 capturingGroupsCount 为 CountLeftCapturingParensWithin(parseResult)。
19. 令 rer 为 RegExp 记录 { [[IgnoreCase]]: i, [[Multiline]]: m, [[DotAll]]: s, [[Unicode]]: u, [[UnicodeSets]]: v, [[CapturingGroupsCount]]: capturingGroupsCount }。
20. 将 obj.[[RegExpRecord]] 设置为 rer。
21. 将 obj.[[RegExpMatcher]] 设置为使用 rer 参数的 parseResult 的 CompilePattern。
22. 执行 `? Set(obj, "lastIndex", +0𝔽, true)`。
23. 返回 obj。

#### 22.2.3.4 静态语义：ParsePattern (patternText, u, v)
抽象操作 ParsePattern 接受参数 patternText（一个 Unicode 代码点序列）、u（一个布尔值）和 v（一个布尔值），并返回一个解析节点或一个非空的 SyntaxError 对象列表。

**注意**
本节在 B.1.2.9 中进行了修订。

调用时执行以下步骤：

1. 如果 v 为 true 且 u 为 true，则
    a. 令 parseResult 为包含一个或多个 SyntaxError 对象的列表。
2. 否则，如果 v 为 true，则
    a. 令 parseResult 为 `ParseText(patternText, Pattern[+UnicodeMode, +UnicodeSetsMode, +NamedCaptureGroups])`。
3. 否则，如果 u 为 true，则
    a. 令 parseResult 为 `ParseText(patternText, Pattern[+UnicodeMode, ~UnicodeSetsMode, +NamedCaptureGroups])`。
4. 否则，
    a. 令 parseResult 为 `ParseText(patternText, Pattern[~UnicodeMode, ~UnicodeSetsMode, +NamedCaptureGroups])`。
5. 返回 parseResult。

### 22.2.4 RegExp 构造函数

RegExp 构造函数：

- 是 %RegExp%。
- 是全局对象的 "RegExp" 属性的初始值。
- 在作为构造函数调用时创建并初始化一个新的 RegExp 对象。
- 在作为函数而不是构造函数调用时，返回一个新的 RegExp 对象，或如果唯一参数是一个 RegExp 对象，则返回该参数本身。
- 可以用作类定义的 extends 子句的值。继承指定的 RegExp 行为的子类构造函数必须包括对 RegExp 构造函数的 super 调用，以便用必要的内部槽创建和初始化子类实例。

#### 22.2.4.1 RegExp (pattern, flags)
调用时执行以下步骤：

1. 令 patternIsRegExp 为 `? IsRegExp(pattern)`。
2. 如果 NewTarget 是 undefined，则
    a. 令 newTarget 为活动函数对象。
    b. 如果 patternIsRegExp 为 true 且 flags 是 undefined，则
        i. 令 patternConstructor 为 `? Get(pattern, "constructor")`。
        ii. 如果 `SameValue(newTarget, patternConstructor)` 为 true，返回 pattern。
3. 否则，
    a. 令 newTarget 为 NewTarget。
4. 如果 pattern 是一个对象且 pattern 有一个 [[RegExpMatcher]] 内部槽，则
    a. 令 P 为 pattern.[[OriginalSource]]。
    b. 如果 flags 是 undefined，令 F 为 pattern.[[OriginalFlags]]。
    c. 否则，令 F 为 flags。
5. 否则，如果 patternIsRegExp 为 true，则
    a. 令 P 为 `? Get(pattern, "source")`。
    b. 如果 flags 是 undefined，则
        i. 令 F 为 `? Get(pattern, "flags")`。
    c. 否则，
        i. 令 F 为 flags。
6. 否则，
    a. 令 P 为 pattern。
    b. 令 F 为 flags。
7. 令 O 为 `? RegExpAlloc(newTarget)`。
8. 返回 `? RegExpInitialize(O, P, F)`。

**注意**
如果 pattern 是通过字符串字面量提供的，则在此函数处理字符串之前会执行通常的转义序列替换。如果 pattern 必须包含一个转义序列以被此函数识别，则必须在字符串字面量内转义任何 U+005C（反斜杠）代码点，以防它们在形成字符串字面量的内容时被移除。

### 22.2.5 RegExp 构造函数的属性

RegExp 构造函数：

- 具有 [[Prototype]] 内部槽，其值为 %Function.prototype%。
- 具有以下属性：

#### 22.2.5.1 RegExp.prototype
RegExp.prototype 的初始值是 RegExp 原型对象。

此属性具有 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } 属性。

#### 22.2.5.2 获取 RegExp [@@species]
RegExp[@@species] 是一个访问器属性，其设置访问器函数为 undefined。其获取访问器函数在调用时执行以下步骤：

1. 返回 this 值。

此函数的 "name" 属性的值是 "get [Symbol.species]"。

**注意**
RegExp 原型方法通常使用其 this 值的构造函数来创建派生对象。但是，子类构造函数可以通过重新定义其 @@species 属性来覆盖此默认行为。

### 22.2.6 RegExp 原型对象的属性

RegExp 原型对象：

- 是 %RegExp.prototype%。
- 是一个普通对象。
- 不是 RegExp 实例，并且没有 [[RegExpMatcher]] 内部槽或 RegExp 实例对象的任何其他内部槽。
- 具有 [[Prototype]] 内部槽，其值为 %Object.prototype%。

**注意**
RegExp 原型对象没有自己的 "valueOf" 属性；然而，它继承自 Object 原型对象的 "valueOf" 属性。

#### 22.2.6.1 RegExp.prototype.constructor
RegExp.prototype.constructor 的初始值是 %RegExp%。

#### 22.2.6.2 RegExp.prototype.exec (string)
此方法在字符串中搜索正则表达式模式的出现，并返回一个包含匹配

结果的数组，或如果字符串未匹配，则返回 null。

调用时执行以下步骤：

1. 令 R 为 this 值。
2. 执行 `? RequireInternalSlot(R, [[RegExpMatcher]])`。
3. 令 S 为 `? ToString(string)`。
4. 返回 `? RegExpBuiltinExec(R, S)`。

#### 22.2.6.3 获取 RegExp.prototype.dotAll
RegExp.prototype.dotAll 是一个访问器属性，其设置访问器函数为 undefined。其获取访问器函数在调用时执行以下步骤：

1. 令 R 为 this 值。
2. 令 cu 为代码单元 0x0073（小写字母 s）。
3. 返回 `? RegExpHasFlag(R, cu)`。

#### 22.2.6.4 获取 RegExp.prototype.flags
RegExp.prototype.flags 是一个访问器属性，其设置访问器函数为 undefined。其获取访问器函数在调用时执行以下步骤：

1. 令 R 为 this 值。
2. 如果 R 不是对象，抛出一个 TypeError 异常。
3. 令 codeUnits 为一个新的空列表。
4. 令 hasIndices 为 `ToBoolean(? Get(R, "hasIndices"))`。
5. 如果 hasIndices 为 true，向 codeUnits 中附加代码单元 0x0064（小写字母 d）。
6. 令 global 为 `ToBoolean(? Get(R, "global"))`。
7. 如果 global 为 true，向 codeUnits 中附加代码单元 0x0067（小写字母 g）。
8. 令 ignoreCase 为 `ToBoolean(? Get(R, "ignoreCase"))`。
9. 如果 ignoreCase 为 true，向 codeUnits 中附加代码单元 0x0069（小写字母 i）。
10. 令 multiline 为 `ToBoolean(? Get(R, "multiline"))`。
11. 如果 multiline 为 true，向 codeUnits 中附加代码单元 0x006D（小写字母 m）。
12. 令 dotAll 为 `ToBoolean(? Get(R, "dotAll"))`。
13. 如果 dotAll 为 true，向 codeUnits 中附加代码单元 0x0073（小写字母 s）。
14. 令 unicode 为 `ToBoolean(? Get(R, "unicode"))`。
15. 如果 unicode 为 true，向 codeUnits 中附加代码单元 0x0075（小写字母 u）。
16. 令 unicodeSets 为 `ToBoolean(? Get(R, "unicodeSets"))`。
17. 如果 unicodeSets 为 true，向 codeUnits 中附加代码单元 0x0076（小写字母 v）。
18. 令 sticky 为 `ToBoolean(? Get(R, "sticky"))`。
19. 如果 sticky 为 true，向 codeUnits 中附加代码单元 0x0079（小写字母 y）。
20. 返回由 codeUnits 列表元素组成的字符串值。如果 codeUnits 没有元素，则返回空字符串。

#### 22.2.6.4.1 RegExpHasFlag (R, codeUnit)
抽象操作 RegExpHasFlag 接受参数 R（一个 ECMAScript 语言值）和 codeUnit（一个代码单元），并返回一个包含布尔值或 undefined 的正常完成，或抛出完成。调用时执行以下步骤：

1. 如果 R 不是对象，抛出一个 TypeError 异常。
2. 如果 R 没有 [[OriginalFlags]] 内部槽，则
    a. 如果 `SameValue(R, %RegExp.prototype%)` 为 true，返回 undefined。
    b. 否则，抛出一个 TypeError 异常。
3. 令 flags 为 R.[[OriginalFlags]]。
4. 如果 flags 包含 codeUnit，返回 true。
5. 返回 false。

#### 22.2.6.5 获取 RegExp.prototype.global
RegExp.prototype.global 是一个访问器属性，其设置访问器函数为 undefined。其获取访问器函数在调用时执行以下步骤：

1. 令 R 为 this 值。
2. 令 cu 为代码单元 0x0067（小写字母 g）。
3. 返回 `? RegExpHasFlag(R, cu)`。

#### 22.2.6.6 获取 RegExp.prototype.hasIndices
RegExp.prototype.hasIndices 是一个访问器属性，其设置访问器函数为 undefined。其获取访问器函数在调用时执行以下步骤：

1. 令 R 为 this 值。
2. 令 cu 为代码单元 0x0064（小写字母 d）。
3. 返回 `? RegExpHasFlag(R, cu)`。

#### 22.2.6.7 获取 RegExp.prototype.ignoreCase
RegExp.prototype.ignoreCase 是一个访问器属性，其设置访问器函数为 undefined。其获取访问器函数在调用时执行以下步骤：

1. 令 R 为 this 值。
2. 令 cu 为代码单元 0x0069（小写字母 i）。
3. 返回 `? RegExpHasFlag(R, cu)`。

#### 22.2.6.8 RegExp.prototype [@@match] (string)
调用此方法时执行以下步骤：

1. 令 rx 为 this 值。
2. 如果 rx 不是对象，则抛出 TypeError 异常。
3. 令 S 为 `? ToString(string)`。
4. 令 flags 为 `? ToString(? Get(rx, "flags"))`。
5. 如果 flags 不包含 "g"，则
   a. 返回 `? RegExpExec(rx, S)`。
6. 否则，
   a. 如果 flags 包含 "u" 或 "v"，则令 fullUnicode 为 true。否则，令 fullUnicode 为 false。
   b. 执行 `? Set(rx, "lastIndex", +0𝔽, true)`。
   c. 令 A 为 `! ArrayCreate(0)`。
   d. 令 n 为 0。
   e. 重复以下步骤，
      i. 令 result 为 `? RegExpExec(rx, S)`。
      ii. 如果 result 为 null，则
         1. 如果 n = 0，则返回 null。
         2. 返回 A。
      iii. 否则，
         1. 令 matchStr 为 `? ToString(? Get(result, "0"))`。
         2. 执行 `! CreateDataPropertyOrThrow(A, ! ToString(𝔽(n)), matchStr)`。
         3. 如果 matchStr 是空字符串，则
            a. 令 thisIndex 为 ℝ(? ToLength(? Get(rx, "lastIndex")))。
            b. 令 nextIndex 为 AdvanceStringIndex(S, thisIndex, fullUnicode)。
            c. 执行 `? Set(rx, "lastIndex", 𝔽(nextIndex), true)`。
         4. 将 n 设置为 n + 1。
该方法的 "name" 属性的值为 "[Symbol.match]"。

**注意**
@@match 属性由 IsRegExp 抽象操作用于识别具有基本正则表达式行为的对象。如果对象没有 @@match 属性或该属性的值不能转换为 true，则表示该对象不打算用作正则表达式对象。

#### 22.2.6.9 RegExp.prototype [@@matchAll] (string)
调用此方法时执行以下步骤：

1. 令 R 为 this 值。
2. 如果 R 不是对象，则抛出 TypeError 异常。
3. 令 S 为 `? ToString(string)`。
4. 令 C 为 `? SpeciesConstructor(R, %RegExp%)`。
5. 令 flags 为 `? ToString(? Get(R, "flags"))`。
6. 令 matcher 为 `? Construct(C, « R, flags »)`。
7. 令 lastIndex 为 `? ToLength(? Get(R, "lastIndex"))`。
8. 执行 `? Set(matcher, "lastIndex", lastIndex, true)`。
9. 如果 flags 包含 "g"，则令 global 为 true。
10. 否则，令 global 为 false。
11. 如果 flags 包含 "u" 或 "v"，则令 fullUnicode 为 true。
12. 否则，令 fullUnicode 为 false。
13. 返回 CreateRegExpStringIterator(matcher, S, global, fullUnicode)。
该方法的 "name" 属性的值为 "[Symbol.matchAll]"。

#### 22.2.6.10 获取 RegExp.prototype.multiline
RegExp.prototype.multiline 是一个访问器属性，其设置访问器函数为 undefined。其获取访问器函数在调用时执行以下步骤：

1. 令 R 为 this 值。
2. 令 cu 为代码单元 0x006D（小写字母 m）。
3. 返回 `? RegExpHasFlag(R, cu)`。

#### 22.2.6.11 RegExp.prototype [@@replace] (string, replaceValue)
调用此方法时执行以下步骤：

1. 令 rx 为 this 值。
2. 如果 rx 不是对象，则抛出 TypeError 异常。
3. 令 S 为 `? ToString(string)`。
4. 令 lengthS 为 S 的长度。
5. 令 functionalReplace 为 IsCallable(replaceValue)。
6. 如果 functionalReplace 为 false，则
   a. 将 replaceValue 设置为 `? ToString(replaceValue)`。
7. 令 flags 为 `? ToString(? Get(rx, "flags"))`。
8. 如果 flags 包含 "g"，则令 global 为 true。否则，令 global 为 false。
9. 如果 global 为 true，则
   a. 执行 `? Set(rx, "lastIndex", +0𝔽, true)`。
10. 令 results 为一个新的空列表。
11. 令 done 为 false。
12. 重复以下步骤，当 done 为 false 时，
   a. 令 result 为 `? RegExpExec(rx, S)`。
   b. 如果 result 为 null，则
      i. 将 done 设置为 true。
   c. 否则，
      i. 将 result 添加到 results。
      ii. 如果 global 为 false，则
         1. 将 done 设置为 true。
      iii. 否则，
         1. 令 matchStr 为 `? ToString(? Get(result, "0"))`。
         2. 如果 matchStr 是空字符串，则
            a. 令 thisIndex 为 ℝ(? ToLength(? Get(rx, "lastIndex")))。
            b. 如果 flags 包含 "u" 或 "v"，则令 fullUnicode 为 true。否则，令 fullUnicode 为 false。
            c. 令 nextIndex 为 AdvanceStringIndex(S, thisIndex, fullUnicode)。
            d. 执行 `? Set(rx, "lastIndex", 𝔽(nextIndex), true)`。
13. 令 accumulatedResult 为空字符串。
14. 令 nextSourcePosition 为 0。
15. 对于 results 的每个元素 result，执行以下步骤，
   a. 令 resultLength 为 `? LengthOfArrayLike(result)`。
   b. 令 nCaptures 为 max(resultLength - 1, 0)。
   c. 令 matched 为 `? ToString(? Get(result, "0"))`。
   d. 令 matchLength 为 matched 的长度。
   e. 令 position 为 `? ToIntegerOrInfinity(? Get(result, "index"))`。
   f. 将 position 夹紧在 0 和 lengthS 之间。
   g. 令 captures 为一个新的空列表。
   h. 令 n 为 1。
   i. 重复以下步骤，当 n ≤ nCaptures 时，
      i. 令 capN 为 `? Get(result, ! ToString(𝔽(n)))`。
      ii. 如果 capN 不为 undefined，则
         1. 将 capN 设置为 `? ToString(capN)`。
      iii. 将 capN 添加到 captures。
      iv. 注：当 n = 1 时，上述步骤将第一个元素放入 captures（在索引 0）。更一般地，第 n 个捕获（由第 n 组捕获括号捕获的字符）位于 captures[n - 1]。
      v. 将 n 设置为 n + 1。
   j. 令 namedCaptures 为 `? Get(result, "groups")`。
   k. 如果 functionalReplace 为 true，则
      i. 令 replacerArgs 为 « matched », captures 和 « 𝔽(position), S » 的列表连接。
      ii. 如果 namedCaptures 不为 undefined，则
         1. 将 namedCaptures 添加到 replacerArgs。
      iii. 令 replValue 为 `? Call(replaceValue, undefined, replacerArgs)`。
      iv. 令 replacement 为 `? ToString(replValue)`。
   l. 否则，
      i. 如果 namedCaptures 不为 undefined，则
         1. 将 namedCaptures 设置为 `? ToObject(namedCaptures)`。
      ii. 令 replacement 为 `? GetSubstitution(matched, S, position, captures, namedCaptures, replaceValue)`。
   m. 如果 position ≥ nextSourcePosition，则
      i. 注：position 通常不应向后移动。如果它移动，则表示正则表达式子类行为不正常或使用触发副作用的访问更改 rx 的 global 标志或其他特性。在这种情况下，相应的替换被忽略。
      ii. 将 accumulatedResult 设置为 accumulatedResult、从 nextSourcePosition 到 position 的 S 的子字符串以及 replacement 的字符串连接。
      iii. 将 nextSourcePosition 设置为 position + matchLength。
16. 如果 nextSourcePosition ≥ lengthS，则返回 accumulatedResult。
17. 返回 accumulatedResult 和从 nextSourcePosition 开始的 S 子字符串的字符串连接。
该方法的 "name" 属性的值为 "[Symbol.replace]"。

#### 22.2.6.12 RegExp.prototype [@@search] (string)
调用此方法时执行以下步骤：

1. 令 rx 为 this 值。
2. 如果 rx 不是对象，则抛出 TypeError 异常。
3. 令 S 为 `? ToString(string)`。
4. 令 previousLastIndex 为 `? Get(rx, "lastIndex")`。
5. 如果 previousLastIndex 不是 +0𝔽，则
   a. 执行 `? Set(rx, "lastIndex", +0𝔽, true)`。
6. 令 result 为 `? Reg

ExpExec(rx, S)`。
7. 令 currentLastIndex 为 `? Get(rx, "lastIndex")`。
8. 如果 `SameValue(currentLastIndex, previousLastIndex)` 为 false，则
   a. 执行 `? Set(rx, "lastIndex", previousLastIndex, true)`。
9. 如果 result 为 null，则返回 -1𝔽。
10. 返回 `? Get(result, "index")`。
该方法的 "name" 属性的值为 "[Symbol.search]"。

**注意**
执行搜索时会忽略此正则表达式对象的 "lastIndex" 和 "global" 属性。"lastIndex" 属性保持不变。

#### 22.2.6.13 获取 RegExp.prototype.source
RegExp.prototype.source 是一个访问器属性，其设置访问器函数为 undefined。其获取访问器函数在调用时执行以下步骤：

1. 令 R 为 this 值。
2. 如果 R 不是对象，则抛出 TypeError 异常。
3. 如果 R 没有 [[OriginalSource]] 内部槽，则
   a. 如果 `SameValue(R, %RegExp.prototype%)` 为 true，则返回 "(?:)"。
   b. 否则，抛出 TypeError 异常。
4. 断言：R 具有 [[OriginalFlags]] 内部槽。
5. 令 src 为 R.[[OriginalSource]]。
6. 令 flags 为 R.[[OriginalFlags]]。
7. 返回 EscapeRegExpPattern(src, flags)。

#### 22.2.6.13.1 EscapeRegExpPattern (P, F)
抽象操作 EscapeRegExpPattern 接受参数 P（一个字符串）和 F（一个字符串），并返回一个字符串。调用时执行以下步骤：

1. 如果 F 包含 "v"，则
   a. 令 patternSymbol 为 Pattern[+UnicodeMode, +UnicodeSetsMode]。
2. 否则，如果 F 包含 "u"，则
   a. 令 patternSymbol 为 Pattern[+UnicodeMode, ~UnicodeSetsMode]。
3. 否则，
   a. 令 patternSymbol 为 Pattern[~UnicodeMode, ~UnicodeSetsMode]。
4. 令 S 为一种 patternSymbol 形式的字符串，该形式等同于 P，解释为 UTF-16 编码的 Unicode 代码点（6.1.4），其中某些代码点按如下描述进行转义。S 可能与 P 不同；然而，评估 S 作为 patternSymbol 产生的抽象闭包必须与由构造对象的 [[RegExpMatcher]] 内部槽给出的抽象闭包表现相同。对相同的 P 和 F 值多次调用此抽象操作必须产生相同的结果。
5. 模式中的 / 或任何行终止符应在 S 中转义，以确保字符串连接 "/", S, "/", 和 F 可以解析为在适当的词法上下文中解析为行为与构造的正则表达式相同的 RegularExpressionLiteral。例如，如果 P 为 "/"，则 S 可以是 "\/" 或 "\u002F" 等其他可能形式，但不能是 "/"，因为 /// 后跟 F 将解析为 SingleLineComment 而不是 RegularExpressionLiteral。如果 P 是空字符串，则此规范可以通过让 S 为 "(?:)" 来满足。
6. 返回 S。

#### 22.2.6.14 RegExp.prototype [@@split] (string, limit)
**注意 1**
此方法返回一个数组，其中存储了将字符串转换为字符串后的子字符串。这些子字符串是通过从左到右搜索匹配的 this 值正则表达式来确定的；这些出现不会成为返回数组中的任何字符串的一部分，而是用于分隔字符串值。

this 值可以是空正则表达式或可以匹配空字符串的正则表达式。在这种情况下，正则表达式不会匹配输入字符串开头或结尾的空子字符串，也不会匹配上一个分隔符匹配结尾的空子字符串。（例如，如果正则表达式匹配空字符串，则字符串被分割成单个代码单元元素；结果数组的长度等于字符串的长度，每个子字符串包含一个代码单元。）只考虑字符串中给定索引的第一次匹配，即使回溯可以在该索引处生成非空子字符串匹配。（例如，/a*?/[Symbol.split]("ab") 计算结果为数组 ["a", "b"]，而 /a*/[Symbol.split]("ab") 计算结果为数组 ["","b"]。）

如果字符串是（或转换为）空字符串，结果取决于正则表达式是否可以匹配空字符串。如果可以，结果数组不包含任何元素。否则，结果数组包含一个元素，即空字符串。

如果正则表达式包含捕获括号，则每次匹配到分隔符时，捕获括号的结果（包括任何未定义的结果）将被插入到输出数组中。例如，

```js
/<(\/)?([^<>]+)>/[Symbol.split]("A<B>bold</B>and<CODE>coded</CODE>")
```

计算结果为数组：

["A", undefined, "B", "bold", "/", "B", "and", undefined, "CODE", "coded", "/", "CODE", ""]

如果 limit 不为 undefined，则输出数组被截断，使其包含不超过 limit 个元素。

调用此方法时执行以下步骤：

1. 令 rx 为 this 值。
2. 如果 rx 不是对象，则抛出 TypeError 异常。
3. 令 S 为 `? ToString(string)`。
4. 令 C 为 `? SpeciesConstructor(rx, %RegExp%)`。
5. 令 flags 为 `? ToString(? Get(rx, "flags"))`。
6. 如果 flags 包含 "u" 或 "v"，则令 unicodeMatching 为 true。
7. 否则，令 unicodeMatching 为 false。
8. 如果 flags 包含 "y"，则令 newFlags 为 flags。
9. 否则，令 newFlags 为 flags 的字符串连接 "y"。
10. 令 splitter 为 `? Construct(C, « rx, newFlags »)`。
11. 令 A 为 `! ArrayCreate(0)`。
12. 令 lengthA 为 0。
13. 如果 limit 为 undefined，则令 lim 为 2**32 - 1；否则，令 lim 为 ℝ(? ToUint32(limit))。
14. 如果 lim = 0，则返回 A。
15. 如果 S 是空字符串，则
    a. 令 z 为 `? RegExpExec(splitter, S)`。
    b. 如果 z 不为 null，则返回 A。
    c. 执行 `! CreateDataPropertyOrThrow(A, "0", S)`。
    d. 返回 A。
16. 令 size 为 S 的长度。
17. 令 p 为 0。
18. 令 q 为 p。
19. 重复以下步骤，当 q < size 时，
    a. 执行 `? Set(splitter, "lastIndex", 𝔽(q), true)`。
    b. 令 z 为 `? RegExpExec(splitter, S)`。
    c. 如果 z 为 null，则
        i. 将 q 设置为 AdvanceStringIndex(S, q, unicodeMatching)。
    d. 否则，
        i. 令 e 为 ℝ(? ToLength(? Get(splitter, "lastIndex")))。
        ii. 将 e 设置为 min(e, size)。
        iii. 如果 e = p，则
            1. 将 q 设置为 AdvanceStringIndex(S, q, unicodeMatching)。
        iv. 否则，
            1. 令 T 为 S 从 p 到 q 的子字符串。
            2. 执行 `! CreateDataPropertyOrThrow(A, ! ToString(𝔽(lengthA)), T)`。
            3. 将 lengthA 设置为 lengthA + 1。
            4. 如果 lengthA = lim，则返回 A。
            5. 将 p 设置为 e。
            6. 令 numberOfCaptures 为 `? LengthOfArrayLike(z)`。
            7. 将 numberOfCaptures 设置为 max(numberOfCaptures - 1, 0)。
            8. 令 i 为 1。
            9. 重复以下步骤，当 i ≤ numberOfCaptures 时，
                a. 令 nextCapture 为 `? Get(z, ! ToString(𝔽(i)))`。
                b. 执行 `! CreateDataPropertyOrThrow(A, ! ToString(𝔽(lengthA)), nextCapture)`。
                c. 将 i 设置为 i + 1。
                d. 将 lengthA 设置为 lengthA + 1。
                e. 如果 lengthA = lim，则返回 A。
10. 将 q 设置为 p。
20. 令 T 为 S 从 p 到 size 的子字符串。
21. 执行 `! CreateDataPropertyOrThrow(A, ! ToString(𝔽(lengthA)), T)`。
22. 返回 A。

该方法的 "name" 属性的值为 "[Symbol.split]"。

**注意 2**
此方法忽略此正则表达式对象的 "global" 和 "sticky" 属性的值。

### 22.2.6.15 获取 RegExp.prototype.sticky
RegExp.prototype.sticky 是一个访问器属性，其设置访问器函数为 undefined。其获取访问器函数在调用时执行以下步骤：

1. 令 R 为 this 值。
2. 令 cu 为代码单元 0x0079（小写字母 y）。
3. 返回 `? RegExpHasFlag(R, cu)`。

### 22.2.6.16 RegExp.prototype.test (S)
调用此方法时执行以下步骤：

1. 令 R 为 this 值。
2. 如果 R 不是对象，则抛出 TypeError 异常。
3. 令 string 为 `? ToString(S)`。
4. 令 match 为 `? RegExpExec(R, string)`。
5. 如果 match 不为 null，则返回 true；否则返回 false。

### 22.2.6.17 RegExp.prototype.toString ()
调用此方法时执行以下步骤：

1. 令 R 为 this 值。
2. 如果 R 不是对象，则抛出 TypeError 异常。
3. 令 pattern 为 `? ToString(? Get(R, "source"))`。
4. 令 flags 为 `? ToString(? Get(R, "flags"))`。
5. 令 result 为字符串连接 "/", pattern, "/", 和 flags。
6. 返回 result。

**注意**
返回的字符串形式为 RegularExpressionLiteral，其计算结果为具有与该对象相同行为的另一个 RegExp 对象。

### 22.2.6.18 获取 RegExp.prototype.unicode
RegExp.prototype.unicode 是一个访问器属性，其设置访问器函数为 undefined。其获取访问器函数在调用时执行以下步骤：

1. 令 R 为 this 值。
2. 令 cu 为代码单元 0x0075（小写字母 u）。
3. 返回 `? RegExpHasFlag(R, cu)`。

### 22.2.6.19 获取 RegExp.prototype.unicodeSets
RegExp.prototype.unicodeSets 是一个访问器属性，其设置访问器函数为 undefined。其获取访问器函数在调用时执行以下步骤：

1. 令 R 为 this 值。
2. 令 cu 为代码单元 0x0076（小写字母 v）。
3. 返回 `? RegExpHasFlag(R, cu)`。

### 22.2.7 正则表达式匹配的抽象操作
#### 22.2.7.1 RegExpExec (R, S)
抽象操作 RegExpExec 接受参数 R（一个对象）和 S（一个字符串），返回包含一个对象或 null 的正常完成，或抛出完成。在调用时执行以下步骤：

1. 令 exec 为 `? Get(R, "exec")`。
2. 如果 IsCallable(exec) 为 true，则
   a. 令 result 为 `? Call(exec, R, « S »)`。
   b. 如果 result 不是对象且 result 不是 null，则抛出 TypeError 异常。
   c. 返回 result。
3. 执行 `? RequireInternalSlot(R, [[RegExpMatcher]])`。
4. 返回 `? RegExpBuiltinExec(R, S)`。

**注意**
如果没有找到可调用的 "exec" 属性，该算法将回退到尝试使用内置的正则表达式匹配算法。这为以前版本编写的代码提供了兼容的行为，其中大多数内置算法使用正则表达式时不会动态查找 "exec" 属性。

#### 22.2.7.2 RegExpBuiltinExec (R, S)
抽象操作 RegExpBuiltinExec 接受参数 R（一个初始化的 RegExp 实例）和 S（一个字符串），返回包含一个数组异质对象或 null 的正常完成，或抛出完成。在调用时执行以下步骤：

1. 令 length 为 S 的长度。
2. 令 lastIndex 为 ℝ(? ToLength(? Get(R, "lastIndex")))。
3. 令 flags 为 R.[[OriginalFlags]]。
4. 如果 flags 包含 "g"，则令 global 为 true；否则令 global 为 false。
5. 如果 flags 包含 "y"，则令 sticky 为 true；否则令 sticky 为 false。
6. 如果 flags 包含 "d"，则令 hasIndices 为 true；否则令 hasIndices 为 false。
7. 如果 global 为 false 且 sticky 为 false，则将 lastIndex 设置为 0。
8. 令 matcher 为 R.[[RegExpMatcher]]。
9. 如果 flags 包含 "u" 或 "v"，则令 fullUnicode 为 true；否则令 fullUnicode 为 false。
10. 令 matchSucceeded 为 false。
11. 如果 fullUnicode 为 true，则令 input 为 StringToCodePoints(S)。否则，令 input 为一个列表，其元素为 S 的代码单元。
12. **注意**：input 的每个元素都被视为一个字符。
13. 重复以下步骤，直到 matchSucceeded 为 false，
    a. 如果 lastIndex > length，则
       i. 如果 global 为 true 或 sticky 为 true，则
          1. 执行 `? Set(R, "lastIndex", +0𝔽, true)`。
       ii. 返回 null。
    b. 令 inputIndex 为从 S 的 lastIndex 元素获取字符的 input 中的索引。
    c. 令 r 为 matcher(input, inputIndex)。
    d. 如果 r 是 FAILURE，则
       i. 如果 sticky 为 true，则
          1. 执行 `? Set(R, "lastIndex", +0𝔽, true)`。
          2. 返回 null。
       ii. 将 lastIndex 设置为 AdvanceStringIndex(S, lastIndex, fullUnicode)。
    e. 否则，
       i. 断言：r 是一个 MatchState。
       ii. 设置 matchSucceeded 为 true。
14. 令 e 为 r.[[EndIndex]]。
15. 如果 fullUnicode 为 true，则将 e 设置为 GetStringIndex(S, e)。
16. 如果 global 为 true 或 sticky 为 true，则
    a. 执行 `? Set(R, "lastIndex", 𝔽(e), true)`。
17. 令 n 为 r.[[Captures]] 中的元素数量。
18. 断言：n = R.[[RegExpRecord]].[[CapturingGroupsCount]]。
19. 断言：n < 2**32 - 1。
20. 令 A 为 `! ArrayCreate(n + 1)`。
21. 断言：A 的 "length" 属性的数学值为 n + 1。
22. 执行 `! CreateDataPropertyOrThrow(A, "index", 𝔽(lastIndex))`。
23. 执行 `! CreateDataPropertyOrThrow(A, "input", S)`。
24. 令 match 为匹配记录 { [[StartIndex]]: lastIndex, [[EndIndex]]: e }。
25. 令 indices 为一个新的空列表。
26. 令 groupNames 为一个新的空列表。
27. 将 match 添加到 indices。
28. 令 matchedSubstr 为 GetMatchString(S, match)。
29. 执行 `! CreateDataPropertyOrThrow(A, "0", matchedSubstr)`。
30. 如果 R 包含任何 GroupName，则
    a. 令 groups 为 OrdinaryObjectCreate(null)。
    b. 令 hasGroups 为 true。
31. 否则，
    a. 令 groups 为 undefined。
    b. 令 hasGroups 为 false。
32. 执行 `! CreateDataPropertyOrThrow(A, "groups", groups)`。
33. 对于每个整数 i，满足 1 ≤ i ≤ n，按升序执行以下步骤，
    a. 令 captureI 为 r.[[Captures]] 的第 i 个元素。
    b. 如果 captureI 为 undefined，则
       i. 令 capturedValue 为 undefined。
       ii. 将 undefined 添加到 indices。
    c. 否则，
       i. 令 captureStart 为 captureI.[[StartIndex]]。
       ii. 令 captureEnd 为 captureI.[[EndIndex]]。
       iii. 如果 fullUnicode 为 true，则
          1. 将 captureStart 设置为 GetStringIndex(S, captureStart)。
          2. 将 captureEnd 设置为 GetStringIndex(S, captureEnd)。
       iv. 令 capture 为匹配记录 { [[StartIndex]]: captureStart, [[EndIndex]]: captureEnd }。
       v. 令 capturedValue 为 GetMatchString(S, capture)。
       vi. 将 capture 添加到 indices。
    d. 执行 `! CreateDataPropertyOrThrow(A, ! ToString(𝔽(i)), capturedValue)`。
    e. 如果 R 的第 i 个捕获由 GroupName 定义，则
       i. 令 s 为该 GroupName 的 CapturingGroupName。
       ii. 执行 `! CreateDataPropertyOrThrow(groups, s, capturedValue)`。
       iii. 将 s 添加到 groupNames。
    f. 否则，
       i. 将 undefined 添加到 groupNames。
34. 如果 hasIndices 为 true，则
    a. 令 indicesArray 为 MakeMatchIndicesIndexPairArray(S, indices, groupNames, hasGroups)。
    b. 执行 `! CreateDataPropertyOrThrow(A, "indices", indicesArray)`。
35. 返回 A。

#### 22.2.7.3 AdvanceStringIndex (S, index, unicode)
抽象

操作 AdvanceStringIndex 接受参数 S（一个字符串）、index（一个非负整数）和 unicode（一个布尔值），返回一个整数。在调用时执行以下步骤：

1. 断言：index ≤ 2**53 - 1。
2. 如果 unicode 为 false，则返回 index + 1。
3. 令 length 为 S 的长度。
4. 如果 index + 1 ≥ length，则返回 index + 1。
5. 令 cp 为 CodePointAt(S, index)。
6. 返回 index + cp.[[CodeUnitCount]]。

#### 22.2.7.4 GetStringIndex (S, codePointIndex)
抽象操作 GetStringIndex 接受参数 S（一个字符串）和 codePointIndex（一个非负整数），返回一个非负整数。它将 S 解释为 UTF-16 编码的代码点序列，如 6.1.4 所述，并返回与代码点索引 codePointIndex 对应的代码单元索引（如果存在）。否则，返回 S 的长度。在调用时执行以下步骤：

1. 如果 S 是空字符串，则返回 0。
2. 令 len 为 S 的长度。
3. 令 codeUnitCount 为 0。
4. 令 codePointCount 为 0。
5. 重复以下步骤，当 codeUnitCount < len 时，
    a. 如果 codePointCount = codePointIndex，则返回 codeUnitCount。
    b. 令 cp 为 CodePointAt(S, codeUnitCount)。
    c. 将 codeUnitCount 设置为 codeUnitCount + cp.[[CodeUnitCount]]。
    d. 将 codePointCount 设置为 codePointCount + 1。
6. 返回 len。

#### 22.2.7.5 匹配记录
匹配记录是用于封装正则表达式匹配或捕获的起始和结束索引的记录值。

匹配记录具有表 69 中列出的字段。

**表 69：匹配记录字段**

| 字段名称       | 值                     | 含义                                               |
|----------------|------------------------|---------------------------------------------------|
| [[StartIndex]] | 一个非负整数           | 匹配开始（含）的字符串起始处的代码单元数           |
| [[EndIndex]]   | 一个大于等于 [[StartIndex]] 的整数 | 匹配结束（不含）的字符串起始处的代码单元数          |

#### 22.2.7.6 GetMatchString (S, match)
抽象操作 GetMatchString 接受参数 S（一个字符串）和 match（一个匹配记录），返回一个字符串。在调用时执行以下步骤：

1. 断言：match.[[StartIndex]] ≤ match.[[EndIndex]] ≤ S 的长度。
2. 返回 S 从 match.[[StartIndex]] 到 match.[[EndIndex]] 的子字符串。

#### 22.2.7.7 GetMatchIndexPair (S, match)
抽象操作 GetMatchIndexPair 接受参数 S（一个字符串）和 match（一个匹配记录），返回一个数组。在调用时执行以下步骤：

1. 断言：match.[[StartIndex]] ≤ match.[[EndIndex]] ≤ S 的长度。
2. 返回 CreateArrayFromList(« 𝔽(match.[[StartIndex]]), 𝔽(match.[[EndIndex]]) »)。

#### 22.2.7.8 MakeMatchIndicesIndexPairArray (S, indices, groupNames, hasGroups)
抽象操作 MakeMatchIndicesIndexPairArray 接受参数 S（一个字符串）、indices（一个匹配记录或 undefined 的列表）、groupNames（一个字符串或 undefined 的列表）和 hasGroups（一个布尔值），返回一个数组。在调用时执行以下步骤：

1. 令 n 为 indices 中的元素数量。
2. 断言：n < 2**32 - 1。
3. 断言：groupNames 具有 n - 1 个元素。
4. **注意**：groupNames 列表从 indices[1] 开始包含与 indices 列表对齐的元素。
5. 令 A 为 `! ArrayCreate(n)`。
6. 如果 hasGroups 为 true，则
    a. 令 groups 为 OrdinaryObjectCreate(null)。
7. 否则，
    a. 令 groups 为 undefined。
8. 执行 `! CreateDataPropertyOrThrow(A, "groups", groups)`。
9. 对于每个整数 i，使得 0 ≤ i < n，按升序执行以下步骤，
    a. 令 matchIndices 为 indices[i]。
    b. 如果 matchIndices 不是 undefined，则
       i. 令 matchIndexPair 为 GetMatchIndexPair(S, matchIndices)。
    c. 否则，
       i. 令 matchIndexPair 为 undefined。
    d. 执行 `! CreateDataPropertyOrThrow(A, ! ToString(𝔽(i)), matchIndexPair)`。
    e. 如果 i > 0 并且 groupNames[i - 1] 不是 undefined，则
       i. 断言：groups 不是 undefined。
       ii. 执行 `! CreateDataPropertyOrThrow(groups, groupNames[i - 1], matchIndexPair)`。
10. 返回 A。

### 22.2.8 正则表达式实例的属性

正则表达式实例是普通对象，继承自正则表达式原型对象的属性。正则表达式实例具有内部插槽 [[OriginalSource]]、[[OriginalFlags]]、[[RegExpRecord]] 和 [[RegExpMatcher]]。[[RegExpMatcher]] 内部插槽的值是正则表达式对象模式的抽象闭包表示。

**注意**
在 ECMAScript 2015 之前，正则表达式实例被指定为具有 "source"、"global"、"ignoreCase" 和 "multiline" 自身数据属性。这些属性现在被指定为 RegExp.prototype 的访问器属性。

正则表达式实例还具有以下属性：

#### 22.2.8.1 lastIndex
"lastIndex" 属性的值指定了开始下一次匹配的字符串索引。在使用时，该值被强制转换为一个整数（参见 22.2.7.2）。此属性应具有以下属性：{ [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false }。

### 22.2.9 正则表达式字符串迭代器对象
正则表达式字符串迭代器是一个对象，表示针对某个特定字符串实例对象和某个特定正则表达式实例对象的特定迭代。正则表达式字符串迭代器对象没有命名构造函数。相反，正则表达式字符串迭代器对象是通过调用某些正则表达式实例对象的方法创建的。

#### 22.2.9.1 CreateRegExpStringIterator (R, S, global, fullUnicode)
抽象操作 CreateRegExpStringIterator 接受参数 R（一个对象）、S（一个字符串）、global（一个布尔值）和 fullUnicode（一个布尔值），返回一个生成器。在调用时执行以下步骤：

1. 创建一个新的抽象闭包，该闭包没有参数，捕获 R、S、global 和 fullUnicode，并在调用时执行以下步骤：
   a. 重复，
      i. 令 match 为 `? RegExpExec(R, S)`。
      ii. 如果 match 为 null，则返回 undefined。
      iii. 如果 global 为 false，则
          1. 执行 `? GeneratorYield(CreateIterResultObject(match, false))`。
          2. 返回 undefined。
      iv. 令 matchStr 为 `? ToString(? Get(match, "0"))`。
      v. 如果 matchStr 是空字符串，则
          1. 令 thisIndex 为 ℝ(? ToLength(? Get(R, "lastIndex")))。
          2. 令 nextIndex 为 AdvanceStringIndex(S, thisIndex, fullUnicode)。
          3. 执行 `? Set(R, "lastIndex", 𝔽(nextIndex), true)`。
      vi. 执行 `? GeneratorYield(CreateIterResultObject(match, false))`。
2. 返回 `CreateIteratorFromClosure(closure, "%RegExpStringIteratorPrototype%", %RegExpStringIteratorPrototype%)`。

#### 22.2.9.2 %RegExpStringIteratorPrototype% 对象
%RegExpStringIteratorPrototype% 对象：

- 具有所有正则表达式字符串迭代器对象继承的属性。
- 是一个普通对象。
- 具有 [[Prototype]] 内部插槽，其值为 %IteratorPrototype%。
- 具有以下属性：

##### 22.2.9.2.1 %RegExpStringIteratorPrototype%.next ()
1. 返回 `? GeneratorResume(this value, EMPTY, "%RegExpStringIteratorPrototype%")`。

##### 22.2.9.2.2 %RegExpStringIteratorPrototype% [@@toStringTag]
@@toStringTag 属性的初始值为字符串 "RegExp String Iterator"。

该属性具有以下属性：{ [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }。

### 23 索引集合
#### 23.1 数组对象
数组是对某类属性名进行特殊处理的特殊对象。有关此特殊处理的定义，请参见 10.4.2。

#### 23.1.1 数组构造函数
数组构造函数：

- 是 %Array%。
- 是全局对象的 "Array" 属性的初始值。
- 在作为构造函数调用时创建并初始化一个新的数组。
- 在作为函数而不是构造函数调用时也会创建并初始化一个新的数组。因此，函数调用 Array(…) 等效于具有相同参数的对象创建表达式 new Array(…)。
- 是一个函数，其行为因其参数的数量和类型而异。
- 可以用作类定义的 extends 子句的值。打算继承特殊数组行为的子类构造函数必须包含对数组构造函数的 super 调用，以初始化作为数组特殊对象的子类实例。然而，大多数 Array.prototype 方法是泛型方法，它们不依赖于它们的 this 值是数组特殊对象。

##### 23.1.1.1 Array (…values)
当调用此函数时，执行以下步骤：

1. 如果 NewTarget 为 undefined，则令 newTarget 为活动函数对象；否则令 newTarget 为 NewTarget。
2. 令 proto 为 `? GetPrototypeFromConstructor(newTarget, "%Array.prototype%")`。
3. 令 numberOfArgs 为 values 中元素的数量。
4. 如果 numberOfArgs = 0，则
   a. 返回 `! ArrayCreate(0, proto)`。
5. 否则如果 numberOfArgs = 1，则
   a. 令 len 为 values[0]。
   b. 令 array 为 `! ArrayCreate(0, proto)`。
   c. 如果 len 不是数字，则
      i. 执行 `! CreateDataPropertyOrThrow(array, "0", len)`。
      ii. 令 intLen 为 1𝔽。
   d. 否则，
      i. 令 intLen 为 `! ToUint32(len)`。
      ii. 如果 SameValueZero(intLen, len) 为 false，则抛出 RangeError 异常。
   e. 执行 `! Set(array, "length", intLen, true)`。
   f. 返回 array。
6. 否则，
   a. 断言：numberOfArgs ≥ 2。
   b. 令 array 为 `? ArrayCreate(numberOfArgs, proto)`。
   c. 令 k 为 0。
   d. 重复，直到 k < numberOfArgs，
      i. 令 Pk 为 `! ToString(𝔽(k))`。
      ii. 令 itemK 为 values[k]。
      iii. 执行 `! CreateDataPropertyOrThrow(array, Pk, itemK)`。
      iv. 将 k 设置为 k + 1。
   e. 断言：array 的 "length" 属性的数学值为 numberOfArgs。
   f. 返回 array。

#### 23.1.2 数组构造函数的属性
数组构造函数：

- 具有 [[Prototype]] 内部插槽，其值为 %Function.prototype%。
- 具有 "length" 属性，其值为 1𝔽。
- 具有以下属性：

##### 23.1.2.1 Array.from (items [ , mapfn [ , thisArg ] ])
当调用此方法时，执行以下步骤：

1. 令 C 为 this 值。
2. 如果 mapfn 为 undefined，则
   a. 令 mapping 为 false。
3. 否则，
   a. 如果 IsCallable(mapfn) 为 false，则抛出 TypeError 异常。
   b. 令 mapping 为 true。
4. 令 usingIterator 为 `? GetMethod(items, @@iterator)`。
5. 如果 usingIterator 不是 undefined，则
   a. 如果 IsConstructor(C) 为 true，则
      i. 令 A 为 `? Construct(C)`。
   b. 否则，
      i. 令 A 为 `! ArrayCreate(0)`。
   c. 令 iteratorRecord 为 `? GetIteratorFromMethod(items, usingIterator)`。
   d. 令 k 为 0。
   e. 重复，
      i. 如果 k ≥ 2**53 - 1，则
         1. 令 error 为 `ThrowCompletion(一个新创建的 TypeError 对象)`。
         2. 返回 `? IteratorClose(iteratorRecord, error)`。
      ii. 令 Pk 为 `! ToString(𝔽(k))`。
      iii. 令 next 为 `? IteratorStepValue(iteratorRecord)`。
      iv. 如果 next 为 DONE，则
         1. 执行 `? Set(A, "length", 𝔽(k), true)`。
         2. 返回 A。
      v. 如果 mapping 为 true，则
         1. 令 mappedValue 为 `Completion(Call(mapfn, thisArg, « next, 𝔽(k) »))`。
         2. `IfAbruptCloseIterator(mappedValue, iteratorRecord)`。
      vi. 否则，
         1. 令 mappedValue 为 next。
      vii. 令 defineStatus 为 `Completion(CreateDataPropertyOrThrow(A, Pk, mappedValue))`。
      viii. `IfAbruptCloseIterator(defineStatus, iteratorRecord)`。
      ix. 将 k 设置为 k + 1。
6. **注意

**：items 不是可迭代对象，因此假设它是类数组对象。
7. 令 arrayLike 为 `! ToObject(items)`。
8. 令 len 为 `? LengthOfArrayLike(arrayLike)`。
9. 如果 IsConstructor(C) 为 true，则
   a. 令 A 为 `? Construct(C, « 𝔽(len) »)`。
10. 否则，
    a. 令 A 为 `? ArrayCreate(len)`。
11. 令 k 为 0。
12. 重复，直到 k < len，
    a. 令 Pk 为 `! ToString(𝔽(k))`。
    b. 令 kValue 为 `? Get(arrayLike, Pk)`。
    c. 如果 mapping 为 true，则
       i. 令 mappedValue 为 `? Call(mapfn, thisArg, « kValue, 𝔽(k) »)`。
    d. 否则，
       i. 令 mappedValue 为 kValue。
    e. 执行 `? CreateDataPropertyOrThrow(A, Pk, mappedValue)`。
    f. 将 k 设置为 k + 1。
13. 执行 `? Set(A, "length", 𝔽(len), true)`。
14. 返回 A。

**注意**
此方法是一个有意设计的通用工厂方法；它不要求其 this 值是数组构造函数。因此，它可以转移到或继承任何其他可以用一个数字参数调用的构造函数。

### 23.1.2.2 Array.isArray(arg)
调用此函数时执行以下步骤：

1. 返回 `? IsArray(arg)`。

### 23.1.2.3 Array.of(...items)
调用此方法时执行以下步骤：

1. 令 len 为 items 中元素的数量。
2. 令 lenNumber 为 𝔽(len)。
3. 令 C 为 this 值。
4. 如果 `IsConstructor(C)` 为 true，则
   a. 令 A 为 `? Construct(C, «lenNumber»)`。
5. 否则，
   a. 令 A 为 `? ArrayCreate(len)`。
6. 令 k 为 0。
7. 重复，直到 k < len，
   a. 令 kValue 为 items[k]。
   b. 令 Pk 为 `! ToString(𝔽(k))`。
   c. 执行 `? CreateDataPropertyOrThrow(A, Pk, kValue)`。
   d. 将 k 设置为 k + 1。
8. 执行 `? Set(A, "length", lenNumber, true)`。
9. 返回 A。

**注意**
此方法是有意设计的通用工厂方法；它不要求其 this 值是数组构造函数。因此，它可以转移到或继承其他可以用单个数字参数调用的构造函数。

### 23.1.2.4 Array.prototype
Array.prototype 的值是数组原型对象。

此属性具有以下属性：{ [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }。

### 23.1.2.5 get Array[@@species]
Array[@@species] 是一个访问器属性，其 set 访问器函数为 undefined。其 get 访问器函数在调用时执行以下步骤：

1. 返回 this 值。
此函数的 "name" 属性值为 "get [Symbol.species]"。

**注意**
数组原型方法通常使用其 this 值的构造函数来创建派生对象。然而，子类构造函数可以通过重新定义其 @@species 属性来覆盖这种默认行为。

### 23.1.3 数组原型对象的属性
数组原型对象：

- 是 %Array.prototype%。
- 是一个数组特殊对象，并具有为此类对象指定的内部方法。
- 具有 "length" 属性，其初始值为 +0𝔽，并且其属性为 { [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false }。
- 具有 [[Prototype]] 内部插槽，其值为 %Object.prototype%。

**注意**
数组原型对象被指定为数组特殊对象，以确保与 ECMAScript 2015 规范之前创建的 ECMAScript 代码兼容。

### 23.1.3.1 Array.prototype.at(index)
1. 令 O 为 `? ToObject(this 值)`。
2. 令 len 为 `? LengthOfArrayLike(O)`。
3. 令 relativeIndex 为 `? ToIntegerOrInfinity(index)`。
4. 如果 relativeIndex ≥ 0，则
   a. 令 k 为 relativeIndex。
5. 否则，
   a. 令 k 为 len + relativeIndex。
6. 如果 k < 0 或 k ≥ len，则返回 undefined。
7. 返回 `? Get(O, ! ToString(𝔽(k)))`。

### 23.1.3.2 Array.prototype.concat(...items)
此方法返回一个包含对象的数组元素以及每个参数的数组元素的新数组。

调用时执行以下步骤：

1. 令 O 为 `? ToObject(this 值)`。
2. 令 A 为 `? ArraySpeciesCreate(O, 0)`。
3. 令 n 为 0。
4. 将 O 预置到 items。
5. 对于 items 中的每个元素 E，执行
   a. 令 spreadable 为 `? IsConcatSpreadable(E)`。
   b. 如果 spreadable 为 true，则
      i. 令 len 为 `? LengthOfArrayLike(E)`。
      ii. 如果 n + len > 2**53 - 1，则抛出 TypeError 异常。
      iii. 令 k 为 0。
      iv. 重复，直到 k < len，
         1. 令 Pk 为 `! ToString(𝔽(k))`。
         2. 令 exists 为 `? HasProperty(E, Pk)`。
         3. 如果 exists 为 true，则
            a. 令 subElement 为 `? Get(E, Pk)`。
            b. 执行 `? CreateDataPropertyOrThrow(A, ! ToString(𝔽(n)), subElement)`。
         4. 将 n 设置为 n + 1。
         5. 将 k 设置为 k + 1。
   c. 否则，
      i. **注意**：E 被作为单个项目添加，而不是展开。
      ii. 如果 n ≥ 2**53 - 1，则抛出 TypeError 异常。
      iii. 执行 `? CreateDataPropertyOrThrow(A, ! ToString(𝔽(n)), E)`。
      iv. 将 n 设置为 n + 1。
6. 执行 `? Set(A, "length", 𝔽(n), true)`。
7. 返回 A。
此方法的 "length" 属性值为 1𝔽。

**注意 1**
在第 6 步中显式设置 "length" 属性，旨在确保当 items 的最终非空元素有尾随空洞或 A 不是内置数组时长度正确。

**注意 2**
此方法是有意设计的通用方法；它不要求其 this 值是数组。因此，它可以转移到其他类型的对象中用作方法。

### 23.1.3.2.1 IsConcatSpreadable(O)
抽象操作 IsConcatSpreadable 接受参数 O（一个 ECMAScript 语言值），返回一个包含布尔值或抛出完成的普通完成。调用时执行以下步骤：

1. 如果 O 不是对象，返回 false。
2. 令 spreadable 为 `? Get(O, @@isConcatSpreadable)`。
3. 如果 spreadable 不是 undefined，返回 ToBoolean(spreadable)。
4. 返回 `? IsArray(O)`。

### 23.1.3.3 Array.prototype.constructor
Array.prototype.constructor 的初始值为 %Array%。

### 23.1.3.4 Array.prototype.copyWithin(target, start[, end])
**注意 1**
end 参数是可选的。如果未提供，则使用 this 值的长度。

**注意 2**
如果 target 为负数，则处理为 length + target，其中 length 为数组的长度。如果 start 为负数，则处理为 length + start。如果 end 为负数，则处理为 length + end。

调用此方法时执行以下步骤：

1. 令 O 为 `? ToObject(this 值)`。
2. 令 len 为 `? LengthOfArrayLike(O)`。
3. 令 relativeTarget 为 `? ToIntegerOrInfinity(target)`。
4. 如果 relativeTarget = -∞，则令 to 为 0。
5. 否则，如果 relativeTarget < 0，则令 to 为 max(len + relativeTarget, 0)。
6. 否则，令 to 为 min(relativeTarget, len)。
7. 令 relativeStart 为 `? ToIntegerOrInfinity(start)`。
8. 如果 relativeStart = -∞，则令 from 为 0。
9. 否则，如果 relativeStart < 0，则令 from 为 max(len + relativeStart, 0)。
10. 否则，令 from 为 min(relativeStart, len)。
11. 如果 end 为 undefined，则令 relativeEnd 为 len；否则令 relativeEnd 为 `? ToIntegerOrInfinity(end)`。
12. 如果 relativeEnd = -∞，则令 final 为 0。
13. 否则，如果 relativeEnd < 0，则令 final 为 max(len + relativeEnd, 0)。
14. 否则，令 final 为 min(relativeEnd, len)。
15. 令 count 为 min(final - from, len - to)。
16. 如果 from < to 且 to < from + count，则
    a. 令 direction 为 -1。
    b. 将 from 设置为 from + count - 1。
    c. 将 to 设置为 to + count - 1。
17. 否则，
    a. 令 direction 为 1。
18. 重复，直到 count > 0，
    a. 令 fromKey 为 `! ToString(𝔽(from))`。
    b. 令 toKey 为 `! ToString(𝔽(to))`。
    c. 令 fromPresent 为 `? HasProperty(O, fromKey)`。
    d. 如果 fromPresent 为 true，则
        i. 令 fromValue 为 `? Get(O, fromKey)`。
        ii. 执行 `? Set(O, toKey, fromValue, true)`。
    e. 否则，
        i. 断言：fromPresent 为 false。
        ii. 执行 `? DeletePropertyOrThrow(O, toKey)`。
    f. 将 from 设置为 from + direction。
    g. 将 to 设置为 to + direction。
    h. 将 count 设置为 count - 1。
19. 返回 O。

**注意 3**
此方法是有意设计的通用方法

；它不要求其 this 值是数组。因此，它可以转移到其他类型的对象中用作方法。

### 23.1.3.5 Array.prototype.entries()
调用此方法时执行以下步骤：

1. 令 O 为 `? ToObject(this 值)`。
2. 返回 CreateArrayIterator(O, KEY+VALUE)。

### 23.1.3.6 Array.prototype.every(callbackfn[, thisArg])
**注意 1**
callbackfn 应该是一个接受三个参数并返回一个可以强制转换为布尔值的函数。every 会按升序调用 callbackfn 一次，直到找到一个 callbackfn 返回 false 的元素。如果找到这样的元素，every 会立即返回 false。否则，every 返回 true。callbackfn 只会被调用数组中实际存在的元素；它不会被调用数组中的缺失元素。

如果提供了 thisArg 参数，它将用作每次调用 callbackfn 的 this 值。如果未提供，则使用 undefined。

callbackfn 被调用时传递三个参数：元素的值、元素的索引和正在遍历的对象。

every 不会直接改变调用它的对象，但对象可能会被调用 callbackfn 的调用所改变。

every 处理的元素范围在第一次调用 callbackfn 前已确定。调用 every 开始后添加到数组中的元素不会被 callbackfn 访问。如果现有数组元素被更改，它们在 every 访问时的值将是访问时的值；调用 every 开始后删除的元素不会被访问。every 的行为类似于数学中的“全称量词”。特别地，对于空数组，它返回 true。

调用此方法时执行以下步骤：

1. 令 O 为 `? ToObject(this 值)`。
2. 令 len 为 `? LengthOfArrayLike(O)`。
3. 如果 `IsCallable(callbackfn)` 为 false，则抛出 TypeError 异常。
4. 令 k 为 0。
5. 重复，直到 k < len，
    a. 令 Pk 为 `! ToString(𝔽(k))`。
    b. 令 kPresent 为 `? HasProperty(O, Pk)`。
    c. 如果 kPresent 为 true，则
        i. 令 kValue 为 `? Get(O, Pk)`。
        ii. 令 testResult 为 ToBoolean(`? Call(callbackfn, thisArg, « kValue, 𝔽(k), O »)`)。
        iii. 如果 testResult 为 false，返回 false。
    d. 将 k 设置为 k + 1。
6. 返回 true。

**注意 2**
此方法是有意设计的通用方法；它不要求其 this 值是数组。因此，它可以转移到其他类型的对象中用作方法。

### 23.1.3.7 Array.prototype.fill(value[, start[, end]])
**注意 1**
start 参数是可选的。如果未提供，则使用 +0𝔽。

end 参数是可选的。如果未提供，则使用 this 值的长度。

**注意 2**
如果 start 为负数，则处理为 length + start，其中 length 是数组的长度。如果 end 为负数，则处理为 length + end。

调用此方法时执行以下步骤：

1. 令 O 为 `? ToObject(this 值)`。
2. 令 len 为 `? LengthOfArrayLike(O)`。
3. 令 relativeStart 为 `? ToIntegerOrInfinity(start)`。
4. 如果 relativeStart = -∞，则令 k 为 0。
5. 否则，如果 relativeStart < 0，则令 k 为 max(len + relativeStart, 0)。
6. 否则，令 k 为 min(relativeStart, len)。
7. 如果 end 为 undefined，则令 relativeEnd 为 len；否则令 relativeEnd 为 `? ToIntegerOrInfinity(end)`。
8. 如果 relativeEnd = -∞，则令 final 为 0。
9. 否则，如果 relativeEnd < 0，则令 final 为 max(len + relativeEnd, 0)。
10. 否则，令 final 为 min(relativeEnd, len)。
11. 重复，直到 k < final，
    a. 令 Pk 为 `! ToString(𝔽(k))`。
    b. 执行 `? Set(O, Pk, value, true)`。
    c. 将 k 设置为 k + 1。
12. 返回 O。

**注意 3**
此方法是有意设计的通用方法；它不要求其 this 值是数组。因此，它可以转移到其他类型的对象中用作方法。

### 23.1.3.8 Array.prototype.filter(callbackfn[, thisArg])
**注意 1**
callbackfn 应该是一个接受三个参数并返回一个可以强制转换为布尔值的函数。filter 会按升序调用 callbackfn 一次，并构造一个包含 callbackfn 返回 true 的所有值的新数组。callbackfn 只会被调用数组中实际存在的元素；它不会被调用数组中的缺失元素。

如果提供了 thisArg 参数，它将用作每次调用 callbackfn 的 this 值。如果未提供，则使用 undefined。

callbackfn 被调用时传递三个参数：元素的值、元素的索引和正在遍历的对象。

filter 不会直接改变调用它的对象，但对象可能会被调用 callbackfn 的调用所改变。

filter 处理的元素范围在第一次调用 callbackfn 前已确定。调用 filter 开始后添加到数组中的元素不会被 callbackfn 访问。如果现有数组元素被更改，它们在 filter 访问时的值将是访问时的值；调用 filter 开始后删除的元素不会被访问。

调用此方法时执行以下步骤：

1. 令 O 为 `? ToObject(this 值)`。
2. 令 len 为 `? LengthOfArrayLike(O)`。
3. 如果 `IsCallable(callbackfn)` 为 false，则抛出 TypeError 异常。
4. 令 A 为 `? ArraySpeciesCreate(O, 0)`。
5. 令 k 为 0。
6. 令 to 为 0。
7. 重复，直到 k < len，
    a. 令 Pk 为 `! ToString(𝔽(k))`。
    b. 令 kPresent 为 `? HasProperty(O, Pk)`。
    c. 如果 kPresent 为 true，则
        i. 令 kValue 为 `? Get(O, Pk)`。
        ii. 令 selected 为 ToBoolean(`? Call(callbackfn, thisArg, «kValue, 𝔽(k), O»`)。
        iii. 如果 selected 为 true，则
            1. 执行 `? CreateDataPropertyOrThrow(A, ! ToString(𝔽(to)), kValue)`。
            2. 将 to 设置为 to + 1。
    d. 将 k 设置为 k + 1。
8. 返回 A。

**注意 2**
此方法是有意设计的通用方法；它不要求其 this 值是数组。因此，它可以转移到其他类型的对象中用作方法。

### 23.1.3.9 Array.prototype.find(predicate[, thisArg])
**注意 1**
此方法按升序索引顺序调用 predicate 一次，直到找到一个使 predicate 返回值为 true 的元素。如果找到这样的元素，find 立即返回该元素值。否则，find 返回 undefined。

有关更多信息，请参见 FindViaPredicate。

调用此方法时执行以下步骤：

1. 令 O 为 `? ToObject(this 值)`。
2. 令 len 为 `? LengthOfArrayLike(O)`。
3. 令 findRec 为 `? FindViaPredicate(O, len, ASCENDING, predicate, thisArg)`。
4. 返回 findRec.[[Value]]。

**注意 2**
此方法是有意设计的通用方法；它不要求其 this 值是数组。因此，它可以转移到其他类型的对象中用作方法。

### 23.1.3.10 Array.prototype.findIndex(predicate[, thisArg])
**注意 1**
此方法按升序索引顺序调用 predicate 一次，直到找到一个使 predicate 返回值为 true 的元素。如果找到这样的元素，findIndex 立即返回该元素值的索引。否则，findIndex 返回 -1。

有关更多信息，请参见 FindViaPredicate。

调用此方法时执行以下步骤：

1. 令 O 为 `? ToObject(this 值)`。
2. 令 len 为 `? LengthOfArrayLike(O)`。
3. 令 findRec 为 `? FindViaPredicate(O, len, ASCENDING, predicate, thisArg)`。
4. 返回 findRec.[[Index]]。

**注意 2**
此方法是有意设计的通用方法；它不要求其 this 值是数组。因此，它可以转移到其他类型的对象中用作方法。

### 23.1.3.11 Array.prototype.findLast(predicate[, thisArg])
**注意 1**
此方法按降序索引顺序调用 predicate 一次，直到找到一个使 predicate 返回值为 true 的元素。如果找到这样的元素，findLast 立即返回该元素值。否则，findLast 返回 undefined。

有关更多信息，请参见 FindViaPredicate。

调用此方法时执行以下步骤：

1. 令 O 为 `? ToObject(this 值)`。
2. 令 len 为 `? LengthOfArrayLike(O)`。
3. 令 findRec 为 `? FindViaPredicate(O, len, DESCENDING, predicate, thisArg)`。
4. 返回 findRec.[[Value]]。

**注意 2**
此方法是有意设计的通用方法；它不要求其 this 值是数组对象。因此，它可以转移到其他类型的对象中用作方法。

### 23.1.3.12 Array.prototype.findLastIndex(predicate[, thisArg])
**注意 1**
此方法按降序索引顺序调用 predicate 一次，直到找到一个使 predicate 返回值为 true 的元素。如果找到这样的元素，findLastIndex 立即返回该元素值的索引。否则，findLastIndex 返回 -1。

有关更多信息，请参见 FindViaPredicate。

调用此方法时执行以下步骤：

1. 令 O 为 `? ToObject(this 值)`。
2. 令 len 为 `? LengthOfArrayLike(O)`。
3. 令 findRec 为 `? FindViaPredicate(O, len, DESCENDING, predicate, thisArg)`。
4. 返回 findRec.[[Index]]。

**注意 2**
此方法是有意设计的通用方法；它不要求其 this 值是数组对象。因此，它可以转移到其他类型的对象中用作方法。

### 23.1.3.12.1 通过谓词查找 (FindViaPredicate)

抽象操作 FindViaPredicate 接受参数 O（一个对象）、len（一个非负整数）、direction（ASCENDING 或 DESCENDING）、predicate（一个 ECMAScript 语言值）和 thisArg（一个 ECMAScript 语言值），并返回一个包含字段 [[Index]]（一个整数）和 [[Value]]（一个 ECMAScript 语言值）的普通完成记录，或抛出一个完成异常。

O 应为类数组对象或 TypedArray。此操作会对 O 的每个元素调用一次 predicate，按照 direction 指定的顺序（升序或降序），直到找到一个使 predicate 返回一个可以转换为 true 的值的元素。此时，该操作会返回一个记录，其中包含找到的元素的索引和值。如果未找到此类元素，则该操作会返回一个索引为 -1𝔽，值为 undefined 的记录。

predicate 应为一个函数。调用数组元素时，会传递三个参数：元素的值、元素的索引以及正在遍历的对象。返回值将被强制转换为布尔值。

thisArg 将作为每次调用 predicate 时的 this 值。

此操作不会直接更改调用它的对象，但对象可能会因调用 predicate 而发生变化。

在遍历开始前，处理元素的范围已设置。在这之后附加到数组的元素不会被 predicate 访问。如果数组的现有元素发生变化，它们传递给 predicate 的值将是此操作访问它们时的值。遍历开始后且在访问前被删除的元素仍会被访问，并从原型或 undefined 中查找。

当被调用时，执行以下步骤：

1. 如果 predicate 不是可调用的，抛出一个 TypeError 异常。
2. 如果 direction 是 ASCENDING，则
   a. 令 indices 为从 0（包含）到 len（不包含）区间内整数的升序列表。
3. 否则，
   a. 令 indices 为从 0（包含）到 len（不包含）区间内整数的降序列表。
4. 对于 indices 中的每个整数 k，执行
   a. 令 Pk 为 ! ToString(𝔽(k))。
   b. 注意：如果 O 是 TypedArray，接下来的 Get 调用将返回一个普通完成。
   c. 令 kValue 为 ? Get(O, Pk)。
   d. 令 testResult 为 ? Call(predicate, thisArg, « kValue, 𝔽(k), O »)。
   e. 如果 ToBoolean(testResult) 为 true，返回记录 { [[Index]]: 𝔽(k), [[Value]]: kValue }。
5. 返回记录 { [[Index]]: -1𝔽, [[Value]]: undefined }。

### 23.1.3.13 Array.prototype.flat（[depth]）

调用该方法时执行以下步骤：

1. 令 O 为 ? ToObject(this value)。
2. 令 sourceLen 为 ? LengthOfArrayLike(O)。
3. 令 depthNum 为 1。
4. 如果 depth 不是 undefined，则
   a. 将 depthNum 设置为 ? ToIntegerOrInfinity(depth)。
   b. 如果 depthNum < 0，则将 depthNum 设置为 0。
5. 令 A 为 ? ArraySpeciesCreate(O, 0)。
6. 执行 ? FlattenIntoArray(A, O, sourceLen, 0, depthNum)。
7. 返回 A。

### 23.1.3.13.1 FlattenIntoArray（target, source, sourceLen, start, depth [ , mapperFunction [ , thisArg ] ]）

抽象操作 FlattenIntoArray 接受参数 target（一个对象）、source（一个对象）、sourceLen（一个非负整数）、start（一个非负整数）、depth（一个非负整数或 +∞），以及可选参数 mapperFunction（一个函数对象）和 thisArg（一个 ECMAScript 语言值），并返回一个包含非负整数的普通完成或一个抛出完成。调用时执行以下步骤：

1. 断言：如果存在 mapperFunction，则 IsCallable(mapperFunction) 为 true，thisArg 存在且 depth 为 1。
2. 令 targetIndex 为 start。
3. 令 sourceIndex 为 +0𝔽。
4. 重复，当 ℝ(sourceIndex) < sourceLen 时，
   a. 令 P 为 ! ToString(sourceIndex)。
   b. 令 exists 为 ? HasProperty(source, P)。
   c. 如果 exists 为 true，则
      i. 令 element 为 ? Get(source, P)。
      ii. 如果存在 mapperFunction，则
         1. 将 element 设置为 ? Call(mapperFunction, thisArg, « element, sourceIndex, source »)。
      iii. 令 shouldFlatten 为 false。
      iv. 如果 depth > 0，则
         1. 将 shouldFlatten 设置为 ? IsArray(element)。
      v. 如果 shouldFlatten 为 true，则
         1. 如果 depth = +∞，则 newDepth 为 +∞。
         2. 否则，令 newDepth 为 depth - 1。
         3. 令 elementLen 为 ? LengthOfArrayLike(element)。
         4. 将 targetIndex 设置为 ? FlattenIntoArray(target, element, elementLen, targetIndex, newDepth)。
      vi. 否则，
         1. 如果 targetIndex ≥ 2**53 - 1，抛出一个 TypeError 异常。
         2. 执行 ? CreateDataPropertyOrThrow(target, ! ToString(𝔽(targetIndex)), element)。
         3. 将 targetIndex 设置为 targetIndex + 1。
   d. 将 sourceIndex 设置为 sourceIndex + 1𝔽。
5. 返回 targetIndex。

### 23.1.3.14 Array.prototype.flatMap（mapperFunction [ , thisArg ]）

调用该方法时执行以下步骤：

1. 令 O 为 ? ToObject(this value)。
2. 令 sourceLen 为 ? LengthOfArrayLike(O)。
3. 如果 mapperFunction 不是可调用的，抛出一个 TypeError 异常。
4. 令 A 为 ? ArraySpeciesCreate(O, 0)。
5. 执行 ? FlattenIntoArray(A, O, sourceLen, 0, 1, mapperFunction, thisArg)。
6. 返回 A。

### 23.1.3.15 Array.prototype.forEach（callbackfn [ , thisArg ]）

注释 1：callbackfn 应为一个接受三个参数的函数。forEach 为数组中每个存在的元素调用一次 callbackfn，按升序调用。仅对实际存在的数组元素调用 callbackfn；不会对缺失的元素调用。

如果提供了 thisArg 参数，它将作为每次调用 callbackfn 的 this 值。如果未提供，则使用 undefined。

callbackfn 被调用时会传递三个参数：元素的值、元素的索引以及正在遍历的对象。

forEach 不会直接更改调用它的对象，但对象可能会因调用 callbackfn 而发生变化。

forEach 处理的元素范围在第一次调用 callbackfn 前设置。在这之后附加到数组的元素不会被 callbackfn 访问。如果数组的现有元素发生变化，它们传递给 callbackfn 的值将是 forEach 访问它们时的值；在调用 forEach 开始后且在访问前被删除的元素不会被访问。

调用该方法时执行以下步骤：

1. 令 O 为 ? ToObject(this value)。
2. 令 len 为 ? LengthOfArrayLike(O)。
3. 如果 callbackfn 不是可调用的，抛出一个 TypeError 异常。
4. 令 k 为 0。
5. 重复，直到 k < len，
   a. 令 Pk 为 ! ToString(𝔽(k))。
   b. 令 kPresent 为 ? HasProperty(O, Pk)。
   c. 如果 kPresent 为 true，则
      i. 令 kValue 为 ? Get(O, Pk)。
      ii. 执行 ? Call(callbackfn, thisArg, « kValue, 𝔽(k), O »)。
   d. 将 k 设置为 k + 1。
6. 返回 undefined。

注释 2：该方法有意设计为通用；它不要求 its this value 必须为数组。因此，它可以转移到其他类型的对象上用作方法。

### 23.1.3.16 Array.prototype.includes ( searchElement [ , fromIndex ] )

**注1：**
该方法使用 SameValueZero 算法按升序将 searchElement 与数组元素进行比较，如果在任意位置找到则返回 true；否则，返回 false。

第二个可选参数 fromIndex 默认值为 +0𝔽（即搜索整个数组）。如果它大于或等于数组长度，则返回 false，即不会搜索数组。如果小于 -0𝔽，则作为从数组末尾计算的偏移量用于计算 fromIndex。如果计算出的索引小于或等于 +0𝔽，则搜索整个数组。

当调用此方法时，执行以下步骤：

1. 令 O 为 ? ToObject(this value)。
2. 令 len 为 ? LengthOfArrayLike(O)。
3. 如果 len = 0，返回 false。
4. 令 n 为 ? ToIntegerOrInfinity(fromIndex)。
5. 断言：如果 fromIndex 未定义，则 n 为 0。
6. 如果 n = +∞，返回 false。
7. 否则如果 n = -∞，将 n 设为 0。
8. 如果 n ≥ 0，则
   a. 令 k 为 n。
9. 否则，
   a. 令 k 为 len + n。
   b. 如果 k < 0，将 k 设为 0。
10. 重复，直到 k < len，
   a. 令 elementK 为 ? Get(O, ! ToString(𝔽(k)))。
   b. 如果 SameValueZero(searchElement, elementK) 为 true，返回 true。
   c. 将 k 设为 k + 1。
11. 返回 false。

**注2：**
该方法有意设计为通用方法；它不要求其 this 值是一个数组。因此，可以将其转移到其他类型的对象上用作方法。

**注3：**
该方法有意与类似的 indexOf 方法在两方面不同。首先，它使用 SameValueZero 算法，而不是 IsStrictlyEqual，从而能够检测到 NaN 数组元素。其次，它不会跳过缺失的数组元素，而是将它们视为 undefined。

### 23.1.3.17 Array.prototype.indexOf ( searchElement [ , fromIndex ] )

该方法使用 IsStrictlyEqual 算法按升序将 searchElement 与数组元素进行比较，如果在一个或多个索引处找到，返回最小的那个索引；否则，返回 -1𝔽。

**注1：**
第二个可选参数 fromIndex 默认值为 +0𝔽（即搜索整个数组）。如果它大于或等于数组长度，则返回 -1𝔽，即不会搜索数组。如果小于 -0𝔽，则作为从数组末尾计算的偏移量用于计算 fromIndex。如果计算出的索引小于或等于 +0𝔽，则搜索整个数组。

当调用此方法时，执行以下步骤：

1. 令 O 为 ? ToObject(this value)。
2. 令 len 为 ? LengthOfArrayLike(O)。
3. 如果 len = 0，返回 -1𝔽。
4. 令 n 为 ? ToIntegerOrInfinity(fromIndex)。
5. 断言：如果 fromIndex 未定义，则 n 为 0。
6. 如果 n = +∞，返回 -1𝔽。
7. 否则如果 n = -∞，将 n 设为 0。
8. 如果 n ≥ 0，则
   a. 令 k 为 n。
9. 否则，
   a. 令 k 为 len + n。
   b. 如果 k < 0，将 k 设为 0。
10. 重复，直到 k < len，
   a. 令 Pk 为 ! ToString(𝔽(k))。
   b. 令 kPresent 为 ? HasProperty(O, Pk)。
   c. 如果 kPresent 为 true，则
      i. 令 elementK 为 ? Get(O, Pk)。
      ii. 如果 IsStrictlyEqual(searchElement, elementK) 为 true，返回 𝔽(k)。
   d. 将 k 设为 k + 1。
11. 返回 -1𝔽。

**注2：**
该方法有意设计为通用方法；它不要求其 this 值是一个数组。因此，可以将其转移到其他类型的对象上用作方法。

### 23.1.3.18 Array.prototype.join ( separator )

该方法将数组元素转换为字符串，然后将这些字符串连接起来，用 separator 分隔。如果未提供 separator，则使用单个逗号作为分隔符。

当调用此方法时，执行以下步骤：

1. 令 O 为 ? ToObject(this value)。
2. 令 len 为 ? LengthOfArrayLike(O)。
3. 如果 separator 未定义，令 sep 为 ","。
4. 否则，令 sep 为 ? ToString(separator)。
5. 令 R 为空字符串。
6. 令 k 为 0。
7. 重复，直到 k < len，
   a. 如果 k > 0，将 R 设为 R 与 sep 的字符串连接。
   b. 令 element 为 ? Get(O, ! ToString(𝔽(k)))。
   c. 如果 element 既不是 undefined 也不是 null，则
      i. 令 S 为 ? ToString(element)。
      ii. 将 R 设为 R 与 S 的字符串连接。
   d. 将 k 设为 k + 1。
8. 返回 R。

**注：**
该方法有意设计为通用方法；它不要求其 this 值是一个数组。因此，可以将其转移到其他类型的对象上用作方法。

### 23.1.3.19 Array.prototype.keys ( )

调用此方法时执行以下步骤：

1. 令 O 为 ? ToObject(this value)。
2. 返回 CreateArrayIterator(O, KEY)。

### 23.1.3.20 Array.prototype.lastIndexOf ( searchElement [ , fromIndex ] )

**注1：**
该方法使用 IsStrictlyEqual 算法按降序将 searchElement 与数组元素进行比较，如果在一个或多个索引处找到，返回最大的那个索引；否则，返回 -1𝔽。

第二个可选参数 fromIndex 默认值为数组的长度减一（即搜索整个数组）。如果它大于或等于数组长度，则搜索整个数组。如果小于 -0𝔽，则作为从数组末尾计算的偏移量用于计算 fromIndex。如果计算出的索引小于或等于 +0𝔽，则返回 -1𝔽。

调用此方法时执行以下步骤：

1. 令 O 为 ? ToObject(this value)。
2. 令 len 为 ? LengthOfArrayLike(O)。
3. 如果 len = 0，返回 -1𝔽。
4. 如果 fromIndex 存在，令 n 为 ? ToIntegerOrInfinity(fromIndex)；否则令 n 为 len - 1。
5. 如果 n = -∞，返回 -1𝔽。
6. 如果 n ≥ 0，则
   a. 令 k 为 min(n, len - 1)。
7. 否则，
   a. 令 k 为 len + n。
8. 重复，直到 k ≥ 0，
   a. 令 Pk 为 ! ToString(𝔽(k))。
   b. 令 kPresent 为 ? HasProperty(O, Pk)。
   c. 如果 kPresent 为 true，则
      i. 令 elementK 为 ? Get(O, Pk)。
      ii. 如果 IsStrictlyEqual(searchElement, elementK) 为 true，返回 𝔽(k)。
   d. 将 k 设为 k - 1。
9. 返回 -1𝔽。

**注2：**
该方法有意设计为通用方法；它不要求其 this 值是一个数组。因此，可以将其转移到其他类型的对象上用作方法。

### 23.1.3.21 Array.prototype.map ( callbackfn [ , thisArg ] )

**注1：**
callbackfn 应该是一个接受三个参数的函数。map 会按升序为数组中的每个元素调用一次 callbackfn，并根据结果构建一个新数组。callbackfn 仅对数组中实际存在的元素调用；不会为数组中的缺失元素调用。

如果提供了 thisArg 参数，它将在每次调用 callbackfn 时用作 this 值。如果未提供，则使用 undefined。

callbackfn 使用三个参数调用：元素的值、元素的索引和正在遍历的对象。

map 不直接改变调用它的对象，但对象可能会因为调用 callbackfn 而改变。

map 处理的元素范围在首次调用 callbackfn 之前确定。调用 map 开始后添加到数组中的元素不会被 callbackfn 访问。如果数组中现有的元素发生变化，则其值在 map 访问它们时将是变化后的值；调用 map 后在被访问之前删除的元素不会被访问。

调用此方法时执行以下步骤：

1. 令 O 为 ? ToObject(this value)。
2. 令 len 为 ? LengthOfArrayLike(O)。
3. 如果 IsCallable(callbackfn) 为 false，抛出一个 TypeError 异常。
4. 令 A 为 ? ArraySpeciesCreate(O, len)。
5. 令 k 为 0。
6. 重复，直到 k < len，
   a. 令 Pk 为 ! ToString(𝔽(k))。
   b. 令 kPresent 为 ? HasProperty(O, Pk)。
   c. 如果 kPresent 为 true，则
      i. 令 kValue 为 ? Get(O, Pk)。
      ii. 令 mappedValue 为 ? Call(callbackfn, thisArg, « kValue, 𝔽(k), O »)。
      iii. 执行 ? CreateDataPropertyOrThrow(A, Pk, mappedValue)。
   d. 将 k 设为 k + 1。
7. 返回 A。

**注2：**
该方法有意设计为通用方法；它不要求其 this 值是一个数组。因此，可以将其转移到其他类型的对象上用作方法。

### 23.1.3.22 Array.prototype.pop ( )

**注1：**
该方法移除数组的最后一个元素并返回它。

调用此方法时执行以下步骤：

1. 令 O 为 ? ToObject(this value)。
2. 令 len 为 ? LengthOfArrayLike(O)。
3. 如果 len = 0，则
   a. 执行 ? Set(O, "length", +0𝔽, true)。
   b. 返回 undefined。
4. 否则，
   a. 断言：len > 0。
   b. 令 newLen 为 𝔽(len - 1)。
   c. 令 index 为 ! ToString(newLen)。
   d. 令 element 为 ? Get(O, index)。
   e. 执行 ? DeletePropertyOrThrow(O, index)。
   f. 执行 ? Set(O, "length", newLen, true)。
   g. 返回 element。

**注2：**
该方法有意设计为通用方法；它不要求其 this 值是一个数组。因此，可以将其转移到其他类型的对象上用作方法。

### 23.1.3.23 Array.prototype.push ( ...items )

**注1：**
该方法按参数出现的顺序将参数附加到数组的末尾。它返回数组的新长度。

调用此方法时执行以下步骤：

1. 令 O 为 ? ToObject(this value)。
2. 令 len 为 ? LengthOfArrayLike(O)。
3. 令 argCount 为 items 中元素的数量。
4. 如果 len + argCount > 2**53 - 1，抛出一个 TypeError 异常。
5. 对于 items 中的每个元素 E，执行
   a. 执行 ? Set(O, ! ToString(𝔽(len)), E, true)。
   b. 令 len 为 len + 1。
6. 执行 ? Set(O, "length", 𝔽(len), true)。
7. 返回 𝔽(len)。

该方法的 "length" 属性为 1𝔽。

**注2：**
该方法有意设计为通用方法；它不要求其 this 值是一个数组。因此，可以将其转移到其他类型的对象上用作方法。

### 23.1.3.24 Array.prototype.reduce ( callbackfn [ , initialValue ] )

**注1：**
callbackfn 应该是一个接受四个参数的函数。reduce 将 callbackfn 作为函数调用一次，对于数组中从第一个元素开始的每个元素，按升序进行。

callbackfn 用四个参数调用：previousValue（上一次调用 callbackfn 的返回值）、currentValue（当前元素的值）、currentIndex 和正在遍历的对象。第一次调用 callbackfn 时，previousValue 和 currentValue 可以是两种值之一。如果在调用 reduce 时提供了 initialValue，则 previousValue 为 initialValue，currentValue 为数组中的第一个值。如果未提供 initialValue，则 previousValue 为数组中的第一个值，currentValue 为第二个值。如果数组中没有元素且未提供 initialValue，则抛出一个 TypeError。

reduce 不直接改变调用它的对象，但对象可能会因为调用 callbackfn 而改变。

reduce 处理的元素范围在首次调用 callbackfn 之前确定。调用 reduce 开始后添加到数组中的元素不会被 callbackfn 访问。如果数组中现有的元素发生变化，则其值在 reduce 访问它们时将是变化后的值；调用 reduce 后在被访问之前删除的元素不会被访问。

调用此方法时执行以下步骤：

1. 令 O 为 ? ToObject(this value)。
2. 令 len 为 ? LengthOfArrayLike(O)。
3. 如果 IsCallable(callbackfn) 为 false，抛出一个 TypeError 异常。
4. 如果 len = 0 且未提供 initialValue，抛出一个 TypeError 异常。
5. 令 k 为 0。
6. 令 accumulator 为 undefined。
7. 如果提供了 initialValue，则
   a. 将 accumulator 设为 initialValue。
8. 否则，
   a. 令 kPresent 为 false。
   b. 重复，直到 kPresent 为 false 且 k < len，
      i. 令 Pk 为 ! ToString(𝔽(k))。
      ii. 将 kPresent 设为 ? HasProperty(O, Pk)。
      iii. 如果 kPresent 为 true，则
         1. 将 accumulator 设为 ? Get(O, Pk)。
      iv. 将 k 设为 k + 1。
   c. 如果 kPresent 为 false，抛出一个 TypeError 异常。
9. 重复，直到 k < len，
   a. 令 Pk 为 ! ToString(𝔽(k))。
   b. 令 kPresent 为 ? HasProperty(O, Pk)。
   c. 如果 kPresent 为 true，则
      i. 令 kValue 为 ? Get(O, Pk)。
      ii. 将 accumulator 设为 ? Call(callbackfn, undefined, « accumulator, kValue, 𝔽(k), O »)。
   d. 将 k 设为 k + 1。
10. 返回 accumulator。

**注2：**
该方法有意设计为通用方法；它不要求其 this 值是一个数组。因此，可以将其转移到其他类型的对象上用作方法。

### 23.1.3.25 Array.prototype.reduceRight ( callbackfn [ , initialValue ] )

**注1：**
callbackfn 应该是一个接受四个参数的函数。reduceRight 将 callbackfn 作为函数调用一次，对于数组中从第一个元素开始的每个元素，按降序进行。

callbackfn 用四个参数调用：previousValue（上一次调用 callbackfn 的返回值）、currentValue（当前元素的值）、currentIndex 和正在遍历的对象。第一次调用 callbackfn 时，previousValue 和 currentValue 可以是两种值之一。如果在调用 reduceRight 时提供了 initialValue，则 previousValue 为 initialValue，currentValue 为数组中的最后一个值。如果未提供 initialValue，则 previousValue 为数组中的最后一个值，currentValue 为倒数第二个值。如果数组中没有元素且未提供 initialValue，则抛出一个 TypeError。

reduceRight 不直接改变调用它的对象，但对象可能会因为调用 callbackfn 而改变。

reduceRight 处理的元素范围在首次调用 callbackfn 之前确定。调用 reduceRight 开始后添加到数组中的元素不会被 callbackfn 访问。如果数组中现有的元素发生变化，则其值在 reduceRight 访问它们时将是变化后的值；调用 reduceRight 后在被访问之前删除的元素不会被访问。

调用此方法时执行以下步骤：

1. 令 O 为 ? ToObject(this value)。
2. 令 len 为 ? LengthOfArrayLike(O)。
3. 如果 IsCallable(callbackfn) 为 false，抛出一个 TypeError 异常。
4. 如果 len = 0 且未提供 initialValue，抛出一个 TypeError 异常。
5. 令 k 为 len - 1。
6. 令 accumulator 为 undefined。
7. 如果提供了 initialValue，则
   a. 将 accumulator 设为 initialValue。
8. 否则，
   a. 令 kPresent 为 false。
   b. 重复，直到 kPresent 为 false 且 k ≥ 0，
      i. 令 Pk 为 ! ToString(𝔽(k))。
      ii. 将 kPresent 设为 ? HasProperty(O, Pk)。
      iii. 如果 kPresent 为 true，则
         1. 将 accumulator 设为 ? Get(O, Pk)。
      iv. 将 k 设为 k - 1。
   c. 如果 kPresent 为 false，抛出一个 TypeError 异常。
9. 重复，直到 k ≥ 0，
   a. 令 Pk 为 ! ToString(𝔽(k))。
   b. 令 kPresent 为 ? HasProperty(O, Pk)。
   c. 如果 kPresent 为 true，则
      i. 令 kValue 为 ? Get(O, Pk)。
      ii. 将 accumulator 设为 ? Call(callbackfn, undefined, « accumulator, kValue, 𝔽(k), O »)。
   d. 将 k 设为 k - 1。
10. 返回 accumulator。

**注2：**
该方法有意设计为通用方法；它不要求其 this 值是一个数组。因此，可以将其转移到其他类型的对象上用作方法。

### 23.1.3.26 Array.prototype.reverse ( )

**注1：**
该方法重新排列数组的元素以使其顺序相反。它返回调用它的对象。

调用此方法时执行以下步骤：

1. 令 O 为 ? ToObject(this value)。
2. 令 len 为 ? LengthOfArrayLike(O)。
3. 令 middle 为 floor(len / 2)。
4. 令 lower 为 0。
5. 重复，直到 lower ≠ middle，
   a. 令 upper 为 len - lower - 1。
   b. 令 upperP 为 ! ToString(𝔽(upper))。
   c. 令 lowerP 为 ! ToString(𝔽(lower))。
   d. 令 lowerExists 为 ? HasProperty(O, lowerP)。
   e. 如果 lowerExists 为 true，则
      i. 令 lowerValue 为 ? Get(O, lowerP)。
   f. 令 upperExists 为 ? HasProperty(O, upperP)。
   g. 如果 upperExists 为 true，则
      i. 令 upperValue 为 ? Get(O, upperP)。
   h. 如果 lowerExists 为 true 且 upperExists 为 true，则
      i. 执行 ? Set(O, lowerP, upperValue, true)。
      ii. 执行 ? Set(O, upperP, lowerValue, true)。
   i. 否则如果 lowerExists 为 false 且 upperExists 为 true，则
      i. 执行 ? Set(O, lowerP, upperValue, true)。
      ii. 执行 ? DeletePropertyOrThrow(O, upperP)。
   j. 否则如果 lowerExists 为 true 且 upperExists 为 false，则
      i. 执行 ? DeletePropertyOrThrow(O, lowerP)。
      ii. 执行 ? Set(O, upperP, lowerValue, true)。
   k. 否则，
      i. 断言：lowerExists 和 upperExists 均为 false。
      ii. **注**：不需要采取任何行动。
   l. 将 lower 设为 lower + 1。
6. 返回 O。

**注2：**
该方法有意设计为通用方法；它不要求其 this 值是一个数组。因此，可以将其转移到其他类型的对象上用作方法。

### 23.1.3.27 Array.prototype.shift ( )

该方法移除数组的第一个元素并返回它。

调用此方法时执行以下步骤：

1. 令 O 为 ? ToObject(this value)。
2. 令 len 为 ? LengthOfArrayLike(O)。
3. 如果 len = 0，则
   a. 执行 ? Set(O, "length", +0𝔽, true)。
   b. 返回 undefined。
4. 令 first 为 ? Get(O, "0")。
5. 令 k 为 1。
6. 重复，直到 k < len，
   a. 令 from 为 ! ToString(𝔽(k))。
   b. 令 to 为 ! ToString(𝔽(k - 1))。


   c. 令 fromPresent 为 ? HasProperty(O, from)。
   d. 如果 fromPresent 为 true，则
      i. 令 fromValue 为 ? Get(O, from)。
      ii. 执行 ? Set(O, to, fromValue, true)。
   e. 否则，
      i. 断言：fromPresent 为 false。
      ii. 执行 ? DeletePropertyOrThrow(O, to)。
   f. 将 k 设为 k + 1。
7. 执行 ? DeletePropertyOrThrow(O, ! ToString(𝔽(len - 1)))。
8. 执行 ? Set(O, "length", 𝔽(len - 1), true)。
9. 返回 first。

**注：**
该方法有意设计为通用方法；它不要求其 this 值是一个数组。因此，可以将其转移到其他类型的对象上用作方法。

### 23.1.3.28 Array.prototype.slice ( start, end )

该方法返回一个包含数组从元素 start 到（但不包括）元素 end 的元素的新数组（或到数组末尾，如果 end 未定义）。如果 start 为负数，则将其视为 length + start，其中 length 是数组的长度。如果 end 为负数，则将其视为 length + end，其中 length 是数组的长度。

调用此方法时执行以下步骤：

1. 令 O 为 ? ToObject(this value)。
2. 令 len 为 ? LengthOfArrayLike(O)。
3. 令 relativeStart 为 ? ToIntegerOrInfinity(start)。
4. 如果 relativeStart = -∞，令 k 为 0。
5. 否则如果 relativeStart < 0，令 k 为 max(len + relativeStart, 0)。
6. 否则，令 k 为 min(relativeStart, len)。
7. 如果 end 未定义，令 relativeEnd 为 len；否则令 relativeEnd 为 ? ToIntegerOrInfinity(end)。
8. 如果 relativeEnd = -∞，令 final 为 0。
9. 否则如果 relativeEnd < 0，令 final 为 max(len + relativeEnd, 0)。
10. 否则，令 final 为 min(relativeEnd, len)。
11. 令 count 为 max(final - k, 0)。
12. 令 A 为 ? ArraySpeciesCreate(O, count)。
13. 令 n 为 0。
14. 重复，直到 k < final，
    a. 令 Pk 为 ! ToString(𝔽(k))。
    b. 令 kPresent 为 ? HasProperty(O, Pk)。
    c. 如果 kPresent 为 true，则
       i. 令 kValue 为 ? Get(O, Pk)。
       ii. 执行 ? CreateDataPropertyOrThrow(A, ! ToString(𝔽(n)), kValue)。
    d. 将 k 设为 k + 1。
    e. 将 n 设为 n + 1。
15. 执行 ? Set(A, "length", 𝔽(n), true)。
16. 返回 A。

**注1：**
步骤 15 中显式设置 "length" 属性旨在确保即使 A 不是内置数组，长度也是正确的。

**注2：**
该方法有意设计为通用方法；它不要求其 this 值是一个数组。因此，可以将其转移到其他类型的对象上用作方法。

### 23.1.3.29 Array.prototype.some ( callbackfn [ , thisArg ] )

**注1：**
callbackfn 应该是一个接受三个参数并返回一个可强制转换为布尔值的值的函数。some 按升序调用 callbackfn 一次，以检查数组中的每个元素，直到找到一个返回 true 的元素。如果找到这样的元素，some 立即返回 true。否则，some 返回 false。callbackfn 仅对数组中实际存在的元素调用；不会对数组中的缺失元素调用。

如果提供了 thisArg 参数，它将在每次调用 callbackfn 时用作 this 值。如果未提供，则使用 undefined。

callbackfn 使用三个参数调用：元素的值、元素的索引和正在遍历的对象。

some 不直接改变调用它的对象，但对象可能会因为调用 callbackfn 而改变。

some 处理的元素范围在首次调用 callbackfn 之前确定。调用 some 开始后添加到数组中的元素不会被 callbackfn 访问。如果数组中现有的元素发生变化，则其值在 some 访问它们时将是变化后的值；调用 some 后在被访问之前删除的元素不会被访问。some 类似于数学中的“存在”量词。特别地，对于空数组，它返回 false。

调用此方法时执行以下步骤：

1. 令 O 为 ? ToObject(this value)。
2. 令 len 为 ? LengthOfArrayLike(O)。
3. 如果 IsCallable(callbackfn) 为 false，抛出一个 TypeError 异常。
4. 令 k 为 0。
5. 重复，直到 k < len，
   a. 令 Pk 为 ! ToString(𝔽(k))。
   b. 令 kPresent 为 ? HasProperty(O, Pk)。
   c. 如果 kPresent 为 true，则
      i. 令 kValue 为 ? Get(O, Pk)。
      ii. 令 testResult 为 ToBoolean(? Call(callbackfn, thisArg, « kValue, 𝔽(k), O »))。
      iii. 如果 testResult 为 true，返回 true。
   d. 将 k 设为 k + 1。
6. 返回 false。

**注2：**
该方法有意设计为通用方法；它不要求其 this 值是一个数组。因此，可以将其转移到其他类型的对象上用作方法。

### 23.1.3.30 Array.prototype.sort ( comparefn )

该方法对数组的元素进行排序。排序必须是稳定的（即比较相等的元素必须保持其原始顺序）。如果 comparefn 未定义，则其应为一个接受两个参数 x 和 y 的函数，并在 x < y 时返回一个负数，在 x > y 时返回一个正数，否则返回 0。

调用此方法时执行以下步骤：

1. 如果 comparefn 未定义且 IsCallable(comparefn) 为 false，抛出一个 TypeError 异常。
2. 令 obj 为 ? ToObject(this value)。
3. 令 len 为 ? LengthOfArrayLike(obj)。
4. 令 SortCompare 为一个新的抽象闭包，参数为 (x, y)，捕获 comparefn 并在调用时执行以下步骤：
   a. 返回 ? CompareArrayElements(x, y, comparefn)。
5. 令 sortedList 为 ? SortIndexedProperties(obj, len, SortCompare, SKIP-HOLES)。
6. 令 itemCount 为 sortedList 中元素的数量。
7. 令 j 为 0。
8. 重复，直到 j < itemCount，
   a. 执行 ? Set(obj, ! ToString(𝔽(j)), sortedList[j], true)。
   b. 将 j 设为 j + 1。
9. **注**：步骤 5 中对 SortIndexedProperties 的调用使用了 SKIP-HOLES。删除剩余的索引以保留排序时检测到的孔的数量。
10. 重复，直到 j < len，
    a. 执行 ? DeletePropertyOrThrow(obj, ! ToString(𝔽(j)))。
    b. 将 j 设为 j + 1。
11. 返回 obj。

**注1：**
由于不存在的属性值总是大于 undefined 属性值，且 undefined 总是大于任何其他值（见 CompareArrayElements），undefined 属性值总是排序到结果的末尾，后面是不存在的属性值。

**注2：**
由 ToString 抽象操作在步骤 5 和 6 中执行的方法调用可能导致 SortCompare 不作为一致的比较器行为。

**注3：**
该方法有意设计为通用方法；它不要求其 this 值是一个数组。因此，可以将其转移到其他类型的对象上用作方法。

### 23.1.3.30.1 SortIndexedProperties ( obj, len, SortCompare, holes )

抽象操作 SortIndexedProperties 接受参数 obj（一个对象）、len（一个非负整数）、SortCompare（一个有两个参数的抽象闭包）和 holes（SKIP-HOLES 或 READ-THROUGH-HOLES），并返回一个包含 ECMAScript 语言值的列表的正常完成或抛出完成。调用时执行以下步骤：

1. 令 items 为一个新的空列表。
2. 令 k 为 0。
3. 重复，直到 k < len，
   a. 令 Pk 为 ! ToString(𝔽(k))。
   b. 如果 holes 是 SKIP-HOLES，则
      i. 令 kRead 为 ? HasProperty(obj, Pk)。
   c. 否则，
      i. 断言：holes 是 READ-THROUGH-HOLES。
      ii. 令 kRead 为 true。
   d. 如果 kRead 为 true，则
      i. 令 kValue 为 ? Get(obj, Pk)。
      ii. 将 kValue 添加到 items。
   e. 将 k 设为 k + 1。
4. 使用调用 SortCompare 的实现定义的顺序对 items 进行排序。如果任何此类调用返回一个突然完成，则在执行任何进一步的 SortCompare 调用之前停止并返回该完成记录。
5. 返回 items。

排序顺序是上述算法第 4 步完成后 items 的顺序。如果 SortCompare 不是 items 元素的一致比较器，则排序顺序是实现定义的。当 SortIndexedProperties 被 Array.prototype.sort 调用时，如果 comparefn 未定义，并且对 SortCompare 作为参数传递的任何特定值的所有 ToString 调用不产生相同的结果，则排序顺序也是实现定义的。

除非排序顺序被指定为实现定义，否则它必须满足以下所有条件：

- 必须存在一些小于 itemCount 的非负整数的数学排列 π，使得对于每个小于 itemCount 的非负整数 j，元素 old[j] 与 new[π(j)] 完全相同。
- 对于所有小于 itemCount 的非负整数 j 和 k，如果 ℝ(SortCompare(old[j], old[k])) < 0，则 π(j) < π(k)。

这里的记号 old[j] 用于指代第 4 步执行前的 items[j]，记号 new[j] 用于指代第 4 步执行后的 items[j]。

一个抽象闭包或函数比较器是值集 S 的一致比较器，如果所有值 a、b 和 c（可能是相同的值）都满足以下要求：记号 a <C b 表示 ℝ(comparator(a, b)) < 0；a =C b 表示 ℝ(comparator(a, b)) = 0；a >C b 表示 ℝ(comparator(a, b)) > 0。

- 调用 comparator(a, b) 时，给定一对特定的值 a 和 b 作为两个参数时，总是返回相同的值 v。此外，v 是一个数字，并且 v 不是 NaN。注意，这意味着对于一对给定的 a 和 b，a <C b、a =C b 和 a >C b 中只有一个会为 true。
- 调用 comparator(a, b) 不会修改 obj 或 obj 原型链上的任何对象。
- a =C a（自反性）
- 如果 a =C b，则 b =C a（对称性）
- 如果 a =C b 且 b =C c，则 a =C c（=C 的传递性）
- 如果 a <C b 且 b <C c，则 a <C c（<C 的传递性）
- 如果 a >C b 且 b >C c，则 a >C c（>C 的传递性）

**注：**
上述条件是确保 comparator 将值集 S 划分为等价类并且这些等价类完全有序的必要且充分条件。

### 23.1.3.30.2 CompareArrayElements ( x, y, comparefn )

抽象操作 CompareArrayElements 接受参数 x（一个 ECMAScript 语言值）、y（一个 ECMAScript 语言值）和 comparefn（一个函数对象或 undefined），并返回一个包含数字的正常完成或突然完成。调用时执行以下步骤：

1. 如果 x 和 y 均为 undefined，返回 +0𝔽。
2. 如果 x 为 undefined，返回 1𝔽。
3. 如果 y 为 undefined，返回 -1𝔽。
4. 如果 comparefn 未定义，则
   a

. 令 v 为 ? ToNumber(? Call(comparefn, undefined, « x, y »))。
   b. 如果 v 是 NaN，返回 +0𝔽。
   c. 返回 v。
5. 令 xString 为 ? ToString(x)。
6. 令 yString 为 ? ToString(y)。
7. 令 xSmaller 为 ! IsLessThan(xString, yString, true)。
8. 如果 xSmaller 为 true，返回 -1𝔽。
9. 令 ySmaller 为 ! IsLessThan(yString, xString, true)。
10. 如果 ySmaller 为 true，返回 1𝔽。
11. 返回 +0𝔽。

### 23.1.3.31 Array.prototype.splice ( start, deleteCount, ...items )

**注1：**
该方法从整数索引 start 开始删除 deleteCount 个数组元素，并用 items 的元素替换它们。它返回一个包含被删除元素（如果有）的数组。

调用此方法时执行以下步骤：

1. 令 O 为 ? ToObject(this value)。
2. 令 len 为 ? LengthOfArrayLike(O)。
3. 令 relativeStart 为 ? ToIntegerOrInfinity(start)。
4. 如果 relativeStart = -∞，令 actualStart 为 0。
5. 否则如果 relativeStart < 0，令 actualStart 为 max(len + relativeStart, 0)。
6. 否则，令 actualStart 为 min(relativeStart, len)。
7. 令 itemCount 为 items 中元素的数量。
8. 如果 start 不存在，则
   a. 令 actualDeleteCount 为 0。
9. 否则如果 deleteCount 不存在，则
   a. 令 actualDeleteCount 为 len - actualStart。
10. 否则，
    a. 令 dc 为 ? ToIntegerOrInfinity(deleteCount)。
    b. 令 actualDeleteCount 为将 dc 限制在 0 到 len - actualStart 之间的结果。
11. 如果 len + itemCount - actualDeleteCount > 2**53 - 1，抛出一个 TypeError 异常。
12. 令 A 为 ? ArraySpeciesCreate(O, actualDeleteCount)。
13. 令 k 为 0。
14. 重复，直到 k < actualDeleteCount，
    a. 令 from 为 ! ToString(𝔽(actualStart + k))。
    b. 如果 ? HasProperty(O, from) 为 true，则
       i. 令 fromValue 为 ? Get(O, from)。
       ii. 执行 ? CreateDataPropertyOrThrow(A, ! ToString(𝔽(k)), fromValue)。
    c. 将 k 设为 k + 1。
15. 执行 ? Set(A, "length", 𝔽(actualDeleteCount), true)。
16. 如果 itemCount < actualDeleteCount，则
    a. 将 k 设为 actualStart。
    b. 重复，直到 k < (len - actualDeleteCount)，
       i. 令 from 为 ! ToString(𝔽(k + actualDeleteCount))。
       ii. 令 to 为 ! ToString(𝔽(k + itemCount))。
       iii. 如果 ? HasProperty(O, from) 为 true，则
           1. 令 fromValue 为 ? Get(O, from)。
           2. 执行 ? Set(O, to, fromValue, true)。
       iv. 否则，
           1. 执行 ? DeletePropertyOrThrow(O, to)。
       v. 将 k 设为 k + 1。
    c. 将 k 设为 len。
    d. 重复，直到 k > (len - actualDeleteCount + itemCount)，
       i. 执行 ? DeletePropertyOrThrow(O, ! ToString(𝔽(k - 1)))。
       ii. 将 k 设为 k - 1。
17. 否则如果 itemCount > actualDeleteCount，则
    a. 将 k 设为 (len - actualDeleteCount)。
    b. 重复，直到 k > actualStart，
       i. 令 from 为 ! ToString(𝔽(k + actualDeleteCount - 1))。
       ii. 令 to 为 ! ToString(𝔽(k + itemCount - 1))。
       iii. 如果 ? HasProperty(O, from) 为 true，则
           1. 令 fromValue 为 ? Get(O, from)。
           2. 执行 ? Set(O, to, fromValue, true)。
       iv. 否则，
           1. 执行 ? DeletePropertyOrThrow(O, to)。
       v. 将 k 设为 k - 1。
18. 将 k 设为 actualStart。
19. 对 items 中的每个元素 E，执行
    a. 执行 ? Set(O, ! ToString(𝔽(k)), E, true)。
    b. 将 k 设为 k + 1。
20. 执行 ? Set(O, "length", 𝔽(len - actualDeleteCount + itemCount), true)。
21. 返回 A。

**注2：**
步骤 15 和 20 中显式设置 "length" 属性旨在确保长度即使在对象不是内置数组时也是正确的。

**注3：**
该方法有意设计为通用方法；它不要求其 this 值是一个数组。因此，可以将其转移到其他类型的对象上用作方法。

### 23.1.3.32 Array.prototype.toLocaleString ( [ reserved1 [ , reserved2 ] ] )

包含 ECMA-402 国际化 API 的 ECMAScript 实现必须按照 ECMA-402 规范实现此方法。如果 ECMAScript 实现不包含 ECMA-402 API，则使用以下方法规范。

**注1：**
ECMA-402 的第一版不包括此方法的替代规范。

此方法的可选参数的含义在 ECMA-402 规范中定义；不包含 ECMA-402 支持的实现不得将这些参数位置用于其他任何用途。

调用此方法时执行以下步骤：

1. 令 array 为 ? ToObject(this value)。
2. 令 len 为 ? LengthOfArrayLike(array)。
3. 令 separator 为适合于宿主环境当前语言环境的实现定义的列表分隔字符串值（例如 ", "）。
4. 令 R 为空字符串。
5. 令 k 为 0。
6. 重复，直到 k < len，
   a. 如果 k > 0，将 R 设为 R 和 separator 的字符串连接。
   b. 令 element 为 ? Get(array, ! ToString(𝔽(k)))。
   c. 如果 element 既不是 undefined 也不是 null，则
      i. 令 S 为 ? ToString(? Invoke(element, "toLocaleString"))。
      ii. 将 R 设为 R 和 S 的字符串连接。
   d. 将 k 设为 k + 1。
7. 返回 R。

**注2：**
此方法使用数组元素的 toLocaleString 方法将它们转换为字符串，然后用实现定义的语言环境敏感分隔符字符串将这些字符串连接起来。此方法类似于 toString，但其目的是产生与宿主环境当前语言环境约定相对应的语言环境敏感结果。

**注3：**
该方法有意设计为通用方法；它不要求其 this 值是一个数组。因此，可以将其转移到其他类型的对象上用作方法。

### 23.1.3.33 Array.prototype.toReversed ( )

调用此方法时执行以下步骤：

1. 令 O 为 ? ToObject(this value)。
2. 令 len 为 ? LengthOfArrayLike(O)。
3. 令 A 为 ? ArrayCreate(len)。
4. 令 k 为 0。
5. 重复，直到 k < len，
   a. 令 from 为 ! ToString(𝔽(len - k - 1))。
   b. 令 Pk 为 ! ToString(𝔽(k))。
   c. 令 fromValue 为 ? Get(O, from)。
   d. 执行 ! CreateDataPropertyOrThrow(A, Pk, fromValue)。
   e. 将 k 设为 k + 1。
6. 返回 A。

### 23.1.3.34 Array.prototype.toSorted ( comparefn )

调用此方法时执行以下步骤：

1. 如果 comparefn 未定义且 IsCallable(comparefn) 为 false，抛出一个 TypeError 异常。
2. 令 O 为 ? ToObject(this value)。
3. 令 len 为 ? LengthOfArrayLike(O)。
4. 令 A 为 ? ArrayCreate(len)。
5. 令 SortCompare 为一个新的抽象闭包，参数为 (x, y)，捕获 comparefn 并在调用时执行以下步骤：
   a. 返回 ? CompareArrayElements(x, y, comparefn)。
6. 令 sortedList 为 ? SortIndexedProperties(O, len, SortCompare, READ-THROUGH-HOLES)。
7. 令 j 为 0。
8. 重复，直到 j < len，
   a. 执行 ! CreateDataPropertyOrThrow(A, ! ToString(𝔽(j)), sortedList[j])。
   b. 将 j 设为 j + 1。
9. 返回 A。

### 23.1.3.35 Array.prototype.toSpliced ( start, skipCount, ...items )
### 23.1.3.35 Array.prototype.toSpliced ( start, skipCount, ...items )

调用此方法时执行以下步骤：

1. 令 O 为 ? ToObject(this value)。
2. 令 len 为 ? LengthOfArrayLike(O)。
3. 令 relativeStart 为 ? ToIntegerOrInfinity(start)。
4. 如果 relativeStart = -∞，令 actualStart 为 0。
5. 否则如果 relativeStart < 0，令 actualStart 为 max(len + relativeStart, 0)。
6. 否则，令 actualStart 为 min(relativeStart, len)。
7. 令 insertCount 为 items 中元素的数量。
8. 如果 start 不存在，则
   a. 令 actualSkipCount 为 0。
9. 否则如果 skipCount 不存在，则
   a. 令 actualSkipCount 为 len - actualStart。
10. 否则，
    a. 令 sc 为 ? ToIntegerOrInfinity(skipCount)。
    b. 令 actualSkipCount 为将 sc 限制在 0 到 len - actualStart 之间的结果。
11. 令 newLen 为 len + insertCount - actualSkipCount。
12. 如果 newLen > 2**53 - 1，抛出一个 TypeError 异常。
13. 令 A 为 ? ArrayCreate(newLen)。
14. 令 i 为 0。
15. 令 r 为 actualStart + actualSkipCount。
16. 重复，直到 i < actualStart，
    a. 令 Pi 为 ! ToString(𝔽(i))。
    b. 令 iValue 为 ? Get(O, Pi)。
    c. 执行 ! CreateDataPropertyOrThrow(A, Pi, iValue)。
    d. 将 i 设为 i + 1。
17. 对 items 中的每个元素 E，执行
    a. 令 Pi 为 ! ToString(𝔽(i))。
    b. 执行 ! CreateDataPropertyOrThrow(A, Pi, E)。
    c. 将 i 设为 i + 1。
18. 重复，直到 i < newLen，
    a. 令 Pi 为 ! ToString(𝔽(i))。
    b. 令 from 为 ! ToString(𝔽(r))。
    c. 令 fromValue 为 ? Get(O, from)。
    d. 执行 ! CreateDataPropertyOrThrow(A, Pi, fromValue)。
    e. 将 i 设为 i + 1。
    f. 将 r 设为 r + 1。
19. 返回 A。

### 23.1.3.36 Array.prototype.toString ( )

调用此方法时执行以下步骤：

1. 令 array 为 ? ToObject(this value)。
2. 令 func 为 ? Get(array, "join")。
3. 如果 IsCallable(func) 为 false，将 func 设为内置函数 %Object.prototype.toString%。
4. 返回 ? Call(func, array)。

**注：**
该方法有意设计为通用方法；它不要求其 this 值是一个数组。因此，可以将其转移到其他类型的对象上用作方法。

### 23.1.3.37 Array.prototype.unshift ( ...items )

该方法将参数预置到数组的开头，使它们在数组中的顺序与它们在参数列表中出现的顺序相同。

调用此方法时执行以下步骤：

1. 令 O 为 ? ToObject(this value)。
2. 令 len 为 ? LengthOfArrayLike(O)。
3. 令 argCount 为 items 中元素的数量。
4. 如果 argCount > 0，则
   a. 如果 len + argCount > 2**53 - 1，抛出一个 TypeError 异常。
   b. 令 k 为 len。
   c. 重复，直到 k > 0，
      i. 令 from 为 ! ToString(𝔽(k - 1))。
      ii. 令 to 为 ! ToString(𝔽(k + argCount - 1))。
      iii. 令 fromPresent 为 ? HasProperty(O, from)。
      iv. 如果 fromPresent 为 true，则
          1. 令 fromValue 为 ? Get(O, from)。
          2. 执行 ? Set(O, to, fromValue, true)。
      v. 否则，
          1. 断言：fromPresent 为 false。
          2. 执行 ? DeletePropertyOrThrow(O, to)。
      vi. 将 k 设为 k - 1。
   d. 令 j 为 +0𝔽。
   e. 对 items 中的每个元素 E，执行
      i. 执行 ? Set(O, ! ToString(j), E, true)。
      ii. 将 j 设为 j + 1𝔽。
5. 执行 ? Set(O, "length", 𝔽(len + argCount), true)。
6. 返回 𝔽(len + argCount)。

该方法的 "length" 属性为 1𝔽。

**注：**
该方法有意设计为通用方法；它不要求其 this 值是一个数组。因此，可以将其转移到其他类型的对象上用作方法。

### 23.1.3.38 Array.prototype.values ( )

调用此方法时执行以下步骤：

1. 令 O 为 ? ToObject(this value)。
2. 返回 CreateArrayIterator(O, VALUE)。

### 23.1.3.39 Array.prototype.with ( index, value )

调用此方法时执行以下步骤：

1. 令 O 为 ? ToObject(this value)。
2. 令 len 为 ? LengthOfArrayLike(O)。
3. 令 relativeIndex 为 ? ToIntegerOrInfinity(index)。
4. 如果 relativeIndex ≥ 0，令 actualIndex 为 relativeIndex。
5. 否则，令 actualIndex 为 len + relativeIndex。
6. 如果 actualIndex ≥ len 或 actualIndex < 0，抛出一个 RangeError 异常。
7. 令 A 为 ? ArrayCreate(len)。
8. 令 k 为 0。
9. 重复，直到 k < len，
   a. 令 Pk 为 ! ToString(𝔽(k))。
   b. 如果 k = actualIndex，令 fromValue 为 value。
   c. 否则，令 fromValue 为 ? Get(O, Pk)。
   d. 执行 ! CreateDataPropertyOrThrow(A, Pk, fromValue)。
   e. 将 k 设为 k + 1。
10. 返回 A。

### 23.1.3.40 Array.prototype [ @@iterator ] ( )

@@iterator 属性的初始值是 %Array.prototype.values%，定义在 23.1.3.38 中。

### 23.1.3.41 Array.prototype [ @@unscopables ]

@@unscopables 数据属性的初始值是一个按以下步骤创建的对象：

1. 令 unscopableList 为 OrdinaryObjectCreate(null)。
2. 执行 ! CreateDataPropertyOrThrow(unscopableList, "at", true)。
3. 执行 ! CreateDataPropertyOrThrow(unscopableList, "copyWithin", true)。
4. 执行 ! CreateDataPropertyOrThrow(unscopableList, "entries", true)。
5. 执行 ! CreateDataPropertyOrThrow(unscopableList, "fill", true)。
6. 执行 ! CreateDataPropertyOrThrow(unscopableList, "find", true)。
7. 执行 ! CreateDataPropertyOrThrow(unscopableList, "findIndex", true)。
8. 执行 ! CreateDataPropertyOrThrow(unscopableList, "findLast", true)。
9. 执行 ! CreateDataPropertyOrThrow(unscopableList, "findLastIndex", true)。
10. 执行 ! CreateDataPropertyOrThrow(unscopableList, "flat", true)。
11. 执行 ! CreateDataPropertyOrThrow(unscopableList, "flatMap", true)。
12. 执行 ! CreateDataPropertyOrThrow(unscopableList, "includes", true)。
13. 执行 ! CreateDataPropertyOrThrow(unscopableList, "keys", true)。
14. 执行 ! CreateDataPropertyOrThrow(unscopableList, "toReversed", true)。
15. 执行 ! CreateDataPropertyOrThrow(unscopableList, "toSorted", true)。
16. 执行 ! CreateDataPropertyOrThrow(unscopableList, "toSpliced", true)。
17. 执行 ! CreateDataPropertyOrThrow(unscopableList, "values", true)。
18. 返回 unscopableList。

该属性具有 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true } 的属性。

**注：**
该对象的自有属性名称是 ECMAScript 2015 规范之前未包含为 Array.prototype 标准属性的属性名称。这些名称在 with 语句绑定目的中被忽略，以保留现有代码的行为，这些代码可能会使用其中一个名称作为外部作用域中的绑定，而该绑定被 with 语句的绑定对象数组所遮蔽。

"with" 未包含在 unscopableList 中的原因是它已经是一个保留字。

### 23.1.4 Array 实例的属性

Array 实例是 Array 特殊对象，并且具有为此类对象指定的内部方法。Array 实例从 Array 原型对象继承属性。

Array 实例具有一个 "length" 属性，以及一组具有数组索引名称的可枚举属性。

#### 23.1.4.1 length

Array 实例的 "length" 属性是一个数据属性，其值总是大于每个名称为数组索引且为可配置自有属性的名称。

"length" 属性最初具有 { [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false } 的属性。

**注：**
减少 "length" 属性的值会导致删除其数组索引在旧长度值和新长度值之间的自有数组元素。然而，不能删除不可配置的属性。尝试将 Array 的 "length" 属性设置为小于或等于现有不可配置数组索引属性的最大数值自有属性名的值，将导致 "length" 被设置为一个比该不可配置数值自有属性名大一的数值。见 10.4.2.1。

### 23.1.5 Array 迭代器对象

Array 迭代器是一个对象，表示对某个特定 Array 实例对象的特定迭代。Array 迭代器对象没有命名构造函数。相反，Array 迭代器对象是通过调用 Array 实例对象的某些方法创建的。

#### 23.1.5.1 CreateArrayIterator ( array, kind )

抽象操作 CreateArrayIterator 接受参数 array（一个对象）和 kind（KEY+VALUE、KEY 或 VALUE），并返回一个生成器。它用于为返回此类迭代器的 Array 方法创建迭代器对象。调用时执行以下步骤：

1. 令 closure 为一个没有参数的新抽象闭包，捕获 kind 和 array，并在调用时执行以下步骤：
   a. 令 index 为 0。
   b. 重复，
      i. 如果 array 具有 [[TypedArrayName]] 内部槽，
         1. 令 taRecord 为 MakeTypedArrayWithBufferWitnessRecord(array, SEQ-CST)。
         2. 如果 IsTypedArrayOutOfBounds(taRecord) 为 true，抛出一个 TypeError 异常。
         3. 令 len 为 TypedArrayLength(taRecord)。
      ii. 否则，
         1. 令 len 为 ? LengthOfArrayLike(array)。
      iii. 如果 index ≥ len，返回 NormalCompletion(undefined)。
      iv. 令 indexNumber 为 𝔽(index)。
      v. 如果 kind 是 KEY，
         1. 令 result 为 indexNumber。
      vi. 否则，
         1. 令 elementKey 为 ! ToString(indexNumber)。
         2. 令 elementValue 为 ? Get(array, elementKey)。
         3. 如果 kind 是 VALUE，
            a. 令 result 为 elementValue。
         4. 否则，
            a. 断言：kind 是 KEY+VALUE。
            b. 令 result 为 CreateArrayFromList(« indexNumber, elementValue »)。
      vii. 执行 ? GeneratorYield(CreateIterResultObject(result, false))。
      viii. 将 index 设为 index + 1。
2. 返回 CreateIteratorFromClosure(closure, "%ArrayIteratorPrototype%", %ArrayIteratorPrototype%)。

#### 23.1.5.2 %ArrayIteratorPrototype% 对象

%ArrayIteratorPrototype% 对象：

- 具有所有 Array 迭代器对象继承的属性。
- 是一个普通对象。
- 具有 [[Prototype]] 内部槽，其值为 %IteratorPrototype%。
- 具有以下属性：

##### 23.1.5.2.1 %ArrayIteratorPrototype%.next ( )

1. 返回 ? GeneratorResume(this value, EMPTY, "%ArrayIteratorPrototype%")。

##### 23.1.5.2.2 %ArrayIteratorPrototype% [ @@toStringTag ]

@@toStringTag 属性的初始值是字符串 "Array Iterator"。

该属性具有 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true } 的属性。

### 23.2 TypedArray 对象

TypedArray 提供了底层二进制数据缓冲区的类数组视图（参见 25.1）。TypedArray 元素类型是所有 TypedArray 实例元素所具有的底层二进制标量数据类型。表 70 中列出了每种支持的元素类型的独特 TypedArray 构造函数。表 70 中的每个构造函数都有一个相应的独特原型对象。

**表 70: TypedArray 构造函数**
| 构造函数名称和内在对象 | 元素类型       | 元素大小 | 转换操作   | 描述                                  |
|--------------------------|-----------------|----------|------------|---------------------------------------|
| Int8Array                | %Int8Array%     | INT8     | 1          | ToInt8      | 8位二进制补码有符号整数           |
| Uint8Array               | %Uint8Array%    | UINT8    | 1          | ToUint8     | 8位无符号整数                     |
| Uint8ClampedArray        | %Uint8ClampedArray% | UINT8CLAMPED | 1 | ToUint8Clamp | 8位无符号整数（夹取转换）     |
| Int16Array               | %Int16Array%    | INT16    | 2          | ToInt16     | 16位二进制补码有符号整数          |
| Uint16Array              | %Uint16Array%   | UINT16   | 2          | ToUint16    | 16位无符号整数                    |
| Int32Array               | %Int32Array%    | INT32    | 4          | ToInt32     | 32位二进制补码有符号整数          |
| Uint32Array              | %Uint32Array%   | UINT32   | 4          | ToUint32    | 32位无符号整数                    |
| BigInt64Array            | %BigInt64Array% | BIGINT64 | 8          | ToBigInt64  | 64位二进制补码有符号整数          |
| BigUint64Array           | %BigUint64Array% | BIGUINT64 | 8         | ToBigUint64 | 64位无符号整数                   |
| Float32Array             | %Float32Array%  | FLOAT32  | 4          |            | 32位IEEE浮点数                   |
| Float64Array             | %Float64Array%  | FLOAT64  | 8          |            | 64位IEEE浮点数                   |

在下面的定义中，TypedArray 的引用应替换为上表中的适当构造函数名称。

### 23.2.1 %TypedArray% 内在对象

%TypedArray% 内在对象：

- 是一个构造函数对象，所有 TypedArray 构造函数对象都继承自它。
- 以及其相应的原型对象，提供所有 TypedArray 构造函数及其实例继承的通用属性。
- 没有全局名称或作为全局对象的属性出现。
- 作为各种 TypedArray 构造函数的抽象超类。
- 调用时会抛出错误，因为它是一个抽象类构造函数。TypedArray 构造函数不会对其进行超调用。

#### 23.2.1.1 %TypedArray% ( )

调用此函数时执行以下步骤：

1. 抛出一个 TypeError 异常。

此函数的 "length" 属性为 +0𝔽。

### 23.2.2 %TypedArray% 内在对象的属性

%TypedArray% 内在对象：

- 具有 [[Prototype]] 内部槽，其值为 %Function.prototype%。
- 具有 "name" 属性，其值为 "TypedArray"。
- 具有以下属性：

#### 23.2.2.1 %TypedArray%.from ( source [ , mapfn [ , thisArg ] ] )

调用此方法时执行以下步骤：

1. 令 C 为 this 值。
2. 如果 IsConstructor(C) 为 false，抛出一个 TypeError 异常。
3. 如果 mapfn 未定义，则
   a. 令 mapping 为 false。
4. 否则，
   a. 如果 IsCallable(mapfn) 为 false，抛出一个 TypeError 异常。
   b. 令 mapping 为 true。
5. 令 usingIterator 为 ? GetMethod(source, @@iterator)。
6. 如果 usingIterator 不为 undefined，则
   a. 令 values 为 ? IteratorToList(? GetIteratorFromMethod(source, usingIterator))。
   b. 令 len 为 values 中元素的数量。
   c. 令 targetObj 为 ? TypedArrayCreateFromConstructor(C, « 𝔽(len) »)。
   d. 令 k 为 0。
   e. 重复，直到 k < len，
      i. 令 Pk 为 ! ToString(𝔽(k))。
      ii. 令 kValue 为 values 的第一个元素。
      iii. 从 values 中移除第一个元素。
      iv. 如果 mapping 为 true，则
          1. 令 mappedValue 为 ? Call(mapfn, thisArg, « kValue, 𝔽(k) »)。
      v. 否则，
          1. 令 mappedValue 为 kValue。
      vi. 执行 ? Set(targetObj, Pk, mappedValue, true)。
      vii. 将 k 设为 k + 1。
   f. 断言：values 现在是一个空列表。
   g. 返回 targetObj。
7. **注：** source 不是 Iterable，因此假设它已经是一个类数组对象。
8. 令 arrayLike 为 ! ToObject(source)。
9. 令 len 为 ? LengthOfArrayLike(arrayLike)。
10. 令 targetObj 为 ? TypedArrayCreateFromConstructor(C, « 𝔽(len) »)。
11. 令 k 为 0。
12. 重复，直到 k < len，
    a. 令 Pk 为 ! ToString(𝔽(k))。
    b. 令 kValue 为 ? Get(arrayLike, Pk)。
    c. 如果 mapping 为 true，则
       i. 令 mappedValue 为 ? Call(mapfn, thisArg, « kValue, 𝔽(k) »)。
    d. 否则，
       i. 令 mappedValue 为 kValue。
    e. 执行 ? Set(targetObj, Pk, mappedValue, true)。
    f. 将 k 设为 k + 1。
13. 返回 targetObj。

#### 23.2.2.2 %TypedArray%.of ( ...items )

调用此方法时执行以下步骤：

1. 令 len 为 items 中元素的数量。
2. 令 C 为 this 值。
3. 如果 IsConstructor(C) 为 false，抛出一个 TypeError 异常。
4. 令 newObj 为 ? TypedArrayCreateFromConstructor(C, « 𝔽(len) »)。
5. 令 k 为 0。
6. 重复，直到 k < len，
    a. 令 kValue 为 items[k]。
    b. 令 Pk 为 ! ToString(𝔽(k))。
    c. 执行 ? Set(newObj, Pk, kValue, true)。
    d. 将 k 设为 k + 1。
7. 返回 newObj。

#### 23.2.2.3 %TypedArray%.prototype

%TypedArray%.prototype 的初始值是 %TypedArray% 原型对象。

此属性具有 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } 的属性。

#### 23.2.2.4 get %TypedArray% [ @@species ]

%TypedArray%[@@species] 是一个访问器属性，其 set 访问器函数为 undefined。其 get 访问器函数在调用时执行以下步骤：

1. 返回 this 值。

此函数的 "name" 属性的值为 "get [Symbol.species]"。

**注：**
%TypedArray.prototype% 方法通常使用其 this 值的构造函数来创建派生对象。然而，子类构造函数可以通过重新定义其 @@species 属性来覆盖该默认行为。

### 23.2.3 %TypedArray% 原型对象的属性

%TypedArray% 原型对象：

- 具有 [[Prototype]] 内部槽，其值为 %Object.prototype%。
- 是 %TypedArray.prototype%。
- 是一个普通对象。
- 没有 [[ViewedArrayBuffer]] 或任何其他特定于 TypedArray 实例对象的内部槽。

#### 23.2.3.1 %TypedArray%.prototype.at ( index )

1. 令 O 为 this 值。
2. 令 taRecord 为 ? ValidateTypedArray(O, SEQ-CST)。
3. 令 len 为 TypedArrayLength(taRecord)。
4. 令 relativeIndex 为 ? ToIntegerOrInfinity(index)。
5. 如果 relativeIndex ≥ 0，则
    a. 令 k 为 relativeIndex。
6. 否则，
    a. 令 k 为 len + relativeIndex。
7. 如果 k < 0 或 k ≥ len，返回 undefined。
8. 返回 ! Get(O, ! ToString(𝔽(k)))。

#### 23.

2.3.2 get %TypedArray%.prototype.buffer

%TypedArray%.prototype.buffer 是一个访问器属性，其 set 访问器函数为 undefined。其 get 访问器函数在调用时执行以下步骤：

1. 令 O 为 this 值。
2. 执行 ? RequireInternalSlot(O, [[TypedArrayName]])。
3. 断言：O 具有 [[ViewedArrayBuffer]] 内部槽。
4. 令 buffer 为 O.[[ViewedArrayBuffer]]。
5. 返回 buffer。

#### 23.2.3.3 get %TypedArray%.prototype.byteLength

%TypedArray%.prototype.byteLength 是一个访问器属性，其 set 访问器函数为 undefined。其 get 访问器函数在调用时执行以下步骤：

1. 令 O 为 this 值。
2. 执行 ? RequireInternalSlot(O, [[TypedArrayName]])。
3. 断言：O 具有 [[ViewedArrayBuffer]] 内部槽。
4. 令 taRecord 为 MakeTypedArrayWithBufferWitnessRecord(O, SEQ-CST)。
5. 令 size 为 TypedArrayByteLength(taRecord)。
6. 返回 𝔽(size)。

#### 23.2.3.4 get %TypedArray%.prototype.byteOffset

%TypedArray%.prototype.byteOffset 是一个访问器属性，其 set 访问器函数为 undefined。其 get 访问器函数在调用时执行以下步骤：

1. 令 O 为 this 值。
2. 执行 ? RequireInternalSlot(O, [[TypedArrayName]])。
3. 断言：O 具有 [[ViewedArrayBuffer]] 内部槽。
4. 令 taRecord 为 MakeTypedArrayWithBufferWitnessRecord(O, SEQ-CST)。
5. 如果 IsTypedArrayOutOfBounds(taRecord) 为 true，返回 +0𝔽。
6. 令 offset 为 O.[[ByteOffset]]。
7. 返回 𝔽(offset)。

#### 23.2.3.5 %TypedArray%.prototype.constructor

%TypedArray%.prototype.constructor 的初始值为 %TypedArray%。

#### 23.2.3.6 %TypedArray%.prototype.copyWithin ( target, start [ , end ] )

此方法的参数的解释和使用与 23.1.3.4 中定义的 Array.prototype.copyWithin 相同。

调用此方法时执行以下步骤：

1. 令 O 为 this 值。
2. 令 taRecord 为 ? ValidateTypedArray(O, SEQ-CST)。
3. 令 len 为 TypedArrayLength(taRecord)。
4. 令 relativeTarget 为 ? ToIntegerOrInfinity(target)。
5. 如果 relativeTarget = -∞，令 targetIndex 为 0。
6. 否则如果 relativeTarget < 0，令 targetIndex 为 max(len + relativeTarget, 0)。
7. 否则，令 targetIndex 为 min(relativeTarget, len)。
8. 令 relativeStart 为 ? ToIntegerOrInfinity(start)。
9. 如果 relativeStart = -∞，令 startIndex 为 0。
10. 否则如果 relativeStart < 0，令 startIndex 为 max(len + relativeStart, 0)。
11. 否则，令 startIndex 为 min(relativeStart, len)。
12. 如果 end 未定义，令 relativeEnd 为 len；否则令 relativeEnd 为 ? ToIntegerOrInfinity(end)。
13. 如果 relativeEnd = -∞，令 endIndex 为 0。
14. 否则如果 relativeEnd < 0，令 endIndex 为 max(len + relativeEnd, 0)。
15. 否则，令 endIndex 为 min(relativeEnd, len)。
16. 令 count 为 min(endIndex - startIndex, len - targetIndex)。
17. 如果 count > 0，则
    a. **注：** 必须以保持源数据的比特级别编码的方式执行复制。
    b. 令 buffer 为 O.[[ViewedArrayBuffer]]。
    c. 将 taRecord 设为 MakeTypedArrayWithBufferWitnessRecord(O, SEQ-CST)。
    d. 如果 IsTypedArrayOutOfBounds(taRecord) 为 true，抛出一个 TypeError 异常。
    e. 将 len 设为 TypedArrayLength(taRecord)。
    f. 令 elementSize 为 TypedArrayElementSize(O)。
    g. 令 byteOffset 为 O.[[ByteOffset]]。
    h. 令 bufferByteLimit 为 (len × elementSize) + byteOffset。
    i. 令 toByteIndex 为 (targetIndex × elementSize) + byteOffset。
    j. 令 fromByteIndex 为 (startIndex × elementSize) + byteOffset。
    k. 令 countBytes 为 count × elementSize。
    l. 如果 fromByteIndex < toByteIndex 且 toByteIndex < fromByteIndex + countBytes，则
        i. 令 direction 为 -1。
        ii. 将 fromByteIndex 设为 fromByteIndex + countBytes - 1。
        iii. 将 toByteIndex 设为 toByteIndex + countBytes - 1。
    m. 否则，
        i. 令 direction 为 1。
    n. 重复，直到 countBytes > 0，
        i. 如果 fromByteIndex < bufferByteLimit 且 toByteIndex < bufferByteLimit，则
            1. 令 value 为 GetValueFromBuffer(buffer, fromByteIndex, UINT8, true, UNORDERED)。
            2. 执行 SetValueInBuffer(buffer, toByteIndex, UINT8, value, true, UNORDERED)。
            3. 将 fromByteIndex 设为 fromByteIndex + direction。
            4. 将 toByteIndex 设为 toByteIndex + direction。
            5. 将 countBytes 设为 countBytes - 1。
        ii. 否则，
            1. 将 countBytes 设为 0。
18. 返回 O。

#### 23.2.3.7 %TypedArray%.prototype.entries ( )

调用此方法时执行以下步骤：

1. 令 O 为 this 值。
2. 执行 ? ValidateTypedArray(O, SEQ-CST)。
3. 返回 CreateArrayIterator(O, KEY+VALUE)。

#### 23.2.3.8 %TypedArray%.prototype.every ( callbackfn [ , thisArg ] )

此方法的参数的解释和使用与 23.1.3.6 中定义的 Array.prototype.every 相同。

调用此方法时执行以下步骤：

1. 令 O 为 this 值。
2. 令 taRecord 为 ? ValidateTypedArray(O, SEQ-CST)。
3. 令 len 为 TypedArrayLength(taRecord)。
4. 如果 IsCallable(callbackfn) 为 false，抛出一个 TypeError 异常。
5. 令 k 为 0。
6. 重复，直到 k < len，
    a. 令 Pk 为 ! ToString(𝔽(k))。
    b. 令 kValue 为 ! Get(O, Pk)。
    c. 令 testResult 为 ToBoolean(? Call(callbackfn, thisArg, « kValue, 𝔽(k), O »))。
    d. 如果 testResult 为 false，返回 false。
    e. 将 k 设为 k + 1。
7. 返回 true。

此方法不是通用的。this 值必须是一个具有 [[TypedArrayName]] 内部槽的对象。

#### 23.2.3.9 %TypedArray%.prototype.fill ( value [ , start [ , end ] )

此方法的参数的解释和使用与 23.1.3.7 中定义的 Array.prototype.fill 相同。

调用此方法时执行以下步骤：

1. 令 O 为 this 值。
2. 令 taRecord 为 ? ValidateTypedArray(O, SEQ-CST)。
3. 令 len 为 TypedArrayLength(taRecord)。
4. 如果 O.[[ContentType]] 是 BIGINT，将 value 设为 ? ToBigInt(value)。
5. 否则，将 value 设为 ? ToNumber(value)。
6. 令 relativeStart 为 ? ToIntegerOrInfinity(start)。
7. 如果 relativeStart = -∞，令 startIndex 为 0。
8. 否则如果 relativeStart < 0，令 startIndex 为 max(len + relativeStart, 0)。
9. 否则，令 startIndex 为 min(relativeStart, len)。
10. 如果 end 未定义，令 relativeEnd 为 len；否则令 relativeEnd 为 ? ToIntegerOrInfinity(end)。
11. 如果 relativeEnd = -∞，令 endIndex 为 0。
12. 否则如果 relativeEnd < 0，令 endIndex 为 max(len + relativeEnd, 0)。
13. 否则，令 endIndex 为 min(relativeEnd, len)。
14. 将 taRecord 设为 MakeTypedArrayWithBufferWitnessRecord(O, SEQ-CST)。
15. 如果 IsTypedArrayOutOfBounds(taRecord) 为 true，抛出一个 TypeError 异常。
16. 将 len 设为 TypedArrayLength(taRecord)。
17. 将 endIndex 设为 min(endIndex, len)。
18. 令 k 为 startIndex。
19. 重复，直到 k < endIndex，
    a. 令 Pk 为 ! ToString(𝔽(k))。
    b. 执行 ! Set(O, Pk, value, true)。
    c. 将 k 设

为 k + 1。
20. 返回 O。

### 23.2.3.10 %TypedArray%.prototype.filter ( callbackfn [ , thisArg ] )

此方法的参数的解释和使用与 23.1.3.8 中定义的 Array.prototype.filter 相同。

调用此方法时执行以下步骤：

1. 令 O 为 this 值。
2. 令 taRecord 为 ? ValidateTypedArray(O, SEQ-CST)。
3. 令 len 为 TypedArrayLength(taRecord)。
4. 如果 IsCallable(callbackfn) 为 false，抛出一个 TypeError 异常。
5. 令 kept 为一个新的空列表。
6. 令 captured 为 0。
7. 令 k 为 0。
8. 重复，直到 k < len，
   a. 令 Pk 为 ! ToString(𝔽(k))。
   b. 令 kValue 为 ! Get(O, Pk)。
   c. 令 selected 为 ToBoolean(? Call(callbackfn, thisArg, « kValue, 𝔽(k), O »))。
   d. 如果 selected 为 true，则
      i. 将 kValue 添加到 kept。
      ii. 将 captured 设为 captured + 1。
   e. 将 k 设为 k + 1。
9. 令 A 为 ? TypedArraySpeciesCreate(O, « 𝔽(captured) »)。
10. 令 n 为 0。
11. 对于 kept 中的每个元素 e，执行
    a. 执行 ! Set(A, ! ToString(𝔽(n)), e, true)。
    b. 将 n 设为 n + 1。
12. 返回 A。

此方法不是通用的。this 值必须是一个具有 [[TypedArrayName]] 内部槽的对象。

### 23.2.3.11 %TypedArray%.prototype.find ( predicate [ , thisArg ] )

此方法的参数的解释和使用与 23.1.3.9 中定义的 Array.prototype.find 相同。

调用此方法时执行以下步骤：

1. 令 O 为 this 值。
2. 令 taRecord 为 ? ValidateTypedArray(O, SEQ-CST)。
3. 令 len 为 TypedArrayLength(taRecord)。
4. 令 findRec 为 ? FindViaPredicate(O, len, ASCENDING, predicate, thisArg)。
5. 返回 findRec.[[Value]]。

此方法不是通用的。this 值必须是一个具有 [[TypedArrayName]] 内部槽的对象。

### 23.2.3.12 %TypedArray%.prototype.findIndex ( predicate [ , thisArg ] )

此方法的参数的解释和使用与 23.1.3.10 中定义的 Array.prototype.findIndex 相同。

调用此方法时执行以下步骤：

1. 令 O 为 this 值。
2. 令 taRecord 为 ? ValidateTypedArray(O, SEQ-CST)。
3. 令 len 为 TypedArrayLength(taRecord)。
4. 令 findRec 为 ? FindViaPredicate(O, len, ASCENDING, predicate, thisArg)。
5. 返回 findRec.[[Index]]。

此方法不是通用的。this 值必须是一个具有 [[TypedArrayName]] 内部槽的对象。

### 23.2.3.13 %TypedArray%.prototype.findLast ( predicate [ , thisArg ] )

此方法的参数的解释和使用与 23.1.3.11 中定义的 Array.prototype.findLast 相同。

调用此方法时执行以下步骤：

1. 令 O 为 this 值。
2. 令 taRecord 为 ? ValidateTypedArray(O, SEQ-CST)。
3. 令 len 为 TypedArrayLength(taRecord)。
4. 令 findRec 为 ? FindViaPredicate(O, len, DESCENDING, predicate, thisArg)。
5. 返回 findRec.[[Value]]。

此方法不是通用的。this 值必须是一个具有 [[TypedArrayName]] 内部槽的对象。

### 23.2.3.14 %TypedArray%.prototype.findLastIndex ( predicate [ , thisArg ] )

此方法的参数的解释和使用与 23.1.3.12 中定义的 Array.prototype.findLastIndex 相同。

调用此方法时执行以下步骤：

1. 令 O 为 this 值。
2. 令 taRecord 为 ? ValidateTypedArray(O, SEQ-CST)。
3. 令 len 为 TypedArrayLength(taRecord)。
4. 令 findRec 为 ? FindViaPredicate(O, len, DESCENDING, predicate, thisArg)。
5. 返回 findRec.[[Index]]。

此方法不是通用的。this 值必须是一个具有 [[TypedArrayName]] 内部槽的对象。

### 23.2.3.15 %TypedArray%.prototype.forEach ( callbackfn [ , thisArg ] )

此方法的参数的解释和使用与 23.1.3.15 中定义的 Array.prototype.forEach 相同。

调用此方法时执行以下步骤：

1. 令 O 为 this 值。
2. 令 taRecord 为 ? ValidateTypedArray(O, SEQ-CST)。
3. 令 len 为 TypedArrayLength(taRecord)。
4. 如果 IsCallable(callbackfn) 为 false，抛出一个 TypeError 异常。
5. 令 k 为 0。
6. 重复，直到 k < len，
   a. 令 Pk 为 ! ToString(𝔽(k))。
   b. 令 kValue 为 ! Get(O, Pk)。
   c. 执行 ? Call(callbackfn, thisArg, « kValue, 𝔽(k), O »)。
   d. 将 k 设为 k + 1。
7. 返回 undefined。

此方法不是通用的。this 值必须是一个具有 [[TypedArrayName]] 内部槽的对象。

### 23.2.3.16 %TypedArray%.prototype.includes ( searchElement [ , fromIndex ] )

此方法的参数的解释和使用与 23.1.3.16 中定义的 Array.prototype.includes 相同。

调用此方法时执行以下步骤：

1. 令 O 为 this 值。
2. 令 taRecord 为 ? ValidateTypedArray(O, SEQ-CST)。
3. 令 len 为 TypedArrayLength(taRecord)。
4. 如果 len = 0，返回 false。
5. 令 n 为 ? ToIntegerOrInfinity(fromIndex)。
6. 断言：如果 fromIndex 未定义，则 n 为 0。
7. 如果 n = +∞，返回 false。
8. 否则如果 n = -∞，将 n 设为 0。
9. 如果 n ≥ 0，则
   a. 令 k 为 n。
10. 否则，
    a. 令 k 为 len + n。
    b. 如果 k < 0，将 k 设为 0。
11. 重复，直到 k < len，
    a. 令 elementK 为 ! Get(O, ! ToString(𝔽(k)))。
    b. 如果 SameValueZero(searchElement, elementK) 为 true，返回 true。
    c. 将 k 设为 k + 1。
12. 返回 false。

此方法不是通用的。this 值必须是一个具有 [[TypedArrayName]] 内部槽的对象。

### 23.2.3.17 %TypedArray%.prototype.indexOf ( searchElement [ , fromIndex ] )

此方法的参数的解释和使用与 23.1.3.17 中定义的 Array.prototype.indexOf 相同。

调用此方法时执行以下步骤：

1. 令 O 为 this 值。
2. 令 taRecord 为 ? ValidateTypedArray(O, SEQ-CST)。
3. 令 len 为 TypedArrayLength(taRecord)。
4. 如果 len = 0，返回 -1𝔽。
5. 令 n 为 ? ToIntegerOrInfinity(fromIndex)。
6. 断言：如果 fromIndex 未定义，则 n 为 0。
7. 如果 n = +∞，返回 -1𝔽。
8. 否则如果 n = -∞，将 n 设为 0。
9. 如果 n ≥ 0，则
   a. 令 k 为 n。
10. 否则，
    a. 令 k 为 len + n。
    b. 如果 k < 0，将 k 设为 0。
11. 重复，直到 k < len，
    a. 令 kPresent 为 ! HasProperty(O, ! ToString(𝔽(k)))。
    b. 如果 kPresent 为 true，则
       i. 令 elementK 为 ! Get(O, ! ToString(𝔽(k)))。
       ii. 如果 IsStrictlyEqual(searchElement, elementK) 为 true，返回 𝔽(k)。
    c. 将 k 设为 k + 1。
12. 返回 -1𝔽。

此方法不是通用的。this 值必须是一个具有 [[TypedArrayName]] 内部槽的对象。

### 23.2.3.18 %TypedArray%.prototype.join ( separator )

此方法的参数的解释和使用与 23.1.3.18 中定义的 Array.prototype.join 相同。

调用此方法时执行以下步骤：

1. 令 O 为 this 值。
2. 令 taRecord 为 ? ValidateTypedArray(O, SEQ-CST)。


3. 令 len 为 TypedArrayLength(taRecord)。
4. 如果 separator 未定义，令 sep 为 ","。
5. 否则，令 sep 为 ? ToString(separator)。
6. 令 R 为空字符串。
7. 令 k 为 0。
8. 重复，直到 k < len，
   a. 如果 k > 0，将 R 设为 R 和 sep 的字符串连接。
   b. 令 element 为 ! Get(O, ! ToString(𝔽(k)))。
   c. 如果 element 不为 undefined，则
      i. 令 S 为 ! ToString(element)。
      ii. 将 R 设为 R 和 S 的字符串连接。
   d. 将 k 设为 k + 1。
9. 返回 R。

此方法不是通用的。this 值必须是一个具有 [[TypedArrayName]] 内部槽的对象。

### 23.2.3.19 %TypedArray%.prototype.keys ( )

调用此方法时执行以下步骤：

1. 令 O 为 this 值。
2. 执行 ? ValidateTypedArray(O, SEQ-CST)。
3. 返回 CreateArrayIterator(O, KEY)。

### 23.2.3.20 %TypedArray%.prototype.lastIndexOf ( searchElement [ , fromIndex ] )

此方法的参数的解释和使用与 23.1.3.20 中定义的 Array.prototype.lastIndexOf 相同。

调用此方法时执行以下步骤：

1. 令 O 为 this 值。
2. 令 taRecord 为 ? ValidateTypedArray(O, SEQ-CST)。
3. 令 len 为 TypedArrayLength(taRecord)。
4. 如果 len = 0，返回 -1𝔽。
5. 如果 fromIndex 存在，令 n 为 ? ToIntegerOrInfinity(fromIndex)；否则令 n 为 len - 1。
6. 如果 n = -∞，返回 -1𝔽。
7. 如果 n ≥ 0，则
   a. 令 k 为 min(n, len - 1)。
8. 否则，
   a. 令 k 为 len + n。
9. 重复，直到 k ≥ 0，
   a. 令 kPresent 为 ! HasProperty(O, ! ToString(𝔽(k)))。
   b. 如果 kPresent 为 true，则
      i. 令 elementK 为 ! Get(O, ! ToString(𝔽(k)))。
      ii. 如果 IsStrictlyEqual(searchElement, elementK) 为 true，返回 𝔽(k)。
   c. 将 k 设为 k - 1。
10. 返回 -1𝔽。

此方法不是通用的。this 值必须是一个具有 [[TypedArrayName]] 内部槽的对象。

### 23.2.3.21 get %TypedArray%.prototype.length

%TypedArray%.prototype.length 是一个访问器属性，其 set 访问器函数为 undefined。其 get 访问器函数在调用时执行以下步骤：

1. 令 O 为 this 值。
2. 执行 ? RequireInternalSlot(O, [[TypedArrayName]])。
3. 断言：O 具有 [[ViewedArrayBuffer]] 和 [[ArrayLength]] 内部槽。
4. 令 taRecord 为 MakeTypedArrayWithBufferWitnessRecord(O, SEQ-CST)。
5. 如果 IsTypedArrayOutOfBounds(taRecord) 为 true，返回 +0𝔽。
6. 令 length 为 TypedArrayLength(taRecord)。
7. 返回 𝔽(length)。

此函数不是通用的。this 值必须是一个具有 [[TypedArrayName]] 内部槽的对象。

### 23.2.3.22 %TypedArray%.prototype.map ( callbackfn [ , thisArg ] )

此方法的参数的解释和使用与 23.1.3.21 中定义的 Array.prototype.map 相同。

调用此方法时执行以下步骤：

1. 令 O 为 this 值。
2. 令 taRecord 为 ? ValidateTypedArray(O, SEQ-CST)。
3. 令 len 为 TypedArrayLength(taRecord)。
4. 如果 IsCallable(callbackfn) 为 false，抛出一个 TypeError 异常。
5. 令 A 为 ? TypedArraySpeciesCreate(O, « 𝔽(len) »)。
6. 令 k 为 0。
7. 重复，直到 k < len，
   a. 令 Pk 为 ! ToString(𝔽(k))。
   b. 令 kValue 为 ! Get(O, Pk)。
   c. 令 mappedValue 为 ? Call(callbackfn, thisArg, « kValue, 𝔽(k), O »)。
   d. 执行 ? Set(A, Pk, mappedValue, true)。
   e. 将 k 设为 k + 1。
8. 返回 A。

此方法不是通用的。this 值必须是一个具有 [[TypedArrayName]] 内部槽的对象。

### 23.2.3.23 %TypedArray%.prototype.reduce ( callbackfn [ , initialValue ] )

此方法的参数的解释和使用与 23.1.3.24 中定义的 Array.prototype.reduce 相同。

调用此方法时执行以下步骤：

1. 令 O 为 this 值。
2. 令 taRecord 为 ? ValidateTypedArray(O, SEQ-CST)。
3. 令 len 为 TypedArrayLength(taRecord)。
4. 如果 IsCallable(callbackfn) 为 false，抛出一个 TypeError 异常。
5. 如果 len = 0 且 initialValue 不存在，抛出一个 TypeError 异常。
6. 令 k 为 0。
7. 令 accumulator 为 undefined。
8. 如果 initialValue 存在，则
   a. 将 accumulator 设为 initialValue。
9. 否则，
   a. 令 Pk 为 ! ToString(𝔽(k))。
   b. 将 accumulator 设为 ! Get(O, Pk)。
   c. 将 k 设为 k + 1。
10. 重复，直到 k < len，
    a. 令 Pk 为 ! ToString(𝔽(k))。
    b. 令 kValue 为 ! Get(O, Pk)。
    c. 将 accumulator 设为 ? Call(callbackfn, undefined, « accumulator, kValue, 𝔽(k), O »)。
    d. 将 k 设为 k + 1。
11. 返回 accumulator。

此方法不是通用的。this 值必须是一个具有 [[TypedArrayName]] 内部槽的对象。

### 23.2.3.24 %TypedArray%.prototype.reduceRight ( callbackfn [ , initialValue ] )

此方法的参数的解释和使用与 23.1.3.25 中定义的 Array.prototype.reduceRight 相同。

调用此方法时执行以下步骤：

1. 令 O 为 this 值。
2. 令 taRecord 为 ? ValidateTypedArray(O, SEQ-CST)。
3. 令 len 为 TypedArrayLength(taRecord)。
4. 如果 IsCallable(callbackfn) 为 false，抛出一个 TypeError 异常。
5. 如果 len = 0 且 initialValue 不存在，抛出一个 TypeError 异常。
6. 令 k 为 len - 1。
7. 令 accumulator 为 undefined。
8. 如果 initialValue 存在，则
   a. 将 accumulator 设为 initialValue。
9. 否则，
   a. 令 Pk 为 ! ToString(𝔽(k))。
   b. 将 accumulator 设为 ! Get(O, Pk)。
   c. 将 k 设为 k - 1。
10. 重复，直到 k ≥ 0，
    a. 令 Pk 为 ! ToString(𝔽(k))。
    b. 令 kValue 为 ! Get(O, Pk)。
    c. 将 accumulator 设为 ? Call(callbackfn, undefined, « accumulator, kValue, 𝔽(k), O »)。
    d. 将 k 设为 k - 1。
11. 返回 accumulator。

此方法不是通用的。this 值必须是一个具有 [[TypedArrayName]] 内部槽的对象。

### 23.2.3.25 %TypedArray%.prototype.reverse ( )
此方法的参数的解释和使用与 23.1.3.26 中定义的 Array.prototype.reverse 相同。

调用此方法时执行以下步骤：

1. 令 O 为 this 值。
2. 令 taRecord 为 ? ValidateTypedArray(O, SEQ-CST)。
3. 令 len 为 TypedArrayLength(taRecord)。
4. 令 middle 为 floor(len / 2)。
5. 令 lower 为 0。
6. 重复，直到 lower ≠ middle，
   a. 令 upper 为 len - lower - 1。
   b. 令 upperP 为 ! ToString(𝔽(upper))。
   c. 令 lowerP 为 ! ToString(𝔽(lower))。
   d. 令 lowerValue 为 ! Get(O, lowerP)。
   e. 令 upperValue 为 ! Get(O, upperP)。
   f. 执行 ! Set(O, lowerP, upperValue, true)。
   g. 执行 ! Set(O, upperP, lowerValue, true)。
   h. 将 lower 设为 lower + 1。
7. 返回 O。

此方法不是通用的。this 值必须是一个具有 [[TypedArrayName]] 内部槽的对象。

### 23.2.3.26 %TypedArray%.prototype.set ( source [ , offset ] )
此方法将多个值设置到此 TypedArray 中，从 source 读取这些值。根据 source 的类型，细节会有所不同。可选的 offset 值表示在此 TypedArray 中写入值的第一个元素索引。如果省略，则假定为 0。

调用此方法时执行以下步骤：

1. 令 target 为 this 值。
2. 执行 ? RequireInternalSlot(target, [[TypedArrayName]])。
3. 断言：target 具有 [[ViewedArrayBuffer]] 内部槽。
4. 令 targetOffset 为 ? ToIntegerOrInfinity(offset)。
5. 如果 targetOffset < 0，抛出一个 RangeError 异常。
6. 如果 source 是一个具有 [[TypedArrayName]] 内部槽的对象，则
   a. 执行 ? SetTypedArrayFromTypedArray(target, targetOffset, source)。
7. 否则，
   a. 执行 ? SetTypedArrayFromArrayLike(target, targetOffset, source)。
8. 返回 undefined。

此方法不是通用的。this 值必须是一个具有 [[TypedArrayName]] 内部槽的对象。

### 23.2.3.26.1 SetTypedArrayFromTypedArray ( target, targetOffset, source )
抽象操作 SetTypedArrayFromTypedArray 接受参数 target (一个 TypedArray)、targetOffset (一个非负整数或 +∞)、source (一个 TypedArray)，并返回包含 UNUSED 的正常完成或一个抛出完成。它在 target 中从 targetOffset 开始设置多个值，从 source 中读取这些值。调用时执行以下步骤：

1. 令 targetBuffer 为 target.[[ViewedArrayBuffer]]。
2. 令 targetRecord 为 MakeTypedArrayWithBufferWitnessRecord(target, SEQ-CST)。
3. 如果 IsTypedArrayOutOfBounds(targetRecord) 为 true，抛出一个 TypeError 异常。
4. 令 targetLength 为 TypedArrayLength(targetRecord)。
5. 令 srcBuffer 为 source.[[ViewedArrayBuffer]]。
6. 令 srcRecord 为 MakeTypedArrayWithBufferWitnessRecord(source, SEQ-CST)。
7. 如果 IsTypedArrayOutOfBounds(srcRecord) 为 true，抛出一个 TypeError 异常。
8. 令 srcLength 为 TypedArrayLength(srcRecord)。
9. 令 targetType 为 TypedArrayElementType(target)。
10. 令 targetElementSize 为 TypedArrayElementSize(target)。
11. 令 targetByteOffset 为 target.[[ByteOffset]]。
12. 令 srcType 为 TypedArrayElementType(source)。
13. 令 srcElementSize 为 TypedArrayElementSize(source)。
14. 令 srcByteOffset 为 source.[[ByteOffset]]。
15. 如果 targetOffset = +∞，抛出一个 RangeError 异常。
16. 如果 srcLength + targetOffset > targetLength，抛出一个 RangeError 异常。
17. 如果 target.[[ContentType]] 与 source.[[ContentType]] 不同，抛出一个 TypeError 异常。
18. 如果 IsSharedArrayBuffer(srcBuffer) 为 true，IsSharedArrayBuffer(targetBuffer) 为 true，且 srcBuffer.[[ArrayBufferData]] 为 targetBuffer.[[ArrayBufferData]]，令 sameSharedArrayBuffer 为 true；否则，令 sameSharedArrayBuffer 为 false。
19. 如果 SameValue(srcBuffer, targetBuffer) 为 true 或 sameSharedArrayBuffer 为 true，则
    a. 令 srcByteLength 为 TypedArrayByteLength(srcRecord)。
    b. 将 srcBuffer 设为 ? CloneArrayBuffer(srcBuffer, srcByteOffset, srcByteLength)。
    c. 令 srcByteIndex 为 0。
20. 否则，
    a. 令 srcByteIndex 为 srcByteOffset。
21. 令 targetByteIndex 为 (targetOffset × targetElementSize) + targetByteOffset。
22. 令 limit 为 targetByteIndex + (targetElementSize × srcLength)。
23. 如果 srcType 与 targetType 相同，则
    a. 注意：传输必须以保留源数据的位级编码的方式进行。
    b. 重复，直到 targetByteIndex < limit，
       i. 令 value 为 GetValueFromBuffer(srcBuffer, srcByteIndex, UINT8, true, UNORDERED)。
       ii. 执行 SetValueInBuffer(targetBuffer, targetByteIndex, UINT8, value, true, UNORDERED)。
       iii. 将 srcByteIndex 设为 srcByteIndex + 1。
       iv. 将 targetByteIndex 设为 targetByteIndex + 1。
24. 否则，
    a. 重复，直到 targetByteIndex < limit，
       i. 令 value 为 GetValueFromBuffer(srcBuffer, srcByteIndex, srcType, true, UNORDERED)。
       ii. 执行 SetValueInBuffer(targetBuffer, targetByteIndex, targetType, value, true, UNORDERED)。
       iii. 将 srcByteIndex 设为 srcByteIndex + srcElementSize。
       iv. 将 targetByteIndex 设为 targetByteIndex + targetElementSize。
25. 返回 UNUSED。

### 23.2.3.26.2 SetTypedArrayFromArrayLike ( target, targetOffset, source )
抽象操作 SetTypedArrayFromArrayLike 接受参数 target (一个 TypedArray)、targetOffset (一个非负整数或 +∞)、source (一个 ECMAScript 语言值，但不是 TypedArray)，并返回包含 UNUSED 的正常完成或一个抛出完成。它在 target 中从 targetOffset 开始设置多个值，从 source 中读取这些值。调用时执行以下步骤：

1. 令 targetRecord 为 MakeTypedArrayWithBufferWitnessRecord(target, SEQ-CST)。
2. 如果 IsTypedArrayOutOfBounds(targetRecord) 为 true，抛出一个 TypeError 异常。
3. 令 targetLength 为 TypedArrayLength(targetRecord)。
4. 令 src 为 ? ToObject(source)。
5. 令 srcLength 为 ? LengthOfArrayLike(src)。
6. 如果 targetOffset = +∞，抛出一个 RangeError 异常。
7. 如果 srcLength + targetOffset > targetLength，抛出一个 RangeError 异常。
8. 令 k 为 0。
9. 重复，直到 k < srcLength，
   a. 令 Pk 为 ! ToString(𝔽(k))。
   b. 令 value 为 ? Get(src, Pk)。
   c. 令 targetIndex 为 𝔽(targetOffset + k)。
   d. 执行 ? TypedArraySetElement(target, targetIndex, value)。
   e. 将 k 设为 k + 1。
10. 返回 UNUSED。

### 23.2.3.27 %TypedArray%.prototype.slice ( start, end )
此方法的参数的解释和使用与 23.1.3.28 中定义的 Array.prototype.slice 相同。

调用此方法时执行以下步骤：

1. 令 O 为 this 值。
2. 令 taRecord 为 ? ValidateTypedArray(O, SEQ-CST)。
3. 令 srcArrayLength 为 TypedArrayLength(taRecord)。
4. 令 relativeStart 为 ? ToIntegerOrInfinity(start)。
5. 如果 relativeStart = -∞，令 startIndex 为 0。
6. 否则如果 relativeStart < 0，令 startIndex 为 max(srcArrayLength + relativeStart, 0)。
7. 否则，令 startIndex 为 min(relativeStart, srcArrayLength)。
8. 如果 end 未定义，令 relativeEnd 为 srcArrayLength；否则令 relativeEnd 为 ? ToIntegerOrInfinity(end)。
9. 如果 relativeEnd = -∞，令 endIndex 为 0。
10. 否则如果 relativeEnd < 0，令 endIndex 为 max(srcArrayLength + relativeEnd, 0)。
11. 否则，令 endIndex 为 min(relativeEnd, srcArrayLength)。
12. 令 countBytes 为 max(endIndex - startIndex, 0)。
13.

 令 A 为 ? TypedArraySpeciesCreate(O, « 𝔽(countBytes) »)。
14. 如果 countBytes > 0，则
    a. 将 taRecord 设为 MakeTypedArrayWithBufferWitnessRecord(O, SEQ-CST)。
    b. 如果 IsTypedArrayOutOfBounds(taRecord) 为 true，抛出一个 TypeError 异常。
    c. 将 endIndex 设为 min(endIndex, TypedArrayLength(taRecord))。
    d. 将 countBytes 设为 max(endIndex - startIndex, 0)。
    e. 令 srcType 为 TypedArrayElementType(O)。
    f. 令 targetType 为 TypedArrayElementType(A)。
    g. 如果 srcType 与 targetType 相同，则
       i. 注意：传输必须以保留源数据的位级编码的方式进行。
       ii. 令 srcBuffer 为 O.[[ViewedArrayBuffer]]。
       iii. 令 targetBuffer 为 A.[[ViewedArrayBuffer]]。
       iv. 令 elementSize 为 TypedArrayElementSize(O)。
       v. 令 srcByteOffset 为 O.[[ByteOffset]]。
       vi. 令 srcByteIndex 为 (startIndex × elementSize) + srcByteOffset。
       vii. 令 targetByteIndex 为 A.[[ByteOffset]]。
       viii. 令 endByteIndex 为 targetByteIndex + (countBytes × elementSize)。
       ix. 重复，直到 targetByteIndex < endByteIndex，
           1. 令 value 为 GetValueFromBuffer(srcBuffer, srcByteIndex, UINT8, true, UNORDERED)。
           2. 执行 SetValueInBuffer(targetBuffer, targetByteIndex, UINT8, value, true, UNORDERED)。
           3. 将 srcByteIndex 设为 srcByteIndex + 1。
           4. 将 targetByteIndex 设为 targetByteIndex + 1。
    h. 否则，
       i. 令 n 为 0。
       ii. 令 k 为 startIndex。
       iii. 重复，直到 k < endIndex，
           1. 令 Pk 为 ! ToString(𝔽(k))。
           2. 令 kValue 为 ! Get(O, Pk)。
           3. 执行 ! Set(A, ! ToString(𝔽(n)), kValue, true)。
           4. 将 k 设为 k + 1。
           5. 将 n 设为 n + 1。
15. 返回 A。

此方法不是通用的。this 值必须是一个具有 [[TypedArrayName]] 内部槽的对象。

### 23.2.3.28 %TypedArray%.prototype.some ( callbackfn [ , thisArg ] )
此方法的参数的解释和使用与 23.1.3.29 中定义的 Array.prototype.some 相同。

调用此方法时执行以下步骤：

1. 令 O 为 this 值。
2. 令 taRecord 为 ? ValidateTypedArray(O, SEQ-CST)。
3. 令 len 为 TypedArrayLength(taRecord)。
4. 如果 IsCallable(callbackfn) 为 false，抛出一个 TypeError 异常。
5. 令 k 为 0。
6. 重复，直到 k < len，
   a. 令 Pk 为 ! ToString(𝔽(k))。
   b. 令 kValue 为 ! Get(O, Pk)。
   c. 令 testResult 为 ToBoolean(? Call(callbackfn, thisArg, « kValue, 𝔽(k), O »))。
   d. 如果 testResult 为 true，返回 true。
   e. 将 k 设为 k + 1。
7. 返回 false。

此方法不是通用的。this 值必须是一个具有 [[TypedArrayName]] 内部槽的对象。

### 23.2.3.29 %TypedArray%.prototype.sort ( comparefn )
这是一个独立的方法，除了以下描述之外，实现与 23.1.3.30 中定义的 Array.prototype.sort 相同的要求。此方法的实现可以基于 this 值是一个具有固定长度且其整数索引属性不稀疏的对象进行优化。

此方法不是通用的。this 值必须是一个具有 [[TypedArrayName]] 内部槽的对象。

调用此方法时执行以下步骤：

1. 如果 comparefn 不为 undefined 且 IsCallable(comparefn) 为 false，抛出一个 TypeError 异常。
2. 令 obj 为 this 值。
3. 令 taRecord 为 ? ValidateTypedArray(obj, SEQ-CST)。
4. 令 len 为 TypedArrayLength(taRecord)。
5. 注意：以下闭包执行的是数值比较，而不是 23.1.3.30 中使用的字符串比较。
6. 令 SortCompare 为一个新的抽象闭包，带有参数 (x, y)，捕获 comparefn 并在调用时执行以下步骤：
   a. 返回 ? CompareTypedArrayElements(x, y, comparefn)。
7. 令 sortedList 为 ? SortIndexedProperties(obj, len, SortCompare, READ-THROUGH-HOLES)。
8. 令 j 为 0。
9. 重复，直到 j < len，
   a. 执行 ! Set(obj, ! ToString(𝔽(j)), sortedList[j], true)。
   b. 将 j 设为 j + 1。
10. 返回 obj。

注意：由于 NaN 总是比任何其他值比较大（参见 CompareTypedArrayElements），因此当未提供 comparefn 时，NaN 属性值总是排序到结果的末尾。

### 23.2.3.30 %TypedArray%.prototype.subarray ( start, end )
此方法返回一个新的 TypedArray，其元素类型与此 TypedArray 的元素类型相同，其 ArrayBuffer 是此 TypedArray 的 ArrayBuffer，引用从 start（包括）到 end（不包括）区间的元素。如果 start 或 end 为负数，则它指的是从数组末尾开始的索引，而不是从开头开始的索引。

调用此方法时执行以下步骤：

1. 令 O 为 this 值。
2. 执行 ? RequireInternalSlot(O, [[TypedArrayName]])。
3. 断言：O 具有 [[ViewedArrayBuffer]] 内部槽。
4. 令 buffer 为 O.[[ViewedArrayBuffer]]。
5. 令 srcRecord 为 MakeTypedArrayWithBufferWitnessRecord(O, SEQ-CST)。
6. 如果 IsTypedArrayOutOfBounds(srcRecord) 为 true，则
   a. 令 srcLength 为 0。
7. 否则，
   a. 令 srcLength 为 TypedArrayLength(srcRecord)。
8. 令 relativeStart 为 ? ToIntegerOrInfinity(start)。
9. 如果 relativeStart = -∞，令 startIndex 为 0。
10. 否则如果 relativeStart < 0，令 startIndex 为 max(srcLength + relativeStart, 0)。
11. 否则，令 startIndex 为 min(relativeStart, srcLength)。
12. 令 elementSize 为 TypedArrayElementSize(O)。
13. 令 srcByteOffset 为 O.[[ByteOffset]]。
14. 令 beginByteOffset 为 srcByteOffset + (startIndex × elementSize)。
15. 如果 O.[[ArrayLength]] 是 AUTO 且 end 未定义，则
    a. 令 argumentsList 为 « buffer, 𝔽(beginByteOffset) »。
16. 否则，
    a. 如果 end 未定义，令 relativeEnd 为 srcLength；否则令 relativeEnd 为 ? ToIntegerOrInfinity(end)。
    b. 如果 relativeEnd = -∞，令 endIndex 为 0。
    c. 否则如果 relativeEnd < 0，令 endIndex 为 max(srcLength + relativeEnd, 0)。
    d. 否则，令 endIndex 为 min(relativeEnd, srcLength)。
    e. 令 newLength 为 max(endIndex - startIndex, 0)。
    f. 令 argumentsList 为 « buffer, 𝔽(beginByteOffset), 𝔽(newLength) »。
17. 返回 ? TypedArraySpeciesCreate(O, argumentsList)。

此方法不是通用的。this 值必须是一个具有 [[TypedArrayName]] 内部槽的对象。

### 23.2.3.31 %TypedArray%.prototype.toLocaleString ( [ reserved1 [ , reserved2 ] ] )
这是一个独立的方法，实现与 23.1.3.32 中定义的 Array.prototype.toLocaleString 相同的算法，只是 TypedArrayLength 被调用以替代执行 "length" 的 [[Get]]。算法的实现可以基于 this 值具有固定长度且其整数索引属性不稀疏进行优化。但是，这种优化不得引入算法指定行为的任何可观察变化。

此方法不是通用的。在评估算法之前，ValidateTypedArray 会以 this 值和 SEQ-CST 作为参数进行调用。如果其结果是一个突然完成，则抛出该异常而不是评估算法。

注意：如果 ECMAScript 实现包含 ECMA-402 国际化 API，此方法基于 ECMA-402 规范中的 Array.prototype.toLocaleString 算法。

### 23.2.3.32 %TypedArray%.prototype.toReversed ( )
调用此方法时执行以下步骤：

1. 

令 O 为 this 值。
2. 令 taRecord 为 ? ValidateTypedArray(O, SEQ-CST)。
3. 令 length 为 TypedArrayLength(taRecord)。
4. 令 A 为 ? TypedArrayCreateSameType(O, « 𝔽(length) »)。
5. 令 k 为 0。
6. 重复，直到 k < length，
   a. 令 from 为 ! ToString(𝔽(length - k - 1))。
   b. 令 Pk 为 ! ToString(𝔽(k))。
   c. 令 fromValue 为 ! Get(O, from)。
   d. 执行 ! Set(A, Pk, fromValue, true)。
   e. 将 k 设为 k + 1。
7. 返回 A。

### 23.2.3.33 %TypedArray%.prototype.toSorted ( comparefn )
调用此方法时执行以下步骤：

1. 如果 comparefn 不为 undefined 且 IsCallable(comparefn) 为 false，抛出一个 TypeError 异常。
2. 令 O 为 this 值。
3. 令 taRecord 为 ? ValidateTypedArray(O, SEQ-CST)。
4. 令 len 为 TypedArrayLength(taRecord)。
5. 令 A 为 ? TypedArrayCreateSameType(O, « 𝔽(len) »)。
6. 注意：以下闭包执行的是数值比较，而不是 23.1.3.34 中使用的字符串比较。
7. 令 SortCompare 为一个新的抽象闭包，带有参数 (x, y)，捕获 comparefn 并在调用时执行以下步骤：
   a. 返回 ? CompareTypedArrayElements(x, y, comparefn)。
8. 令 sortedList 为 ? SortIndexedProperties(O, len, SortCompare, READ-THROUGH-HOLES)。
9. 令 j 为 0。
10. 重复，直到 j < len，
    a. 执行 ! Set(A, ! ToString(𝔽(j)), sortedList[j], true)。
    b. 将 j 设为 j + 1。
11. 返回 A。

### 23.2.3.34 %TypedArray%.prototype.toString ( )
"toString" 属性的初始值为 %Array.prototype.toString%，定义在 23.1.3.36 中。

### 23.2.3.35 %TypedArray%.prototype.values ( )
调用此方法时执行以下步骤：

1. 令 O 为 this 值。
2. 执行 ? ValidateTypedArray(O, SEQ-CST)。
3. 返回 CreateArrayIterator(O, VALUE)。

### 23.2.3.36 %TypedArray%.prototype.with ( index, value )
调用此方法时执行以下步骤：

1. 令 O 为 this 值。
2. 令 taRecord 为 ? ValidateTypedArray(O, SEQ-CST)。
3. 令 len 为 TypedArrayLength(taRecord)。
4. 令 relativeIndex 为 ? ToIntegerOrInfinity(index)。
5. 如果 relativeIndex ≥ 0，令 actualIndex 为 relativeIndex。
6. 否则，令 actualIndex 为 len + relativeIndex。
7. 如果 O.[[ContentType]] 为 BIGINT，令 numericValue 为 ? ToBigInt(value)。
8. 否则，令 numericValue 为 ? ToNumber(value)。
9. 如果 IsValidIntegerIndex(O, 𝔽(actualIndex)) 为 false，抛出一个 RangeError 异常。
10. 令 A 为 ? TypedArrayCreateSameType(O, « 𝔽(len) »)。
11. 令 k 为 0。
12. 重复，直到 k < len，
    a. 令 Pk 为 ! ToString(𝔽(k))。
    b. 如果 k = actualIndex，令 fromValue 为 numericValue。
    c. 否则，令 fromValue 为 ! Get(O, Pk)。
    d. 执行 ! Set(A, Pk, fromValue, true)。
    e. 将 k 设为 k + 1。
13. 返回 A。

### 23.2.3.37 %TypedArray%.prototype [ @@iterator ] ( )
@@iterator 属性的初始值为 %TypedArray.prototype.values%，定义在 23.2.3.35 中。

### 23.2.3.38 get %TypedArray%.prototype [ @@toStringTag ]
%TypedArray%.prototype[@@toStringTag] 是一个访问器属性，其 set 访问器函数为 undefined。其 get 访问器函数在调用时执行以下步骤：

1. 令 O 为 this 值。
2. 如果 O 不是一个对象，返回 undefined。
3. 如果 O 没有 [[TypedArrayName]] 内部槽，返回 undefined。
4. 令 name 为 O.[[TypedArrayName]]。
5. 断言：name 是一个字符串。
6. 返回 name。

此属性具有属性 { [[Enumerable]]: false, [[Configurable]]: true }。

此函数的 "name" 属性的初始值为 "get [Symbol.toStringTag]"。

### 23.2.4 TypedArray 对象的抽象操作

#### 23.2.4.1 TypedArraySpeciesCreate ( exemplar, argumentList )

抽象操作 TypedArraySpeciesCreate 接受参数 exemplar（一个 TypedArray）和 argumentList（一个 ECMAScript 语言值的列表），并返回包含 TypedArray 的正常完成或抛出完成。它用于指定使用从 exemplar 派生的构造函数创建新的 TypedArray。与 ArraySpeciesCreate 不同，后者可以通过使用 @@species 创建非 Array 对象，该操作强制要求构造函数创建实际的 TypedArray。调用时执行以下步骤：

1. 令 defaultConstructor 为与构造函数名 exemplar.[[TypedArrayName]] 关联的内置对象（见表 70）。
2. 令 constructor 为 ? SpeciesConstructor(exemplar, defaultConstructor)。
3. 令 result 为 ? TypedArrayCreateFromConstructor(constructor, argumentList)。
4. 断言：result 具有 [[TypedArrayName]] 和 [[ContentType]] 内部槽。
5. 如果 result.[[ContentType]] 不为 exemplar.[[ContentType]]，抛出一个 TypeError 异常。
6. 返回 result。

#### 23.2.4.2 TypedArrayCreateFromConstructor ( constructor, argumentList )

抽象操作 TypedArrayCreateFromConstructor 接受参数 constructor（一个构造函数）和 argumentList（一个 ECMAScript 语言值的列表），并返回包含 TypedArray 的正常完成或抛出完成。它用于指定使用构造函数创建新的 TypedArray。调用时执行以下步骤：

1. 令 newTypedArray 为 ? Construct(constructor, argumentList)。
2. 令 taRecord 为 ? ValidateTypedArray(newTypedArray, SEQ-CST)。
3. 如果 argumentList 中元素的数量为 1 且 argumentList[0] 是一个数字，则
   a. 如果 IsTypedArrayOutOfBounds(taRecord) 为 true，抛出一个 TypeError 异常。
   b. 令 length 为 TypedArrayLength(taRecord)。
   c. 如果 length < ℝ(argumentList[0])，抛出一个 TypeError 异常。
4. 返回 newTypedArray。

#### 23.2.4.3 TypedArrayCreateSameType ( exemplar, argumentList )

抽象操作 TypedArrayCreateSameType 接受参数 exemplar（一个 TypedArray）和 argumentList（一个 ECMAScript 语言值的列表），并返回包含 TypedArray 的正常完成或抛出完成。它用于指定使用从 exemplar 派生的构造函数创建新的 TypedArray。与 TypedArraySpeciesCreate 不同，后者可以通过使用 @@species 构造自定义 TypedArray 子类，该操作总是使用内置的 TypedArray 构造函数之一。调用时执行以下步骤：

1. 令 constructor 为与构造函数名 exemplar.[[TypedArrayName]] 关联的内置对象（见表 70）。
2. 令 result 为 ? TypedArrayCreateFromConstructor(constructor, argumentList)。
3. 断言：result 具有 [[TypedArrayName]] 和 [[ContentType]] 内部槽。
4. 断言：result.[[ContentType]] 是 exemplar.[[ContentType]]。
5. 返回 result。

#### 23.2.4.4 ValidateTypedArray ( O, order )

抽象操作 ValidateTypedArray 接受参数 O（一个 ECMAScript 语言值）和 order（SEQ-CST 或 UNORDERED），并返回包含 TypedArray With Buffer Witness Record 的正常完成或抛出完成。调用时执行以下步骤：

1. 执行 ? RequireInternalSlot(O, [[TypedArrayName]])。
2. 断言：O 具有 [[ViewedArrayBuffer]] 内部槽。
3. 令 taRecord 为 MakeTypedArrayWithBufferWitnessRecord(O, order)。
4. 如果 IsTypedArrayOutOfBounds(taRecord) 为 true，抛出一个 TypeError 异常。
5. 返回 taRecord。

#### 23.2.4.5 TypedArrayElementSize ( O )

抽象操作 TypedArrayElementSize 接受参数 O（一个 TypedArray），并返回一个非负整数。调用时执行以下步骤：

1. 返回表 70 中为 O.[[TypedArrayName]] 指定的元素大小值。

#### 23.2.4.6 TypedArrayElementType ( O )

抽象操作 TypedArrayElementType 接受参数 O（一个 TypedArray），并返回一个 TypedArray 元素类型。调用时执行以下步骤：

1. 返回表 70 中为 O.[[TypedArrayName]] 指定的元素类型值。

#### 23.2.4.7 CompareTypedArrayElements ( x, y, comparefn )

抽象操作 CompareTypedArrayElements 接受参数 x（一个 Number 或 BigInt）、y（一个 Number 或 BigInt）和 comparefn（一个函数对象或 undefined），并返回包含 Number 的正常完成或一个突然完成。调用时执行以下步骤：

1. 断言：x 是一个 Number 且 y 是一个 Number，或 x 是一个 BigInt 且 y 是一个 BigInt。
2. 如果 comparefn 不为 undefined，则
   a. 令 v 为 ? ToNumber(? Call(comparefn, undefined, « x, y »))。
   b. 如果 v 是 NaN，返回 +0𝔽。
   c. 返回 v。
3. 如果 x 和 y 都是 NaN，返回 +0𝔽。
4. 如果 x 是 NaN，返回 1𝔽。
5. 如果 y 是 NaN，返回 -1𝔽。
6. 如果 x < y，返回 -1𝔽。
7. 如果 x > y，返回 1𝔽。
8. 如果 x 是 -0𝔽 且 y 是 +0𝔽，返回 -1𝔽。
9. 如果 x 是 +0𝔽 且 y 是 -0𝔽，返回 1𝔽。
10. 返回 +0𝔽。

注意：这执行的是数值比较，而不是 23.1.3.30.2 中使用的字符串比较。

### 23.2.5 TypedArray 构造函数

每个 TypedArray 构造函数：

- 是一个具有如下结构的内置对象，只是使用的构造函数名称不同，而不是表 70 中的 TypedArray 名称。
- 是一个函数，其行为因其参数的数量和类型而异。调用 TypedArray 的实际行为取决于传递给它的参数的数量和种类。
- 不是用作函数调用的，并且在以这种方式调用时会抛出异常。
- 可以用作类定义的 extends 子句的值。意图继承指定的 TypedArray 行为的子类构造函数必须包括对 TypedArray 构造函数的 super 调用，以创建和初始化子类实例，具有支持 %TypedArray%.prototype 内置方法所需的内部状态。

#### 23.2.5.1 TypedArray ( ...args )

每个 TypedArray 构造函数在调用时执行以下步骤：

1. 如果 NewTarget 是 undefined，抛出一个 TypeError 异常。
2. 令 constructorName 为表 70 中为此 TypedArray 构造函数指定的构造函数名称的字符串值。
3. 令 proto 为 "%TypedArray.prototype%"。
4. 令 numberOfArgs 为 args 中元素的数量。
5. 如果 numberOfArgs = 0，则
   a. 返回 ? AllocateTypedArray(constructorName, NewTarget, proto, 0)。
6. 否则，
   a. 令 firstArgument 为 args[0]。
   b. 如果 firstArgument 是一个对象，则
      i. 令 O 为 ? AllocateTypedArray(constructorName, NewTarget, proto)。
      ii. 如果 firstArgument 具有 [[TypedArrayName]] 内部槽，则
         1. 执行 ? InitializeTypedArrayFromTypedArray(O, firstArgument)。
      iii. 否则，如果 firstArgument 具有 [[ArrayBufferData]] 内部槽，则
         1. 如果 numberOfArgs > 1，令 byteOffset 为 args[1]；否则令 byteOffset 为 undefined。
         2. 如果 numberOfArgs > 2，令 length 为 args[2]；否则令 length 为 undefined。
         3. 执行 ? InitializeTypedArrayFromArrayBuffer(O, firstArgument, byteOffset, length)。
      iv. 否则，
         1. 断言：firstArgument 是一个对象且没有 [[TypedArrayName]] 或 [[ArrayBufferData]] 内部槽。
         2. 令 usingIterator 为 ? GetMethod(firstArgument, @@iterator)。
         3. 如果 usingIterator 不为 undefined，则
            a. 令 values 为 ? IteratorToList(? GetIteratorFromMethod(firstArgument, usingIterator))。
            b. 执行 ? InitializeTypedArrayFromList(O, values)。
         4. 否则，
            a. 注意：firstArgument 不是一个可迭代对象，因此假定它已经是一个类似数组的对象。
            b. 执行 ? InitializeTypedArrayFromArrayLike(O, firstArgument)。
      v. 返回 O。
   c. 否则，
      i. 断言：firstArgument 不是一个对象。
      ii. 令 elementLength 为 ? ToIndex(firstArgument)。
      iii. 返回 ? AllocateTypedArray(constructorName, NewTarget, proto,

 elementLength)。

#### 23.2.5.1.1 AllocateTypedArray ( constructorName, newTarget, defaultProto [ , length ] )

抽象操作 AllocateTypedArray 接受参数 constructorName（一个字符串，是表 70 中 TypedArray 构造函数的名称）、newTarget（一个构造函数）和 defaultProto（一个字符串）以及可选参数 length（一个非负整数），并返回包含 TypedArray 的正常完成或抛出完成。它用于验证和创建 TypedArray 构造函数的实例。如果传递了 length 参数，还会分配一个该长度的 ArrayBuffer 并与新的 TypedArray 实例关联。AllocateTypedArray 提供了 TypedArray 使用的通用语义。调用时执行以下步骤：

1. 令 proto 为 ? GetPrototypeFromConstructor(newTarget, defaultProto)。
2. 令 obj 为 TypedArrayCreate(proto)。
3. 断言：obj.[[ViewedArrayBuffer]] 为 undefined。
4. 将 obj.[[TypedArrayName]] 设为 constructorName。
5. 如果 constructorName 是 "BigInt64Array" 或 "BigUint64Array"，将 obj.[[ContentType]] 设为 BIGINT。
6. 否则，将 obj.[[ContentType]] 设为 NUMBER。
7. 如果 length 不存在，则
   a. 将 obj.[[ByteLength]] 设为 0。
   b. 将 obj.[[ByteOffset]] 设为 0。
   c. 将 obj.[[ArrayLength]] 设为 0。
8. 否则，
   a. 执行 ? AllocateTypedArrayBuffer(obj, length)。
9. 返回 obj。

#### 23.2.5.1.2 InitializeTypedArrayFromTypedArray ( O, srcArray )

抽象操作 InitializeTypedArrayFromTypedArray 接受参数 O（一个 TypedArray）和 srcArray（一个 TypedArray），并返回包含 UNUSED 的正常完成或抛出完成。调用时执行以下步骤：

1. 令 srcData 为 srcArray.[[ViewedArrayBuffer]]。
2. 令 elementType 为 TypedArrayElementType(O)。
3. 令 elementSize 为 TypedArrayElementSize(O)。
4. 令 srcType 为 TypedArrayElementType(srcArray)。
5. 令 srcElementSize 为 TypedArrayElementSize(srcArray)。
6. 令 srcByteOffset 为 srcArray.[[ByteOffset]]。
7. 令 srcRecord 为 MakeTypedArrayWithBufferWitnessRecord(srcArray, SEQ-CST)。
8. 如果 IsTypedArrayOutOfBounds(srcRecord) 为 true，抛出一个 TypeError 异常。
9. 令 elementLength 为 TypedArrayLength(srcRecord)。
10. 令 byteLength 为 elementSize × elementLength。
11. 如果 elementType 为 srcType，则
    a. 令 data 为 ? CloneArrayBuffer(srcData, srcByteOffset, byteLength)。
12. 否则，
    a. 令 data 为 ? AllocateArrayBuffer(%ArrayBuffer%, byteLength)。
    b. 如果 srcArray.[[ContentType]] 不为 O.[[ContentType]]，抛出一个 TypeError 异常。
    c. 令 srcByteIndex 为 srcByteOffset。
    d. 令 targetByteIndex 为 0。
    e. 令 count 为 elementLength。
    f. 重复，直到 count > 0，
       i. 令 value 为 GetValueFromBuffer(srcData, srcByteIndex, srcType, true, UNORDERED)。
       ii. 执行 SetValueInBuffer(data, targetByteIndex, elementType, value, true, UNORDERED)。
       iii. 将 srcByteIndex 设为 srcByteIndex + srcElementSize。
       iv. 将 targetByteIndex 设为 targetByteIndex + elementSize。
       v. 将 count 设为 count - 1。
13. 将 O.[[ViewedArrayBuffer]] 设为 data。
14. 将 O.[[ByteLength]] 设为 byteLength。
15. 将 O.[[ByteOffset]] 设为 0。
16. 将 O.[[ArrayLength]] 设为 elementLength。
17. 返回 UNUSED。

#### 23.2.5.1.3 InitializeTypedArrayFromArrayBuffer ( O, buffer, byteOffset, length )

抽象操作 InitializeTypedArrayFromArrayBuffer 接受参数 O（一个 TypedArray）、buffer（一个 ArrayBuffer 或 SharedArrayBuffer）、byteOffset（一个 ECMAScript 语言值）和 length（一个 ECMAScript 语言值），并返回包含 UNUSED 的正常完成或抛出完成。调用时执行以下步骤：

1. 令 elementSize 为 TypedArrayElementSize(O)。
2. 令 offset 为 ? ToIndex(byteOffset)。
3. 如果 offset 模 elementSize ≠ 0，抛出一个 RangeError 异常。
4. 令 bufferIsFixedLength 为 IsFixedLengthArrayBuffer(buffer)。
5. 如果 length 不为 undefined，则
   a. 令 newLength 为 ? ToIndex(length)。
6. 如果 IsDetachedBuffer(buffer) 为 true，抛出一个 TypeError 异常。
7. 令 bufferByteLength 为 ArrayBufferByteLength(buffer, SEQ-CST)。
8. 如果 length 为 undefined 且 bufferIsFixedLength 为 false，则
   a. 如果 offset > bufferByteLength，抛出一个 RangeError 异常。
   b. 将 O.[[ByteLength]] 设为 AUTO。
   c. 将 O.[[ArrayLength]] 设为 AUTO。
9. 否则，
   a. 如果 length 为 undefined，则
      i. 如果 bufferByteLength 模 elementSize ≠ 0，抛出一个 RangeError 异常。
      ii. 令 newByteLength 为 bufferByteLength - offset。
      iii. 如果 newByteLength < 0，抛出一个 RangeError 异常。
   b. 否则，
      i. 令 newByteLength 为 newLength × elementSize。
      ii. 如果 offset + newByteLength > bufferByteLength，抛出一个 RangeError 异常。
   c. 将 O.[[ByteLength]] 设为 newByteLength。
   d. 将 O.[[ArrayLength]] 设为 newByteLength / elementSize。
10. 将 O.[[ViewedArrayBuffer]] 设为 buffer。
11. 将 O.[[ByteOffset]] 设为 offset。
12. 返回 UNUSED。

#### 23.2.5.1.4 InitializeTypedArrayFromList ( O, values )

抽象操作 InitializeTypedArrayFromList 接受参数 O（一个 TypedArray）和 values（一个 ECMAScript 语言值的列表），并返回包含 UNUSED 的正常完成或抛出完成。调用时执行以下步骤：

1. 令 len 为 values 中元素的数量。
2. 执行 ? AllocateTypedArrayBuffer(O, len)。
3. 令 k 为 0。
4. 重复，直到 k < len，
   a. 令 Pk 为 ! ToString(𝔽(k))。
   b. 令 kValue 为 values 中的第一个元素。
   c. 从 values 中移除第一个元素。
   d. 执行 ? Set(O, Pk, kValue, true)。
   e. 将 k 设为 k + 1。
5. 断言：values 现在是一个空列表。
6. 返回 UNUSED。

#### 23.2.5.1.5 InitializeTypedArrayFromArrayLike ( O, arrayLike )

抽象操作 InitializeTypedArrayFromArrayLike 接受参数 O（一个 TypedArray）和 arrayLike（一个对象，但不是 TypedArray 或 ArrayBuffer），并返回包含 UNUSED 的正常完成或抛出完成。调用时执行以下步骤：

1. 令 len 为 ? LengthOfArrayLike(arrayLike)。
2. 执行 ? AllocateTypedArrayBuffer(O, len)。
3. 令 k 为 0。
4. 重复，直到 k < len，
   a. 令 Pk 为 ! ToString(𝔽(k))。
   b. 令 kValue 为 ? Get(arrayLike, Pk)。
   c. 执行 ? Set(O, Pk, kValue, true)。
   d. 将 k 设为 k + 1。
5. 返回 UNUSED。

#### 23.2.5.1.6 AllocateTypedArrayBuffer ( O, length )

抽象操作 AllocateTypedArrayBuffer 接受参数 O（一个 TypedArray）和 length（一个非负整数），并返回包含 UNUSED 的正常完成或抛出完成。它分配并关联一个 ArrayBuffer 给 O。调用时执行以下步骤：

1. 断言：O.[[ViewedArrayBuffer]] 为 undefined。
2. 令 elementSize 为 TypedArrayElementSize(O)。
3. 令 byteLength 为 elementSize × length。
4. 令 data 为 ? AllocateArrayBuffer(%ArrayBuffer%, byteLength)。
5. 将 O.[[ViewedArrayBuffer]] 设为 data。
6. 将 O.[[ByteLength]] 设为 byteLength。
7. 将 O.[[ByteOffset]] 设为 0。
8. 将 O.[[ArrayLength]] 设为 length。
9. 返回 UNUSED。

### 23.2.6 TypedArray 构造函数的属性

每个 TypedArray 构造函数：

- 具有一个 [[Prototype]] 内部槽，其值为 %TypedArray%。
- 具有一个 "length" 属性，其值为 3𝔽。
- 具有一个 "name" 属性，其值为表 70 中为其指定的构造函数名称的字符串值。
- 具有以下属性：

#### 23.2.6.1 TypedArray.BYTES_PER_ELEMENT

TypedArray.BYTES_PER_ELEMENT 的值是表 70 中为 TypedArray 指定的元素大小值。

此属性的属性特性为 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }。

#### 23.2.6.2 TypedArray.prototype

TypedArray.prototype 的初始值是相应的 TypedArray 原型内置对象（见 23.2.7）。

此属性的属性特性为 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }。

### 23.2.7 TypedArray 原型对象的属性

每个 TypedArray 原型对象：

- 具有一个 [[Prototype]] 内部槽，其值为 %TypedArray.prototype%。
- 是一个普通对象。
- 没有 [[ViewedArrayBuffer]] 或其他任何特定于 TypedArray 实例对象的内部槽。

#### 23.2.7.1 TypedArray.prototype.BYTES_PER_ELEMENT

TypedArray.prototype.BYTES_PER_ELEMENT 的值是表 70 中为 TypedArray 指定的元素大小值。

此属性的属性特性为 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }。

#### 23.2.7.2 TypedArray.prototype.constructor

给定 TypedArray 构造函数的原型的 "constructor" 属性的初始值是构造函数本身。

### 23.2.8 TypedArray 实例的属性

TypedArray 实例是 TypedArrays。每个 TypedArray 实例继承自相应的 TypedArray 原型对象。每个 TypedArray 实例具有以下内部槽：[[TypedArrayName]]、[[ViewedArrayBuffer]]、[[ByteLength]]、[[ByteOffset]] 和 [[ArrayLength]]。

### 24 键控集合

#### 24.1 Map 对象

Maps 是键值对的集合，其中键和值都可以是任意的 ECMAScript 语言值。在 Map 的集合中，每个键值对只能出现一次不同的键值。不同的键值使用 SameValueZero 比较算法进行区分。

Maps 必须使用哈希表或其他机制实现，这些机制在平均情况下提供的访问时间在集合中元素数量的子线性范围内。此规范中使用的数据结构仅用于描述 Maps 的所需可观察语义。它不打算作为一个可行的实现模型。

#### 24.1.1 Map 构造函数

Map 构造函数：

- 是 %Map%。
- 是全局对象的 "Map" 属性的初始值。
- 作为构造函数调用时，创建并初始化一个新的 Map。
- 不应作为函数调用，作为函数调用时将抛出异常。
- 可以用作类定义的 extends 子句的值。意图继承指定 Map 行为的子类构造函数必须包括对 Map 构造函数的 super 调用，以创建并初始化子类实例，使其具有支持 Map.prototype 内置方法所需的内部状态。

##### 24.1.1.1 Map ( [ iterable ] )

调用时，此函数执行以下步骤：

1. 如果 NewTarget 为 undefined，抛出一个 TypeError 异常。
2. 令 map 为 ? OrdinaryCreateFromConstructor(NewTarget, "%Map.prototype%", « [[MapData]] »)。
3. 将 map.[[MapData]] 设为一个新的空列表。
4. 如果 iterable 为 undefined 或 null，则返回 map。
5. 令 adder 为 ? Get(map, "set")。
6. 如果 IsCallable(adder) 为 false，抛出一个 TypeError 异常。
7. 返回 ? AddEntriesFromIterable(map, iterable, adder)。

**注意**：如果存在参数 iterable，则它应当是一个实现 @@iterator 方法的对象，该方法返回一个迭代器对象，该迭代器对象生成一个两元素的类似数组对象，其第一个元素将用作 Map 键，第二个元素是与该键关联的值。

##### 24.1.1.2 AddEntriesFromIterable ( target, iterable, adder )

抽象操作 AddEntriesFromIterable 接受参数 target（一个对象）、iterable（一个 ECMAScript 语言值，但不能是 undefined 或 null）和 adder（一个函数对象），并返回包含 ECMAScript 语言值的正常完成或抛出完成。adder 将被调用，并以 target 作为接收者。调用时执行以下步骤：

1. 令 iteratorRecord 为 ? GetIterator(iterable, SYNC)。
2. 重复，
   a. 令 next 为 ? IteratorStepValue(iteratorRecord)。
   b. 如果 next 为 DONE，返回 target。
   c. 如果 next 不是一个对象，则
      i. 令 error 为 ThrowCompletion（一个新创建的 TypeError 对象）。
      ii. 返回 ? IteratorClose(iteratorRecord, error)。
   d. 令 k 为 Completion(Get(next, "0"))。
   e. IfAbruptCloseIterator(k, iteratorRecord)。
   f. 令 v 为 Completion(Get(next, "1"))。
   g. IfAbruptCloseIterator(v, iteratorRecord)。
   h. 令 status 为 Completion(Call(adder, target, « k, v »))。
   i. IfAbruptCloseIterator(status, iteratorRecord)。

**注意**：参数 iterable 应当是一个实现 @@iterator 方法的对象，该方法返回一个迭代器对象，该迭代器对象生成一个两元素的类似数组对象，其第一个元素将用作 Map 键，第二个元素是与该键关联的值。

#### 24.1.2 Map 构造函数的属性

Map 构造函数：

- 具有一个 [[Prototype]] 内部槽，其值为 %Function.prototype%。
- 具有以下属性：

##### 24.1.2.1 Map.groupBy ( items, callbackfn )

**注意**：callbackfn 应当是一个接受两个参数的函数。groupBy 按升序调用 callbackfn 一次用于 items 中的每个元素，并构造一个新的 Map。callbackfn 返回的每个值用作 Map 中的键。对于每个这样的键，结果 Map 具有一个条目，其键是该键，其值是一个包含所有元素的数组，其中 callbackfn 返回了该键。

callbackfn 以两个参数调用：元素的值和元素的索引。

groupBy 的返回值是一个 Map。

调用时，此函数执行以下步骤：

1. 令 groups 为 ? GroupBy(items, callbackfn, COLLECTION)。
2. 令 map 为 ! Construct(%Map%)。
3. 对于 groups 中的每个记录 { [[Key]], [[Elements]] } g，执行
   a. 令 elements 为 CreateArrayFromList(g.[[Elements]])。
   b. 令 entry 为记录 { [[Key]]: g.[[Key]], [[Value]]: elements }。
   c. 将 entry 附加到 map.[[MapData]]。
4. 返回 map。

##### 24.1.2.2 Map.prototype

Map.prototype 的初始值是 Map 原型对象。

此属性的属性特性为 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }。

##### 24.1.2.3 get Map [ @@species ]

Map[@@species] 是一个访问器属性，其 set 访问器函数为 undefined。其 get 访问器函数在调用时执行以下步骤：

1. 返回 this 值。

此函数的 "name" 属性的值是 "get [Symbol.species]"。

**注意**：创建派生集合对象的方法应调用 @@species 以确定用于创建派生对象的构造函数。子类构造函数可以重写 @@species 以更改默认构造函数分配。

### 24.1.3 Map 原型对象的属性

Map 原型对象：

- 是 %Map.prototype%。
- 具有一个 [[Prototype]] 内部槽，其值为 %Object.prototype%。
- 是一个普通对象。
- 没有 [[MapData]] 内部槽。

#### 24.1.3.1 Map.prototype.clear ( )

调用时，此方法执行以下步骤：

1. 令 M 为 this 值。
2. 执行 ? RequireInternalSlot(M, [[MapData]])。
3. 对于 M.[[MapData]] 中的每个记录 { [[Key]], [[Value]] } p，执行
   a. 将 p.[[Key]] 设为 EMPTY。
   b. 将 p.[[Value]] 设为 EMPTY。
4. 返回 undefined。

**注意**：现有的 [[MapData]] 列表被保留，因为可能存在正在迭代该列表中途暂停的现有 Map 迭代器对象。

#### 24.1.3.2 Map.prototype.constructor

Map.prototype.constructor 的初始值是 %Map%。

#### 24.1.3.3 Map.prototype.delete ( key )

调用时，此方法执行以下步骤：

1.

 令 M 为 this 值。
2. 执行 ? RequireInternalSlot(M, [[MapData]])。
3. 将 key 设为 CanonicalizeKeyedCollectionKey(key)。
4. 对于 M.[[MapData]] 中的每个记录 { [[Key]], [[Value]] } p，执行
   a. 如果 p.[[Key]] 不是 EMPTY 且 SameValue(p.[[Key]], key) 为 true，则
      i. 将 p.[[Key]] 设为 EMPTY。
      ii. 将 p.[[Value]] 设为 EMPTY。
      iii. 返回 true。
5. 返回 false。

**注意**：值 EMPTY 作为一种规范设备，用于表示条目已被删除。实际实现可能会采取其他操作，例如从内部数据结构中物理删除条目。

#### 24.1.3.4 Map.prototype.entries ( )

调用时，此方法执行以下步骤：

1. 令 M 为 this 值。
2. 返回 ? CreateMapIterator(M, KEY+VALUE)。

#### 24.1.3.5 Map.prototype.forEach ( callbackfn [ , thisArg ] )

调用时，此方法执行以下步骤：

1. 令 M 为 this 值。
2. 执行 ? RequireInternalSlot(M, [[MapData]])。
3. 如果 IsCallable(callbackfn) 为 false，抛出一个 TypeError 异常。
4. 令 entries 为 M.[[MapData]]。
5. 令 numEntries 为 entries 中元素的数量。
6. 令 index 为 0。
7. 重复，直到 index < numEntries，
   a. 令 e 为 entries[index]。
   b. 将 index 设为 index + 1。
   c. 如果 e.[[Key]] 不是 EMPTY，则
      i. 执行 ? Call(callbackfn, thisArg, « e.[[Value]], e.[[Key]], M »)。
      ii. **注意**：在 callbackfn 的执行过程中，entries 中的元素数量可能会增加。
      iii. 将 numEntries 设为 entries 中的元素数量。
8. 返回 undefined。

**注意**：callbackfn 应当是一个接受三个参数的函数。forEach 按键插入顺序调用 callbackfn 一次用于 Map 中的每个键值对。callbackfn 仅对 Map 中实际存在的键调用；它不会对已从 Map 中删除的键调用。

如果提供了 thisArg 参数，它将用作每次调用 callbackfn 的 this 值。如果未提供，则使用 undefined。

callbackfn 以三个参数调用：项目的值、项目的键以及正在遍历的 Map。

forEach 不直接改变调用它的对象，但该对象可能会被调用 callbackfn 时更改。Map 的每个 [[MapData]] 条目仅被访问一次。forEach 调用开始后添加的新键将被访问。如果键在被访问后被删除，然后在 forEach 调用完成之前重新添加，则该键将被重新访问。forEach 调用开始后删除的键在被访问之前不会被访问，除非在 forEach 调用完成之前重新添加该键。

#### 24.1.3.6 Map.prototype.get ( key )

调用时，此方法执行以下步骤：

1. 令 M 为 this 值。
2. 执行 ? RequireInternalSlot(M, [[MapData]])。
3. 将 key 设为 CanonicalizeKeyedCollectionKey(key)。
4. 对于 M.[[MapData]] 中的每个记录 { [[Key]], [[Value]] } p，执行
   a. 如果 p.[[Key]] 不是 EMPTY 且 SameValue(p.[[Key]], key) 为 true，则返回 p.[[Value]]。
5. 返回 undefined。

#### 24.1.3.7 Map.prototype.has ( key )

调用时，此方法执行以下步骤：

1. 令 M 为 this 值。
2. 执行 ? RequireInternalSlot(M, [[MapData]])。
3. 将 key 设为 CanonicalizeKeyedCollectionKey(key)。
4. 对于 M.[[MapData]] 中的每个记录 { [[Key]], [[Value]] } p，执行
   a. 如果 p.[[Key]] 不是 EMPTY 且 SameValue(p.[[Key]], key) 为 true，则返回 true。
5. 返回 false。

#### 24.1.3.8 Map.prototype.keys ( )

调用时，此方法执行以下步骤：

1. 令 M 为 this 值。
2. 返回 ? CreateMapIterator(M, KEY)。

#### 24.1.3.9 Map.prototype.set ( key, value )

调用时，此方法执行以下步骤：

1. 令 M 为 this 值。
2. 执行 ? RequireInternalSlot(M, [[MapData]])。
3. 将 key 设为 CanonicalizeKeyedCollectionKey(key)。
4. 对于 M.[[MapData]] 中的每个记录 { [[Key]], [[Value]] } p，执行
   a. 如果 p.[[Key]] 不是 EMPTY 且 SameValue(p.[[Key]], key) 为 true，则
      i. 将 p.[[Value]] 设为 value。
      ii. 返回 M。
5. 令 p 为记录 { [[Key]]: key, [[Value]]: value }。
6. 将 p 附加到 M.[[MapData]]。
7. 返回 M。

#### 24.1.3.10 get Map.prototype.size

Map.prototype.size 是一个访问器属性，其 set 访问器函数为 undefined。其 get 访问器函数在调用时执行以下步骤：

1. 令 M 为 this 值。
2. 执行 ? RequireInternalSlot(M, [[MapData]])。
3. 令 count 为 0。
4. 对于 M.[[MapData]] 中的每个记录 { [[Key]], [[Value]] } p，执行
   a. 如果 p.[[Key]] 不是 EMPTY，则将 count 设为 count + 1。
5. 返回 𝔽(count)。

#### 24.1.3.11 Map.prototype.values ( )

调用时，此方法执行以下步骤：

1. 令 M 为 this 值。
2. 返回 ? CreateMapIterator(M, VALUE)。

#### 24.1.3.12 Map.prototype [ @@iterator ] ( )

@@iterator 属性的初始值是 %Map.prototype.entries%，定义在 24.1.3.4 中。

#### 24.1.3.13 Map.prototype [ @@toStringTag ]

@@toStringTag 属性的初始值是字符串值 "Map"。

此属性的属性特性为 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }。

### 24.1.4 Map 实例的属性

Map 实例是从 Map 原型继承属性的普通对象。Map 实例还具有一个 [[MapData]] 内部槽。

### 24.1.5 Map 迭代器对象

Map 迭代器是一个表示特定 Map 实例对象的特定迭代的对象。Map 迭代器对象没有命名的构造函数。相反，Map 迭代器对象是通过调用 Map 实例对象的某些方法创建的。

#### 24.1.5.1 CreateMapIterator ( map, kind )

抽象操作 CreateMapIterator 接受参数 map（一个 ECMAScript 语言值）和 kind（KEY+VALUE、KEY 或 VALUE），并返回包含生成器的正常完成或抛出完成。它用于为返回这些迭代器的 Map 方法创建迭代器对象。调用时执行以下步骤：

1. 执行 ? RequireInternalSlot(map, [[MapData]])。
2. 令 closure 为一个新的抽象闭包，没有参数，捕获 map 和 kind，并在调用时执行以下步骤：
   a. 令 entries 为 map.[[MapData]]。
   b. 令 index 为 0。
   c. 令 numEntries 为 entries 中的元素数量。
   d. 重复，直到 index < numEntries，
      i. 令 e 为 entries[index]。
      ii. 将 index 设为 index + 1。
      iii. 如果 e.[[Key]] 不是 EMPTY，则
         1. 如果 kind 是 KEY，则
            a. 令 result 为 e.[[Key]]。
         2. 否则如果 kind 是 VALUE，则
            a. 令 result 为 e.[[Value]]。
         3. 否则，
            a. 断言：kind 是 KEY+VALUE。
            b. 令 result 为 CreateArrayFromList(« e.[[Key]], e.[[Value]] »)。
         4. 执行 ? GeneratorYield(CreateIterResultObject(result, false))。
         5. **注意**：在此抽象操作因 Yield 暂停执行期间，entries 中的元素数量可能增加。
      iv. 将 numEntries 设为 entries 中的元素数量。
   e. 返回 undefined。
3. 返回 CreateIteratorFromClosure(closure, "%MapIteratorPrototype%", %MapIteratorPrototype%)。

#### 24.1.5.2 %MapIteratorPrototype% 对象

%MapIteratorPrototype% 对象：

- 具有所有 Map 迭代器对象继承的属性。
- 是一个普通对象。
- 具有一个 [[Prototype]] 内部槽，其值为 %IteratorPrototype%。
- 具有以下属性：

##### 24.1.5.2.1 %MapIteratorPrototype%.next ( )

1. 返回 ? GeneratorResume(this 值, EMPTY, "%MapIteratorPrototype%")。

##### 24.1.5.2.2 %MapIteratorPrototype% [ @@toStringTag ]

@@toStringTag 属性的初始值是字符串值 "Map Iterator"。

此属性的属性特性为 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }。

### 24.2 Set 对象

Set 对象是 ECMAScript 语言值的集合。在 Set 的集合中，每个不同的值只会出现一次。不同的值通过 SameValueZero 比较算法进行区分。

Set 对象必须使用哈希表或其他机制实现，这些机制在平均情况下提供的访问时间在集合中元素数量的子线性范围内。此规范中使用的数据结构仅用于描述 Set 对象的所需可观察语义。它不打算作为一个可行的实现模型。

#### 24.2.1 Set 对象的抽象操作

##### 24.2.1.1 Set 记录

Set 记录是用于封装 Set 或类似对象接口的记录值。

Set 记录具有表 71 中列出的字段。

表 71: Set 记录字段

| 字段名称      | 值                 | 含义                               |
|-------------|-------------------|----------------------------------|
| [[SetObject]] | 一个对象            | Set 或类似对象                     |
| [[Size]]      | 一个非负整数或 +∞   | 对象的报告大小                       |
| [[Has]]       | 一个函数对象         | 对象的 has 方法                     |
| [[Keys]]      | 一个函数对象         | 对象的 keys 方法                     |

##### 24.2.1.2 GetSetRecord ( obj )

抽象操作 GetSetRecord 接受参数 obj（一个 ECMAScript 语言值），并返回包含 Set 记录的正常完成或抛出完成。调用时执行以下步骤：

1. 如果 obj 不是一个对象，抛出一个 TypeError 异常。
2. 令 rawSize 为 ? Get(obj, "size")。
3. 令 numSize 为 ? ToNumber(rawSize)。
4. **注意**：如果 rawSize 是 undefined，则 numSize 将是 NaN。
5. 如果 numSize 是 NaN，抛出一个 TypeError 异常。
6. 令 intSize 为 ! ToIntegerOrInfinity(numSize)。
7. 如果 intSize < 0，抛出一个 RangeError 异常。
8. 令 has 为 ? Get(obj, "has")。
9. 如果 IsCallable(has) 为 false，抛出一个 TypeError 异常。
10. 令 keys 为 ? Get(obj, "keys")。
11. 如果 IsCallable(keys) 为 false，抛出一个 TypeError 异常。
12. 返回一个新的 Set 记录 { [[SetObject]]: obj, [[Size]]: intSize, [[Has]]: has, [[Keys]]: keys }。

##### 24.2.1.3 SetDataHas ( setData, value )

抽象操作 SetDataHas 接受参数 setData（一个 ECMAScript 语言值或 EMPTY 的列表）和 value（一个 ECMAScript 语言值），并返回一个布尔值。调用时执行以下步骤：

1. 如果 SetDataIndex(setData, value) 是 NOT-FOUND，返回 false。
2. 返回 true。

##### 24.2.1.4 SetDataIndex ( setData, value )

抽象操作 SetDataIndex 接受参数 setData（一个 ECMAScript 语言值或 EMPTY 的列表）和 value（一个 ECMAScript 语言值），并返回一个非负整数或 NOT-FOUND。调用时执行以下步骤：

1. 将 value 设为 CanonicalizeKeyedCollectionKey(value)。
2. 令 size 为 setData 中元素的数量。
3. 令 index 为 0。
4. 重复，直到 index < size，
   a. 令 e 为 setData[index]。
   b. 如果 e 不是 EMPTY 且 e 是 value，则
      i. 返回 index。
   c. 将 index 设为 index + 1。
5. 返回 NOT-FOUND。

##### 24.2.1.5 SetDataSize ( setData )

抽象操作 SetDataSize 接受参数 setData（一个 ECMAScript 语言值或 EMPTY 的列表），并返回一个非负整数。调用时执行以下步骤：

1. 令 count 为 0。
2. 对于 setData 中的每个元素 e，执行
   a. 如果 e 不是 EMPTY，将 count 设为 count + 1。
3. 返回 count。

#### 24.2.2 Set 构造函数

Set 构造函数：

- 是 %Set%。
- 是全局对象的 "Set" 属性的初始值。
- 作为构造函数调用时，创建并初始化一个新的 Set 对象。
- 不应作为函数调用，作为函数调用时将抛出异常。
- 可以用作类定义的 extends 子句的值。意图继承指定 Set 行为的子类构造函数必须包括对 Set 构造函数的 super 调用，以创建并初始化子类实例，使其具有支持 Set.prototype 内置方法所需的内部状态。

##### 24.2.2.1 Set ( [ iterable ] )

调用时，此函数执行以下步骤：

1. 如果 NewTarget 为 undefined，抛出一个 TypeError 异常。
2. 令 set 为 ? OrdinaryCreateFromConstructor(NewTarget, "%Set.prototype%", « [[SetData]] »)。
3. 将 set.[[SetData]] 设为一个新的空列表。
4. 如果 iterable 为 undefined 或 null，则返回 set。
5. 令 adder 为 ? Get(set, "add")。
6. 如果 IsCallable(adder) 为 false，抛出一个 TypeError 异常。
7. 令 iteratorRecord 为 ? GetIterator(iterable, SYNC)。
8. 重复，
   a. 令 next 为 ? IteratorStepValue(iteratorRecord)。
   b. 如果 next 为 DONE，则返回 set。
   c. 令 status 为 Completion(Call(adder, set, « next »))。
   d. IfAbruptCloseIterator(status, iteratorRecord)。

#### 24.2.3 Set 构造函数的属性

Set 构造函数：

- 具有一个 [[Prototype]] 内部槽，其值为 %Function.prototype%。
- 具有以下属性：

##### 24.2.3.1 Set.prototype

Set.prototype 的初始值是 Set 原型对象。

此属性的属性特性为 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }。

##### 24.2.3.2 get Set [ @@species ]

Set[@@species] 是一个访问

器属性，其 set 访问器函数为 undefined。其 get 访问器函数在调用时执行以下步骤：

1. 返回 this 值。

此函数的 "name" 属性值为 "get [Symbol.species]"。

**注意**：创建派生集合对象的方法应调用 @@species 以确定用于创建派生对象的构造函数。子类构造函数可以重写 @@species 以更改默认构造函数分配。

#### 24.2.4 Set 原型对象的属性

Set 原型对象：

- 是 %Set.prototype%。
- 具有一个 [[Prototype]] 内部槽，其值为 %Object.prototype%。
- 是一个普通对象。
- 没有 [[SetData]] 内部槽。

##### 24.2.4.1 Set.prototype.add ( value )

调用时，此方法执行以下步骤：

1. 令 S 为 this 值。
2. 执行 ? RequireInternalSlot(S, [[SetData]])。
3. 将 value 设为 CanonicalizeKeyedCollectionKey(value)。
4. 对于 S.[[SetData]] 中的每个元素 e，执行
   a. 如果 e 不是 EMPTY 且 SameValue(e, value) 为 true，则
      i. 返回 S。
5. 将 value 附加到 S.[[SetData]]。
6. 返回 S。

##### 24.2.4.2 Set.prototype.clear ( )

调用时，此方法执行以下步骤：

1. 令 S 为 this 值。
2. 执行 ? RequireInternalSlot(S, [[SetData]])。
3. 对于 S.[[SetData]] 中的每个元素 e，执行
   a. 将 S.[[SetData]] 中值为 e 的元素替换为一个值为 EMPTY 的元素。
4. 返回 undefined。

**注意**：现有的 [[SetData]] 列表被保留，因为可能存在在该列表中途暂停迭代的 Set 迭代器对象。

##### 24.2.4.3 Set.prototype.constructor

Set.prototype.constructor 的初始值为 %Set%。

##### 24.2.4.4 Set.prototype.delete ( value )

调用时，此方法执行以下步骤：

1. 令 S 为 this 值。
2. 执行 ? RequireInternalSlot(S, [[SetData]])。
3. 将 value 设为 CanonicalizeKeyedCollectionKey(value)。
4. 对于 S.[[SetData]] 中的每个元素 e，执行
   a. 如果 e 不是 EMPTY 且 SameValue(e, value) 为 true，则
      i. 将 S.[[SetData]] 中值为 e 的元素替换为一个值为 EMPTY 的元素。
      ii. 返回 true。
5. 返回 false。

**注意**：值 EMPTY 作为一种规范设备，用于表示条目已被删除。实际实现可能会采取其他操作，例如从内部数据结构中物理删除条目。

##### 24.2.4.5 Set.prototype.difference ( other )

调用时，此方法执行以下步骤：

1. 令 O 为 this 值。
2. 执行 ? RequireInternalSlot(O, [[SetData]])。
3. 令 otherRec 为 ? GetSetRecord(other)。
4. 令 resultSetData 为 O.[[SetData]] 的副本。
5. 如果 O.[[SetData]] 的 SetDataSize ≤ otherRec.[[Size]]，则
   a. 令 thisSize 为 O.[[SetData]] 中元素的数量。
   b. 令 index 为 0。
   c. 重复，直到 index < thisSize，
      i. 令 e 为 resultSetData[index]。
      ii. 如果 e 不是 EMPTY，则
         1. 令 inOther 为 ToBoolean(? Call(otherRec.[[Has]], otherRec.[[SetObject]], « e »))。
         2. 如果 inOther 为 true，则
            a. 将 resultSetData[index] 设为 EMPTY。
      iii. 将 index 设为 index + 1。
6. 否则，
   a. 令 keysIter 为 ? GetIteratorFromMethod(otherRec.[[SetObject]], otherRec.[[Keys]])。
   b. 令 next 为 NOT-STARTED。
   c. 重复，直到 next 为 DONE，
      i. 将 next 设为 ? IteratorStepValue(keysIter)。
      ii. 如果 next 不是 DONE，则
         1. 将 next 设为 CanonicalizeKeyedCollectionKey(next)。
         2. 令 valueIndex 为 SetDataIndex(resultSetData, next)。
         3. 如果 valueIndex 不是 NOT-FOUND，则
            a. 将 resultSetData[valueIndex] 设为 EMPTY。
7. 令 result 为 OrdinaryObjectCreate(%Set.prototype%, « [[SetData]] »)。
8. 将 result.[[SetData]] 设为 resultSetData。
9. 返回 result。

##### 24.2.4.6 Set.prototype.entries ( )

调用时，此方法执行以下步骤：

1. 令 S 为 this 值。
2. 返回 ? CreateSetIterator(S, KEY+VALUE)。

**注意**：为了迭代目的，Set 类似于一个 Map，其中每个条目的键和值相同。

##### 24.2.4.7 Set.prototype.forEach ( callbackfn [ , thisArg ] )

调用时，此方法执行以下步骤：

1. 令 S 为 this 值。
2. 执行 ? RequireInternalSlot(S, [[SetData]])。
3. 如果 IsCallable(callbackfn) 为 false，抛出一个 TypeError 异常。
4. 令 entries 为 S.[[SetData]]。
5. 令 numEntries 为 entries 中元素的数量。
6. 令 index 为 0。
7. 重复，直到 index < numEntries，
   a. 令 e 为 entries[index]。
   b. 将 index 设为 index + 1。
   c. 如果 e 不是 EMPTY，则
      i. 执行 ? Call(callbackfn, thisArg, « e, e, S »)。
      ii. **注意**：在 callbackfn 的执行过程中，entries 中的元素数量可能会增加。
      iii. 将 numEntries 设为 entries 中的元素数量。
8. 返回 undefined。

**注意**：callbackfn 应当是一个接受三个参数的函数。forEach 按值插入顺序调用 callbackfn 一次用于 Set 对象中的每个值。callbackfn 仅对 Set 中实际存在的值调用；它不会对已从 Set 中删除的键调用。

如果提供了 thisArg 参数，它将用作每次调用 callbackfn 的 this 值。如果未提供，则使用 undefined。

callbackfn 以三个参数调用：前两个参数是 Set 中包含的一个值。相同的值用于两个参数。遍历的 Set 对象作为第三个参数传递。

callbackfn 以三个参数调用，以与 Map 和 Array 的 forEach 方法使用的回调函数一致。对于 Set，每个项目值被视为键和值。

forEach 不直接改变调用它的对象，但该对象可能会被调用 callbackfn 时更改。

每个值通常只被访问一次。但是，如果值在访问后被删除并在 forEach 调用完成之前重新添加，则该值将被重新访问。forEach 调用开始后删除的值在被访问之前不会被访问，除非在 forEach 调用完成之前重新添加该值。forEach 调用开始后添加的新值将被访问。

##### 24.2.4.8 Set.prototype.has ( value )

调用时，此方法执行以下步骤：

1. 令 S 为 this 值。
2. 执行 ? RequireInternalSlot(S, [[SetData]])。
3. 将 value 设为 CanonicalizeKeyedCollectionKey(value)。
4. 对于 S.[[SetData]] 中的每个元素 e，执行
   a. 如果 e 不是 EMPTY 且 SameValue(e, value) 为 true，则返回 true。
5. 返回 false。

##### 24.2.4.9 Set.prototype.intersection ( other )

调用时，此方法执行以下步骤：

1. 令 O 为 this 值。
2. 执行 ? RequireInternalSlot(O, [[SetData]])。
3. 令 otherRec 为 ? GetSetRecord(other)。
4. 令 resultSetData 为一个新的空列表。
5. 如果 O.[[SetData]] 的 SetDataSize ≤ otherRec.[[Size]]，则
   a. 令 thisSize 为 O.[[SetData]] 中的元素数量。
   b. 令 index 为 0。
   c. 重复，直到 index < thisSize，
      i. 令 e 为 O.[[SetData]][index]。
      ii. 将 index 设为 index + 1。
      iii. 如果 e 不是 EMPTY，则
         1. 令 inOther 为 ToBoolean(? Call(otherRec.[[Has]], otherRec.[[SetObject]], « e »))。
         2. 如果 inOther 为 true，则
            a. **注意**：可能会出现早期调用 otherRec.[[Has]] 删除并重新添加 O.[[SetData]] 的元素的情况，这会导致在此迭代期间访问相同的元素两次。
            b. 如果 SetDataHas(resultSetData, e) 为 false，则
               i. 将 e 附加到 resultSetData。
      iv. **注意**：在执行 otherRec.[[Has]] 

期间，O.[[SetData]] 中的元素数量可能会增加。
      v. 将 thisSize 设为 O.[[SetData]] 中的元素数量。
6. 否则，
   a. 令 keysIter 为 ? GetIteratorFromMethod(otherRec.[[SetObject]], otherRec.[[Keys]])。
   b. 令 next 为 NOT-STARTED。
   c. 重复，直到 next 为 DONE，
      i. 将 next 设为 ? IteratorStepValue(keysIter)。
      ii. 如果 next 不是 DONE，则
         1. 将 next 设为 CanonicalizeKeyedCollectionKey(next)。
         2. 令 inThis 为 SetDataHas(O.[[SetData]], next)。
         3. 如果 inThis 为 true，则
            a. **注意**：因为 other 是一个任意对象，其 "keys" 迭代器可能会多次生成相同的值。
            b. 如果 SetDataHas(resultSetData, next) 为 false，则
               i. 将 next 附加到 resultSetData。
7. 令 result 为 OrdinaryObjectCreate(%Set.prototype%, « [[SetData]] »)。
8. 将 result.[[SetData]] 设为 resultSetData。
9. 返回 result。

##### 24.2.4.10 Set.prototype.isDisjointFrom ( other )

调用时，此方法执行以下步骤：

1. 令 O 为 this 值。
2. 执行 ? RequireInternalSlot(O, [[SetData]])。
3. 令 otherRec 为 ? GetSetRecord(other)。
4. 如果 O.[[SetData]] 的 SetDataSize ≤ otherRec.[[Size]]，则
   a. 令 thisSize 为 O.[[SetData]] 中的元素数量。
   b. 令 index 为 0。
   c. 重复，直到 index < thisSize，
      i. 令 e 为 O.[[SetData]][index]。
      ii. 将 index 设为 index + 1。
      iii. 如果 e 不是 EMPTY，则
         1. 令 inOther 为 ToBoolean(? Call(otherRec.[[Has]], otherRec.[[SetObject]], « e »))。
         2. 如果 inOther 为 true，则返回 false。
      iv. **注意**：在执行 otherRec.[[Has]] 期间，O.[[SetData]] 中的元素数量可能会增加。
      v. 将 thisSize 设为 O.[[SetData]] 中的元素数量。
5. 否则，
   a. 令 keysIter 为 ? GetIteratorFromMethod(otherRec.[[SetObject]], otherRec.[[Keys]])。
   b. 令 next 为 NOT-STARTED。
   c. 重复，直到 next 为 DONE，
      i. 将 next 设为 ? IteratorStepValue(keysIter)。
      ii. 如果 next 不是 DONE，则
         1. 如果 SetDataHas(O.[[SetData]], next) 为 true，则
            a. 执行 ? IteratorClose(keysIter, NormalCompletion(UNUSED))。
            b. 返回 false。
6. 返回 true。

##### 24.2.4.11 Set.prototype.isSubsetOf ( other )

调用时，此方法执行以下步骤：

1. 令 O 为 this 值。
2. 执行 ? RequireInternalSlot(O, [[SetData]])。
3. 令 otherRec 为 ? GetSetRecord(other)。
4. 如果 O.[[SetData]] 的 SetDataSize > otherRec.[[Size]]，返回 false。
5. 令 thisSize 为 O.[[SetData]] 中的元素数量。
6. 令 index 为 0。
7. 重复，直到 index < thisSize，
   a. 令 e 为 O.[[SetData]][index]。
   b. 将 index 设为 index + 1。
   c. 如果 e 不是 EMPTY，则
      i. 令 inOther 为 ToBoolean(? Call(otherRec.[[Has]], otherRec.[[SetObject]], « e »))。
      ii. 如果 inOther 为 false，返回 false。
      iii. **注意**：在执行 otherRec.[[Has]] 期间，O.[[SetData]] 中的元素数量可能会增加。
      iv. 将 thisSize 设为 O.[[SetData]] 中的元素数量。
8. 返回 true。

#### 24.2.4.12 Set.prototype.isSupersetOf (other)
调用此方法时，执行以下步骤：

1. 令 O 为 this 值。
2. 执行 ? RequireInternalSlot(O, [[SetData]])。
3. 令 otherRec 为 ? GetSetRecord(other)。
4. 如果 O.[[SetData]] 的 SetDataSize 小于 otherRec.[[Size]]，返回 false。
5. 令 keysIter 为 ? GetIteratorFromMethod(otherRec.[[SetObject]], otherRec.[[Keys]])。
6. 令 next 为 NOT-STARTED。
7. 重复，直到 next 为 DONE，
   a. 将 next 设为 ? IteratorStepValue(keysIter)。
   b. 如果 next 不是 DONE，则
      i. 如果 SetDataHas(O.[[SetData]], next) 为 false，则
         1. 执行 ? IteratorClose(keysIter, NormalCompletion(UNUSED))。
         2. 返回 false。
8. 返回 true。

#### 24.2.4.13 Set.prototype.keys ( )
"keys" 属性的初始值是 %Set.prototype.values%，定义在 24.2.4.17。

**注意**：为了迭代目的，Set 类似于一个 Map，其中每个条目的键和值相同。

#### 24.2.4.14 get Set.prototype.size
Set.prototype.size 是一个访问器属性，其 set 访问器函数为 undefined。其 get 访问器函数在调用时执行以下步骤：

1. 令 S 为 this 值。
2. 执行 ? RequireInternalSlot(S, [[SetData]])。
3. 令 size 为 SetDataSize(S.[[SetData]])。
4. 返回 𝔽(size)。

#### 24.2.4.15 Set.prototype.symmetricDifference (other)
调用此方法时，执行以下步骤：

1. 令 O 为 this 值。
2. 执行 ? RequireInternalSlot(O, [[SetData]])。
3. 令 otherRec 为 ? GetSetRecord(other)。
4. 令 keysIter 为 ? GetIteratorFromMethod(otherRec.[[SetObject]], otherRec.[[Keys]])。
5. 令 resultSetData 为 O.[[SetData]] 的副本。
6. 令 next 为 NOT-STARTED。
7. 重复，直到 next 为 DONE，
   a. 将 next 设为 ? IteratorStepValue(keysIter)。
   b. 如果 next 不是 DONE，则
      i. 将 next 设为 CanonicalizeKeyedCollectionKey(next)。
      ii. 令 resultIndex 为 SetDataIndex(resultSetData, next)。
      iii. 如果 resultIndex 为 NOT-FOUND，则令 alreadyInResult 为 false。否则令 alreadyInResult 为 true。
      iv. 如果 SetDataHas(O.[[SetData]], next) 为 true，则
         1. 如果 alreadyInResult 为 true，将 resultSetData[resultIndex] 设为 EMPTY。
      v. 否则，
         1. 如果 alreadyInResult 为 false，将 next 附加到 resultSetData。
8. 令 result 为 OrdinaryObjectCreate(%Set.prototype%, « [[SetData]] »)。
9. 将 result.[[SetData]] 设为 resultSetData。
10. 返回 result。

#### 24.2.4.16 Set.prototype.union (other)
调用此方法时，执行以下步骤：

1. 令 O 为 this 值。
2. 执行 ? RequireInternalSlot(O, [[SetData]])。
3. 令 otherRec 为 ? GetSetRecord(other)。
4. 令 keysIter 为 ? GetIteratorFromMethod(otherRec.[[SetObject]], otherRec.[[Keys]])。
5. 令 resultSetData 为 O.[[SetData]] 的副本。
6. 令 next 为 NOT-STARTED。
7. 重复，直到 next 为 DONE，
   a. 将 next 设为 ? IteratorStepValue(keysIter)。
   b. 如果 next 不是 DONE，则
      i. 将 next 设为 CanonicalizeKeyedCollectionKey(next)。
      ii. 如果 SetDataHas(resultSetData, next) 为 false，则
         1. 将 next 附加到 resultSetData。
8. 令 result 为 OrdinaryObjectCreate(%Set.prototype%, « [[SetData]] »)。
9. 将 result.[[SetData]] 设为 resultSetData。
10. 返回 result。

#### 24.2.4.17 Set.prototype.values ( )
调用此方法时，执行以下步骤：

1. 令 S 为 this 值。
2. 返回 ? CreateSetIterator(S, VALUE)。

#### 24.2.4.18 Set.prototype [ @@iterator ] ( )
@@iterator 属性的初始值是 %Set.prototype.values%，定义在 24.2.4.17。

#### 24.2.4.19 Set.prototype [ @@toStringTag ]
@@toStringTag 属性的初始值是字符串值 "Set"。

此属性的属性为 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }。

#### 24.2.5 Set 实例的属性
Set 实例是从 Set 原型继承属性的普通对象。Set 实例也具有一个 [[SetData]] 内部槽。

#### 24.2.6 Set 迭代器对象
Set 迭代器是一个普通对象，具有下面定义的结构，表示对某个特定 Set 实例对象的特定迭代。Set 迭代器对象没有命名构造函数，而是通过调用 Set 实例对象的某些方法创建的。

#### 24.2.6.1 CreateSetIterator (set, kind)
抽象操作 CreateSetIterator 接受参数 set（一个 ECMAScript 语言值）和 kind（KEY+VALUE 或 VALUE），返回一个包含生成器的正常完成或抛出完成。它用于为返回此类迭代器的 Set 方法创建迭代器对象。调用时执行以下步骤：

1. 执行 ? RequireInternalSlot(set, [[SetData]])。
2. 让闭包为一个新的抽象闭包，没有参数，捕获 set 和 kind，并在调用时执行以下步骤：
   a. 令 index 为 0。
   b. 令 entries 为 set.[[SetData]]。
   c. 令 numEntries 为 entries 中元素的数量。
   d. 重复，直到 index < numEntries，
      i. 令 e 为 entries[index]。
      ii. 将 index 设为 index + 1。
      iii. 如果 e 不是 EMPTY，则
         1. 如果 kind 是 KEY+VALUE，则
            a. 令 result 为 CreateArrayFromList(« e, e »)。
            b. 执行 ? GeneratorYield(CreateIterResultObject(result, false))。
         2. 否则，
            a. 断言：kind 是 VALUE。
            b. 执行 ? GeneratorYield(CreateIterResultObject(e, false))。
         3. 注意：在此抽象操作因 Yield 暂停执行期间，entries 中的元素数量可能会增加。
         4. 将 numEntries 设为 entries 中的元素数量。
   e. 返回 undefined。
3. 返回 CreateIteratorFromClosure(closure, "%SetIteratorPrototype%", %SetIteratorPrototype%)。

#### 24.2.6.2 %SetIteratorPrototype% 对象
%SetIteratorPrototype% 对象：

- 具有所有 Set 迭代器对象继承的属性。
- 是一个普通对象。
- 具有一个 [[Prototype]] 内部槽，其值为 %IteratorPrototype%。
- 具有以下属性：

##### 24.2.6.2.1 %SetIteratorPrototype%.next ( )
1. 返回 ? GeneratorResume(this 值, EMPTY, "%SetIteratorPrototype%")。

##### 24.2.6.2.2 %SetIteratorPrototype% [ @@toStringTag ]
@@toStringTag 属性的初始值是字符串值 "Set Iterator"。

此属性的属性为 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }。

### 24.3 WeakMap 对象
WeakMap 是包含键/值对的集合，其中键是对象和/或符号，值可以是任意 ECMAScript 语言值。可以查询 WeakMap 看它是否包含具有特定键的键/值对，但不提供枚举其持有的值的机制。在某些条件下，不再存活的值作为 WeakMap 键会被移除，如 9.9.3 中所述。

实现可以在 WeakMap 的键/值对变得不可访问和从 WeakMap 中移除之间施加任意确定的延迟。如果这种延迟对 ECMAScript 程序可观察，则会成为影响程序执行的不确定性来源。因此，ECMAScript 实现不得提供任何观察 WeakMap 键的手段，除非观察者呈现被观察的键。

WeakMap 必须使用哈希表或其他机制实现，这些机制平均提供低于集合中键/值对数量的访问时间。本规范中使用的数据结构仅用于描述 WeakMap 的所需可观察语义，而不是可行的实现模型。

**注意**：
WeakMap 和 WeakSet 旨在提供一种机制，用于动态地将状态与对象或符号关联，在没有 WeakMap 或 WeakSet 实例的情况下，如果对象或符号变得不可访问并且实现的垃圾收集机制对资源进行回收，不会“泄漏”内存资源。这一特性可以通过使用 WeakMap 或 WeakSet 实例到键的反向每个对象/符号映射来实现。或者，每个 WeakMap 或 WeakSet 实例可以在内部存储其键和值数据，但这种方法需要 WeakMap 或 WeakSet 实现和垃圾收集器之间的协调。以下参考文献描述了可能对 WeakMap 和 WeakSet 实现有用的机制：

Barry Hayes. 1997. Ephemerons: a new finalization mechanism. 在第 12 届 ACM SIGPLAN 面向对象编程、系统、语言和应用会议（OOPSLA '97）论文集中，A. Michael Berman（编）。ACM，纽约，NY，USA，176-183, [http://doi.acm.org/10.1145/263698.263733](http://doi.acm.org/10.1145/263698.263733)。

Alexandra Barros, Roberto Ierusalimschy, Eliminating Cycles in Weak Tables. Journal of Universal Computer Science - J.UCS, 第 14 卷第 21 期，pp. 3481-3497，2008，[http://www.jucs.org/jucs_14_21/eliminating_cycles_in_weak](http://www.jucs.org/jucs_14_21/eliminating_cycles_in_weak)。

#### 24.3.1 WeakMap 构造函数
WeakMap 构造函数：

- 是 %WeakMap%。
- 是全局对象的 "WeakMap" 属性的初始值。
- 在作为构造函数调用时创建并初始化一个新的 WeakMap。
- 不应作为函数调用，并且在以这种方式调用时会抛出异常。
- 可以在类定义的 extends 子句中使用。打算继承指定 WeakMap 行为的子类构造函数必须包含对 WeakMap 构造函数的 super 调用，以创建和初始化子类实例，并具有支持 WeakMap.prototype 内置方法的内部状态。

##### 24.3.1.1 WeakMap ( [ iterable ] )
调用此函数时，执行以下步骤：

1. 如果 NewTarget 为 undefined，抛出 TypeError 异常。
2. 令 map 为 ? OrdinaryCreateFromConstructor(NewTarget, "%WeakMap.prototype%", « [[WeakMapData]] »)。
3. 将 map.[[WeakMapData]] 设为一个新的空列表。
4. 如果 iterable 为 undefined 或 null，返回 map。
5. 令 adder 为 ? Get(map, "set")。
6. 如果 IsCallable(adder) 为 false，抛出 TypeError 异常。
7. 返回 ? AddEntriesFromIterable(map, iterable, adder)。

**注意**：如果提供了参数 iterable，期望它是一个实现 @@iterator 方法的对象，该方法返回一个迭代器对象，该对象生成一个两个元素的类数组对象，其中第一个元素是用作 WeakMap 键的值，第二个元素是与该键关联的值。

#### 24.3.2 WeakMap 构造函数的属性
WeakMap 构造函数：

- 具有一个 [[Prototype]] 内部槽，其值为 %Function.prototype%。
- 具有以下属性：

##### 24.3.2.1 WeakMap.prototype
WeakMap.prototype 的初始值是 WeakMap 原型对象。

此属性的属性为 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }。

#### 24.3.3 WeakMap 原型对象的属性
WeakMap 原型对象：

- 是 %WeakMap.prototype%。
- 具有一个 [[Prototype]] 内部槽，其值为 %Object.prototype%。
- 是一个普通对象。
- 没有 [[WeakMapData]] 内部槽。

##### 24.3.3.1 WeakMap.prototype.constructor
WeakMap.prototype.constructor 的初始值是 %WeakMap%。

##### 24.3.3.2 WeakMap.prototype.delete (key)
调用此方法时，执行以下步骤：

1. 令 M 为 this 值。
2. 执行 ? RequireInternalSlot(M, [[WeakMapData]])。
3. 如果 CanBeHeldWeakly(key) 为 false，返回 false。
4. 对于 M.[[WeakMapData]] 中的每个记录 { [[Key]], [[Value]] } p，执行
   a. 如果 p.[[Key]] 不是 EMPTY 并且 SameValue(p.[[Key]], key) 为 true，则
      i. 将 p.[[Key]] 设为 EMPTY。
      ii. 将 p.[[Value]] 设为 EMPTY。
      iii. 返回 true。
5. 返回 false。

**注意**：值 EMPTY 用作规范设备，表示条目已被删除。实际实现可能会采取其他操作，例如从内部数据结构中实际移除条目。

##### 24.3.3.3 WeakMap.prototype.get (key)
#### 24.3.3.3 WeakMap.prototype.get (key)
调用此方法时，执行以下步骤：

1. 令 M 为 this 值。
2. 执行 ? RequireInternalSlot(M, [[WeakMapData]])。
3. 如果 CanBeHeldWeakly(key) 为 false，返回 undefined。
4. 对于 M.[[WeakMapData]] 中的每个记录 { [[Key]], [[Value]] } p，执行
   a. 如果 p.[[Key]] 不是 EMPTY 并且 SameValue(p.[[Key]], key) 为 true，返回 p.[[Value]]。
5. 返回 undefined。

#### 24.3.3.4 WeakMap.prototype.has (key)
调用此方法时，执行以下步骤：

1. 令 M 为 this 值。
2. 执行 ? RequireInternalSlot(M, [[WeakMapData]])。
3. 如果 CanBeHeldWeakly(key) 为 false，返回 false。
4. 对于 M.[[WeakMapData]] 中的每个记录 { [[Key]], [[Value]] } p，执行
   a. 如果 p.[[Key]] 不是 EMPTY 并且 SameValue(p.[[Key]], key) 为 true，返回 true。
5. 返回 false。

#### 24.3.3.5 WeakMap.prototype.set (key, value)
调用此方法时，执行以下步骤：

1. 令 M 为 this 值。
2. 执行 ? RequireInternalSlot(M, [[WeakMapData]])。
3. 如果 CanBeHeldWeakly(key) 为 false，抛出 TypeError 异常。
4. 对于 M.[[WeakMapData]] 中的每个记录 { [[Key]], [[Value]] } p，执行
   a. 如果 p.[[Key]] 不是 EMPTY 并且 SameValue(p.[[Key]], key) 为 true，则
      i. 将 p.[[Value]] 设为 value。
      ii. 返回 M。
5. 令 p 为记录 { [[Key]]: key, [[Value]]: value }。
6. 将 p 附加到 M.[[WeakMapData]]。
7. 返回 M。

#### 24.3.3.6 WeakMap.prototype [@@toStringTag]
@@toStringTag 属性的初始值是字符串值 "WeakMap"。

此属性的属性为 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }。

### 24.3.4 WeakMap 实例的属性
WeakMap 实例是从 WeakMap 原型继承属性的普通对象。WeakMap 实例也具有一个 [[WeakMapData]] 内部槽。

### 24.4 WeakSet 对象
WeakSet 是包含对象和/或符号的集合。一个独特的对象或符号在 WeakSet 的集合中只能出现一次。可以查询 WeakSet 看它是否包含特定值，但不提供枚举其持有的值的机制。在某些条件下，不再存活的值会作为 WeakSet 元素被移除，如 9.9.3 中所述。

实现可以在 WeakSet 包含的值变得不可访问和从 WeakSet 中移除之间施加任意确定的延迟。如果这种延迟对 ECMAScript 程序可观察，则会成为影响程序执行的不确定性来源。因此，ECMAScript 实现不得提供任何确定 WeakSet 是否包含特定值的手段，除非观察者呈现被观察的值。

WeakSet 必须使用哈希表或其他机制实现，这些机制平均提供低于集合中元素数量的访问时间。本规范中使用的数据结构仅用于描述 WeakSet 的所需可观察语义，而不是可行的实现模型。

**注意**：
参见 24.3 中的注意事项。

### 24.4.1 WeakSet 构造函数
WeakSet 构造函数：

- 是 %WeakSet%。
- 是全局对象的 "WeakSet" 属性的初始值。
- 在作为构造函数调用时创建并初始化一个新的 WeakSet。
- 不应作为函数调用，并且在以这种方式调用时会抛出异常。
- 可以在类定义的 extends 子句中使用。打算继承指定 WeakSet 行为的子类构造函数必须包含对 WeakSet 构造函数的 super 调用，以创建和初始化子类实例，并具有支持 WeakSet.prototype 内置方法的内部状态。

#### 24.4.1.1 WeakSet ( [ iterable ] )
调用此函数时，执行以下步骤：

1. 如果 NewTarget 为 undefined，抛出 TypeError 异常。
2. 令 set 为 ? OrdinaryCreateFromConstructor(NewTarget, "%WeakSet.prototype%", « [[WeakSetData]] »)。
3. 将 set.[[WeakSetData]] 设为一个新的空列表。
4. 如果 iterable 为 undefined 或 null，返回 set。
5. 令 adder 为 ? Get(set, "add")。
6. 如果 IsCallable(adder) 为 false，抛出 TypeError 异常。
7. 令 iteratorRecord 为 ? GetIterator(iterable, SYNC)。
8. 重复，
   a. 令 next 为 ? IteratorStepValue(iteratorRecord)。
   b. 如果 next 为 DONE，返回 set。
   c. 令 status 为 Completion(Call(adder, set, « next »))。
   d. 如果 status 为 Abrupt，执行 IteratorClose(iteratorRecord, status)。

### 24.4.2 WeakSet 构造函数的属性
WeakSet 构造函数：

- 具有一个 [[Prototype]] 内部槽，其值为 %Function.prototype%。
- 具有以下属性：

#### 24.4.2.1 WeakSet.prototype
WeakSet.prototype 的初始值是 WeakSet 原型对象。

此属性的属性为 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }。

### 24.4.3 WeakSet 原型对象的属性
WeakSet 原型对象：

- 是 %WeakSet.prototype%。
- 具有一个 [[Prototype]] 内部槽，其值为 %Object.prototype%。
- 是一个普通对象。
- 没有 [[WeakSetData]] 内部槽。

#### 24.4.3.1 WeakSet.prototype.add (value)
调用此方法时，执行以下步骤：

1. 令 S 为 this 值。
2. 执行 ? RequireInternalSlot(S, [[WeakSetData]])。
3. 如果 CanBeHeldWeakly(value) 为 false，抛出 TypeError 异常。
4. 对于 S.[[WeakSetData]] 中的每个元素 e，执行
   a. 如果 e 不是 EMPTY 并且 SameValue(e, value) 为 true，则
      i. 返回 S。
5. 将 value 附加到 S.[[WeakSetData]]。
6. 返回 S。

#### 24.4.3.2 WeakSet.prototype.constructor
WeakSet.prototype.constructor 的初始值是 %WeakSet%。

#### 24.4.3.3 WeakSet.prototype.delete (value)
调用此方法时，执行以下步骤：

1. 令 S 为 this 值。
2. 执行 ? RequireInternalSlot(S, [[WeakSetData]])。
3. 如果 CanBeHeldWeakly(value) 为 false，返回 false。
4. 对于 S.[[WeakSetData]] 中的每个元素 e，执行
   a. 如果 e 不是 EMPTY 并且 SameValue(e, value) 为 true，则
      i. 将 S.[[WeakSetData]] 中值为 e 的元素替换为值为 EMPTY 的元素。
      ii. 返回 true。
5. 返回 false。

**注意**：值 EMPTY 用作规范设备，表示条目已被删除。实际实现可能会采取其他操作，例如从内部数据结构中实际移除条目。

#### 24.4.3.4 WeakSet.prototype.has (value)
调用此方法时，执行以下步骤：

1. 令 S 为 this 值。
2. 执行 ? RequireInternalSlot(S, [[WeakSetData]])。
3. 如果 CanBeHeldWeakly(value) 为 false，返回 false。
4. 对于 S.[[WeakSetData]] 中的每个元素 e，执行
   a. 如果 e 不是 EMPTY 并且 SameValue(e, value) 为 true，返回 true。
5. 返回 false。

#### 24.4.3.5 WeakSet.prototype [@@toStringTag]
@@toStringTag 属性的初始值是字符串值 "WeakSet"。

此属性的属性为 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }。

### 24.4.4 WeakSet 实例的属性
WeakSet 实例是从 WeakSet 原型继承属性的普通对象。WeakSet 实例也具有一个 [[WeakSetData]] 内部槽。

### 24.5 键控集合的抽象操作
#### 24.5.1 CanonicalizeKeyedCollectionKey (key)
抽象操作 CanonicalizeKeyedCollectionKey 接受参数 key（一个 ECMAScript 语言值），返回一个 ECMAScript 语言值。调用时执行以下步骤：

1. 如果 key 是 -0𝔽，返回 +0𝔽。
2. 返回 key。

### 25. 结构化数据
#### 25.1 ArrayBuffer 对象
#### 25.1.1 符号
本节、25.4 和 29 中的描述使用读-修改-写修改函数内部数据结构。

读-修改-写修改函数是一个数学函数，符号上表示为一个抽象闭包，接受两个字节值列表作为参数并返回一个字节值列表。这些抽象闭包满足以下所有属性：

- 它们的所有算法步骤都是原子执行的。
- 它们的单个算法步骤是不可观察的。

**注意**：为了帮助验证读-修改-写修改函数的算法步骤构成纯数学函数，建议使用以下编辑约定：

- 它们不访问（直接或通过调用的抽象操作和抽象闭包）任何语言或规范值，除非是它们的参数和捕获的值。
- 它们不返回完成记录。

#### 25.1.2 定长和可调整长度的 ArrayBuffer 对象
定长 ArrayBuffer 是在创建后其字节长度不能改变的 ArrayBuffer。

可调整长度的 ArrayBuffer 是在创建后其字节长度可以通过调用 ArrayBuffer.prototype.resize(newLength) 改变的 ArrayBuffer。

创建的 ArrayBuffer 对象的种类取决于传递给 ArrayBuffer (length [, options]) 的参数。

#### 25.1.3 ArrayBuffer 对象的抽象操作
##### 25.1.3.1 AllocateArrayBuffer (constructor, byteLength [, maxByteLength])
抽象操作 AllocateArrayBuffer 接受参数 constructor（一个构造函数）和 byteLength（一个非负整数）以及可选参数 maxByteLength（一个非负整数或 EMPTY），返回一个包含 ArrayBuffer 的正常完成或一个抛出的完成。它用于创建一个 ArrayBuffer。调用时执行以下步骤：

1. 令 slots 为 « [[ArrayBufferData]], [[ArrayBufferByteLength]], [[ArrayBufferDetachKey]] »。
2. 如果 maxByteLength 存在且不是 EMPTY，令 allocatingResizableBuffer 为 true；否则令 allocatingResizableBuffer 为 false。
3. 如果 allocatingResizableBuffer 为 true，则
   a. 如果 byteLength > maxByteLength，抛出 RangeError 异常。
   b. 将 [[ArrayBufferMaxByteLength]] 附加到 slots。
4. 令 obj 为 ? OrdinaryCreateFromConstructor(constructor, "%ArrayBuffer.prototype%", slots)。
5. 令 block 为 ? CreateByteDataBlock(byteLength)。
6. 将 obj.[[ArrayBufferData]] 设为 block。
7. 将 obj.[[ArrayBufferByteLength]] 设为 byteLength。
8. 如果 allocatingResizableBuffer 为 true，则
   a. 如果无法创建由 maxByteLength 字节组成的数据块 block，抛出 RangeError 异常。
   b. **注意**：可调整大小的 ArrayBuffer 设计为可通过原地增长实现。实现可能会抛出异常，例如，如果无法预先保留虚拟内存。
   c. 将 obj.[[ArrayBufferMaxByteLength]] 设为 maxByteLength。
9. 返回 obj。

##### 25.1.3.2 ArrayBufferByteLength (arrayBuffer, order)
抽象操作 ArrayBufferByteLength 接受参数 arrayBuffer（一个 ArrayBuffer 或 SharedArrayBuffer）和 order（SEQ-CST 或 UNORDERED），返回一个非负整数。调用时执行以下步骤：

1. 如果 IsSharedArrayBuffer(arrayBuffer) 为 true 且 arrayBuffer 具有 [[ArrayBufferByteLengthData]] 内部槽，则
   a. 令 bufferByteLengthBlock 为 arrayBuffer.[[ArrayBufferByteLengthData]]。
   b. 令 rawLength 为 GetRawBytesFromSharedBlock(bufferByteLengthBlock, 0, BIGUINT64, true, order)。
   c. 令 isLittleEndian 为当前代理的代理记录中 [[LittleEndian]] 字段的值。
   d. 返回 ℝ(RawBytesToNumeric(BIGUINT64, rawLength, isLittleEndian))。
2. 断言：IsDetachedBuffer(arrayBuffer) 为 false。
3. 返回 arrayBuffer.[[ArrayBufferByteLength]]。

##### 25.1.3.3 ArrayBufferCopyAndDetach (arrayBuffer, newLength, preserveResizability)
抽象操作 ArrayBufferCopyAndDetach 接受参数 arrayBuffer（一个 ECMAScript 语言值）、newLength（一个 ECMAScript 语言值）和 preserveResizability（PRESERVE-RESIZABILITY 或 FIXED-LENGTH），返回一个包含 ArrayBuffer 的正常完成或一个抛出的完成。调用时执行以下步骤：

1. 执行 ? RequireInternalSlot(arrayBuffer, [[ArrayBufferData]])。
2. 如果 IsSharedArrayBuffer(arrayBuffer) 为 true，抛出 TypeError 异常。
3. 如果 newLength 未定义，则
   a. 令 newByteLength 为 arrayBuffer.[[ArrayBufferByteLength]]。
4. 否则，
   a. 令 newByteLength 为 ? ToIndex(newLength)。
5. 如果 IsDetachedBuffer(arrayBuffer) 为 true，抛出 TypeError 异常。
6. 如果 preserveResizability 为 PRESERVE-RESIZABILITY 且 IsFixedLengthArrayBuffer(arrayBuffer) 为 false，则
   a. 令 newMaxByteLength 为 arrayBuffer.[[ArrayBufferMaxByteLength]]。
7. 否则，
   a. 令 newMaxByteLength 为 EMPTY。
8. 如果 arrayBuffer.[[ArrayBufferDetachKey]] 未定义，抛出 TypeError 异常。
9. 令 newBuffer 为 ? AllocateArrayBuffer(%ArrayBuffer%, newByteLength, newMaxByteLength)。
10. 令 copyLength 为 min(newByteLength, arrayBuffer.[[ArrayBufferByteLength]])。
11. 令 fromBlock 为 arrayBuffer.[[ArrayBufferData]]。
12. 令 toBlock 为 newBuffer.[[ArrayBufferData]]。
13. 执行 CopyDataBlockBytes(toBlock, 0, fromBlock, 0, copyLength)。
14. **注意**：创建新数据块和从旧数据块复制的操作都是不可观察的。实现可以将此方法实现为零复制移动或重新分配。
15. 执行 ! DetachArrayBuffer(arrayBuffer)。
16. 返回 newBuffer。

##### 25.1.3.4 IsDetachedBuffer (arrayBuffer)
抽象操作 IsDetachedBuffer 接受参数 arrayBuffer（一个 ArrayBuffer 或 SharedArrayBuffer），返回一个布尔值。调用时执行以下步骤：

1. 如果 arrayBuffer.[[ArrayBufferData]] 为 null，返回 true。
2. 返回 false。

##### 25.1.3.5 DetachArrayBuffer (arrayBuffer [, key])
抽象操作 DetachArrayBuffer 接受参数 arrayBuffer（一个 ArrayBuffer）和可选参数 key（任意值），返回一个包含 UNUSED 的正常完成或一个抛出的完成。调用时执行以下步骤：

1. 断言：IsSharedArrayBuffer(arrayBuffer) 为 false。
2. 如果 key 不存在，设 key 为 undefined。
3. 如果 arrayBuffer.[[ArrayBufferDetachKey]] 不是 key，抛出 TypeError 异常。
4. 将 arrayBuffer.[[ArrayBufferData]] 设为 null。
5. 将 arrayBuffer.[[ArrayBufferByteLength]] 设为 0。
6. 返回 UNUSED。

**注意**：分离 ArrayBuffer 实例会将作为其后备存储的数据块与实例解除关联，并将缓冲区的字节长度设为 0。

##### 25.1.3.6 CloneArrayBuffer (srcBuffer, srcByteOffset, srcLength)
抽象操作 CloneArrayBuffer 接受参数 srcBuffer（一个 ArrayBuffer 或 SharedArrayBuffer）、srcByteOffset（一个非负整数）和 srcLength（一个非负整数），返回一个包含 ArrayBuffer 的正常完成或一个抛出的完成。它创建一个新的 ArrayBuffer，其数据是 srcBuffer 的数据从 srcByteOffset 开始并持续 srcLength 字节的副本。调用时执行以下步骤：

1. 断言：IsDetachedBuffer(srcBuffer) 为 false。
2. 令 targetBuffer 为 ? AllocateArrayBuffer(%ArrayBuffer%, srcLength)。
3. 令 srcBlock 为 srcBuffer.[[ArrayBufferData]]。
4. 令 targetBlock 为 targetBuffer.[[ArrayBufferData]]。
5. 执行 CopyDataBlockBytes(targetBlock, 0, srcBlock, srcByteOffset, srcLength)。
6. 返回 targetBuffer。

##### 25.1.3.7 GetArrayBufferMaxByteLengthOption (options)
抽象操作 GetArrayBufferMaxByteLengthOption 接受参数 options（一个 ECMAScript 语言值），返回一个包含非负整数或 EMPTY 的正常完成，或一个抛出的完成。调用时执行以下步骤：

1. 如果 options 不是一个对象，返回 EMPTY。
2. 令 maxByteLength 为 ? Get(options, "maxByteLength")。
3. 如果 maxByteLength 未定义，返回 EMPTY。
4. 返回 ? ToIndex(maxByteLength)。

##### 25.1.3.8 HostResizeArrayBuffer (buffer, newByteLength)
主机定义的抽象操作 HostResizeArrayBuffer 接受参数 buffer（一个 ArrayBuffer）和 newByteLength（一个非负整数），返回一个包含 HANDLED 或 UNHANDLED 的正常完成，或一个抛出的完成。它给主机一个执行特定实现的 buffer 调整大小的机会

。如果主机选择不处理 buffer 的调整大小，它可以返回 UNHANDLED 以表示默认行为。

HostResizeArrayBuffer 的实现必须符合以下要求：

- 抽象操作不分离 buffer。
- 如果抽象操作正常完成并且返回 HANDLED，则 buffer.[[ArrayBufferByteLength]] 为 newByteLength。
- HostResizeArrayBuffer 的默认实现是返回 NormalCompletion(UNHANDLED)。

##### 25.1.3.9 IsFixedLengthArrayBuffer (arrayBuffer)
抽象操作 IsFixedLengthArrayBuffer 接受参数 arrayBuffer（一个 ArrayBuffer 或 SharedArrayBuffer），返回一个布尔值。调用时执行以下步骤：

1. 如果 arrayBuffer 具有 [[ArrayBufferMaxByteLength]] 内部槽，返回 false。
2. 返回 true。

##### 25.1.3.10 IsUnsignedElementType (type)
抽象操作 IsUnsignedElementType 接受参数 type（一个 TypedArray 元素类型），返回一个布尔值。它验证参数 type 是否是一个无符号 TypedArray 元素类型。调用时执行以下步骤：

1. 如果 type 是 UINT8、UINT8CLAMPED、UINT16、UINT32 或 BIGUINT64 之一，返回 true。
2. 返回 false。

##### 25.1.3.11 IsUnclampedIntegerElementType (type)
抽象操作 IsUnclampedIntegerElementType 接受参数 type（一个 TypedArray 元素类型），返回一个布尔值。它验证参数 type 是否是一个不包括 UINT8CLAMPED 的 Integer TypedArray 元素类型。调用时执行以下步骤：

1. 如果 type 是 INT8、UINT8、INT16、UINT16、INT32 或 UINT32 之一，返回 true。
2. 返回 false。

##### 25.1.3.12 IsBigIntElementType (type)
抽象操作 IsBigIntElementType 接受参数 type（一个 TypedArray 元素类型），返回一个布尔值。它验证参数 type 是否是一个 BigInt TypedArray 元素类型。调用时执行以下步骤：

1. 如果 type 是 BIGUINT64 或 BIGINT64 之一，返回 true。
2. 返回 false。

##### 25.1.3.13 IsNoTearConfiguration (type, order)
抽象操作 IsNoTearConfiguration 接受参数 type（一个 TypedArray 元素类型）和 order（SEQ-CST、UNORDERED 或 INIT），返回一个布尔值。调用时执行以下步骤：

1. 如果 IsUnclampedIntegerElementType(type) 为 true，返回 true。
2. 如果 IsBigIntElementType(type) 为 true 且 order 既不是 INIT 也不是 UNORDERED，返回 true。
3. 返回 false。

##### 25.1.3.14 RawBytesToNumeric (type, rawBytes, isLittleEndian)
抽象操作 RawBytesToNumeric 接受参数 type（一个 TypedArray 元素类型）、rawBytes（一个字节值列表）和 isLittleEndian（一个布尔值），返回一个 Number 或 BigInt。调用时执行以下步骤：

1. 令 elementSize 为 表 70 中针对元素类型 type 指定的元素大小值。
2. 如果 isLittleEndian 为 false，反转 rawBytes 的顺序。
3. 如果 type 是 FLOAT32，则
   a. 令 value 为 rawBytes 的字节元素，连接并解释为一个小端位字符串编码的 IEEE 754-2019 binary32 值。
   b. 如果 value 是一个 IEEE 754-2019 binary32 NaN 值，返回 NaN 数值。
   c. 返回与 value 对应的数值。
4. 如果 type 是 FLOAT64，则
   a. 令 value 为 rawBytes 的字节元素，连接并解释为一个小端位字符串编码的 IEEE 754-2019 binary64 值。
   b. 如果 value 是一个 IEEE 754-2019 binary64 NaN 值，返回 NaN 数值。
   c. 返回与 value 对应的数值。
5. 如果 IsUnsignedElementType(type) 为 true，则
   a. 令 intValue 为 rawBytes 的字节元素，连接并解释为一个无符号小端二进制数的位字符串编码。
6. 否则，
   a. 令 intValue 为 rawBytes 的字节元素，连接并解释为一个二进制小端二进制补码数，位长度为 elementSize × 8。
7. 如果 IsBigIntElementType(type) 为 true，返回与 intValue 对应的 BigInt 值。
8. 否则，返回与 intValue 对应的数值。

##### 25.1.3.15 GetRawBytesFromSharedBlock (block, byteIndex, type, isTypedArray, order)
抽象操作 GetRawBytesFromSharedBlock 接受参数 block（一个共享数据块）、byteIndex（一个非负整数）、type（一个 TypedArray 元素类型）、isTypedArray（一个布尔值）和 order（SEQ-CST 或 UNORDERED），返回一个字节值列表。调用时执行以下步骤：

1. 令 elementSize 为 表 70 中针对元素类型 type 指定的元素大小值。
2. 令 execution 为当前代理的代理记录的 [[CandidateExecution]] 字段。
3. 令 eventsRecord 为 execution.[[EventsRecords]] 中 [[AgentSignifier]] 为 AgentSignifier() 的代理事件记录。
4. 如果 isTypedArray 为 true 且 IsNoTearConfiguration(type, order) 为 true，令 noTear 为 true；否则令 noTear 为 false。
5. 令 rawValue 为一个长度为 elementSize 的列表，其元素是非确定性选择的字节值。
6. **注意**：在实现中，rawValue 是底层硬件上的非原子或原子读指令的结果。非确定性是内存模型的语义规定，用于描述弱一致性硬件的可观察行为。
7. 令 readEvent 为 ReadSharedMemory { [[Order]]: order, [[NoTear]]: noTear, [[Block]]: block, [[ByteIndex]]: byteIndex, [[ElementSize]]: elementSize }。
8. 将 readEvent 附加到 eventsRecord.[[EventList]]。
9. 将 Chosen Value Record { [[Event]]: readEvent, [[ChosenValue]]: rawValue } 附加到 execution.[[ChosenValues]]。
10. 返回 rawValue。

##### 25.1.3.16 GetValueFromBuffer (arrayBuffer, byteIndex, type, isTypedArray, order [, isLittleEndian])
抽象操作 GetValueFromBuffer 接受参数 arrayBuffer（一个 ArrayBuffer 或 SharedArrayBuffer）、byteIndex（一个非负整数）、type（一个 TypedArray 元素类型）、isTypedArray（一个布尔值）和 order（SEQ-CST 或 UNORDERED）以及可选参数 isLittleEndian（一个布尔值），返回一个数值或 BigInt。调用时执行以下步骤：

1. 断言：IsDetachedBuffer(arrayBuffer) 为 false。
2. 断言：arrayBuffer 中从 byteIndex 开始有足够的字节表示一个 type 值。
3. 令 block 为 arrayBuffer.[[ArrayBufferData]]。
4. 令 elementSize 为 表 70 中针对元素类型 type 指定的元素大小值。
5. 如果 IsSharedArrayBuffer(arrayBuffer) 为 true，则
   a. 断言：block 是一个共享数据块。
   b. 令 rawValue 为 GetRawBytesFromSharedBlock(block, byteIndex, type, isTypedArray, order)。
6. 否则，
   a. 令 rawValue 为一个列表，其元素是 block 中从 byteIndex（含）到 byteIndex + elementSize（不含）范围内的字节。
7. 断言：rawValue 中的元素数量为 elementSize。
8. 如果 isLittleEndian 不存在，设 isLittleEndian 为当前代理的代理记录的 [[LittleEndian]] 字段的值。
9. 返回 RawBytesToNumeric(type, rawValue, isLittleEndian)。

##### 25.1.3.17 NumericToRawBytes (type, value, isLittleEndian)
抽象操作 NumericToRawBytes 接受参数 type（一个 TypedArray 元素类型）、value（一个数值或 BigInt）和 isLittleEndian（一个布尔值），返回一个字节值列表。调用时执行以下步骤：

1. 如果 type 是 FLOAT32，则
   a. 令 rawBytes 为一个列表，其元素是将 value 转换为 IEEE 754-2019 binary32 格式，使用 roundTiesToEven 模式的结果的 4 个字节。字节按小端顺序排列。如果 value 是 NaN，rawBytes 可以设置为任何实现选择的 IEEE 754-2019 binary32 格式的 NaN 编码。对于每个实现可区分的 NaN 值，实现必须始终选择相同的编码。
2. 否则如果 type 是 FLOAT64，则
   a. 令 rawBytes 为一个列表，其元素是 IEEE 754-2019 binary64 格式编码的 value 的 8 个字节。字节按小端顺序排列。如果 value 是 NaN，rawBytes 可以设置为任何实现选择的 IEEE 754-2019 binary64 格式的 NaN 编码。对于每个实现可区分的 NaN 值，实现必须始终选择相同的编码。
3. 否则，
   a. 令 n 为 表 70 中针对元素类型

 type 指定的元素大小值。
   b. 令 convOp 为 表 70 中针对元素类型 type 指定的转换操作列中的抽象操作名称。
   c. 令 intValue 为 ℝ(convOp(value))。
   d. 如果 intValue ≥ 0，则
      i. 令 rawBytes 为一个列表，其元素是 intValue 的 n 字节二进制编码。字节按小端顺序排列。
   e. 否则，
      i. 令 rawBytes 为一个列表，其元素是 intValue 的 n 字节二进制补码编码。字节按小端顺序排列。
4. 如果 isLittleEndian 为 false，反转 rawBytes 的顺序。
5. 返回 rawBytes。

##### 25.1.3.18 SetValueInBuffer (arrayBuffer, byteIndex, type, value, isTypedArray, order [, isLittleEndian])
抽象操作 SetValueInBuffer 接受参数 arrayBuffer（一个 ArrayBuffer 或 SharedArrayBuffer）、byteIndex（一个非负整数）、type（一个 TypedArray 元素类型）、value（一个数值或 BigInt）、isTypedArray（一个布尔值）和 order（SEQ-CST、UNORDERED 或 INIT）以及可选参数 isLittleEndian（一个布尔值），返回 UNUSED。调用时执行以下步骤：

1. 断言：IsDetachedBuffer(arrayBuffer) 为 false。
2. 断言：arrayBuffer 中从 byteIndex 开始有足够的字节表示一个 type 值。
3. 断言：如果 IsBigIntElementType(type) 为 true，value 是一个 BigInt；否则，value 是一个数值。
4. 令 block 为 arrayBuffer.[[ArrayBufferData]]。
5. 令 elementSize 为 表 70 中针对元素类型 type 指定的元素大小值。
6. 如果 isLittleEndian 不存在，设 isLittleEndian 为当前代理的代理记录的 [[LittleEndian]] 字段的值。
7. 令 rawBytes 为 NumericToRawBytes(type, value, isLittleEndian)。
8. 如果 IsSharedArrayBuffer(arrayBuffer) 为 true，则
   a. 令 execution 为当前代理的代理记录的 [[CandidateExecution]] 字段。
   b. 令 eventsRecord 为 execution.[[EventsRecords]] 中 [[AgentSignifier]] 为 AgentSignifier() 的代理事件记录。
   c. 如果 isTypedArray 为 true 且 IsNoTearConfiguration(type, order) 为 true，令 noTear 为 true；否则令 noTear 为 false。
   d. 将 WriteSharedMemory { [[Order]]: order, [[NoTear]]: noTear, [[Block]]: block, [[ByteIndex]]: byteIndex, [[ElementSize]]: elementSize, [[Payload]]: rawBytes } 附加到 eventsRecord.[[EventList]]。
9. 否则，
   a. 将 rawBytes 的各个字节存储到 block 中，从 block[byteIndex] 开始。
10. 返回 UNUSED。

##### 25.1.3.19 GetModifySetValueInBuffer (arrayBuffer, byteIndex, type, value, op)
抽象操作 GetModifySetValueInBuffer 接受参数 arrayBuffer（一个 ArrayBuffer 或 SharedArrayBuffer）、byteIndex（一个非负整数）、type（一个 TypedArray 元素类型）、value（一个数值或 BigInt）和 op（一个读-修改-写修改函数），返回一个数值或 BigInt。调用时执行以下步骤：

1. 断言：IsDetachedBuffer(arrayBuffer) 为 false。
2. 断言：arrayBuffer 中从 byteIndex 开始有足够的字节表示一个 type 值。
3. 断言：如果 IsBigIntElementType(type) 为 true，value 是一个 BigInt；否则，value 是一个数值。
4. 令 block 为 arrayBuffer.[[ArrayBufferData]]。
5. 令 elementSize 为 表 70 中针对元素类型 type 指定的元素大小值。
6. 令 isLittleEndian 为当前代理的代理记录的 [[LittleEndian]] 字段的值。
7. 令 rawBytes 为 NumericToRawBytes(type, value, isLittleEndian)。
8. 如果 IsSharedArrayBuffer(arrayBuffer) 为 true，则
   a. 令 execution 为当前代理的代理记录的 [[CandidateExecution]] 字段。
   b. 令 eventsRecord 为 execution.[[EventsRecords]] 中 [[AgentSignifier]] 为 AgentSignifier() 的代理事件记录。
   c. 令 rawBytesRead 为一个长度为 elementSize 的列表，其元素是非确定性选择的字节值。
   d. **注意**：在实现中，rawBytesRead 是底层硬件上的加载链接、加载独占或读-修改-写指令的操作数的结果。非确定性是内存模型的语义规定，用于描述弱一致性硬件的可观察行为。
   e. 令 rmwEvent 为 ReadModifyWriteSharedMemory { [[Order]]: SEQ-CST, [[NoTear]]: true, [[Block]]: block, [[ByteIndex]]: byteIndex, [[ElementSize]]: elementSize, [[Payload]]: rawBytes, [[ModifyOp]]: op }。
   f. 将 rmwEvent 附加到 eventsRecord.[[EventList]]。
   g. 将 Chosen Value Record { [[Event]]: rmwEvent, [[ChosenValue]]: rawBytesRead } 附加到 execution.[[ChosenValues]]。
9. 否则，
   a. 令 rawBytesRead 为一个长度为 elementSize 的列表，其元素是从 block[byteIndex] 开始的 elementSize 个字节的序列。
   b. 令 rawBytesModified 为 op(rawBytesRead, rawBytes)。
   c. 将 rawBytesModified 的各个字节存储到 block 中，从 block[byteIndex] 开始。
10. 返回 RawBytesToNumeric(type, rawBytesRead, isLittleEndian)。

### 25.1.4 ArrayBuffer 构造函数

ArrayBuffer 构造函数：

- 是 %ArrayBuffer%。
- 是全局对象的 "ArrayBuffer" 属性的初始值。
- 当作为构造函数调用时，创建并初始化一个新的 ArrayBuffer。
- 不打算作为函数调用，若以这种方式调用会抛出异常。
- 可作为类定义的 extends 子句的值。意图继承指定的 ArrayBuffer 行为的子类构造函数必须包含对 ArrayBuffer 构造函数的 super 调用，以创建并初始化具有支持 ArrayBuffer.prototype 内置方法所需的内部状态的子类实例。

#### 25.1.4.1 ArrayBuffer(length [, options])
调用时执行以下步骤：

1. 如果 NewTarget 未定义，抛出一个 TypeError 异常。
2. 令 byteLength 为 ? ToIndex(length)。
3. 令 requestedMaxByteLength 为 ? GetArrayBufferMaxByteLengthOption(options)。
4. 返回 ? AllocateArrayBuffer(NewTarget, byteLength, requestedMaxByteLength)。

### 25.1.5 ArrayBuffer 构造函数的属性

ArrayBuffer 构造函数：

- 具有 [[Prototype]] 内部槽，其值为 %Function.prototype%。
- 具有以下属性：

#### 25.1.5.1 ArrayBuffer.isView(arg)
调用时执行以下步骤：

1. 如果 arg 不是一个对象，返回 false。
2. 如果 arg 具有 [[ViewedArrayBuffer]] 内部槽，返回 true。
3. 返回 false。

#### 25.1.5.2 ArrayBuffer.prototype
ArrayBuffer.prototype 的初始值是 ArrayBuffer 原型对象。

此属性具有 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } 特性。

#### 25.1.5.3 get ArrayBuffer [ @@species ]
ArrayBuffer[@@species] 是一个访问器属性，其 set 访问器函数未定义。其 get 访问器函数在调用时执行以下步骤：

1. 返回 this 值。

此函数的 "name" 属性的值为 "get [Symbol.species]"。

**注意**
ArrayBuffer.prototype.slice(start, end) 通常使用其 this 值的构造函数来创建派生对象。然而，子类构造函数可以通过重新定义其 @@species 属性来覆盖 ArrayBuffer.prototype.slice(start, end) 方法的默认行为。

### 25.1.6 ArrayBuffer 原型对象的属性

ArrayBuffer 原型对象：

- 是 %ArrayBuffer.prototype%。
- 具有 [[Prototype]] 内部槽，其值为 %Object.prototype%。
- 是一个普通对象。
- 不具有 [[ArrayBufferData]] 或 [[ArrayBufferByteLength]] 内部槽。

#### 25.1.6.1 get ArrayBuffer.prototype.byteLength
ArrayBuffer.prototype.byteLength 是一个访问器属性，其 set 访问器函数未定义。其 get 访问器函数在调用时执行以下步骤：

1. 令 O 为 this 值。
2. 执行 ? RequireInternalSlot(O, [[ArrayBufferData]])。
3. 如果 IsSharedArrayBuffer(O) 为 true，抛出一个 TypeError 异常。
4. 如果 IsDetachedBuffer(O) 为 true，返回 +0𝔽。
5. 令 length 为 O.[[ArrayBufferByteLength]]。
6. 返回 𝔽(length)。

#### 25.1.6.2 ArrayBuffer.prototype.constructor
ArrayBuffer.prototype.constructor 的初始值是 %ArrayBuffer%。

#### 25.1.6.3 get ArrayBuffer.prototype.detached
ArrayBuffer.prototype.detached 是一个访问器属性，其 set 访问器函数未定义。其 get 访问器函数在调用时执行以下步骤：

1. 令 O 为 this 值。
2. 执行 ? RequireInternalSlot(O, [[ArrayBufferData]])。
3. 如果 IsSharedArrayBuffer(O) 为 true，抛出一个 TypeError 异常。
4. 返回 IsDetachedBuffer(O)。

#### 25.1.6.4 get ArrayBuffer.prototype.maxByteLength
ArrayBuffer.prototype.maxByteLength 是一个访问器属性，其 set 访问器函数未定义。其 get 访问器函数在调用时执行以下步骤：

1. 令 O 为 this 值。
2. 执行 ? RequireInternalSlot(O, [[ArrayBufferData]])。
3. 如果 IsSharedArrayBuffer(O) 为 true，抛出一个 TypeError 异常。
4. 如果 IsDetachedBuffer(O) 为 true，返回 +0𝔽。
5. 如果 IsFixedLengthArrayBuffer(O) 为 true，则
   a. 令 length 为 O.[[ArrayBufferByteLength]]。
6. 否则，
   a. 令 length 为 O.[[ArrayBufferMaxByteLength]]。
7. 返回 𝔽(length)。

#### 25.1.6.5 get ArrayBuffer.prototype.resizable
ArrayBuffer.prototype.resizable 是一个访问器属性，其 set 访问器函数未定义。其 get 访问器函数在调用时执行以下步骤：

1. 令 O 为 this 值。
2. 执行 ? RequireInternalSlot(O, [[ArrayBufferData]])。
3. 如果 IsSharedArrayBuffer(O) 为 true，抛出一个 TypeError 异常。
4. 如果 IsFixedLengthArrayBuffer(O) 为 false，返回 true；否则返回 false。

#### 25.1.6.6 ArrayBuffer.prototype.resize(newLength)
调用时执行以下步骤：

1. 令 O 为 this 值。
2. 执行 ? RequireInternalSlot(O, [[ArrayBufferMaxByteLength]])。
3. 如果 IsSharedArrayBuffer(O) 为 true，抛出一个 TypeError 异常。
4. 令 newByteLength 为 ? ToIndex(newLength)。
5. 如果 IsDetachedBuffer(O) 为 true，抛出一个 TypeError 异常。
6. 如果 newByteLength > O.[[ArrayBufferMaxByteLength]]，抛出一个 RangeError 异常。
7. 令 hostHandled 为 ? HostResizeArrayBuffer(O, newByteLength)。
8. 如果 hostHandled 为 HANDLED，返回 undefined。
9. 令 oldBlock 为 O.[[ArrayBufferData]]。
10. 令 newBlock 为 ? CreateByteDataBlock(newByteLength)。
11. 令 copyLength 为 min(newByteLength, O.[[ArrayBufferByteLength]])。
12. 执行 CopyDataBlockBytes(newBlock, 0, oldBlock, 0, copyLength)。
13. **注意**：新数据块的创建和从旧数据块的复制都是不可观察的。实现可以将此方法实现为原地增长或缩小。
14. 将 O.[[ArrayBufferData]] 设置为 newBlock。
15. 将 O.[[ArrayBufferByteLength]] 设置为 newByteLength。
16. 返回 undefined。

#### 25.1.6.7 ArrayBuffer.prototype.slice(start, end)
调用时执行以下步骤：

1. 令 O 为 this 值。
2. 执行 ? RequireInternalSlot(O, [[ArrayBufferData]])。
3. 如果 IsSharedArrayBuffer(O) 为 true，抛出一个 TypeError 异常。
4. 如果 IsDetachedBuffer(O) 为 true，抛出一个 TypeError 异常。
5. 令 len 为 O.[[ArrayBufferByteLength]]。
6. 令 relativeStart 为 ? ToIntegerOrInfinity(start)。
7. 如果 relativeStart = -∞，令 first 为 0。
8. 否则如果 relativeStart < 0，令 first 为 max(len + relativeStart, 0)。
9. 否则，令 first 为 min(relativeStart, len)。
10. 如果 end 未定义，令 relativeEnd 为 len；否则令 relativeEnd 为 ? ToIntegerOrInfinity(end)。
11. 如果 relativeEnd = -∞，令 final 为 0。
12. 否则如果 relativeEnd < 0，令 final 为 max(len + relativeEnd, 0)。
13. 否则，令 final 为 min(relativeEnd, len)。
14. 令 newLen 为 max(final - first, 0)。
15. 令 ctor 为 ? SpeciesConstructor(O, %ArrayBuffer%)。
16. 令 new 为 ? Construct(ctor, « 𝔽(newLen) »)。
17. 执行 ? RequireInternalSlot(new, [[ArrayBufferData]])。
18. 如果 IsSharedArrayBuffer(new) 为 true，抛出一个 TypeError 异常。
19. 如果 IsDetachedBuffer(new) 为 true，抛出一个 TypeError 异常。
20. 如果 SameValue(new, O) 为 true，抛出一个 TypeError 异常。
21. 如果 new.[[ArrayBufferByteLength]] < newLen，抛出一个 TypeError 异常。
22. **注意**：上述步骤的副作用可能已分离或调整了 O 的大小。
23. 如果 IsDetachedBuffer(O) 为 true，抛出一个 TypeError 异常。
24. 令 fromBuf 为 O.[[ArrayBufferData]]。
25. 令 toBuf 为 new.[[ArrayBufferData]]。
26. 令 currentLen 为 O.[[ArrayBufferByteLength]]。
27. 如果 first < currentLen，则
   a. 令 count 为 min(newLen, currentLen - first)。
   b. 执行 CopyDataBlockBytes(toBuf, 0, fromBuf, first, count)。
28. 返回 new。

#### 25.1

.6.8 ArrayBuffer.prototype.transfer([newLength])
调用时执行以下步骤：

1. 令 O 为 this 值。
2. 返回 ? ArrayBufferCopyAndDetach(O, newLength, PRESERVE-RESIZABILITY)。

#### 25.1.6.9 ArrayBuffer.prototype.transferToFixedLength([newLength])
调用时执行以下步骤：

1. 令 O 为 this 值。
2. 返回 ? ArrayBufferCopyAndDetach(O, newLength, FIXED-LENGTH)。

#### 25.1.6.10 ArrayBuffer.prototype [ @@toStringTag ]
@@toStringTag 属性的初始值为字符串 "ArrayBuffer"。

此属性具有 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true } 特性。

### 25.1.7 ArrayBuffer 实例的属性
ArrayBuffer 实例继承自 ArrayBuffer 原型对象的属性。ArrayBuffer 实例每个都有一个 [[ArrayBufferData]] 内部槽、一个 [[ArrayBufferByteLength]] 内部槽和一个 [[ArrayBufferDetachKey]] 内部槽。可调整大小的 ArrayBuffer 实例每个都有一个 [[ArrayBufferMaxByteLength]] 内部槽。

[[ArrayBufferData]] 为 null 的 ArrayBuffer 实例被认为是已分离的，对 ArrayBuffer 实例中数据进行访问或修改的所有操作都会失败。

[[ArrayBufferDetachKey]] 设置为 undefined 以外的值的 ArrayBuffer 实例需要在所有传递相同 "分离键" 作为参数的 DetachArrayBuffer 调用中，否则会导致 TypeError。这一内部槽只由某些嵌入环境设置，而不是由本规范中的算法设置。

### 25.1.8 可调整大小的 ArrayBuffer 指南

**注意 1**
以下是针对使用可调整大小的 ArrayBuffer 的 ECMAScript 程序员的指南。

我们建议程序尽可能在其部署环境中进行测试。不同硬件设备之间的可用物理内存量差异很大。同样，虚拟内存子系统在硬件设备和操作系统之间也有很大差异。一款在 64 位桌面浏览器上运行时没有内存不足错误的应用程序，在 32 位移动浏览器上可能会耗尽内存。

在为可调整大小的 ArrayBuffer 选择 "maxByteLength" 选项的值时，我们建议选择应用程序所需的最小可能大小。我们建议 "maxByteLength" 不超过 1,073,741,824（2**30 字节或 1GiB）。

请注意，成功构建具有特定最大尺寸的可调整大小的 ArrayBuffer 并不保证未来的调整大小操作会成功。

**注意 2**
以下是针对实现可调整大小的 ArrayBuffer 的 ECMAScript 实现者的指南。

可调整大小的 ArrayBuffer 可以通过复制实现调整大小，也可以通过预先保留虚拟内存来实现原地增长，或者针对构造函数的 "maxByteLength" 选项的不同值结合使用这两种方法。

如果宿主是多租户的（即同时运行多个 ECMAScript 应用程序），如 Web 浏览器，并且其实现选择通过预留虚拟内存来实现原地增长，我们建议 32 位和 64 位实现都对 "maxByteLength" ≥ 1GiB 至 1.5GiB 的值抛出异常。这是为了减少单个应用程序耗尽虚拟内存地址空间的可能性，并减少互操作风险。

如果宿主没有虚拟内存，比如那些在没有 MMU 的嵌入式设备上运行的宿主，或者如果宿主仅通过复制实现调整大小，则可以接受 "maxByteLength" 选项的任意 Number 值。然而，我们建议如果请求的大小永远无法分配内存块，则抛出 RangeError 例如，如果请求的大小大于设备上可用的最大内存量。

### 25.2 共享数组缓冲区对象

#### 25.2.1 固定长度和可增长的共享数组缓冲区对象

固定长度的 SharedArrayBuffer 是一个在创建后其字节长度不能更改的 SharedArrayBuffer。

可增长的 SharedArrayBuffer 是一个在创建后其字节长度可以通过调用 SharedArrayBuffer.prototype.grow(newLength) 增加的 SharedArrayBuffer。

创建的 SharedArrayBuffer 对象的种类取决于传递给 SharedArrayBuffer(length [, options]) 的参数。

#### 25.2.2 共享数组缓冲区对象的抽象操作

##### 25.2.2.1 AllocateSharedArrayBuffer(constructor, byteLength [, maxByteLength])
抽象操作 AllocateSharedArrayBuffer 接受参数 constructor（一个构造函数）和 byteLength（一个非负整数）以及可选参数 maxByteLength（一个非负整数或 EMPTY），并返回一个包含 SharedArrayBuffer 的正常完成或一个抛出完成。它用于创建一个 SharedArrayBuffer。调用时执行以下步骤：

1. 令 slots 为 « [[ArrayBufferData]] »。
2. 如果 maxByteLength 存在且 maxByteLength 不是 EMPTY，则令 allocatingGrowableBuffer 为 true；否则令 allocatingGrowableBuffer 为 false。
3. 如果 allocatingGrowableBuffer 为 true，则
   a. 如果 byteLength > maxByteLength，抛出一个 RangeError 异常。
   b. 将 [[ArrayBufferByteLengthData]] 和 [[ArrayBufferMaxByteLength]] 附加到 slots。
4. 否则，
   a. 将 [[ArrayBufferByteLength]] 附加到 slots。
5. 令 obj 为 ? OrdinaryCreateFromConstructor(constructor, "%SharedArrayBuffer.prototype%", slots)。
6. 如果 allocatingGrowableBuffer 为 true，令 allocLength 为 maxByteLength；否则令 allocLength 为 byteLength。
7. 令 block 为 ? CreateSharedByteDataBlock(allocLength)。
8. 将 obj.[[ArrayBufferData]] 设置为 block。
9. 如果 allocatingGrowableBuffer 为 true，则
   a. 断言：byteLength ≤ maxByteLength。
   b. 令 byteLengthBlock 为 ? CreateSharedByteDataBlock(8)。
   c. 执行 SetValueInBuffer(byteLengthBlock, 0, BIGUINT64, ℤ(byteLength), true, SEQ-CST)。
   d. 将 obj.[[ArrayBufferByteLengthData]] 设置为 byteLengthBlock。
   e. 将 obj.[[ArrayBufferMaxByteLength]] 设置为 maxByteLength。
10. 否则，
    a. 将 obj.[[ArrayBufferByteLength]] 设置为 byteLength。
11. 返回 obj。

##### 25.2.2.2 IsSharedArrayBuffer(obj)
抽象操作 IsSharedArrayBuffer 接受参数 obj（一个 ArrayBuffer 或 SharedArrayBuffer），返回一个布尔值。它测试一个对象是否是 ArrayBuffer、SharedArrayBuffer 或它们的子类型。调用时执行以下步骤：

1. 令 bufferData 为 obj.[[ArrayBufferData]]。
2. 如果 bufferData 为 null，返回 false。
3. 如果 bufferData 是一个数据块，返回 false。
4. 断言：bufferData 是一个共享数据块。
5. 返回 true。

##### 25.2.2.3 HostGrowSharedArrayBuffer(buffer, newByteLength)
宿主定义的抽象操作 HostGrowSharedArrayBuffer 接受参数 buffer（一个 SharedArrayBuffer）和 newByteLength（一个非负整数），并返回包含 HANDLED 或 UNHANDLED 的正常完成或一个抛出完成。它给宿主一个机会来执行 buffer 的实现定义的增长。如果宿主选择不处理 buffer 的增长，它可以返回 UNHANDLED 以实现默认行为。

HostGrowSharedArrayBuffer 的实现必须符合以下要求：

- 如果抽象操作未以 UNHANDLED 正常完成，并且 newByteLength < buffer 的当前字节长度或 newByteLength > buffer.[[ArrayBufferMaxByteLength]]，抛出一个 RangeError 异常。
- 令 isLittleEndian 为周围代理的代理记录的 [[LittleEndian]] 字段的值。如果抽象操作以 HANDLED 正常完成，一个 WriteSharedMemory 或 ReadModifyWriteSharedMemory 事件，其 [[Order]] 为 SEQ-CST，[[Payload]] 为 NumericToRawBytes(BIGUINT64, newByteLength, isLittleEndian)，[[Block]] 为 buffer.[[ArrayBufferByteLengthData]]，[[ByteIndex]] 为 0，[[ElementSize]] 为 8 被添加到周围代理的候选执行中，以确保竞态调用 SharedArrayBuffer.prototype.grow 不会“丢失”，即默默无视。

**注意**
上面的第二个要求有意模糊了读取 buffer 当前字节长度的时间和方式。因为字节长度必须通过底层硬件上的原子读-修改-写操作来更新，所以使用 load-link/store-conditional 或 load-exclusive/store-exclusive 指令对的架构可能希望在指令流中将指令对保持得很近。因此，SharedArrayBuffer.prototype.grow 本身不会在调用 HostGrowSharedArrayBuffer 之前对 newByteLength 执行边界检查，也没有要求何时读取当前字节长度。

这与 HostResizeArrayBuffer 不同，后者保证 newByteLength 的值 ≥ 0 且 ≤ buffer.[[ArrayBufferMaxByteLength]]。

HostGrowSharedArrayBuffer 的默认实现是返回 NormalCompletion(UNHANDLED)。

### 25.2.3 SharedArrayBuffer 构造函数

SharedArrayBuffer 构造函数：

- 是 %SharedArrayBuffer%。
- 是全局对象的 "SharedArrayBuffer" 属性的初始值（如果存在此属性，见下文）。
- 当作为构造函数调用时，创建并初始化一个新的 SharedArrayBuffer。
- 不打算作为函数调用，若以这种方式调用会抛出异常。
- 可作为类定义的 extends 子句的值。意图继承指定的 SharedArrayBuffer 行为的子类构造函数必须包含对 SharedArrayBuffer 构造函数的 super 调用，以创建并初始化具有支持 SharedArrayBuffer.prototype 内置方法所需的内部状态的子类实例。

无并发访问 SharedArrayBuffer 的宿主可以省略全局对象的 "SharedArrayBuffer" 属性。

**注意**
与 ArrayBuffer 不同，SharedArrayBuffer 不能被分离，其内部 [[ArrayBufferData]] 槽永不为 null。

#### 25.2.3.1 SharedArrayBuffer(length [, options])
调用时执行以下步骤：

1. 如果 NewTarget 未定义，抛出一个 TypeError 异常。
2. 令 byteLength 为 ? ToIndex(length)。
3. 令 requestedMaxByteLength 为 ? GetArrayBufferMaxByteLengthOption(options)。
4. 返回 ? AllocateSharedArrayBuffer(NewTarget, byteLength, requestedMaxByteLength)。

### 25.2.4 SharedArrayBuffer 构造函数的属性

SharedArrayBuffer 构造函数：

- 具有 [[Prototype]] 内部槽，其值为 %Function.prototype%。
- 具有以下属性：

#### 25.2.4.1 SharedArray

Buffer.prototype
SharedArrayBuffer.prototype 的初始值是 SharedArrayBuffer 原型对象。

此属性具有 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } 特性。

#### 25.2.4.2 get SharedArrayBuffer [ @@species ]
SharedArrayBuffer[@@species] 是一个访问器属性，其 set 访问器函数为 undefined。其 get 访问器函数在调用时执行以下步骤：

1. 返回 this 值。
该函数的 "name" 属性的值是 "get [Symbol.species]"。

### 25.2.5 SharedArrayBuffer 原型对象的属性

SharedArrayBuffer 原型对象：

- 是 %SharedArrayBuffer.prototype%。
- 具有一个 [[Prototype]] 内部槽，其值为 %Object.prototype%。
- 是一个普通对象。
- 没有 [[ArrayBufferData]] 或 [[ArrayBufferByteLength]] 内部槽。

#### 25.2.5.1 get SharedArrayBuffer.prototype.byteLength
SharedArrayBuffer.prototype.byteLength 是一个访问器属性，其 set 访问器函数为 undefined。其 get 访问器函数在调用时执行以下步骤：

1. 令 O 为 this 值。
2. 执行 ? RequireInternalSlot(O, [[ArrayBufferData]])。
3. 如果 IsSharedArrayBuffer(O) 为 false，抛出一个 TypeError 异常。
4. 令 length 为 ArrayBufferByteLength(O, SEQ-CST)。
5. 返回 𝔽(length)。

#### 25.2.5.2 SharedArrayBuffer.prototype.constructor
SharedArrayBuffer.prototype.constructor 的初始值为 %SharedArrayBuffer%。

#### 25.2.5.3 SharedArrayBuffer.prototype.grow(newLength)
调用时执行以下步骤：

1. 令 O 为 this 值。
2. 执行 ? RequireInternalSlot(O, [[ArrayBufferMaxByteLength]])。
3. 如果 IsSharedArrayBuffer(O) 为 false，抛出一个 TypeError 异常。
4. 令 newByteLength 为 ? ToIndex(newLength)。
5. 令 hostHandled 为 ? HostGrowSharedArrayBuffer(O, newByteLength)。
6. 如果 hostHandled 为 HANDLED，返回 undefined。
7. 令 isLittleEndian 为周围代理的代理记录的 [[LittleEndian]] 字段的值。
8. 令 byteLengthBlock 为 O.[[ArrayBufferByteLengthData]]。
9. 令 currentByteLengthRawBytes 为 GetRawBytesFromSharedBlock(byteLengthBlock, 0, BIGUINT64, true, SEQ-CST)。
10. 令 newByteLengthRawBytes 为 NumericToRawBytes(BIGUINT64, ℤ(newByteLength), isLittleEndian)。
11. 重复，
    a. **注意**：这是一个比较并交换循环，以确保并行增长同一缓冲区的操作是完全有序的，不会丢失，也不会默默无视。循环退出如果它能够尝试未受干扰的增长。
    b. 令 currentByteLength 为 ℝ(RawBytesToNumeric(BIGUINT64, currentByteLengthRawBytes, isLittleEndian))。
    c. 如果 newByteLength = currentByteLength，返回 undefined。
    d. 如果 newByteLength < currentByteLength 或 newByteLength > O.[[ArrayBufferMaxByteLength]]，抛出一个 RangeError 异常。
    e. 令 byteLengthDelta 为 newByteLength - currentByteLength。
    f. 如果无法创建由 byteLengthDelta 字节组成的新共享数据块值，抛出一个 RangeError 异常。
    g. **注意**：此处没有构建并使用新的共享数据块。可增长的 SharedArrayBuffer 的可见行为通过在构造时分配最大大小的共享数据块来指定，此步骤捕捉了实现内存不足时必须抛出 RangeError 的要求。
    h. 令 readByteLengthRawBytes 为 AtomicCompareExchangeInSharedBlock(byteLengthBlock, 0, 8, currentByteLengthRawBytes, newByteLengthRawBytes)。
    i. 如果 ByteListEqual(readByteLengthRawBytes, currentByteLengthRawBytes) 为 true，返回 undefined。
    j. 将 currentByteLengthRawBytes 设置为 readByteLengthRawBytes。

**注意**
禁止比较交换更新长度的虚假失败。如果新长度的边界检查通过且实现没有内存不足，总是将一个 ReadModifyWriteSharedMemory 事件（即成功的比较交换）添加到候选执行中。

并行调用 SharedArrayBuffer.prototype.grow 是完全有序的。例如，考虑两个竞争调用：sab.grow(10) 和 sab.grow(20)。其中一个调用保证会赢得竞争。即使 sab.grow(20) 先发生，调用 sab.grow(10) 也永远不会缩小 sab；在这种情况下，它会抛出一个 RangeError。

#### 25.2.5.4 get SharedArrayBuffer.prototype.growable
SharedArrayBuffer.prototype.growable 是一个访问器属性，其 set 访问器函数为 undefined。其 get 访问器函数在调用时执行以下步骤：

1. 令 O 为 this 值。
2. 执行 ? RequireInternalSlot(O, [[ArrayBufferData]])。
3. 如果 IsSharedArrayBuffer(O) 为 false，抛出一个 TypeError 异常。
4. 如果 IsFixedLengthArrayBuffer(O) 为 false，返回 true；否则返回 false。

#### 25.2.5.5 get SharedArrayBuffer.prototype.maxByteLength
SharedArrayBuffer.prototype.maxByteLength 是一个访问器属性，其 set 访问器函数为 undefined。其 get 访问器函数在调用时执行以下步骤：

1. 令 O 为 this 值。
2. 执行 ? RequireInternalSlot(O, [[ArrayBufferData]])。
3. 如果 IsSharedArrayBuffer(O) 为 false，抛出一个 TypeError 异常。
4. 如果 IsFixedLengthArrayBuffer(O) 为 true，则
    a. 令 length 为 O.[[ArrayBufferByteLength]]。
5. 否则，
    a. 令 length 为 O.[[ArrayBufferMaxByteLength]]。
6. 返回 𝔽(length)。

#### 25.2.5.6 SharedArrayBuffer.prototype.slice(start, end)
调用时执行以下步骤：

1. 令 O 为 this 值。
2. 执行 ? RequireInternalSlot(O, [[ArrayBufferData]])。
3. 如果 IsSharedArrayBuffer(O) 为 false，抛出一个 TypeError 异常。
4. 令 len 为 ArrayBufferByteLength(O, SEQ-CST)。
5. 令 relativeStart 为 ? ToIntegerOrInfinity(start)。
6. 如果 relativeStart = -∞，令 first 为 0。
7. 否则如果 relativeStart < 0，令 first 为 max(len + relativeStart, 0)。
8. 否则，令 first 为 min(relativeStart, len)。
9. 如果 end 为 undefined，令 relativeEnd 为 len；否则令 relativeEnd 为 ? ToIntegerOrInfinity(end)。
10. 如果 relativeEnd = -∞，令 final 为 0。
11. 否则如果 relativeEnd < 0，令 final 为 max(len + relativeEnd, 0)。
12. 否则，令 final 为 min(relativeEnd, len)。
13. 令 newLen 为 max(final - first, 0)。
14. 令 ctor 为 ? SpeciesConstructor(O, %SharedArrayBuffer%)。
15. 令 new 为 ? Construct(ctor, « 𝔽(newLen) »)。
16. 执行 ? RequireInternalSlot(new, [[ArrayBufferData]])。
17. 如果 IsSharedArrayBuffer(new) 为 false，抛出一个 TypeError 异常。
18. 如果 new.[[ArrayBufferData]] 是 O.[[ArrayBufferData]]，抛出一个 TypeError 异常。
19. 如果 ArrayBufferByteLength(new, SEQ-CST) < newLen，抛出一个 TypeError 异常。
20. 令 fromBuf 为 O.[[ArrayBufferData]]。
21. 令 toBuf 为 new.[[ArrayBufferData]]。
22. 执行 CopyDataBlockBytes(toBuf, 0, fromBuf, first, newLen)。
23. 返回 new。

#### 25.2.5.7 SharedArrayBuffer.prototype [ @@toStringTag ]
@@toStringTag 属性的初始值为字符串 "SharedArrayBuffer"。

此属性具有 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true } 特性。

### 25.2.6 SharedArrayBuffer 实例的属性
SharedArrayBuffer 实例继承自 SharedArrayBuffer 原型对象的属性。每个 SharedArrayBuffer 实例都有一个 [[ArrayBufferData]] 内部槽。不可增长的 SharedArrayBuffer 实例各自都有一个 [[ArrayBufferByteLength]] 内部槽。可增长的 SharedArrayBuffer 实例各自都有一个 [[ArrayBufferByteLengthData]] 内部槽和一个 [[ArrayBufferMaxByteLength]] 内部槽。

**注意**
与 ArrayBuffer 实例不同，SharedArrayBuffer 实例从不分离。

### 25.2.7 可增长的 SharedArrayBuffer 指南

**注意 1**
以下是针对使用可增长的 SharedArrayBuffer 的 ECMAScript 程序员的指南。

我们建议程序尽可能在其部署环境中进行测试。不同硬件设备之间的可用物理内存量差

异很大。同样，虚拟内存子系统在硬件设备和操作系统之间也有很大差异。一款在 64 位桌面浏览器上运行时没有内存不足错误的应用程序，在 32 位移动浏览器上可能会耗尽内存。

在为可增长的 SharedArrayBuffer 选择 "maxByteLength" 选项的值时，我们建议选择应用程序所需的最小可能大小。我们建议 "maxByteLength" 不超过 1073741824，或 1GiB。

请注意，成功构建具有特定最大尺寸的可增长的 SharedArrayBuffer 并不保证未来的增长操作会成功。

不是所有对可增长的 SharedArrayBuffer 长度的加载都是同步 SEQ-CST 加载。对整数索引属性访问的边界检查，例如 u8[idx]，的长度加载不是同步的。通常，在没有显式同步的情况下，一个属性访问在范围内并不意味着同一代理中的后续属性访问也在范围内。相比之下，通过 SharedArrayBuffer、%TypedArray%.prototype 和 DataView.prototype 上的长度和 byteLength getter 显式加载的长度是同步的。内建方法执行的长度加载，用于检查 TypedArray 是否完全超出范围，也都是同步的。

**注意 2**
以下是针对实现可增长的 SharedArrayBuffer 的 ECMAScript 实现者的指南。

我们建议可增长的 SharedArrayBuffer 通过预留虚拟内存进行原地增长来实现。

由于增长操作可以与对可增长的 SharedArrayBuffer 的内存访问并行发生，内存模型的约束要求即使是无序访问也不会“撕裂”（其值的位不会混合）。实际上，这意味着可增长的 SharedArrayBuffer 的底层数据块不能通过复制来增长，除非停止所有操作。我们不建议停止所有操作作为一种实现策略，因为它引入了序列化点且速度慢。

从创建之时起，增长的内存必须表现为已清零，包括对任何并行的竞争访问。这可以通过按需零填充的虚拟内存页来实现，或者通过手动清零内存时的小心同步来实现。

在可增长的 SharedArrayBuffer 上的 TypedArray 视图上的整数索引属性访问意图与在不可增长的 SharedArrayBuffer 上的 TypedArray 视图上的访问一样进行优化，因为整数索引属性加载在底层缓冲区的长度上不是同步的（参见上述程序员指南）。例如，属性访问的边界检查仍可以被提升出循环。

### 25.3 DataView 对象

#### 25.3.1 DataView 对象的抽象操作

##### 25.3.1.1 带缓冲区见证记录的 DataView
带缓冲区见证记录的 DataView 是一个记录值，用于封装一个 DataView 以及查看的缓冲区的缓存字节长度。当查看的缓冲区是可增长的 SharedArrayBuffers 时，它用于确保有一个共享内存读取事件。

带缓冲区见证记录的 DataView 具有表 72 中列出的字段。

表 72: 带缓冲区见证记录的 DataView 字段

| 字段名 | 值 | 含义 |
|--------|----|------|
| [[Object]] | 一个 DataView | DataView 对象，其缓冲区的字节长度已加载。 |
| [[CachedBufferByteLength]] | 非负整数或 DETACHED | 记录创建时对象的 [[ViewedArrayBuffer]] 的字节长度。 |

##### 25.3.1.2 MakeDataViewWithBufferWitnessRecord ( obj, order )
抽象操作 MakeDataViewWithBufferWitnessRecord 接受参数 obj（一个 DataView）和 order（SEQ-CST 或 UNORDERED），并返回一个带缓冲区见证记录的 DataView。它在调用时执行以下步骤：

1. 令 buffer 为 obj.[[ViewedArrayBuffer]]。
2. 如果 IsDetachedBuffer(buffer) 为 true，
    a. 令 byteLength 为 DETACHED。
3. 否则，
    a. 令 byteLength 为 ArrayBufferByteLength(buffer, order)。
4. 返回带缓冲区见证记录的 DataView { [[Object]]: obj, [[CachedBufferByteLength]]: byteLength }。

##### 25.3.1.3 GetViewByteLength ( viewRecord )
抽象操作 GetViewByteLength 接受参数 viewRecord（一个带缓冲区见证记录的 DataView）并返回一个非负整数。它在调用时执行以下步骤：

1. 断言：IsViewOutOfBounds(viewRecord) 为 false。
2. 令 view 为 viewRecord.[[Object]]。
3. 如果 view.[[ByteLength]] 不是 AUTO，返回 view.[[ByteLength]]。
4. 断言：IsFixedLengthArrayBuffer(view.[[ViewedArrayBuffer]]) 为 false。
5. 令 byteOffset 为 view.[[ByteOffset]]。
6. 令 byteLength 为 viewRecord.[[CachedBufferByteLength]]。
7. 断言：byteLength 不是 DETACHED。
8. 返回 byteLength - byteOffset。

##### 25.3.1.4 IsViewOutOfBounds ( viewRecord )
抽象操作 IsViewOutOfBounds 接受参数 viewRecord（一个带缓冲区见证记录的 DataView）并返回一个布尔值。它在调用时执行以下步骤：

1. 令 view 为 viewRecord.[[Object]]。
2. 令 bufferByteLength 为 viewRecord.[[CachedBufferByteLength]]。
3. 断言：view.[[ViewedArrayBuffer]] 的 IsDetachedBuffer 为 true 当且仅当 bufferByteLength 为 DETACHED。
4. 如果 bufferByteLength 为 DETACHED，返回 true。
5. 令 byteOffsetStart 为 view.[[ByteOffset]]。
6. 如果 view.[[ByteLength]] 为 AUTO，
    a. 令 byteOffsetEnd 为 bufferByteLength。
7. 否则，
    a. 令 byteOffsetEnd 为 byteOffsetStart + view.[[ByteLength]]。
8. 如果 byteOffsetStart > bufferByteLength 或 byteOffsetEnd > bufferByteLength，返回 true。
9. **注意**：长度为 0 的 DataView 不被认为是越界的。
10. 返回 false。

##### 25.3.1.5 GetViewValue ( view, requestIndex, isLittleEndian, type )
抽象操作 GetViewValue 接受参数 view（一个 ECMAScript 语言值）、requestIndex（一个 ECMAScript 语言值）、isLittleEndian（一个 ECMAScript 语言值）和 type（一个 TypedArray 元素类型），并返回一个正常完成包含一个 Number 或 BigInt，或者抛出一个完成。它被 DataView 实例上的函数用于从视图的缓冲区中检索值。它在调用时执行以下步骤：

1. 执行 ? RequireInternalSlot(view, [[DataView]])。
2. 断言：view 具有 [[ViewedArrayBuffer]] 内部槽。
3. 令 getIndex 为 ? ToIndex(requestIndex)。
4. 将 isLittleEndian 设置为 ToBoolean(isLittleEndian)。
5. 令 viewOffset 为 view.[[ByteOffset]]。
6. 令 viewRecord 为 MakeDataViewWithBufferWitnessRecord(view, UNORDERED)。
7. **注意**：当 view 的后备缓冲区是可增长的 SharedArrayBuffer 时，边界检查不是同步操作。
8. 如果 IsViewOutOfBounds(viewRecord) 为 true，抛出一个 TypeError 异常。
9. 令 viewSize 为 GetViewByteLength(viewRecord)。
10. 令 elementSize 为表 70 中元素类型 type 的元素大小值。
11. 如果 getIndex + elementSize > viewSize，抛出一个 RangeError 异常。
12. 令 bufferIndex 为 getIndex + viewOffset。
13. 返回 GetValueFromBuffer(view.[[ViewedArrayBuffer]], bufferIndex, type, false, UNORDERED, isLittleEndian)。

##### 25.3.1.6 SetViewValue ( view, requestIndex, isLittleEndian, type, value )
抽象操作 SetViewValue 接受参数 view（一个 ECMAScript 语言值）、requestIndex（一个 ECMAScript 语言值）、isLittleEndian（一个 ECMAScript 语言值）、type（一个 TypedArray 元素类型）和 value（一个 ECMAScript 语言值），并返回一个正常完成包含 undefined 或者抛出一个完成。它被 DataView 实例上的函数用于将值存储到视图的缓冲区中。它在调用时执行以下步骤：

1. 执行 ? RequireInternalSlot(view, [[DataView]])。
2. 断言：view 具有 [[ViewedArrayBuffer]] 内部槽。
3. 令 getIndex 为 ? ToIndex(requestIndex)。
4. 如果 IsBigIntElementType(type) 为 true，令 numberValue 为 ? ToBigInt(value)。
5. 否则，令 numberValue 为 ? ToNumber(value)。
6. 将 isLittleEndian 设置为 ToBoolean(isLittleEndian)。
7. 令 viewOffset 为 view.[[ByteOffset]]。
8. 令 viewRecord 为 MakeDataViewWithBufferWitnessRecord(view, UNORDERED)。
9. **注意**：当 view 的后备缓冲区是可增长的 SharedArrayBuffer 时，边界检查不是同步操作。
10. 如果 IsViewOutOfBounds(viewRecord) 为 true，抛出一个 TypeError 异常。
11. 令 viewSize 为 GetViewByteLength(viewRecord)。
12. 令 elementSize 为表 70 中元素类型 type 的元素大小值。
13. 如果 getIndex + elementSize > viewSize，抛出一个 RangeError 异常。
14. 令 bufferIndex 为 getIndex + viewOffset。
15. 执行 SetValueInBuffer(view.[[ViewedArrayBuffer]], bufferIndex, type, numberValue, false, UNORDERED, isLittleEndian)。
16. 返回 undefined。

#### 25.3.2 DataView 构造函数
DataView 构造函数：

- 是 %DataView%。
- 是全局对象的 "DataView" 属性的初始值。
- 在作为构造函数调用时创建并初始化一个新的 DataView。
- 不打算作为函数调用，在这种情况下会抛出一个异常。
- 可以用作类定义的 extends 子句的值。意图继承指定的 DataView 行为的子类构造函数必须包含一个对 DataView 构造函数的 super 调用，以创建并初始化具有支持 DataView.prototype 内置方法所需的内部状态的子类实例。

##### 25.3.2.1 DataView ( buffer [ , byteOffset [ , byteLength ] ] )
该函数在调用时执行以下步骤：

1. 如果 NewTarget 为 undefined，抛出一个 TypeError 异常。
2. 执行 ? RequireInternalSlot(buffer, [[ArrayBufferData]])。
3. 令 offset 为 ? ToIndex(byteOffset)。
4. 如果 IsDetachedBuffer(buffer) 为 true，抛出一个 TypeError 异常。
5. 令 bufferByteLength 为 ArrayBufferByteLength(buffer, SEQ-CST)。
6. 如果 offset > bufferByteLength，抛出一个 RangeError 异常。
7. 令 bufferIsFixedLength 为 IsFixedLengthArrayBuffer(buffer)。
8. 如果 byteLength 为 undefined，则
    a. 如果 bufferIsFixedLength 为 true，则
        i. 令 viewByteLength 为 bufferByteLength - offset。
    b. 否则，
        i. 令 viewByteLength 为 AUTO。
9. 否则，
    a. 令 viewByteLength 为 ? ToIndex(byteLength)。
    b. 如果 offset + viewByteLength > bufferByteLength，抛出一个 RangeError 异常。
10. 令 O 为 ? OrdinaryCreateFromConstructor(NewTarget, "%DataView.prototype%", « [[DataView]], [[ViewedArrayBuffer

]], [[ByteLength]], [[ByteOffset]] »)。
11. 如果 IsDetachedBuffer(buffer) 为 true，抛出一个 TypeError 异常。
12. 将 bufferByteLength 设置为 ArrayBufferByteLength(buffer, SEQ-CST)。
13. 如果 offset > bufferByteLength，抛出一个 RangeError 异常。
14. 如果 byteLength 不是 undefined，则
    a. 如果 offset + viewByteLength > bufferByteLength，抛出一个 RangeError 异常。
15. 将 O.[[ViewedArrayBuffer]] 设置为 buffer。
16. 将 O.[[ByteLength]] 设置为 viewByteLength。
17. 将 O.[[ByteOffset]] 设置为 offset。
18. 返回 O。

#### 25.3.3 DataView 构造函数的属性
DataView 构造函数：

- 具有一个 [[Prototype]] 内部槽，其值为 %Function.prototype%。
- 具有以下属性：

##### 25.3.3.1 DataView.prototype
DataView.prototype 的初始值是 DataView 原型对象。

此属性具有 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } 的属性。

#### 25.3.4 DataView 原型对象的属性
DataView 原型对象：

- 是 %DataView.prototype%。
- 具有一个 [[Prototype]] 内部槽，其值为 %Object.prototype%。
- 是一个普通对象。
- 没有 [[DataView]]、[[ViewedArrayBuffer]]、[[ByteLength]] 或 [[ByteOffset]] 内部槽。

##### 25.3.4.1 get DataView.prototype.buffer
DataView.prototype.buffer 是一个访问器属性，其 set 访问器函数未定义。其 get 访问器函数在调用时执行以下步骤：

1. 令 O 为 this 值。
2. 执行 ? RequireInternalSlot(O, [[DataView]])。
3. 断言：O 具有 [[ViewedArrayBuffer]] 内部槽。
4. 令 buffer 为 O.[[ViewedArrayBuffer]]。
5. 返回 buffer。

##### 25.3.4.2 get DataView.prototype.byteLength
DataView.prototype.byteLength 是一个访问器属性，其 set 访问器函数未定义。其 get 访问器函数在调用时执行以下步骤：

1. 令 O 为 this 值。
2. 执行 ? RequireInternalSlot(O, [[DataView]])。
3. 断言：O 具有 [[ViewedArrayBuffer]] 内部槽。
4. 令 viewRecord 为 MakeDataViewWithBufferWitnessRecord(O, SEQ-CST)。
5. 如果 IsViewOutOfBounds(viewRecord) 为 true，抛出一个 TypeError 异常。
6. 令 size 为 GetViewByteLength(viewRecord)。
7. 返回 𝔽(size)。

##### 25.3.4.3 get DataView.prototype.byteOffset
DataView.prototype.byteOffset 是一个访问器属性，其 set 访问器函数未定义。其 get 访问器函数在调用时执行以下步骤：

1. 令 O 为 this 值。
2. 执行 ? RequireInternalSlot(O, [[DataView]])。
3. 断言：O 具有 [[ViewedArrayBuffer]] 内部槽。
4. 令 viewRecord 为 MakeDataViewWithBufferWitnessRecord(O, SEQ-CST)。
5. 如果 IsViewOutOfBounds(viewRecord) 为 true，抛出一个 TypeError 异常。
6. 令 offset 为 O.[[ByteOffset]]。
7. 返回 𝔽(offset)。

##### 25.3.4.4 DataView.prototype.constructor
DataView.prototype.constructor 的初始值是 %DataView%。

##### 25.3.4.5 DataView.prototype.getBigInt64 ( byteOffset [ , littleEndian ] )
此方法在调用时执行以下步骤：

1. 令 v 为 this 值。
2. 返回 ? GetViewValue(v, byteOffset, littleEndian, BIGINT64)。

##### 25.3.4.6 DataView.prototype.getBigUint64 ( byteOffset [ , littleEndian ] )
此方法在调用时执行以下步骤：

1. 令 v 为 this 值。
2. 返回 ? GetViewValue(v, byteOffset, littleEndian, BIGUINT64)。

##### 25.3.4.7 DataView.prototype.getFloat32 ( byteOffset [ , littleEndian ] )
此方法在调用时执行以下步骤：

1. 令 v 为 this 值。
2. 如果 littleEndian 未出现，将 littleEndian 设置为 false。
3. 返回 ? GetViewValue(v, byteOffset, littleEndian, FLOAT32)。

##### 25.3.4.8 DataView.prototype.getFloat64 ( byteOffset [ , littleEndian ] )
此方法在调用时执行以下步骤：

1. 令 v 为 this 值。
2. 如果 littleEndian 未出现，将 littleEndian 设置为 false。
3. 返回 ? GetViewValue(v, byteOffset, littleEndian, FLOAT64)。

##### 25.3.4.9 DataView.prototype.getInt8 ( byteOffset )
此方法在调用时执行以下步骤：

1. 令 v 为 this 值。
2. 返回 ? GetViewValue(v, byteOffset, true, INT8)。

##### 25.3.4.10 DataView.prototype.getInt16 ( byteOffset [ , littleEndian ] )
此方法在调用时执行以下步骤：

1. 令 v 为 this 值。
2. 如果 littleEndian 未出现，将 littleEndian 设置为 false。
3. 返回 ? GetViewValue(v, byteOffset, littleEndian, INT16)。

##### 25.3.4.11 DataView.prototype.getInt32 ( byteOffset [ , littleEndian ] )
此方法在调用时执行以下步骤：

1. 令 v 为 this 值。
2. 如果 littleEndian 未出现，将 littleEndian 设置为 false。
3. 返回 ? GetViewValue(v, byteOffset, littleEndian, INT32)。

##### 25.3.4.12 DataView.prototype.getUint8 ( byteOffset )
此方法在调用时执行以下步骤：

1. 令 v 为 this 值。
2. 返回 ? GetViewValue(v, byteOffset, true, UINT8)。

##### 25.3.4.13 DataView.prototype.getUint16 ( byteOffset [ , littleEndian ] )
此方法在调用时执行以下步骤：

1. 令 v 为 this 值。
2. 如果 littleEndian 未出现，将 littleEndian 设置为 false。
3. 返回 ? GetViewValue(v, byteOffset, littleEndian, UINT16)。

##### 25.3.4.14 DataView.prototype.getUint32 ( byteOffset [ , littleEndian ] )
此方法在调用时执行以下步骤：

1. 令 v 为 this 值。
2. 如果 littleEndian 未出现，将 littleEndian 设置为 false。
3. 返回 ? GetViewValue(v, byteOffset, littleEndian, UINT32)。

##### 25.3.4.15 DataView.prototype.setBigInt64 ( byteOffset, value [ , littleEndian ] )
此方法在调用时执行以下步骤：

1. 令 v 为 this 值。
2. 返回 ? SetViewValue(v, byteOffset, littleEndian, BIGINT64, value)。

##### 25.3.4.16 DataView.prototype.setBigUint64 ( byteOffset, value [ , littleEndian ] )
此方法在调用时执行以下步骤：

1. 令 v 为 this 值。
2. 返回 ? SetViewValue(v, byteOffset, littleEndian, BIGUINT64, value)。

##### 25.3.4.17 DataView.prototype.setFloat32 ( byteOffset, value [ , littleEndian ] )
此方法在调用时执行以下步骤：

1. 令 v 为 this 值。
2. 如果 littleEndian 未出现，将 littleEndian 设置为 false。
3. 返回 ? SetViewValue(v, byteOffset, littleEndian, FLOAT32, value)。

##### 25.3.4.18 DataView.prototype.setFloat64 ( byteOffset, value [ , littleEndian ] )
此方法在调用时执行以下步骤：

1. 令 v 为 this 值。
2. 如果 littleEndian 未出现，将 littleEndian 设置为 false。
3. 返回 ? SetViewValue(v, byteOffset, littleEndian, FLOAT64, value)。

##### 25.3.4.19 DataView.prototype.setInt8 ( byteOffset, value )
此方法在调用时执行以下步骤：

1. 令 v 为 this 值。
2. 返回 ? SetViewValue(v, byteOffset, true, INT8, value)。

##### 25.3.4.20 DataView.prototype.setInt16 ( byteOffset, value [ , littleEndian ] )
此方法在调用时执行以下步骤：

1. 令 v 为 this 值。
2. 如果 littleEndian 未出现，将 littleEndian 设置为 false。
3. 返回 ? SetViewValue(v, byteOffset, littleEndian, INT16, value)。

##### 25.3.4.21 DataView.prototype.setInt32 ( byteOffset, value [ , littleEndian ] )
此方法在调用时执行以下步骤：

1. 令 v 为 this 值。
2. 如果 littleEndian 未出现，将 littleEndian 设置为 false。
3. 返回 ? SetViewValue(v, byteOffset, littleEndian, INT32, value)。

##### 25.3.4.22 DataView.prototype.setUint8 ( byteOffset, value )
此方法在调用时执行以下步骤：

1. 令 v 为 this 值。
2. 返回 ? SetViewValue(v, byteOffset, true, UINT8, value)。

##### 25

.3.4.23 DataView.prototype.setUint16 ( byteOffset, value [ , littleEndian ] )
此方法在调用时执行以下步骤：

1. 令 v 为 this 值。
2. 如果 littleEndian 未出现，将 littleEndian 设置为 false。
3. 返回 ? SetViewValue(v, byteOffset, littleEndian, UINT16, value)。

##### 25.3.4.24 DataView.prototype.setUint32 ( byteOffset, value [ , littleEndian ] )
此方法在调用时执行以下步骤：

1. 令 v 为 this 值。
2. 如果 littleEndian 未出现，将 littleEndian 设置为 false。
3. 返回 ? SetViewValue(v, byteOffset, littleEndian, UINT32, value)。

##### 25.3.4.25 DataView.prototype [ @@toStringTag ]
@@toStringTag 属性的初始值是字符串值 "DataView"。

此属性具有 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true } 的属性。

#### 25.3.5 DataView 实例的属性
DataView 实例是继承自 DataView 原型对象的普通对象。DataView 实例每个都有 [[DataView]]、[[ViewedArrayBuffer]]、[[ByteLength]] 和 [[ByteOffset]] 内部槽。

**注意**
[[DataView]] 内部槽的值在本规范中未使用。此规范中使用的创建 DataView 构造函数的对象的标识是该内部槽的简单存在。

### 25.4 Atomics 对象

Atomics 对象：

- 是 %Atomics%。
- 是全局对象的 "Atomics" 属性的初始值。
- 是一个普通对象。
- 具有一个 [[Prototype]] 内部槽，其值为 %Object.prototype%。
- 不具有 [[Construct]] 内部方法；不能用 new 运算符作为构造函数使用。
- 不具有 [[Call]] 内部方法；不能作为函数调用。

Atomics 对象提供对共享内存数组单元的不可分操作（原子操作）的函数，以及让代理等待和派发原始事件的函数。通过合理使用，Atomics 函数允许通过共享内存进行通信的多代理程序即使在并行 CPU 上也能够按照可预测的顺序执行。共享内存通信的规则由下面定义的内存模型提供。

**注意**  
关于在 ECMAScript 中编程和实现共享内存的指南，请参见内存模型部分末尾的注释。

#### 25.4.1 Waiter Record

Waiter Record 是一种记录值，用于表示对 Atomics.wait 或 Atomics.waitAsync 的特定调用。

Waiter Record 具有如表 73 所列的字段。

表 73：Waiter Record 字段
| 字段名称               | 值                             | 含义                                                       |
|------------------------|--------------------------------|------------------------------------------------------------|
| [[AgentSignifier]]     | 一个代理标识符                 | 调用了 Atomics.wait 或 Atomics.waitAsync 的代理             |
| [[PromiseCapability]]  | 一个 PromiseCapability Record 或 BLOCKING | 表示对 Atomics.waitAsync 的调用结果承诺，否则为 BLOCKING   |
| [[TimeoutTime]]        | 一个非负扩展数学值             | 超时可能触发的最早时间；使用时间值计算                      |
| [[Result]]             | "ok" 或 "timed-out"            | 调用的返回值                                                |

#### 25.4.2 WaiterList Records

WaiterList Record 用于解释通过 Atomics.wait、Atomics.waitAsync 和 Atomics.notify 代理的等待和通知。

WaiterList Record 具有如表 74 所列的字段。

表 74：WaiterList Record 字段
| 字段名称                 | 值                                  | 含义                                                                            |
|--------------------------|-------------------------------------|---------------------------------------------------------------------------------|
| [[Waiters]]              | 一个 Waiter Record 列表             | 与此 WaiterList 关联的位置正在等待 Atomics.wait 或 Atomics.waitAsync 的调用     |
| [[MostRecentLeaveEvent]] | 一个 Synchronize 事件或 EMPTY       | 最近一次离开其临界区的事件，或者如果其临界区从未被进入则为 EMPTY                |

在一个 WaiterList 中可以有多个具有相同代理标识符的 Waiter Record。

代理集群有一个存储 WaiterList Record 的存储库；存储库由 (block, i) 索引，其中 block 是一个共享数据块，i 是块内存中的字节偏移。WaiterList Record 是代理无关的：在代理集群中的任何代理中，通过 (block, i) 进行 WaiterList Record 查找将得到相同的 WaiterList Record。

每个 WaiterList Record 都有一个临界区，用于在评估期间控制对该 WaiterList Record 的独占访问。一次只有一个代理可以进入一个 WaiterList Record 的临界区。进入和离开 WaiterList Record 的临界区由抽象操作 EnterCriticalSection 和 LeaveCriticalSection 控制。对 WaiterList Record 的操作（添加和移除等待的代理、遍历代理列表、挂起和通知列表中的代理、设置和检索 Synchronize 事件）只能由已经进入 WaiterList Record 临界区的代理执行。

#### 25.4.3 Atomics 的抽象操作

##### 25.4.3.1 ValidateIntegerTypedArray ( typedArray, waitable )
抽象操作 ValidateIntegerTypedArray 接受参数 typedArray（一个 ECMAScript 语言值）和 waitable（一个布尔值），返回一个包含 TypedArray 和 Buffer Witness Record 的正常完成，或者抛出一个完成。调用时执行以下步骤：

1. 令 taRecord 为 ? ValidateTypedArray(typedArray, UNORDERED)。
2. 注意：当 typedArray 的后备缓冲区是可增长的 SharedArrayBuffer 时，边界检查不是同步操作。
3. 如果 waitable 为 true，则
    a. 如果 typedArray.[[TypedArrayName]] 既不是 "Int32Array" 也不是 "BigInt64Array"，抛出一个 TypeError 异常。
4. 否则，
    a. 令 type 为 TypedArrayElementType(typedArray)。
    b. 如果 IsUnclampedIntegerElementType(type) 为 false 且 IsBigIntElementType(type) 为 false，抛出一个 TypeError 异常。
5. 返回 taRecord。

##### 25.4.3.2 ValidateAtomicAccess ( taRecord, requestIndex )
抽象操作 ValidateAtomicAccess 接受参数 taRecord（一个包含 TypedArray 和 Buffer Witness Record）和 requestIndex（一个 ECMAScript 语言值），返回一个包含整数的正常完成，或者抛出一个完成。调用时执行以下步骤：

1. 令 length 为 TypedArrayLength(taRecord)。
2. 令 accessIndex 为 ? ToIndex(requestIndex)。
3. 断言：accessIndex ≥ 0。
4. 如果 accessIndex ≥ length，抛出一个 RangeError 异常。
5. 令 typedArray 为 taRecord.[[Object]]。
6. 令 elementSize 为 TypedArrayElementSize(typedArray)。
7. 令 offset 为 typedArray.[[ByteOffset]]。
8. 返回 (accessIndex × elementSize) + offset。

##### 25.4.3.3 ValidateAtomicAccessOnIntegerTypedArray ( typedArray, requestIndex [ , waitable ] )
抽象操作 ValidateAtomicAccessOnIntegerTypedArray 接受参数 typedArray（一个 ECMAScript 语言值）和 requestIndex（一个 ECMAScript 语言值），以及可选参数 waitable（一个布尔值），返回一个包含整数的正常完成，或者抛出一个完成。调用时执行以下步骤：

1. 如果 waitable 未出现，将 waitable 设置为 false。
2. 令 taRecord 为 ? ValidateIntegerTypedArray(typedArray, waitable)。
3. 返回 ? ValidateAtomicAccess(taRecord, requestIndex)。

##### 25.4.3.4 RevalidateAtomicAccess ( typedArray, byteIndexInBuffer )
抽象操作 RevalidateAtomicAccess 接受参数 typedArray（一个 TypedArray）和 byteIndexInBuffer（一个整数），返回一个包含 UNUSED 的正常完成，或者抛出一个完成。此操作在 Atomics 方法中所有参数强制转换执行后重新验证索引，以防止由于参数强制转换可能产生的副作用导致缓冲区超出范围。当 typedArray 的后备缓冲区是 SharedArrayBuffer 时，此操作不会抛出。调用时执行以下步骤：

1. 令 taRecord 为 MakeTypedArrayWithBufferWitnessRecord(typedArray, UNORDERED)。
2. 注意：当 typedArray 的后备缓冲区是可增长的 SharedArrayBuffer 时，边界检查不是同步操作。
3. 如果 IsTypedArrayOutOfBounds(taRecord) 为 true，抛出一个 TypeError 异常。
4. 断言：byteIndexInBuffer ≥ typedArray.[[ByteOffset]]。
5. 如果 byteIndexInBuffer ≥ taRecord.[[CachedBufferByteLength]]，抛出一个 RangeError 异常。
6. 返回 UNUSED。

##### 25.4.3.5 GetWaiterList ( block, i )
抽象操作 GetWaiterList 接受参数 block（一个共享数据块）和 i（一个非负整数，必须是4的倍数），返回一个 WaiterList Record。调用时执行以下步骤：

1. 断言：i 和 i + 3 是 block 内存中的有效字节偏移。
2. 返回由 (block, i) 引用的 WaiterList Record。

##### 25.4.3.6 EnterCriticalSection ( WL )
抽象操作 EnterCriticalSection 接受参数 WL（一个 WaiterList Record），返回 UNUSED。调用时执行以下步骤：

1. 断言：周围的代理不在任何 WaiterList Record 的临界区。
2. 等待直到没有代理在 WL 的临界区，然后进入 WL 的临界区（不允许其他代理进入）。
3. 如果 WL.[[MostRecentLeaveEvent]] 不是 EMPTY，则
    a. 注意：一个至少进入过一次其临界区的 WL 具有由 LeaveCriticalSection 设置的 Synchronize 事件。
    b. 令 execution 为周围代理的 Agent Record 的 [[CandidateExecution]] 字段。
    c. 令 eventsRecord 为 execution.[[EventsRecords]] 中 [[AgentSignifier]] 为 AgentSignifier() 的 Agent Events Record。
    d. 令 enterEvent 为一个新的 Synchronize 事件。
    e. 将 enterEvent 添加到 eventsRecord.[[EventList]]。
    f. 将 (WL.[[MostRecentLeaveEvent]], enterEvent) 添加到 eventsRecord.[[AgentSynchronizesWith]]。
4. 返回 UNUSED。

当一个代理尝试进入临界区时必须等待另一个代理离开时，EnterCriticalSection 具有争用

。没有争用时，EnterCriticalSection 调用的 FIFO 顺序是可观察的。争用时，实现可以选择任意顺序，但不能导致代理无限期等待。

##### 25.4.3.7 LeaveCriticalSection ( WL )
抽象操作 LeaveCriticalSection 接受参数 WL（一个 WaiterList Record），返回 UNUSED。调用时执行以下步骤：

1. 断言：周围的代理在 WL 的临界区。
2. 令 execution 为周围代理的 Agent Record 的 [[CandidateExecution]] 字段。
3. 令 eventsRecord 为 execution.[[EventsRecords]] 中 [[AgentSignifier]] 为 AgentSignifier() 的 Agent Events Record。
4. 令 leaveEvent 为一个新的 Synchronize 事件。
5. 将 leaveEvent 添加到 eventsRecord.[[EventList]]。
6. 将 WL.[[MostRecentLeaveEvent]] 设置为 leaveEvent。
7. 离开 WL 的临界区。
8. 返回 UNUSED。

##### 25.4.3.8 AddWaiter ( WL, waiterRecord )
抽象操作 AddWaiter 接受参数 WL（一个 WaiterList Record）和 waiterRecord（一个 Waiter Record），返回 UNUSED。调用时执行以下步骤：

1. 断言：周围的代理在 WL 的临界区。
2. 断言：WL.[[Waiters]] 中没有 [[PromiseCapability]] 字段为 waiterRecord.[[PromiseCapability]] 且 [[AgentSignifier]] 字段为 waiterRecord.[[AgentSignifier]] 的 Waiter Record。
3. 将 waiterRecord 添加到 WL.[[Waiters]]。
4. 返回 UNUSED。

##### 25.4.3.9 RemoveWaiter ( WL, waiterRecord )
抽象操作 RemoveWaiter 接受参数 WL（一个 WaiterList Record）和 waiterRecord（一个 Waiter Record），返回 UNUSED。调用时执行以下步骤：

1. 断言：周围的代理在 WL 的临界区。
2. 断言：WL.[[Waiters]] 包含 waiterRecord。
3. 从 WL.[[Waiters]] 中移除 waiterRecord。
4. 返回 UNUSED。

##### 25.4.3.10 RemoveWaiters ( WL, c )
抽象操作 RemoveWaiters 接受参数 WL（一个 WaiterList Record）和 c（一个非负整数或 +∞），返回一个 Waiter Record 列表。调用时执行以下步骤：

1. 断言：周围的代理在 WL 的临界区。
2. 令 len 为 WL.[[Waiters]] 中元素的数量。
3. 令 n 为 min(c, len)。
4. 令 L 为一个列表，其元素为 WL.[[Waiters]] 的前 n 个元素。
5. 从 WL.[[Waiters]] 中移除前 n 个元素。
6. 返回 L。

##### 25.4.3.11 SuspendThisAgent ( WL, waiterRecord )
抽象操作 SuspendThisAgent 接受参数 WL（一个 WaiterList Record）和 waiterRecord（一个 Waiter Record），返回 UNUSED。调用时执行以下步骤：

1. 断言：周围的代理在 WL 的临界区。
2. 断言：WL.[[Waiters]] 包含 waiterRecord。
3. 令 thisAgent 为 AgentSignifier()。
4. 断言：waiterRecord.[[AgentSignifier]] 是 thisAgent。
5. 断言：waiterRecord.[[PromiseCapability]] 是 BLOCKING。
6. 断言：AgentCanSuspend() 为 true。
7. 执行 LeaveCriticalSection(WL) 并挂起周围的代理直到时间到达 waiterRecord.[[TimeoutTime]]，以一种方式执行组合操作，使在临界区退出后但在暂停生效之前到达的通知不会丢失。周围的代理只能由于超时或其他代理调用 NotifyWaiter (WL 和 thisAgent)（即通过调用 Atomics.notify）而从暂停中唤醒。
8. 执行 EnterCriticalSection(WL)。
9. 返回 UNUSED。

##### 25.4.3.12 NotifyWaiter ( WL, waiterRecord )
抽象操作 NotifyWaiter 接受参数 WL（一个 WaiterList Record）和 waiterRecord（一个 Waiter Record），返回 UNUSED。调用时执行以下步骤：

1. 断言：周围的代理在 WL 的临界区。
2. 如果 waiterRecord.[[PromiseCapability]] 是 BLOCKING，则
    a. 将唤醒代理其标识符为 waiterRecord.[[AgentSignifier]] 从暂停状态。
    b. 注意：这会导致代理在 SuspendThisAgent 中恢复执行。
3. 否则，如果 AgentSignifier() 是 waiterRecord.[[AgentSignifier]]，则
    a. 令 promiseCapability 为 waiterRecord.[[PromiseCapability]]。
    b. 执行 ! Call(promiseCapability.[[Resolve]], undefined, « waiterRecord.[[Result]] »)。
4. 否则，
    a. 执行 EnqueueResolveInAgentJob(waiterRecord.[[AgentSignifier]], waiterRecord.[[PromiseCapability]], waiterRecord.[[Result]])。
5. 返回 UNUSED。

注意：代理不得以任何方式访问另一个代理的 promise 能力，除了将其传递给宿主。

##### 25.4.3.13 EnqueueResolveInAgentJob ( agentSignifier, promiseCapability, resolution )
抽象操作 EnqueueResolveInAgentJob 接受参数 agentSignifier（一个代理标识符）、promiseCapability（一个 PromiseCapability Record）和 resolution（一个 ECMAScript 语言值），返回 UNUSED。调用时执行以下步骤：

1. 令 resolveJob 为一个没有参数的新 Job 抽象闭包，其捕获 agentSignifier、promiseCapability 和 resolution 并在调用时执行以下步骤：
    a. 断言：AgentSignifier() 是 agentSignifier。
    b. 执行 ! Call(promiseCapability.[[Resolve]], undefined, « resolution »)。
    c. 返回 UNUSED。
2. 令 realmInTargetAgent 为 ! GetFunctionRealm(promiseCapability.[[Resolve]])。
3. 断言：agentSignifier 是 realmInTargetAgent.[[AgentSignifier]]。
4. 执行 HostEnqueueGenericJob(resolveJob, realmInTargetAgent)。
5. 返回 UNUSED。

##### 25.4.3.14 DoWait ( mode, typedArray, index, value, timeout )
抽象操作 DoWait 接受参数 mode（SYNC 或 ASYNC）、typedArray（一个 ECMAScript 语言值）、index（一个 ECMAScript 语言值）、value（一个 ECMAScript 语言值）和 timeout（一个 ECMAScript 语言值），返回一个包含对象、"not-equal"、"timed-out" 或 "ok" 的正常完成，或者抛出一个完成。调用时执行以下步骤：

1. 令 taRecord 为 ? ValidateIntegerTypedArray(typedArray, true)。
2. 令 buffer 为 taRecord.[[Object]].[[ViewedArrayBuffer]]。
3. 如果 IsSharedArrayBuffer(buffer) 为 false，抛出一个 TypeError 异常。
4. 令 i 为 ? ValidateAtomicAccess(taRecord, index)。
5. 令 arrayTypeName 为 typedArray.[[TypedArrayName]]。
6. 如果 arrayTypeName 是 "BigInt64Array"，令 v 为 ? ToBigInt64(value)。
7. 否则，令 v 为 ? ToInt32(value)。
8. 令 q 为 ? ToNumber(timeout)。
9. 如果 q 是 NaN 或 +∞𝔽，令 t 为 +∞；否则如果 q 是 -∞𝔽，令 t 为 0；否则令 t 为 max(ℝ(q), 0)。
10. 如果 mode 是 SYNC 且 AgentCanSuspend() 为 false，抛出一个 TypeError 异常。
11. 令 block 为 buffer.[[ArrayBufferData]]。
12. 令 offset 为 typedArray.[[ByteOffset]]。
13. 令 byteIndexInBuffer 为 (i × 4) + offset。
14. 令 WL 为 GetWaiterList(block, byteIndexInBuffer)。
15. 如果 mode 是 SYNC，则
    a. 令 promiseCapability 为 BLOCKING。
    b. 令 resultObject 为 undefined。
16. 否则，
    a. 令 promiseCapability 为 ! NewPromiseCapability(%Promise%)。
    b. 令 resultObject 为 OrdinaryObjectCreate(%Object.prototype%)。
17. 执行 EnterCriticalSection(WL)。
18. 令 elementType 为 TypedArrayElementType(typedArray)。
19. 令 w 为 GetValueFromBuffer(buffer, byteIndexInBuffer, elementType, true, SEQ-CST)。
20. 如果 v ≠ w，则
    a. 执行 LeaveCriticalSection(WL)。
    b. 如果 mode 是 SYNC，返回 "not-equal"。
    c. 执行 ! CreateDataPropertyOrThrow(resultObject, "async", false)。
    d. 执行 ! CreateDataPropertyOrThrow(resultObject, "value", "not-equal")。
    e. 返回 resultObject。
21. 如果 t = 0 且 mode 是 ASYNC，则
    a. 注意：没有同步立即超时的特殊处理。异步立即超时有特殊处理，以便快速失败并避免不必要的 Promise 作业。
    b. 执行 LeaveCriticalSection(WL)。
    c. 执行 ! CreateDataPropertyOrThrow(resultObject, "async",

 false)。
    d. 执行 ! CreateDataPropertyOrThrow(resultObject, "value", "timed-out")。
    e. 返回 resultObject。
22. 令 thisAgent 为 AgentSignifier()。
23. 令 now 为标识当前时间的时间值（UTC）。
24. 令 additionalTimeout 为一个实现定义的非负数学值。
25. 令 timeoutTime 为 ℝ(now) + t + additionalTimeout。
26. 注意：当 t 是 +∞ 时，timeoutTime 也是 +∞。
27. 令 waiterRecord 为一个新 Waiter Record { [[AgentSignifier]]: thisAgent, [[PromiseCapability]]: promiseCapability, [[TimeoutTime]]: timeoutTime, [[Result]]: "ok" }。
28. 执行 AddWaiter(WL, waiterRecord)。
29. 如果 mode 是 SYNC，则
    a. 执行 SuspendThisAgent(WL, waiterRecord)。
30. 否则如果 timeoutTime 是有限的，则
    a. 执行 EnqueueAtomicsWaitAsyncTimeoutJob(WL, waiterRecord)。
31. 执行 LeaveCriticalSection(WL)。
32. 如果 mode 是 SYNC，返回 waiterRecord.[[Result]]。
33. 执行 ! CreateDataPropertyOrThrow(resultObject, "async", true)。
34. 执行 ! CreateDataPropertyOrThrow(resultObject, "value", promiseCapability.[[Promise]])。
35. 返回 resultObject。

**注意**  
additionalTimeout 允许实现根据需要调整超时值，例如降低功耗或粗化计时器分辨率以减轻计时攻击。此值可能在每次调用 DoWait 时有所不同。

##### 25.4.3.15 EnqueueAtomicsWaitAsyncTimeoutJob ( WL, waiterRecord )
抽象操作 EnqueueAtomicsWaitAsyncTimeoutJob 接受参数 WL（一个 WaiterList Record）和 waiterRecord（一个 Waiter Record），返回 UNUSED。调用时执行以下步骤：

1. 令 timeoutJob 为一个没有参数的新 Job 抽象闭包，其捕获 WL 和 waiterRecord 并在调用时执行以下步骤：
    a. 执行 EnterCriticalSection(WL)。
    b. 如果 WL.[[Waiters]] 包含 waiterRecord，则
        i. 令 timeOfJobExecution 为标识当前时间的时间值（UTC）。
        ii. 断言：ℝ(timeOfJobExecution) ≥ waiterRecord.[[TimeoutTime]]（忽略时间值的潜在非单调性）。
        iii. 将 waiterRecord.[[Result]] 设置为 "timed-out"。
        iv. 执行 RemoveWaiter(WL, waiterRecord)。
        v. 执行 NotifyWaiter(WL, waiterRecord)。
    c. 执行 LeaveCriticalSection(WL)。
    d. 返回 UNUSED。
2. 令 now 为标识当前时间的时间值（UTC）。
3. 令 currentRealm 为当前的 Realm Record。
4. 执行 HostEnqueueTimeoutJob(timeoutJob, currentRealm, 𝔽(waiterRecord.[[TimeoutTime]]) - now)。
5. 返回 UNUSED。

##### 25.4.3.16 AtomicCompareExchangeInSharedBlock ( block, byteIndexInBuffer, elementSize, expectedBytes, replacementBytes )
抽象操作 AtomicCompareExchangeInSharedBlock 接受参数 block（一个共享数据块）、byteIndexInBuffer（一个整数）、elementSize（一个非负整数）、expectedBytes（一个字节值列表）和 replacementBytes（一个字节值列表），返回一个字节值列表。调用时执行以下步骤：

1. 令 execution 为周围代理的 Agent Record 的 [[CandidateExecution]] 字段。
2. 令 eventsRecord 为 execution.[[EventsRecords]] 中 [[AgentSignifier]] 为 AgentSignifier() 的 Agent Events Record。
3. 令 rawBytesRead 为一个长度为 elementSize 的列表，其元素是非确定性选择的字节值。
4. 注意：在实现中，rawBytesRead 是底层硬件上的一个 load-link、load-exclusive 或 read-modify-write 指令的结果。非确定性是内存模型的语义规定，用于描述具有弱一致性的硬件的可观察行为。
5. 注意：预期值和读取值的比较在 read-modify-write 修改函数之外执行，以避免在预期值不等于读取值时不必要的强同步。
6. 如果 ByteListEqual(rawBytesRead, expectedBytes) 为 true，则
    a. 令 second 为一个新的 read-modify-write 修改函数，其参数为 (oldBytes, newBytes)，不捕获任何内容，并在调用时以原子方式执行以下步骤：
        i. 返回 newBytes。
    b. 令 event 为 ReadModifyWriteSharedMemory { [[Order]]: SEQ-CST, [[NoTear]]: true, [[Block]]: block, [[ByteIndex]]: byteIndexInBuffer, [[ElementSize]]: elementSize, [[Payload]]: replacementBytes, [[ModifyOp]]: second }。
7. 否则，
    a. 令 event 为 ReadSharedMemory { [[Order]]: SEQ-CST, [[NoTear]]: true, [[Block]]: block, [[ByteIndex]]: byteIndexInBuffer, [[ElementSize]]: elementSize }。
8. 将 event 添加到 eventsRecord.[[EventList]]。
9. 将 Chosen Value Record { [[Event]]: event, [[ChosenValue]]: rawBytesRead } 添加到 execution.[[ChosenValues]]。
10. 返回 rawBytesRead。

##### 25.4.3.17 AtomicReadModifyWrite ( typedArray, index, value, op )
抽象操作 AtomicReadModifyWrite 接受参数 typedArray（一个 ECMAScript 语言值）、index（一个 ECMAScript 语言值）、value（一个 ECMAScript 语言值）和 op（一个 read-modify-write 修改函数），返回一个包含 Number 或 BigInt 的正常完成，或者抛出一个完成。op 接受两个字节值列表参数并返回一个字节值列表。此操作以原子方式加载一个值，将其与另一个值组合，并存储组合的结果。它返回加载的值。调用时执行以下步骤：

1. 令 byteIndexInBuffer 为 ? ValidateAtomicAccessOnIntegerTypedArray(typedArray, index)。
2. 如果 typedArray.[[ContentType]] 是 BIGINT，令 v 为 ? ToBigInt(value)。
3. 否则，令 v 为 𝔽(? ToIntegerOrInfinity(value))。
4. 执行 ? RevalidateAtomicAccess(typedArray, byteIndexInBuffer)。
5. 令 buffer 为 typedArray.[[ViewedArrayBuffer]]。
6. 令 elementType 为 TypedArrayElementType(typedArray)。
7. 返回 GetModifySetValueInBuffer(buffer, byteIndexInBuffer, elementType, v, op)。

##### 25.4.3.18 ByteListBitwiseOp ( op, xBytes, yBytes )
抽象操作 ByteListBitwiseOp 接受参数 op（&、^ 或 |）、xBytes（一个字节值列表）和 yBytes（一个字节值列表），返回一个字节值列表。此操作以原子方式对参数的所有字节值执行位操作，并返回一个字节值列表。调用时执行以下步骤：

1. 断言：xBytes 和 yBytes 具有相同数量的元素。
2. 令 result 为一个新的空列表。
3. 令 i 为 0。
4. 对 xBytes 的每个元素 xByte，执行以下步骤：
    a. 令 yByte 为 yBytes[i]。
    b. 如果 op 是 &，则
        i. 令 resultByte 为对 xByte 和 yByte 应用位与操作的结果。
    c. 否则，如果 op 是 ^，则
        i. 令 resultByte 为对 xByte 和 yByte 应用位异或操作的结果。
    d. 否则，
        i. 断言：op 是 |。
        ii. 令 resultByte 为对 xByte 和 yByte 应用位或操作的结果。
    e. 将 i 设置为 i + 1。
    f. 将 resultByte 添加到 result。
5. 返回 result。

##### 25.4.3.19 ByteListEqual ( xBytes, yBytes )
抽象操作 ByteListEqual 接受参数 xBytes（一个字节值列表）和 yBytes（一个字节值列表），返回一个布尔值。调用时执行以下步骤：

1. 如果 xBytes 和 yBytes 没有相同数量的元素，返回 false。
2. 令 i 为 0。
3. 对 xBytes 的每个元素 xByte，执行以下步骤：
    a. 令 yByte 为 yBytes[i]。
    b. 如果 xByte ≠ yByte，返回 false。
    c. 将 i 设置为 i + 1。
4. 返回 true。

##### 25.4.4 Atomics.add ( typedArray, index, value )
此函数在调用时执行以下步骤：

1. 令 type 为 TypedArrayElementType(typedArray)。
2. 令 isLittleEndian 为周围代理的 Agent Record 的 [[LittleEndian]] 字段的值。
3. 令 add 为一个新的 read-modify-write 修改函数，其参数为 (xBytes, yBytes)，捕获 type 和 isLittleEndian，并在调用时以原子方式执行以下步骤：
    a. 令 x 为 RawBytes

ToNumeric(type, xBytes, isLittleEndian)。
    b. 令 y 为 RawBytesToNumeric(type, yBytes, isLittleEndian)。
    c. 如果 x 是 Number，则
        i. 令 sum 为 Number::add(x, y)。
    d. 否则，
        i. 断言：x 是 BigInt。
        ii. 令 sum 为 BigInt::add(x, y)。
    e. 令 sumBytes 为 NumericToRawBytes(type, sum, isLittleEndian)。
    f. 断言：sumBytes、xBytes 和 yBytes 具有相同数量的元素。
    g. 返回 sumBytes。
4. 返回 ? AtomicReadModifyWrite(typedArray, index, value, add)。

##### 25.4.5 Atomics.and ( typedArray, index, value )
此函数在调用时执行以下步骤：

1. 令 and 为一个新的 read-modify-write 修改函数，其参数为 (xBytes, yBytes)，不捕获任何内容，并在调用时以原子方式执行以下步骤：
    a. 返回 ByteListBitwiseOp(&, xBytes, yBytes)。
2. 返回 ? AtomicReadModifyWrite(typedArray, index, value, and)。

##### 25.4.6 Atomics.compareExchange ( typedArray, index, expectedValue, replacementValue )
此函数在调用时执行以下步骤：

1. 令 byteIndexInBuffer 为 ? ValidateAtomicAccessOnIntegerTypedArray(typedArray, index)。
2. 令 buffer 为 typedArray.[[ViewedArrayBuffer]]。
3. 令 block 为 buffer.[[ArrayBufferData]]。
4. 如果 typedArray.[[ContentType]] 是 BIGINT，则
    a. 令 expected 为 ? ToBigInt(expectedValue)。
    b. 令 replacement 为 ? ToBigInt(replacementValue)。
5. 否则，
    a. 令 expected 为 𝔽(? ToIntegerOrInfinity(expectedValue))。
    b. 令 replacement 为 𝔽(? ToIntegerOrInfinity(replacementValue))。
6. 执行 ? RevalidateAtomicAccess(typedArray, byteIndexInBuffer)。
7. 令 elementType 为 TypedArrayElementType(typedArray)。
8. 令 elementSize 为 TypedArrayElementSize(typedArray)。
9. 令 isLittleEndian 为周围代理的 Agent Record 的 [[LittleEndian]] 字段的值。
10. 令 expectedBytes 为 NumericToRawBytes(elementType, expected, isLittleEndian)。
11. 令 replacementBytes 为 NumericToRawBytes(elementType, replacement, isLittleEndian)。
12. 如果 IsSharedArrayBuffer(buffer) 为 true，则
    a. 令 rawBytesRead 为 AtomicCompareExchangeInSharedBlock(block, byteIndexInBuffer, elementSize, expectedBytes, replacementBytes)。
13. 否则，
    a. 令 rawBytesRead 为一个长度为 elementSize 的列表，其元素是从 block[byteIndexInBuffer] 开始的 elementSize 个字节。
    b. 如果 ByteListEqual(rawBytesRead, expectedBytes) 为 true，则
        i. 将 replacementBytes 的各个字节存储到 block，从 block[byteIndexInBuffer] 开始。
14. 返回 RawBytesToNumeric(elementType, rawBytesRead, isLittleEndian)。

##### 25.4.7 Atomics.exchange ( typedArray, index, value )
此函数在调用时执行以下步骤：

1. 令 second 为一个新的 read-modify-write 修改函数，其参数为 (oldBytes, newBytes)，不捕获任何内容，并在调用时以原子方式执行以下步骤：
    a. 返回 newBytes。
2. 返回 ? AtomicReadModifyWrite(typedArray, index, value, second)。

##### 25.4.8 Atomics.isLockFree ( size )
此函数在调用时执行以下步骤：

1. 令 n 为 ? ToIntegerOrInfinity(size)。
2. 令 AR 为周围代理的 Agent Record。
3. 如果 n = 1，返回 AR.[[IsLockFree1]]。
4. 如果 n = 2，返回 AR.[[IsLockFree2]]。
5. 如果 n = 4，返回 true。
6. 如果 n = 8，返回 AR.[[IsLockFree8]]。
7. 返回 false。

**注意**  
此函数是一个优化原语。直觉上，如果原子原语（compareExchange、load、store、add、sub、and、or、xor 或 exchange）的原子步骤将在不获取 n 字节组成的数据之外的锁的情况下执行，则 Atomics.isLockFree(n) 将返回 true。高性能算法将使用此函数来确定在关键部分中使用锁还是原子操作。如果一个原子原语不是无锁的，那么算法通常更有效率地提供其自己的锁定。

Atomics.isLockFree(4) 始终返回 true，因为这可以在所有已知的相关硬件上支持。能够假定这一点通常会简化程序。

无论此函数返回的值如何，所有原子操作都保证是原子的。例如，它们永远不会在操作中间发生可见操作（例如，“撕裂”）。

##### 25.4.9 Atomics.load ( typedArray, index )
此函数在调用时执行以下步骤：

1. 令 byteIndexInBuffer 为 ? ValidateAtomicAccessOnIntegerTypedArray(typedArray, index)。
2. 执行 ? RevalidateAtomicAccess(typedArray, byteIndexInBuffer)。
3. 令 buffer 为 typedArray.[[ViewedArrayBuffer]]。
4. 令 elementType 为 TypedArrayElementType(typedArray)。
5. 返回 GetValueFromBuffer(buffer, byteIndexInBuffer, elementType, true, SEQ-CST)。

##### 25.4.10 Atomics.or ( typedArray, index, value )
此函数在调用时执行以下步骤：

1. 令 or 为一个新的 read-modify-write 修改函数，其参数为 (xBytes, yBytes)，不捕获任何内容，并在调用时以原子方式执行以下步骤：
    a. 返回 ByteListBitwiseOp(|, xBytes, yBytes)。
2. 返回 ? AtomicReadModifyWrite(typedArray, index, value, or)。

##### 25.4.11 Atomics.store ( typedArray, index, value )
此函数在调用时执行以下步骤：

1. 令 byteIndexInBuffer 为 ? ValidateAtomicAccessOnIntegerTypedArray(typedArray, index)。
2. 如果 typedArray.[[ContentType]] 是 BIGINT，令 v 为 ? ToBigInt(value)。
3. 否则，令 v 为 𝔽(? ToIntegerOrInfinity(value))。
4. 执行 ? RevalidateAtomicAccess(typedArray, byteIndexInBuffer)。
5. 令 buffer 为 typedArray.[[ViewedArrayBuffer]]。
6. 令 elementType 为 TypedArrayElementType(typedArray)。
7. 执行 SetValueInBuffer(buffer, byteIndexInBuffer, elementType, v, true, SEQ-CST)。
8. 返回 v。

##### 25.4.12 Atomics.sub ( typedArray, index, value )
此函数在调用时执行以下步骤：

1. 令 type 为 TypedArrayElementType(typedArray)。
2. 令 isLittleEndian 为周围代理的 Agent Record 的 [[LittleEndian]] 字段的值。
3. 令 subtract 为一个新的 read-modify-write 修改函数，其参数为 (xBytes, yBytes)，捕获 type 和 isLittleEndian，并在调用时以原子方式执行以下步骤：
    a. 令 x 为 RawBytesToNumeric(type, xBytes, isLittleEndian)。
    b. 令 y 为 RawBytesToNumeric(type, yBytes, isLittleEndian)。
    c. 如果 x 是 Number，则
        i. 令 difference 为 Number::subtract(x, y)。
    d. 否则，
        i. 断言：x 是 BigInt。
        ii. 令 difference 为 BigInt::subtract(x, y)。
    e. 令 differenceBytes 为 NumericToRawBytes(type, difference, isLittleEndian)。
    f. 断言：differenceBytes、xBytes 和 yBytes 具有相同数量的元素。
    g. 返回 differenceBytes。
4. 返回 ? AtomicReadModifyWrite(typedArray, index, value, subtract)。

##### 25.4.13 Atomics.wait ( typedArray, index, value, timeout )
此函数将周围代理放入等待队列并将其挂起，直到被通知或等待超时，返回一个区分这些情况的字符串。

调用时执行以下步骤：

1. 返回 ? DoWait(SYNC, typedArray, index, value, timeout)。

##### 25.4.14 Atomics.waitAsync ( typedArray, index, value, timeout )
此函数返回一个 Promise，当调用代理被通知或超时达到时该 Promise 会被解决。

调用时执行以下步骤：

1. 返回 ? DoWait(ASYNC, typedArray, index, value, timeout)。

##### 25.4.15 Atomics.notify ( typedArray, index, count )
此函数通知一些在等待队列中睡眠的代理。

调用时执行以下步骤：

1. 令 byteIndexInBuffer 为 ? ValidateAtomicAccessOnIntegerTypedArray(typedArray, index, true)。
2. 如果 count 未定义，则
    a. 令 c 为 +∞。
3. 否则，
    a. 令 intCount 为 ? ToIntegerOrInfinity(count

)。
    b. 令 c 为 max(intCount, 0)。
4. 令 buffer 为 typedArray.[[ViewedArrayBuffer]]。
5. 令 block 为 buffer.[[ArrayBufferData]]。
6. 如果 IsSharedArrayBuffer(buffer) 为 false，返回 +0𝔽。
7. 令 WL 为 GetWaiterList(block, byteIndexInBuffer)。
8. 执行 EnterCriticalSection(WL)。
9. 令 S 为 RemoveWaiters(WL, c)。
10. 对 S 的每个元素 W，执行以下步骤：
    a. 执行 NotifyWaiter(WL, W)。
11. 执行 LeaveCriticalSection(WL)。
12. 令 n 为 S 中元素的数量。
13. 返回 𝔽(n)。

##### 25.4.16 Atomics.xor ( typedArray, index, value )
此函数在调用时执行以下步骤：

1. 令 xor 为一个新的 read-modify-write 修改函数，其参数为 (xBytes, yBytes)，不捕获任何内容，并在调用时以原子方式执行以下步骤：
    a. 返回 ByteListBitwiseOp(^, xBytes, yBytes)。
2. 返回 ? AtomicReadModifyWrite(typedArray, index, value, xor)。

##### 25.4.17 Atomics [ @@toStringTag ]
@@toStringTag 属性的初始值是字符串值 "Atomics"。

此属性的属性描述符为 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }。

### 25.5 The JSON Object

JSON 对象：

- 是 `%JSON%`。
- 是全局对象的 `"JSON"` 属性的初始值。
- 是一个普通对象。
- 包含两个函数，`parse` 和 `stringify`，用于解析和构造 JSON 文本。
- 具有 `[[Prototype]]` 内部槽，其值为 `%Object.prototype%`。
- 没有 `[[Construct]]` 内部方法；不能使用 `new` 操作符作为构造函数。
- 没有 `[[Call]]` 内部方法；不能作为函数调用。

JSON 数据交换格式在 ECMA-404 中定义。本规范中使用的 JSON 交换格式与 ECMA-404 描述的完全相同。`JSON.parse` 和 `JSON.stringify` 的符合实现必须支持 ECMA-404 规范中描述的确切交换格式，不能对格式进行任何删除或扩展。

#### 25.5.1 JSON.parse ( text [ , reviver ] )

此函数解析 JSON 文本（JSON 格式的字符串）并生成一个 ECMAScript 语言值。JSON 格式使用类似于 ECMAScript 字面量、数组初始化器和对象初始化器的语法来表示字面量、数组和对象。解析后，JSON 对象被实现为 ECMAScript 对象。JSON 数组被实现为 ECMAScript 数组实例。JSON 字符串、数字、布尔值和 `null` 被实现为 ECMAScript 字符串、数字、布尔值和 `null`。

可选的 `reviver` 参数是一个函数，它接受两个参数：`key` 和 `value`。它可以过滤和转换结果。解析生成的每个键值对都会调用它，其返回值将代替原始值。如果返回传入的值，则结构不变。如果返回 `undefined`，则结果中的该属性将被删除。

1. 令 `jsonString` 为 `? ToString(text)`。
2. 按照 ECMA-404 的规定，将 `StringToCodePoints(jsonString)` 解析为 JSON 文本。如果它不是有效的 JSON 文本，则抛出 `SyntaxError` 异常。
3. 令 `scriptString` 为 `"("`、`jsonString` 和 `");"` 的字符串连接。
4. 令 `script` 为 `ParseText(scriptString, Script)`。
5. **注意：** `13.2.5.1` 中定义的早期错误规则对上述 `ParseText` 调用有特殊处理。
6. 断言：`script` 是一个解析节点。
7. 令 `completion` 为 `Completion(Evaluation of script)`。
8. **注意：** `13.2.5.5` 中定义的 `PropertyDefinitionEvaluation` 语义对上述评估有特殊处理。
9. 令 `unfiltered` 为 `completion.[[Value]]`。
10. 断言：`unfiltered` 是字符串、数字、布尔值、由数组字面量或对象字面量定义的对象或 `null`。
11. 如果 `IsCallable(reviver)` 为 `true`，则：
    a. 令 `root` 为 `OrdinaryObjectCreate(%Object.prototype%)`。
    b. 令 `rootName` 为空字符串。
    c. 执行 `! CreateDataPropertyOrThrow(root, rootName, unfiltered)`。
    d. 返回 `? InternalizeJSONProperty(root, rootName, reviver)`。
12. 否则，
    a. 返回 `unfiltered`。

此函数的 `"length"` 属性为 `2𝔽`。

**注意：** 有效的 JSON 文本是 ECMAScript `PrimaryExpression` 语法的一个子集。步骤 2 验证 `jsonString` 符合该子集，步骤 10 断言解析和评估返回的值类型适当。

然而，由于 `13.2.5.5` 在 `JSON.parse` 期间的行为不同，相同的源文本在作为 `PrimaryExpression` 评估时可能会产生不同的结果。此外，对象字面量中重复的 `"__proto__"` 属性的早期错误不适用于 `JSON.parse`，这意味着并非所有 `JSON.parse` 接受的文本在作为 `PrimaryExpression` 时都是有效的，尽管它们匹配语法。

#### 25.5.1.1 InternalizeJSONProperty ( holder, name, reviver )

抽象操作 `InternalizeJSONProperty` 接受参数 `holder`（一个对象）、`name`（一个字符串）和 `reviver`（一个函数对象），返回一个包含 ECMAScript 语言值的正常完成或抛出完成。

**注意 1**  
此算法有意不在 `[[Delete]]` 或 `CreateDataProperty` 返回 `false` 时抛出异常。

调用时执行以下步骤：

1. 令 `val` 为 `? Get(holder, name)`。
2. 如果 `val` 是一个对象，则：
    a. 令 `isArray` 为 `? IsArray(val)`。
    b. 如果 `isArray` 为 `true`，则：
        i. 令 `len` 为 `? LengthOfArrayLike(val)`。
        ii. 令 `I` 为 `0`。
        iii. 重复，直到 `I < len`：
            1. 令 `prop` 为 `! ToString(𝔽(I))`。
            2. 令 `newElement` 为 `? InternalizeJSONProperty(val, prop, reviver)`。
            3. 如果 `newElement` 为 `undefined`，则：
                a. 执行 `? val.[[Delete]](prop)`。
            4. 否则，
                a. 执行 `? CreateDataProperty(val, prop, newElement)`。
            5. 将 `I` 加 1。
    c. 否则，
        i. 令 `keys` 为 `? EnumerableOwnProperties(val, KEY)`。
        ii. 对于 `keys` 中的每个字符串 `P`，执行：
            1. 令 `newElement` 为 `? InternalizeJSONProperty(val, P, reviver)`。
            2. 如果 `newElement` 为 `undefined`，则：
                a. 执行 `? val.[[Delete]](P)`。
            3. 否则，
                a. 执行 `? CreateDataProperty(val, P, newElement)`。
3. 返回 `? Call(reviver, holder, « name, val »)`。

不允许符合规范的 `JSON.parse` 实现扩展 JSON 语法。如果实现希望支持修改或扩展的 JSON 交换格式，必须通过定义不同的解析函数来实现。

**注意 2**  
在对象中存在重复的名称字符串的情况下，同一个键的词法上在前的值将被覆盖。

#### 25.5.2 JSON.stringify ( value [ , replacer [ , space ] ] )

此函数返回一个表示 ECMAScript 语言值的 UTF-16 编码的 JSON 格式字符串，或 `undefined`。它可以接受三个参数。`value` 参数是一个 ECMAScript 语言值，通常是对象或数组，尽管它也可以是字符串、布尔值、数字或 `null`。可选的 `replacer` 参数是一个函数，用于更改对象和数组的字符串化方式，或是一个字符串和数字的数组，作为选择对象属性的包含列表，这些属性将被字符串化。可选的 `space` 参数是一个字符串或数字，允许结果中注入空白，以提高人类可读性。

调用时执行以下步骤：

1. 令 `stack` 为一个新的空列表。
2. 令 `indent` 为空字符串。
3. 令 `PropertyList` 为 `undefined`。
4. 令 `ReplacerFunction` 为 `undefined`。
5. 如果 `replacer` 是一个对象，则：
    a. 如果 `IsCallable(replacer)` 为 `true`，则：
        i. 将 `ReplacerFunction` 设置为 `replacer`。
    b. 否则，
        i. 令 `isArray` 为 `? IsArray(replacer)`。
        ii. 如果 `isArray` 为 `true`，则：
            1. 将 `PropertyList` 设置为一个新的空列表。
            2. 令 `len` 为 `? LengthOfArrayLike(replacer)`。
            3. 令 `k` 为 `0`。
            4. 重复，直到 `k < len`：
                a. 令 `prop` 为 `! ToString(𝔽(k))`。
                b. 令 `v` 为 `? Get(replacer, prop)`。
                c. 令 `item` 为 `undefined`。
                d. 如果 `v` 是字符串，则：
                    i. 将 `item` 设置为 `v`。
                e. 否则如果 `v` 是数字，则：
                    i. 将 `item` 设置为 `! ToString(v)`。
                f. 否则如果 `v` 是对象，则：
                    i. 如果 `v` 具有 `[[StringData]]` 或 `[[NumberData]]` 内部槽，则将 `item` 设置为 `? ToString(v)`。
                g. 如果 `item`

 不为 `undefined` 并且 `PropertyList` 不包含 `item`，则：
                    i. 将 `item` 附加到 `PropertyList`。
                h. 将 `k` 加 1。
6. 如果 `space` 是一个对象，则：
    a. 如果 `space` 具有 `[[NumberData]]` 内部槽，则：
        i. 将 `space` 设置为 `? ToNumber(space)`。
    b. 否则如果 `space` 具有 `[[StringData]]` 内部槽，则：
        i. 将 `space` 设置为 `? ToString(space)`。
7. 如果 `space` 是数字，则：
    a. 令 `spaceMV` 为 `! ToIntegerOrInfinity(space)`。
    b. 将 `spaceMV` 设置为 `min(10, spaceMV)`。
    c. 如果 `spaceMV` 小于 `1`，则令 `gap` 为空字符串；否则令 `gap` 为包含 `spaceMV` 个 0x0020（空格）代码单元的字符串值。
8. 否则如果 `space` 是字符串，则：
    a. 如果 `space` 的长度小于或等于 `10`，则令 `gap` 为 `space`；否则令 `gap` 为 `space` 从 `0` 到 `10` 的子字符串。
9. 否则，
    a. 令 `gap` 为空字符串。
10. 令 `wrapper` 为 `OrdinaryObjectCreate(%Object.prototype%)`。
11. 执行 `! CreateDataPropertyOrThrow(wrapper, the empty String, value)`。
12. 令 `state` 为 `JSON Serialization Record { [[ReplacerFunction]]: ReplacerFunction, [[Stack]]: stack, [[Indent]]: indent, [[Gap]]: gap, [[PropertyList]]: PropertyList }`。
13. 返回 `? SerializeJSONProperty(state, the empty String, wrapper)`。

此函数的 `"length"` 属性为 `3𝔽`。

**注意 1**  
JSON 结构允许嵌套到任何深度，但它们必须是非循环的。如果 `value` 是或包含循环结构，则此函数必须抛出 `TypeError` 异常。以下是一个无法字符串化的值的示例：

```javascript
a = [];
a[0] = a;
my_text = JSON.stringify(a); // 必须抛出 TypeError。
```

**注意 2**  
符号原始值的渲染如下：

- `null` 值在 JSON 文本中渲染为字符串值 `"null"`。
- `undefined` 值不渲染。
- `true` 值在 JSON 文本中渲染为字符串值 `"true"`。
- `false` 值在 JSON 文本中渲染为字符串值 `"false"`。

**注意 3**  
字符串值用 `0x0022`（引号）代码单元包裹。代码单元 `"` 和 `\` 使用 `\` 前缀进行转义。控制字符代码单元用转义序列 `\uHHHH` 或更短形式，如 `\b`（退格符）、`\f`（换页符）、`\n`（换行符）、`\r`（回车符）、`\t`（制表符）替换。

**注意 4**  
有限数字用 `ToString(number)` 调用时的方式字符串化。`NaN` 和 `Infinity`（无论符号如何）表示为字符串值 `"null"`。

**注意 5**  
没有 JSON 表示的值（如 `undefined` 和函数）不会生成字符串。相反，它们生成 `undefined` 值。在数组中，这些值表示为字符串值 `"null"`。在对象中，不可表示的值会导致属性从字符串化中排除。

**注意 6**  
对象呈现为 `U+007B`（左大括号）后跟零个或多个属性，用 `U+002C`（逗号）分隔，并以 `U+007D`（右大括号）关闭。属性是表示属性名称的带引号字符串、`U+003A`（冒号），然后是字符串化的属性值。数组呈现为左方括号、元素之间用逗号分隔，并以右方括号关闭。

#### 25.5.2.1 JSON Serialization Record

JSON 序列化记录是一个记录值，用于启用 JSON 格式的序列化。

JSON 序列化记录具有表 75 中列出的字段。

表 75: JSON 序列化记录字段

| 字段名称              | 值                              | 含义                                                             |
| --------------------- | ------------------------------- | ---------------------------------------------------------------- |
| [[ReplacerFunction]]  | 一个函数对象或 `undefined`      | 一个可以为对象属性提供替代值的函数（来自 `JSON.stringify` 的 `replacer` 参数）。 |
| [[PropertyList]]      | 字符串列表或 `undefined`        | 序列化非数组对象时要包含的属性名称（来自 `JSON.stringify` 的 `replacer` 参数）。|
| [[Gap]]               | 一个字符串                      | 缩进单位（来自 `JSON.stringify` 的 `space` 参数）。                          |
| [[Stack]]             | 对象列表                        | 正在序列化的嵌套对象集合。用于检测循环结构。                            |
| [[Indent]]            | 一个字符串                      | 当前缩进。                                                   |

#### 25.5.2.2 SerializeJSONProperty ( state, key, holder )

抽象操作 `SerializeJSONProperty` 接受参数 `state`（一个 JSON 序列化记录）、`key`（一个字符串）和 `holder`（一个对象），返回包含字符串或 `undefined` 的正常完成或抛出完成。调用时执行以下步骤：

1. 令 `value` 为 `? Get(holder, key)`。
2. 如果 `value` 是对象或 `BigInt`，则：
    a. 令 `toJSON` 为 `? GetV(value, "toJSON")`。
    b. 如果 `IsCallable(toJSON)` 为 `true`，则：
        i. 将 `value` 设置为 `? Call(toJSON, value, « key »)`。
3. 如果 `state.[[ReplacerFunction]]` 不为 `undefined`，则：
    a. 将 `value` 设置为 `? Call(state.[[ReplacerFunction]], holder, « key, value »)`。
4. 如果 `value` 是对象，则：
    a. 如果 `value` 具有 `[[NumberData]]` 内部槽，则：
        i. 将 `value` 设置为 `? ToNumber(value)`。
    b. 否则如果 `value` 具有 `[[StringData]]` 内部槽，则：
        i. 将 `value` 设置为 `? ToString(value)`。
    c. 否则如果 `value` 具有 `[[BooleanData]]` 内部槽，则：
        i. 将 `value` 设置为 `value.[[BooleanData]]`。
    d. 否则如果 `value` 具有 `[[BigIntData]]` 内部槽，则：
        i. 将 `value` 设置为 `value.[[BigIntData]]`。
5. 如果 `value` 是 `null`，返回 `"null"`。
6. 如果 `value` 是 `true`，返回 `"true"`。
7. 如果 `value` 是 `false`，返回 `"false"`。
8. 如果 `value` 是字符串，返回 `QuoteJSONString(value)`。
9. 如果 `value` 是数字，则：
    a. 如果 `value` 是有限的，返回 `! ToString(value)`。
    b. 返回 `"null"`。
10. 如果 `value` 是 `BigInt`，抛出 `TypeError` 异常。
11. 如果 `value` 是对象且 `IsCallable(value)` 为 `false`，则：
    a. 令 `isArray` 为 `? IsArray(value)`。
    b. 如果 `isArray` 为 `true`，返回 `? SerializeJSONArray(state, value)`。
    c. 返回 `? SerializeJSONObject(state, value)`。
12. 返回 `undefined`。

#### 25.5.2.3 QuoteJSONString ( value )

抽象操作 `QuoteJSONString` 接受参数 `value`（一个字符串），返回一个字符串。它将 `value` 包裹在 `0x0022`（引号）代码单元中，并对其中的某些代码单元进行转义。此操作将 `value` 解释为 UTF-16 编码的代码点序列，如 `6.1.4` 中所述。调用时执行以下步骤：

1. 令 `product` 为仅包含代码单元 `0x0022`（引号）的字符串值。
2. 对于 `StringToCodePoints(value)` 的每个代码点 `C`，执行：
    a. 如果 `C` 列在表 76 的“代码点”列中，则：
        i. 将 `product` 设置为 `product` 和 `C` 对应行的“转义序列”列中的转义序列的字符串连接。
    b. 否则如果 `C` 的数值小于 `0x0020`（空格）或 `C` 的数值与前导代理或尾随

代理相同，则：
        i. 令 `unit` 为数值为 `C` 数值的代码单元。
        ii. 将 `product` 设置为 `product` 和 `UnicodeEscape(unit)` 的字符串连接。
    c. 否则，
        i. 将 `product` 设置为 `product` 和 `UTF16EncodeCodePoint(C)` 的字符串连接。
3. 将 `product` 设置为 `product` 和代码单元 `0x0022`（引号）的字符串连接。
4. 返回 `product`。

表 76: JSON 单字符转义序列

| 代码点    | Unicode 字符名称 | 转义序列 |
| --------- | ---------------- | -------- |
| U+0008    | 退格符           | \b       |
| U+0009    | 制表符           | \t       |
| U+000A    | 换行符 (LF)      | \n       |
| U+000C    | 换页符 (FF)      | \f       |
| U+000D    | 回车符 (CR)      | \r       |
| U+0022    | 引号             | \"       |
| U+005C    | 反斜杠           | \\       |

#### 25.5.2.4 UnicodeEscape ( C )

抽象操作 `UnicodeEscape` 接受参数 `C`（一个代码单元），返回一个字符串。它将 `C` 表示为 Unicode 转义序列。调用时执行以下步骤：

1. 令 `n` 为 `C` 的数值。
2. 断言：`n ≤ 0xFFFF`。
3. 令 `hex` 为 `n` 的字符串表示，格式为小写的十六进制数。
4. 返回 `代码单元 0x005C`（反斜杠）、`"u"` 和 `StringPad(hex, 4, "0", START)` 的字符串连接。

#### 25.5.2.5 SerializeJSONObject ( state, value )

抽象操作 `SerializeJSONObject` 接受参数 `state`（一个 JSON 序列化记录）和 `value`（一个对象），返回包含字符串的正常完成或抛出完成。它序列化一个对象。调用时执行以下步骤：

1. 如果 `state.[[Stack]]` 包含 `value`，抛出 `TypeError` 异常，因为结构是循环的。
2. 将 `value` 附加到 `state.[[Stack]]`。
3. 令 `stepback` 为 `state.[[Indent]]`。
4. 将 `state.[[Indent]]` 设置为 `state.[[Indent]]` 和 `state.[[Gap]]` 的字符串连接。
5. 如果 `state.[[PropertyList]]` 不为 `undefined`，则：
    a. 令 `K` 为 `state.[[PropertyList]]`。
6. 否则，
    a. 令 `K` 为 `? EnumerableOwnProperties(value, KEY)`。
7. 令 `partial` 为一个新的空列表。
8. 对于 `K` 中的每个元素 `P`，执行：
    a. 令 `strP` 为 `? SerializeJSONProperty(state, P, value)`。
    b. 如果 `strP` 不为 `undefined`，则：
        i. 令 `member` 为 `QuoteJSONString(P)`。
        ii. 将 `member` 设置为 `member` 和 `":"` 的字符串连接。
        iii. 如果 `state.[[Gap]]` 不是空字符串，则：
            1. 将 `member` 设置为 `member` 和代码单元 `0x0020`（空格）的字符串连接。
        iv. 将 `member` 设置为 `member` 和 `strP` 的字符串连接。
        v. 将 `member` 附加到 `partial`。
9. 如果 `partial` 是空的，则：
    a. 令 `final` 为 `"{}"`。
10. 否则，
    a. 如果 `state.[[Gap]]` 是空字符串，则：
        i. 令 `properties` 为通过连接 `partial` 的所有元素字符串形成的字符串值，相邻字符串对之间用代码单元 `0x002C`（逗号）分隔。不在第一个字符串之前或最后一个字符串之后插入逗号。
        ii. 令 `final` 为 `"{"`、`properties` 和 `"}"` 的字符串连接。
    b. 否则，
        i. 令 `separator` 为代码单元 `0x002C`（逗号）、代码单元 `0x000A`（换行符）和 `state.[[Indent]]` 的字符串连接。
        ii. 令 `properties` 为通过连接 `partial` 的所有元素字符串形成的字符串值，相邻字符串对之间用 `separator` 分隔。分隔符字符串不在第一个字符串之前或最后一个字符串之后插入。
        iii. 令 `final` 为 `"{"`、代码单元 `0x000A`（换行符）、`state.[[Indent]]`、`properties`、代码单元 `0x000A`（换行符）、`stepback` 和 `"}"` 的字符串连接。
11. 删除 `state.[[Stack]]` 的最后一个元素。
12. 将 `state.[[Indent]]` 设置为 `stepback`。
13. 返回 `final`。

#### 25.5.2.6 SerializeJSONArray ( state, value )

抽象操作 `SerializeJSONArray` 接受参数 `state`（一个 JSON 序列化记录）和 `value`（一个 ECMAScript 语言值），返回包含字符串的正常完成或抛出完成。它序列化一个数组。调用时执行以下步骤：

1. 如果 `state.[[Stack]]` 包含 `value`，抛出 `TypeError` 异常，因为结构是循环的。
2. 将 `value` 附加到 `state.[[Stack]]`。
3. 令 `stepback` 为 `state.[[Indent]]`。
4. 将 `state.[[Indent]]` 设置为 `state.[[Indent]]` 和 `state.[[Gap]]` 的字符串连接。
5. 令 `partial` 为一个新的空列表。
6. 令 `len` 为 `? LengthOfArrayLike(value)`。
7. 令 `index` 为 `0`。
8. 重复，直到 `index < len`：
    a. 令 `strP` 为 `? SerializeJSONProperty(state, ! ToString(𝔽(index)), value)`。
    b. 如果 `strP` 是 `undefined`，则：
        i. 将 `"null"` 附加到 `partial`。
    c. 否则，
        i. 将 `strP` 附加到 `partial`。
    d. 将 `index` 加 1。
9. 如果 `partial` 是空的，则：
    a. 令 `final` 为 `"[]"`。
10. 否则，
    a. 如果 `state.[[Gap]]` 是空字符串，则：
        i. 令 `properties` 为通过连接 `partial` 的所有元素字符串形成的字符串值，相邻字符串对之间用代码单元 `0x002C`（逗号）分隔。不在第一个字符串之前或最后一个字符串之后插入逗号。
        ii. 令 `final` 为 `"["`、`properties` 和 `"]"` 的字符串连接。
    b. 否则，
        i. 令 `separator` 为代码单元 `0x002C`（逗号）、代码单元 `0x000A`（换行符）和 `state.[[Indent]]` 的字符串连接。
        ii. 令 `properties` 为通过连接 `partial` 的所有元素字符串形成的字符串值，相邻字符串对之间用 `separator` 分隔。分隔符字符串不在第一个字符串之前或最后一个字符串之后插入。
        iii. 令 `final` 为 `"["`、代码单元 `0x000A`（换行符）、`state.[[Indent]]`、`properties`、代码单元 `0x000A`（换行符）、`stepback` 和 `"]"` 的字符串连接。
11. 删除 `state.[[Stack]]` 的最后一个元素。
12. 将 `state.[[Indent]]` 设置为 `stepback`。
13. 返回 `final`。

**注意：** 数组的表示仅包括从 `+0𝔽`（含）到 `array.length`（不含）区间内的元素。键不是数组索引的属性在字符串化时被排除。数组字符串化为左方括号、元素之间用逗号分隔，并以右方括号关闭。

#### 25.5.3 JSON [ @@toStringTag ]

`@@toStringTag` 属性的初始值为字符串 `"JSON"`。

此属性的属性为 `{ [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }`。

### 26 管理内存
#### 26.1 WeakRef 对象
WeakRef 是一个对象，用于引用目标对象或符号而不将其保留在垃圾收集之外。WeakRef 可以被取消引用，以允许访问目标值（如果目标尚未被垃圾收集回收）。

##### 26.1.1 WeakRef 构造函数
WeakRef 构造函数：

- 是 `%WeakRef%`。
- 是全局对象的 "WeakRef" 属性的初始值。
- 在作为构造函数调用时创建并初始化一个新的 WeakRef。
- 不是作为函数调用的，并且在这种方式调用时会抛出异常。
- 可以在类定义的 `extends` 子句中使用。意图继承指定的 WeakRef 行为的子类构造函数必须包含对 WeakRef 构造函数的 `super` 调用，以创建和初始化子类实例，并使其具有支持 WeakRef.prototype 内置方法所需的内部状态。

###### 26.1.1.1 WeakRef ( target )
此函数在调用时执行以下步骤：

1. 如果 `NewTarget` 是 `undefined`，抛出一个 `TypeError` 异常。
2. 如果 `CanBeHeldWeakly(target)` 为 `false`，抛出一个 `TypeError` 异常。
3. 令 `weakRef` 为 `? OrdinaryCreateFromConstructor(NewTarget, "%WeakRef.prototype%", « [[WeakRefTarget]] »)`。
4. 执行 `AddToKeptObjects(target)`。
5. 将 `weakRef.[[WeakRefTarget]]` 设置为 `target`。
6. 返回 `weakRef`。

##### 26.1.2 WeakRef 构造函数的属性
WeakRef 构造函数：

- 具有一个内部槽 `[[Prototype]]`，其值为 `%Function.prototype%`。
- 具有以下属性：

###### 26.1.2.1 WeakRef.prototype
WeakRef.prototype 的初始值是 WeakRef 原型对象。

此属性的属性为 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }。

##### 26.1.3 WeakRef 原型对象的属性
WeakRef 原型对象：

- 是 `%WeakRef.prototype%`。
- 具有一个内部槽 `[[Prototype]]`，其值为 `%Object.prototype%`。
- 是一个普通对象。
- 没有 `[[WeakRefTarget]]` 内部槽。

###### 26.1.3.1 WeakRef.prototype.constructor
WeakRef.prototype.constructor 的初始值是 `%WeakRef%`。

此属性的属性为 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }。

###### 26.1.3.2 WeakRef.prototype.deref ( )
此方法在调用时执行以下步骤：

1. 令 `weakRef` 为 `this` 值。
2. 执行 `? RequireInternalSlot(weakRef, [[WeakRefTarget]])`。
3. 返回 `WeakRefDeref(weakRef)`。

**注意**  
如果 WeakRef 返回一个不为 `undefined` 的目标值，那么在当前 ECMAScript 代码执行完毕之前，该目标值不应被垃圾收集。`AddToKeptObjects` 操作确保读一致性得以维持。

```javascript
let target = { foo() {} };
let weakRef = new WeakRef(target);

// ... later ...

if (weakRef.deref()) {
  weakRef.deref().foo();
}
```
在上面的示例中，如果第一次取消引用没有计算为 `undefined`，那么第二次取消引用也不会。

###### 26.1.3.3 WeakRef.prototype [ @@toStringTag ]
@@toStringTag 属性的初始值是字符串 `"WeakRef"`。

此属性的属性为 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }。

##### 26.1.4 WeakRef 抽象操作
###### 26.1.4.1 WeakRefDeref ( weakRef )
抽象操作 `WeakRefDeref` 接受参数 `weakRef`（一个 WeakRef）并返回 ECMAScript 语言值。调用时执行以下步骤：

1. 令 `target` 为 `weakRef.[[WeakRefTarget]]`。
2. 如果 `target` 不为 `EMPTY`，则：
    a. 执行 `AddToKeptObjects(target)`。
    b. 返回 `target`。
3. 返回 `undefined`。

**注意**  
此抽象操作与 `WeakRef.prototype.deref` 分别定义，仅为简洁地定义活跃性。

##### 26.1.5 WeakRef 实例的属性
WeakRef 实例是继承自 WeakRef 原型的普通对象。WeakRef 实例也有一个 `[[WeakRefTarget]]` 内部槽。

#### 26.2 FinalizationRegistry 对象
FinalizationRegistry 是一个管理在目标对象和符号被垃圾收集时执行的清理操作的注册和注销的对象。

##### 26.2.1 FinalizationRegistry 构造函数
FinalizationRegistry 构造函数：

- 是 `%FinalizationRegistry%`。
- 是全局对象的 "FinalizationRegistry" 属性的初始值。
- 在作为构造函数调用时创建并初始化一个新的 FinalizationRegistry。
- 不是作为函数调用的，并且在这种方式调用时会抛出异常。
- 可以在类定义的 `extends` 子句中使用。意图继承指定的 FinalizationRegistry 行为的子类构造函数必须包含对 FinalizationRegistry 构造函数的 `super` 调用，以创建和初始化子类实例，并使其具有支持 FinalizationRegistry.prototype 内置方法所需的内部状态。

###### 26.2.1.1 FinalizationRegistry ( cleanupCallback )
此函数在调用时执行以下步骤：

1. 如果 `NewTarget` 是 `undefined`，抛出一个 `TypeError` 异常。
2. 如果 `IsCallable(cleanupCallback)` 为 `false`，抛出一个 `TypeError` 异常。
3. 令 `finalizationRegistry` 为 `? OrdinaryCreateFromConstructor(NewTarget, "%FinalizationRegistry.prototype%", « [[Realm]], [[CleanupCallback]], [[Cells]] »)`。
4. 令 `fn` 为活跃的函数对象。
5. 将 `finalizationRegistry.[[Realm]]` 设置为 `fn.[[Realm]]`。
6. 将 `finalizationRegistry.[[CleanupCallback]]` 设置为 `HostMakeJobCallback(cleanupCallback)`。
7. 将 `finalizationRegistry.[[Cells]]` 设置为一个新的空列表。
8. 返回 `finalizationRegistry`。

##### 26.2.2 FinalizationRegistry 构造函数的属性
FinalizationRegistry 构造函数：

- 具有一个内部槽 `[[Prototype]]`，其值为 `%Function.prototype%`。
- 具有以下属性：

###### 26.2.2.1 FinalizationRegistry.prototype
FinalizationRegistry.prototype 的初始值是 FinalizationRegistry 原型对象。

此属性的属性为 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }。

##### 26.2.3 FinalizationRegistry 原型对象的属性
FinalizationRegistry 原型对象：

- 是 `%FinalizationRegistry.prototype%`。
- 具有一个内部槽 `[[Prototype]]`，其值为 `%Object.prototype%`。
- 是一个普通对象。
- 没有 `[[Cells]]` 和 `[[CleanupCallback]]` 内部槽。

###### 26.2.3.1 FinalizationRegistry.prototype.constructor
FinalizationRegistry.prototype.constructor 的初始值是 `%FinalizationRegistry%`。

###### 26.2.3.2 FinalizationRegistry.prototype.register ( target, heldValue [ , unregisterToken ] )
此方法在调用时执行以下步骤：

1. 令 `finalizationRegistry` 为 `this` 值。
2. 执行 `? RequireInternalSlot(finalizationRegistry, [[Cells]])`。
3. 如果 `CanBeHeldWeakly(target)` 为 `false`，抛出一个 `TypeError` 异常。
4. 如果 `SameValue(target, heldValue)` 为 `true`，抛出一个 `TypeError` 异常。
5. 如果 `CanBeHeldWeakly(unregisterToken)` 为 `false`，则：
    a. 如果 `unregisterToken` 不是 `undefined`，抛出一个 `TypeError` 异常。
    b. 将 `unregisterToken` 设置为 `EMPTY`。
6. 令 `cell` 为 `{ [[WeakRefTarget]]: target, [[HeldValue]]: heldValue, [[UnregisterToken]]: unregisterToken }`。
7. 将 `cell` 附加到 `finalizationRegistry.[[Cells]]`。
8. 返回 `undefined`。

**注意**  
根据本规范中的算法和定义，当 `finalizationRegistry.[[Cells]]` 包含 `cell` 时，`cell.[[HeldValue]]` 是活跃的；但是，这并不一定意味着 `cell.[[UnregisterToken]]` 或 `cell.[[Target]]` 是活跃的。例如，用对象自身作为其注销令牌注册一个对象不会使该对象永远存活。

###### 26.2.3.3 FinalizationRegistry.prototype.unregister ( unregisterToken )
此方法在调用时执行以下步骤：



1. 令 `finalizationRegistry` 为 `this` 值。
2. 执行 `? RequireInternalSlot(finalizationRegistry, [[Cells]])`。
3. 如果 `CanBeHeldWeakly(unregisterToken)` 为 `false`，抛出一个 `TypeError` 异常。
4. 令 `removed` 为 `false`。
5. 对于 `finalizationRegistry.[[Cells]]` 中的每个记录 `{ [[WeakRefTarget]], [[HeldValue]], [[UnregisterToken]] }` `cell`，执行：
    a. 如果 `cell.[[UnregisterToken]]` 不是 `EMPTY` 并且 `SameValue(cell.[[UnregisterToken]], unregisterToken)` 为 `true`，则：
        i. 从 `finalizationRegistry.[[Cells]]` 中移除 `cell`。
        ii. 将 `removed` 设置为 `true`。
6. 返回 `removed`。

###### 26.2.3.4 FinalizationRegistry.prototype [ @@toStringTag ]
@@toStringTag 属性的初始值是字符串 `"FinalizationRegistry"`。

此属性的属性为 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }。

##### 26.2.4 FinalizationRegistry 实例的属性
FinalizationRegistry 实例是继承自 FinalizationRegistry 原型的普通对象。FinalizationRegistry 实例也有 `[[Cells]]` 和 `[[CleanupCallback]]` 内部槽。

### 27 控制抽象对象

#### 27.1 迭代
##### 27.1.1 常见的迭代接口
接口是一组属性键，其关联值符合特定规范。任何提供所有符合接口规范的属性的对象都符合该接口。接口不是由独特的对象表示的。可能有许多分别实现的对象符合任何接口。单个对象可以符合多个接口。

###### 27.1.1.1 可迭代接口（The Iterable Interface）
可迭代接口包括表 77 中描述的属性：

**表 77：可迭代接口要求的属性**

| 属性名       | 值                                 | 要求                                                   |
|--------------|------------------------------------|--------------------------------------------------------|
| @@iterator   | 返回迭代器对象的函数               | 返回的对象必须符合迭代器接口（Iterator interface）。   |

###### 27.1.1.2 迭代器接口（The Iterator Interface）
实现迭代器接口的对象必须包括表 78 中的属性。这些对象也可以实现表 79 中的属性。

**表 78：迭代器接口要求的属性**

| 属性名       | 值                                    | 要求                                                                                                                                                                                                 |
|--------------|---------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| "next"       | 返回迭代器结果对象的函数              | 返回的对象必须符合迭代器结果接口（IteratorResult interface）。如果对迭代器的 `next` 方法的上一次调用返回了一个 `done` 属性为 `true` 的迭代器结果对象，则该对象的所有后续调用也应返回 `done` 属性为 `true` 的迭代器结果对象，但此要求不强制执行。 |

**注意 1**：可以向 `next` 函数传递参数，但它们的解释和有效性取决于目标迭代器。`for-of` 语句和其他常见的迭代器用户不传递任何参数，因此期望被这样使用的迭代器对象必须准备好处理没有参数的调用。

**表 79：迭代器接口可选的属性**

| 属性名       | 值                                    | 要求                                                                                                                                                                                             |
|--------------|---------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| "return"     | 返回迭代器结果对象的函数              | 返回的对象必须符合迭代器结果接口（IteratorResult interface）。调用此方法通知迭代器对象调用者不打算再对迭代器进行任何 `next` 方法调用。返回的迭代器结果对象通常具有 `done` 属性，其值为 `true`，以及 `value` 属性，值为传递给 `return` 方法的参数，但此要求不强制执行。 |
| "throw"      | 返回迭代器结果对象的函数              | 返回的对象必须符合迭代器结果接口（IteratorResult interface）。调用此方法通知迭代器对象调用者检测到错误条件。该参数可用于标识错误条件，通常将是一个异常对象。典型的响应是抛出作为参数传递的值。如果该方法不抛出，返回的迭代器结果对象通常具有 `done` 属性，其值为 `true`。 |

**注意 2**：调用这些方法的调用者通常应在调用它们之前检查其存在性。一些 ECMAScript 语言特性包括 `for-of`、`yield*` 和数组解构会在进行存在性检查后调用这些方法。大多数接受可迭代对象作为参数的 ECMAScript 库函数也有条件地调用它们。

###### 27.1.1.3 异步可迭代接口（The AsyncIterable Interface）
异步可迭代接口包括表 80 中描述的属性：

**表 80：异步可迭代接口要求的属性**

| 属性名           | 值                                    | 要求                                                                                           |
|------------------|---------------------------------------|------------------------------------------------------------------------------------------------|
| @@asyncIterator  | 返回异步迭代器对象的函数              | 返回的对象必须符合异步迭代器接口（AsyncIterator interface）。                                   |

###### 27.1.1.4 异步迭代器接口（The AsyncIterator Interface）
实现异步迭代器接口的对象必须包括表 81 中的属性。这些对象也可以实现表 82 中的属性。

**表 81：异步迭代器接口要求的属性**

| 属性名       | 值                                    | 要求                                                                                                                                                                                                                                                                 |
|--------------|---------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| "next"       | 返回承诺迭代器结果对象的函数           | 返回的承诺在履行时，必须履行一个符合迭代器结果接口（IteratorResult interface）的对象。如果对异步迭代器的 `next` 方法的上一次调用返回了一个 `done` 属性为 `true` 的迭代器结果对象的承诺，则该对象的所有后续调用也应返回 `done` 属性为 `true` 的迭代器结果对象的承诺，但此要求不强制执行。|

此外，作为履行值的迭代器结果对象应具有一个 `value` 属性，其值不是承诺（或 “thenable”）。但此要求也不强制执行。

**注意 1**：可以向 `next` 函数传递参数，但它们的解释和有效性取决于目标异步迭代器。`for-await-of` 语句和其他常见的异步迭代器用户不传递任何参数，因此期望被这样使用的异步迭代器对象必须准备好处理没有参数的调用。

**表 82：异步迭代器接口可选的属性**

| 属性名       | 值                                    | 要求                                                                                                                                                                                                                                                                                                               |
|--------------|---------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| "return"     | 返回承诺迭代器结果对象的函数           | 返回的承诺在履行时，必须履行一个符合迭代器结果接口（IteratorResult interface）的对象。调用此方法通知异步迭代器对象调用者不打算再对异步迭代器进行任何 `next` 方法调用。返回的承诺将履行一个迭代器结果对象，该对象通常具有 `done` 属性，其值为 `true`，以及 `value` 属性，值为传递给 `return` 方法的参数，但此要求不强制执行。|

此外，作为履行值的迭代器结果对象应具有一个 `value` 属性，其值不是承诺（或 “thenable”）。如果参数值以典型方式使用，则如果它是被拒绝的承诺，应返回一个被拒绝的承诺，该承诺因相同原因而被拒绝；如果它是被履行的承诺，则应使用其履行值作为返回的承诺的迭代器结果对象履行值的 `value` 属性。但这些要求也不强制执行。

| "throw"      | 返回承诺迭代器结果对象的函数           | 返回的承诺在履行时，必须履行一个符合迭代器结果接口（IteratorResult interface）的对象。调用此方法通知异步迭代器对象调用者检测到错误条件。该参数可用于标识错误条件，通常将是一个异常对象。典型的响应是返回一个因作为参数传递的值而被拒绝的承诺。如果返回的承诺已被履行，则迭代器结果履行值通常具有一个 `done` 属性，其值为 `true`。此外，它应具有一个 `value` 属性，其值不是承诺（或 “thenable”），但此要求不强制执行。|

**注意 2**：调用这些方法的调用者通常应在调用它们之前检查其存在性。一些 ECMAScript 语言特性包括 `for-await-of` 和 `yield*` 会在进行存在性检查后调用这些方法。

###### 27.1.1.5 迭代器结果接口（The IteratorResult Interface）
迭代器结果接口包括表 83 中列出的属性：

**表 83：迭代器结果接口的属性**

| 属性名       | 值                                    | 要求                                                                                                                                                                                |
|--------------|---------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| "done"       | 一个布尔值                             | 这是迭代器 `next` 方法调用的结果状态。如果迭代器的末端已到达，`done` 为 `true`。如果未到达末端，`done` 为 `false` 并且有一个值可用。如果没有 `done` 属性（无论是自有还是继承的），则其被认为具有 `false` 的值。 |
| "value"      | 一个 ECMAScript 语言值                | 如果 `done` 为 `false`，这是当前迭代元素值。如果 `done` 为 `true`，这是迭代器的返回值（如果有提供的话）。如果迭代器没有返回值，`value` 为 `undefined`。在这种情况下，如果对象没有继承显式的 `value` 属性，`value` 属性可能不存在。|

##### 27.1.2 %IteratorPrototype% 对象
%IteratorPrototype

% 对象：

- 具有 [[Prototype]] 内部槽，其值为 %Object.prototype%。
- 是一个普通对象。

**注意**：本规范中定义的所有实现迭代器接口的对象都继承自 %IteratorPrototype%。ECMAScript 代码也可以定义继承自 %IteratorPrototype% 的对象。%IteratorPrototype% 对象提供了一个可以添加适用于所有迭代器对象的其他方法的地方。

以下表达式是 ECMAScript 代码访问 %IteratorPrototype% 对象的一种方式：

```javascript
Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()))
```

###### 27.1.2.1 %IteratorPrototype% [ @@iterator ] ( )
调用此函数时执行以下步骤：

1. 返回 `this` 值。

该函数的 "name" 属性值为 "[Symbol.iterator]"。

##### 27.1.3 %AsyncIteratorPrototype% 对象
%AsyncIteratorPrototype% 对象：

- 具有 [[Prototype]] 内部槽，其值为 %Object.prototype%。
- 是一个普通对象。

**注意**：本规范中定义的所有实现异步迭代器接口的对象都继承自 %AsyncIteratorPrototype%。ECMAScript 代码也可以定义继承自 %AsyncIteratorPrototype% 的对象。%AsyncIteratorPrototype% 对象提供了一个可以添加适用于所有异步迭代器对象的其他方法的地方。

###### 27.1.3.1 %AsyncIteratorPrototype% [ @@asyncIterator ] ( )
调用此函数时执行以下步骤：

1. 返回 `this` 值。

该函数的 "name" 属性值为 "[Symbol.asyncIterator]"。

##### 27.1.4 从同步到异步的迭代器对象（Async-from-Sync Iterator Objects）
从同步到异步的迭代器对象是一个适配特定同步迭代器的异步迭代器对象。从同步到异步的迭代器对象从未直接对 ECMAScript 代码可访问。没有为从同步到异步的迭代器对象命名的构造函数。相反，从同步到异步的迭代器对象是通过需要时调用 `CreateAsyncFromSyncIterator` 抽象操作创建的。

###### 27.1.4.1 CreateAsyncFromSyncIterator ( syncIteratorRecord )
抽象操作 `CreateAsyncFromSyncIterator` 接受参数 `syncIteratorRecord`（一个迭代器记录），并返回一个迭代器记录。它用于从同步迭代器记录创建一个异步迭代器记录。调用时执行以下步骤：

1. 令 `asyncIterator` 为 `OrdinaryObjectCreate(%AsyncFromSyncIteratorPrototype%, « [[SyncIteratorRecord]] »)`。
2. 设置 `asyncIterator.[[SyncIteratorRecord]]` 为 `syncIteratorRecord`。
3. 令 `nextMethod` 为 `! Get(asyncIterator, "next")`。
4. 令 `iteratorRecord` 为迭代器记录 `{ [[Iterator]]: asyncIterator, [[NextMethod]]: nextMethod, [[Done]]: false }`。
5. 返回 `iteratorRecord`。

###### 27.1.4.2 %AsyncFromSyncIteratorPrototype% 对象
%AsyncFromSyncIteratorPrototype% 对象：

- 具有由所有从同步到异步的迭代器对象继承的属性。
- 是一个普通对象。
- 具有 [[Prototype]] 内部槽，其值为 %AsyncIteratorPrototype%。
- 从未直接对 ECMAScript 代码可访问。
- 具有以下属性：

###### 27.1.4.2.1 %AsyncFromSyncIteratorPrototype%.next ( [ value ] )
1. 令 `O` 为 `this` 值。
2. 断言：`O` 是一个具有 [[SyncIteratorRecord]] 内部槽的对象。
3. 令 `promiseCapability` 为 `! NewPromiseCapability(%Promise%)`。
4. 令 `syncIteratorRecord` 为 `O.[[SyncIteratorRecord]]`。
5. 如果 `value` 存在，则：
    a. 令 `result` 为 `Completion(IteratorNext(syncIteratorRecord, value))`。
6. 否则，
    a. 令 `result` 为 `Completion(IteratorNext(syncIteratorRecord))`。
7. `IfAbruptRejectPromise(result, promiseCapability)`。
8. 返回 `AsyncFromSyncIteratorContinuation(result, promiseCapability)`。

###### 27.1.4.2.2 %AsyncFromSyncIteratorPrototype%.return ( [ value ] )
1. 令 `O` 为 `this` 值。
2. 断言：`O` 是一个具有 [[SyncIteratorRecord]] 内部槽的对象。
3. 令 `promiseCapability` 为 `! NewPromiseCapability(%Promise%)`。
4. 令 `syncIterator` 为 `O.[[SyncIteratorRecord]].[[Iterator]]`。
5. 令 `return` 为 `Completion(GetMethod(syncIterator, "return"))`。
6. `IfAbruptRejectPromise(return, promiseCapability)`。
7. 如果 `return` 未定义，则：
    a. 令 `iterResult` 为 `CreateIterResultObject(value, true)`。
    b. 执行 `! Call(promiseCapability.[[Resolve]], undefined, « iterResult »)`。
    c. 返回 `promiseCapability.[[Promise]]`。
8. 如果 `value` 存在，则：
    a. 令 `result` 为 `Completion(Call(return, syncIterator, « value »))`。
9. 否则，
    a. 令 `result` 为 `Completion(Call(return, syncIterator))`。
10. `IfAbruptRejectPromise(result, promiseCapability)`。
11. 如果 `result` 不是一个对象，则：
    a. 执行 `! Call(promiseCapability.[[Reject]], undefined, « a newly created TypeError object »)`。
    b. 返回 `promiseCapability.[[Promise]]`。
12. 返回 `AsyncFromSyncIteratorContinuation(result, promiseCapability)`。

###### 27.1.4.2.3 %AsyncFromSyncIteratorPrototype%.throw ( [ value ] )
**注意**：在此规范中，总是提供 `value`，但为了与 %AsyncFromSyncIteratorPrototype%.return ([value]) 保持一致，`value` 被保留为可选项。

1. 令 `O` 为 `this` 值。
2. 断言：`O` 是一个具有 [[SyncIteratorRecord]] 内部槽的对象。
3. 令 `promiseCapability` 为 `! NewPromiseCapability(%Promise%)`。
4. 令 `syncIterator` 为 `O.[[SyncIteratorRecord]].[[Iterator]]`。
5. 令 `throw` 为 `Completion(GetMethod(syncIterator, "throw"))`。
6. `IfAbruptRejectPromise(throw, promiseCapability)`。
7. 如果 `throw` 未定义，则：
    a. 执行 `! Call(promiseCapability.[[Reject]], undefined, « value »)`。
    b. 返回 `promiseCapability.[[Promise]]`。
8. 如果 `value` 存在，则：
    a. 令 `result` 为 `Completion(Call(throw, syncIterator, « value »))`。
9. 否则，
    a. 令 `result` 为 `Completion(Call(throw, syncIterator))`。
10. `IfAbruptRejectPromise(result, promiseCapability)`。
11. 如果 `result` 不是一个对象，则：
    a. 执行 `! Call(promiseCapability.[[Reject]], undefined, « a newly created TypeError object »)`。
    b. 返回 `promiseCapability.[[Promise]]`。
12. 返回 `AsyncFromSyncIteratorContinuation(result, promiseCapability)`。

##### 27.1.4.3 Async-from-Sync 迭代器实例的属性
Async-from-Sync 迭代器实例是普通对象，继承自 %AsyncFromSyncIteratorPrototype% 内在对象。Async-from-Sync 迭代器实例最初创建时具有表 84 中列出的内部槽。

**表 84：Async-from-Sync 迭代器实例的内部槽**

| 内部槽名           | 类型            | 描述                                            |
|--------------------|-----------------|-------------------------------------------------|
| [[SyncIteratorRecord]] | 一个迭代器记录 | 表示正在适配的原始同步迭代器。                  |

##### 27.1.4.4 AsyncFromSyncIteratorContinuation ( result, promiseCapability )
抽象操作 `AsyncFromSyncIteratorContinuation` 接受参数 `result`（一个对象）和 `promiseCapability`（一个内在 %Promise% 的 PromiseCapability 记录），返回一个承诺。调用时执行以下步骤：

1. **注意**：由于 `promiseCapability` 是从内在 %Promise% 派生的，因此使用 IfAbruptRejectPromise 的 `promiseCapability.[[Reject]]` 的调用保证不会抛出。
2. 令 `done` 为 `Completion(IteratorComplete(result))`。
3. `IfAbruptRejectPromise(done, promiseCapability)`。
4. 令 `value` 为 `Completion(IteratorValue(result))`。
5. `IfAbruptRejectPromise(value, promiseCapability)`。
6. 令 `valueWrapper` 为 `Completion(PromiseResolve(%Promise%, value))`。
7. `IfAbruptRejectPromise(valueWrapper, promiseCapability)`。
8. 令 `unwrap` 为

一个新的抽象闭包，其参数为 `(v)`，捕获 `done` 并在调用时执行以下步骤：
    a. 返回 `CreateIterResultObject(v, done)`。
9. 令 `onFulfilled` 为 `CreateBuiltinFunction(unwrap, 1, "", « »)`。
10. **注意**：`onFulfilled` 在处理迭代器结果对象的 `value` 属性时使用，以等待其值（如果它是一个承诺）并在新的“未包装”迭代器结果对象中重新包装结果。
11. 执行 `PerformPromiseThen(valueWrapper, onFulfilled, undefined, promiseCapability)`。
12. 返回 `promiseCapability.[[Promise]]`。

---

### 27 控制抽象对象

#### 27.2 Promise 对象
Promise 是一个用于表示延迟（和可能异步）计算结果的对象。

任何 Promise 都处于以下三种互斥状态之一：已履行（fulfilled）、已拒绝（rejected）和待定（pending）：

- 如果 `p.then(f, r)` 将立即排队一个作业以调用函数 `f`，则 promise `p` 为已履行状态。
- 如果 `p.then(f, r)` 将立即排队一个作业以调用函数 `r`，则 promise `p` 为已拒绝状态。
- 如果 promise 既不是已履行也不是已拒绝，则为待定状态。

promise 被称为已解决（settled）如果它不是待定的，即如果它是已履行或已拒绝。

promise 被称为已解析（resolved）如果它已解决或如果它已“锁定”以匹配另一个 promise 的状态。试图解析或拒绝一个已解析的 promise 没有任何效果。promise 被称为未解析（unresolved）如果它未解析。未解析的 promise 总是处于待定状态。已解析的 promise 可能是待定、已履行或已拒绝。

##### 27.2.1 Promise 抽象操作

###### 27.2.1.1 PromiseCapability 记录
PromiseCapability 记录是一个记录值，用于封装一个 Promise 或类 Promise 对象以及能够解决或拒绝该 Promise 的函数。PromiseCapability 记录由 `NewPromiseCapability` 抽象操作生成。

PromiseCapability 记录具有表 85 中列出的字段。

**表 85：PromiseCapability 记录字段**

| 字段名   | 值            | 含义                 |
|----------|---------------|----------------------|
| [[Promise]] | 一个对象      | 一个可用作 promise 的对象。 |
| [[Resolve]] | 一个函数对象  | 用于解决给定 promise 的函数。 |
| [[Reject]]  | 一个函数对象  | 用于拒绝给定 promise 的函数。 |

###### 27.2.1.1.1 IfAbruptRejectPromise ( value, capability )
`IfAbruptRejectPromise` 是使用 `PromiseCapability` 记录的一系列算法步骤的简写。形式为：

1. `IfAbruptRejectPromise(value, capability)`。

意味着与以下步骤相同：

1. 断言：`value` 是一个完成记录。
2. 如果 `value` 是一个突然完成，那么：
    a. 执行 `? Call(capability.[[Reject]], undefined, « value.[[Value]] »)`。
    b. 返回 `capability.[[Promise]]`。
3. 否则，
    a. 设置 `value` 为 `! value`。

###### 27.2.1.2 PromiseReaction 记录
PromiseReaction 记录是一个记录值，用于存储 promise 在以给定值解决或拒绝时应如何反应的信息。PromiseReaction 记录由 `PerformPromiseThen` 抽象操作创建，并由 `NewPromiseReactionJob` 返回的抽象闭包使用。

PromiseReaction 记录具有表 86 中列出的字段。

**表 86：PromiseReaction 记录字段**

| 字段名     | 值                         | 含义                                                                                  |
|------------|----------------------------|---------------------------------------------------------------------------------------|
| [[Capability]] | PromiseCapability 记录或未定义 | 提供反应处理程序的 promise 的能力。                                                    |
| [[Type]]       | FULFILL 或 REJECT       | 当 [[Handler]] 为 EMPTY 时，使用 [[Type]] 以允许针对结算类型的特定行为。               |
| [[Handler]]    | JobCallback 记录或 EMPTY | 应用于传入值的函数，其返回值将决定派生 promise 的结果。如果 [[Handler]] 为 EMPTY，则使用取决于 [[Type]] 的函数。 |

###### 27.2.1.3 CreateResolvingFunctions ( promise )
抽象操作 `CreateResolvingFunctions` 接受参数 `promise`（一个 Promise），并返回一个包含字段 [[Resolve]]（一个函数对象）和 [[Reject]]（一个函数对象）的记录。调用时执行以下步骤：

1. 令 `alreadyResolved` 为记录 { [[Value]]: false }。
2. 令 `stepsResolve` 为 `Promise Resolve Functions` 中定义的算法步骤。
3. 令 `lengthResolve` 为 `Promise Resolve Functions` 中函数定义的非可选参数的数量。
4. 令 `resolve` 为 `CreateBuiltinFunction(stepsResolve, lengthResolve, "", « [[Promise]], [[AlreadyResolved]] »)`。
5. 设置 `resolve.[[Promise]]` 为 `promise`。
6. 设置 `resolve.[[AlreadyResolved]]` 为 `alreadyResolved`。
7. 令 `stepsReject` 为 `Promise Reject Functions` 中定义的算法步骤。
8. 令 `lengthReject` 为 `Promise Reject Functions` 中函数定义的非可选参数的数量。
9. 令 `reject` 为 `CreateBuiltinFunction(stepsReject, lengthReject, "", « [[Promise]], [[AlreadyResolved]] »)`。
10. 设置 `reject.[[Promise]]` 为 `promise`。
11. 设置 `reject.[[AlreadyResolved]]` 为 `alreadyResolved`。
12. 返回记录 { [[Resolve]]: resolve, [[Reject]]: reject }。

###### 27.2.1.3.1 Promise Reject Functions
Promise 拒绝函数是一个匿名内置函数，具有 [[Promise]] 和 [[AlreadyResolved]] 内部槽。

调用 promise 拒绝函数时，使用参数 `reason` 执行以下步骤：

1. 令 `F` 为活动函数对象。
2. 断言：`F` 具有值为一个对象的 [[Promise]] 内部槽。
3. 令 `promise` 为 `F.[[Promise]]`。
4. 令 `alreadyResolved` 为 `F.[[AlreadyResolved]]`。
5. 如果 `alreadyResolved.[[Value]]` 为 `true`，则返回 `undefined`。
6. 设置 `alreadyResolved.[[Value]]` 为 `true`。
7. 执行 `RejectPromise(promise, reason)`。
8. 返回 `undefined`。

promise 拒绝函数的 "length" 属性值为 `1𝔽`。

###### 27.2.1.3.2 Promise Resolve Functions
Promise 解决函数是一个匿名内置函数，具有 [[Promise]] 和 [[AlreadyResolved]] 内部槽。

调用 promise 解决函数时，使用参数 `resolution` 执行以下步骤：

1. 令 `F` 为活动函数对象。
2. 断言：`F` 具有值为一个对象的 [[Promise]] 内部槽。
3. 令 `promise` 为 `F.[[Promise]]`。
4. 令 `alreadyResolved` 为 `F.[[AlreadyResolved]]`。
5. 如果 `alreadyResolved.[[Value]]` 为 `true`，则返回 `undefined`。
6. 设置 `alreadyResolved.[[Value]]` 为 `true`。
7. 如果 `SameValue(resolution, promise)` 为 `true`，则：
    a. 令 `selfResolutionError` 为一个新创建的 `TypeError` 对象。
    b. 执行 `RejectPromise(promise, selfResolutionError)`。
    c. 返回 `undefined`。
8. 如果 `resolution` 不是对象，则：
    a. 执行 `FulfillPromise(promise, resolution)`。
    b. 返回 `undefined`。
9. 令 `then` 为 `Completion(Get(resolution, "then"))`。
10. 如果 `then` 是一个突然完成，则：
    a. 执行 `RejectPromise(promise, then.[[Value]])`。
    b. 返回 `undefined`。
11. 令 `thenAction` 为 `then.[[Value]]`。
12. 如果 `IsCallable(thenAction)` 为 `false`，则：
    a. 执行 `FulfillPromise(promise, resolution)`。
    b. 返回 `undefined`。
13. 令 `thenJobCallback` 为 `HostMakeJobCallback(thenAction)`。
14. 令 `job` 为 `NewPromiseResolveThenableJob(promise, resolution, thenJobCallback)`。
15. 执行 `HostEnqueuePromiseJob(job.[[Job]], job.[[Realm]])`。
16. 返回 `undefined`。

promise 解决函数的 "length" 属性值为 `1𝔽`。

###### 27.2.1.4 FulfillPromise ( promise, value )

[[Realm]]`（一个 Realm 记录或 null）的记录。它返回一个新的作业抽象闭包，该闭包以一种约定的方式解析传入的 thenable，并使用 thenable 的解决值来解决 promiseToResolve。调用时执行以下步骤：

1. 令 job 为一个新的作业抽象闭包，无参数，捕获 promiseToResolve、thenable 和 then 并在调用时执行以下步骤：
   a. 令 resolveResult 为 `HostPromiseResolve(thenable, then, promiseToResolve.[[PromiseIsHandled]])`。
   b. 如果 resolveResult 是一个突然完成，则
      i. 返回 `? Call(promiseToResolve.[[Reject]], undefined, « resolveResult.[[Value]] »)`。
   c. 令 resolutionJob 为 `NewPromiseReactionJob({ [[Capability]]: promiseToResolve, [[Type]]: "Fulfill", [[Handler]]: promiseToResolve.[[Resolve]] }, resolveResult.[[Value]])`。
   d. 执行 `HostEnqueuePromiseJob(resolutionJob.[[Job]], resolutionJob.[[Realm]])`。
2. 令 handlerRealm 为 null。
3. 返回记录 { [[Job]]: job, [[Realm]]: handlerRealm }。

### 27.2.3 Properties of the Promise Constructor
### 27.2.3 Promise 构造函数

**Promise 构造函数：**

- 是 `%Promise%`。
- 是全局对象的 "Promise" 属性的初始值。
- 当作为构造函数调用时创建和初始化一个新的 Promise。
- 不打算作为函数调用，如果以该方式调用会抛出异常。
- 可以作为类定义中 `extends` 子句中的值。意图继承指定的 Promise 行为的子类构造函数必须包括一个对 Promise 构造函数的 super 调用，以创建和初始化支持 Promise 和 Promise.prototype 内建方法所需的子类实例的内部状态。

### 27.2.3.1 Promise ( executor )

调用时执行以下步骤：

1. 如果 NewTarget 为 undefined，则抛出一个 TypeError 异常。
2. 如果 IsCallable(executor) 为 false，则抛出一个 TypeError 异常。
3. 令 promise 为 `? OrdinaryCreateFromConstructor(NewTarget, "%Promise.prototype%", « [[PromiseState]], [[PromiseResult]], [[PromiseFulfillReactions]], [[PromiseRejectReactions]], [[PromiseIsHandled]] »)`。
4. 将 promise.[[PromiseState]] 设置为 PENDING。
5. 将 promise.[[PromiseFulfillReactions]] 设置为一个新的空列表。
6. 将 promise.[[PromiseRejectReactions]] 设置为一个新的空列表。
7. 将 promise.[[PromiseIsHandled]] 设置为 false。
8. 令 resolvingFunctions 为 `CreateResolvingFunctions(promise)`。
9. 令 completion 为 `Completion(Call(executor, undefined, « resolvingFunctions.[[Resolve]], resolvingFunctions.[[Reject]] »))`。
10. 如果 completion 是一个突然完成，则
    a. 执行 `? Call(resolvingFunctions.[[Reject]], undefined, « completion.[[Value]] »)`。
11. 返回 promise。

**注意：**
executor 参数必须是一个函数对象。它被调用来启动和报告可能延迟执行的操作的完成。executor 接收两个参数：resolve 和 reject。这些函数可以被 executor 函数用来报告延迟计算的最终完成或失败。从 executor 函数返回并不意味着延迟操作已经完成，而只是请求最终执行延迟操作的接受。

resolve 函数被传递给 executor 函数，接受一个参数。executor 代码最终可能调用 resolve 函数来指示它希望解析相关的 Promise。传递给 resolve 函数的参数表示延迟操作的最终值，可以是实际的完成值，也可以是另一个 Promise，如果它被解析将提供值。

reject 函数被传递给 executor 函数，接受一个参数。executor 代码最终可能调用 reject 函数来指示相关的 Promise 被拒绝，并且将永远不会被解析。传递给 reject 函数的参数被用作 Promise 的拒绝值。通常会是一个 Error 对象。

由 Promise 构造函数传递给 executor 函数的 resolve 和 reject 函数具有实际解析和拒绝相关 Promise 的能力。子类可以具有不同的构造函数行为，通过传入定制的值来定义 resolve 和 reject。

### 27.2.4 Promise 构造函数的属性

**Promise 构造函数：**

- 具有一个 `[[Prototype]]` 内部插槽，其值为 `%Function.prototype%`。
- 具有以下属性：

#### 27.2.4.1 Promise.all ( iterable )

该函数返回一个新的 Promise，该 Promise 将以传递的 Promise 的完成值数组解析，或者以第一个拒绝的 Promise 的原因拒绝。它在运行此算法时将传递的可迭代对象的所有元素解析为 Promise。

1. 令 C 为当前函数对象。
2. 令 promiseCapability 为 `? NewPromiseCapability(C)`。
3. 令 promiseResolve 为 `Completion(GetPromiseResolve(C))`。
4. 如果 `IfAbruptRejectPromise(promiseResolve, promiseCapability)`。
5. 令 iteratorRecord 为 `Completion(GetIterator(iterable, SYNC))`。
6. 如果 `IfAbruptRejectPromise(iteratorRecord, promiseCapability)`。
7. 令 result 为 `Completion(PerformPromiseAll(iteratorRecord, C, promiseCapability, promiseResolve))`。
8. 如果 result 是一个突然完成，则
   a. 如果 iteratorRecord.[[Done]] 为 false，则将 result 设置为 `Completion(IteratorClose(iteratorRecord, result))`。
   b. `IfAbruptRejectPromise(result, promiseCapability)`。
9. 返回 `? result`。

**注意：**
该函数要求其 this 值是支持 Promise 构造函数参数约定的构造函数。

### 27.2.4.1.1 GetPromiseResolve ( promiseConstructor )

抽象操作 GetPromiseResolve 接收参数 promiseConstructor（一个构造函数），并返回一个包含函数对象的正常完成或抛出完成。调用时执行以下步骤：

1. 令 promiseResolve 为 `? Get(promiseConstructor, "resolve")`。
2. 如果 `IsCallable(promiseResolve)` 为 false，则抛出一个 TypeError 异常。
3. 返回 promiseResolve。

### 27.2.4.1.2 PerformPromiseAll ( iteratorRecord, constructor, resultCapability, promiseResolve )

抽象操作 PerformPromiseAll 接收参数 iteratorRecord（一个迭代器记录）、constructor（一个构造函数）、resultCapability（一个 PromiseCapability 记录）和 promiseResolve（一个函数对象），并返回一个包含 ECMAScript 语言值的正常完成或抛出完成。调用时执行以下步骤：

1. 令 values 为一个新的空列表。
2. 令 remainingElementsCount 为记录 `{ [[Value]]: 1 }`。
3. 令 index 为 0。
4. 重复以下步骤，
   a. 令 next 为 `? IteratorStepValue(iteratorRecord)`。
   b. 如果 next 为 DONE，则
      i. 将 remainingElementsCount.[[Value]] 减去 1。
      ii. 如果 `remainingElementsCount.[[Value]] = 0`，则
          1. 令 valuesArray 为 `CreateArrayFromList(values)`。
          2. 执行 `? Call(resultCapability.[[Resolve]], undefined, « valuesArray »)`。
      iii. 返回 `resultCapability.[[Promise]]`。
   c. 将 undefined 追加到 values。
   d. 令 nextPromise 为 `? Call(promiseResolve, constructor, « next »)`。
   e. 令 steps 为 Promise.all Resolve Element Functions 中定义的算法步骤。
   f. 令 length 为 Promise.all Resolve Element Functions 中函数定义的非可选参数数量。
   g. 令 onFulfilled 为 `CreateBuiltinFunction(steps, length, "", « [[AlreadyCalled]], [[Index]], [[Values]], [[Capability]], [[RemainingElements]] »)`。
   h. 将 `onFulfilled.[[AlreadyCalled]]` 设置为 false。
   i. 将 `onFulfilled.[[Index]]` 设置为 index。
   j. 将 `onFulfilled.[[Values]]` 设置为 values。
   k. 将 `onFulfilled.[[Capability]]` 设置为 resultCapability。
   l. 将 `onFulfilled.[[RemainingElements]]` 设置为 remainingElementsCount。
   m. 将 `remainingElementsCount.[[Value]]` 增加 1。
   n. 执行 `? Invoke(nextPromise, "then", « onFulfilled, resultCapability.[[Reject]] »)`。
   o. 将 index 增加 1。

### 27.2.4.1.3 Promise.all Resolve Element Functions

Promise.all resolve element functions 是用于解析特定 Promise.all 元素的匿名内置函数。每个 Promise.all resolve element function 具有 `[[Index]]`、`[[Values]]`、`[[Capability]]`、`[[RemainingElements]]` 和 `[[AlreadyCalled]]` 内部插槽。

当调用一个 Promise.all resolve element function 时，带有参数 x，执行以下步骤：

1. 令 F 为当前活动的函数对象。
2. 如果 `F.[[AlreadyCalled]]` 为 true，则返回 undefined。
3. 将 `F.[[AlreadyCalled]]` 设置为 true。
4. 令 index 为 `F.[[Index]]`。
5. 令 values 为 `F.[[Values]]`。
6. 令 promiseCapability 为 `F.[[Capability]]`。
7. 令 remainingElementsCount 为 `F.[[RemainingElements]]`。
8. 将 values[index] 设置为 x。
9. 将 `remainingElementsCount.[[Value]]` 减去 1。
10. 如果 `remainingElementsCount.[[Value]] = 0`，则
    a. 令 valuesArray 为 `CreateArrayFromList(values)`。
    b. 返回 `? Call(promiseCapability.[[Resolve]], undefined, « valuesArray »)`。
11. 返回 undefined。

Promise.all resolve element function 的 "length" 属性为 1𝔽。

### 27.2.4.2 Promise.allSettled ( iterable )

该函数返回一个 Promise，该 Promise 在所有原始 Promise 已经 settled（即已被 fulfilled 或 rejected）后，以一个 Promise 状态快照数组来成功解析。它会在运行该算法时将传入的可迭代对象的所有元素转换为 Promise。

1. 令 C 为当前的 this 值。
2. 令 promiseCapability 为 `? NewPromiseCapability(C)`。
3. 令 promiseResolve 为 `Completion(GetPromiseResolve(C))`。
4. 如果 `IfAbruptRejectPromise(promiseResolve, promiseCapability)`。
5. 令 iteratorRecord 为 `Completion(GetIterator(iterable, SYNC))`。
6. 如果 `IfAbruptRejectPromise(iteratorRecord, promiseCapability)`。
7. 令 result 为 `Completion(PerformPromiseAllSettled(iteratorRecord, C, promiseCapability, promiseResolve))`。
8. 如果 result 是突发完成，则
   a. 如果 `iteratorRecord.[[Done]]` 为 false，则将 result 设置为 `Completion(IteratorClose(iteratorRecord, result))`。
   b. `IfAbruptRejectPromise(result, promiseCapability)`。
9. 返回 `? result`。

**注意：** 该函数要求其 this 值是一个支持 Promise 构造函数参数约定的构造函数。

### 27.2.4.2.1 PerformPromiseAllSettled ( iteratorRecord, constructor, resultCapability, promiseResolve )

抽象操作 PerformPromiseAllSettled 接收参数 iteratorRecord（一个迭代器记录）、constructor（一个构造函数）、resultCapability（一个 PromiseCapability 记录）和 promiseResolve（一个函数对象），并返回一个包含 ECMAScript 语言值的正常完成或抛出完成。调用时执行以下步骤：

1. 令 values 为一个新的空列表。
2. 令 remainingElementsCount 为记录 `{ [[Value]]: 1 }`。
3. 令 index 为 0。
4. 重复以下步骤，
   a. 令 next 为 `? IteratorStepValue(iteratorRecord)`。
   b. 如果 next 为 DONE，则
      i. 将 `remainingElementsCount.[[Value]]` 减去 1。
      ii. 如果 `remainingElementsCount.[[Value]] = 0`，则
          1. 令 valuesArray 为 `CreateArrayFromList(values)`。
          2. 执行 `? Call(resultCapability.[[Resolve]], undefined, « valuesArray »)`。
      iii. 返回 `resultCapability.[[Promise]]`。
   c. 将 undefined 追加到 values。
   d. 令 nextPromise 为 `? Call(promiseResolve, constructor, « next »)`。
   e. 令 stepsFulfilled 为 Promise.allSettled Resolve Element Functions 中定义的算法步骤。
   f. 令 lengthFulfilled 为 Promise.allSettled Resolve Element Functions 中函数定义的非可选参数数量。
   g. 令 onFulfilled 为 `CreateBuiltinFunction(stepsFulfilled, lengthFulfilled, "", « [[AlreadyCalled]], [[Index]], [[Values]], [[Capability]], [[RemainingElements]] »)`。
   h. 令 alreadyCalled 为记录 `{ [[Value]]: false }`。
   i. 将 `onFulfilled.[[AlreadyCalled]]` 设置为 alreadyCalled。
   j. 将 `onFulfilled.[[Index]]` 设置为 index。
   k. 将 `onFulfilled.[[Values]]` 设置为 values。
   l. 将 `onFulfilled.[[Capability]]` 设置为 resultCapability。
   m. 将 `onFulfilled.[[RemainingElements]]` 设置为 remainingElementsCount。
   n. 令 stepsRejected 为 Promise.allSettled Reject Element Functions 中定义的算法步骤。
   o. 令 lengthRejected 为 Promise.allSettled Reject Element Functions 中函数定义的非可选参数数量。
   p. 令 onRejected 为 `CreateBuiltinFunction(stepsRejected, lengthRejected, "", « [[AlreadyCalled]], [[Index]], [[Values]], [[Capability]], [[RemainingElements]] »)`。
   q. 将 `onRejected.[[AlreadyCalled]]` 设置为 alreadyCalled。
   r. 将 `onRejected.[[Index]]` 设置为 index。
   s. 将 `onRejected.[[Values]]` 设置为 values。
   t. 将 `onRejected.[[Capability]]` 设置为 resultCapability。
   u. 将 `onRejected.[[RemainingElements]]` 设置为 remainingElementsCount。
   v. 将 `remainingElementsCount.[[Value]]` 增加 1。
   w. 执行 `? Invoke(nextPromise, "then", « onFulfilled, onRejected »)`。
   x. 将 index 增加 1。

### 27.2.4.2.2 Promise.allSettled Resolve Element Functions

Promise.allSettled resolve element function 是一个用于解析特定 Promise.allSettled 元素的匿名内置函数。每个 Promise.allSettled resolve element function 具有 `[[Index]]`、`[[Values]]`、`[[Capability]]`、`[[RemainingElements]]` 和 `[[AlreadyCalled]]` 内部插槽。

当调用一个 Promise.allSettled resolve element function 时，带有参数 x，执行以下步骤：

1. 令 F 为当前活动的函数对象。
2. 令 alreadyCalled 为 `F.[[AlreadyCalled]]`。
3. 如果 `alreadyCalled.[[Value]]` 为 true，则返回 undefined。
4. 将 `alreadyCalled.[[Value]]` 设置为 true。
5. 令 index 为 `F.[[Index]]`。
6. 令 values 为 `F.[[Values]]`。
7. 令 promiseCapability 为 `F.[[Capability]]`。
8. 令 remainingElementsCount 为 `F.[[RemainingElements]]`。
9. 令 obj 为 `OrdinaryObjectCreate(%Object.prototype%)`。
10. 执行 `! CreateDataPropertyOrThrow(obj, "status", "fulfilled")`。
11. 执行 `! CreateDataPropertyOrThrow(obj, "value", x)`。
12. 将 values[index] 设置为 obj。
13. 将 `remainingElementsCount.[[Value]]` 减去 1。
14. 如果 `remainingElementsCount.[[Value]] = 0`，则
    a. 令 valuesArray 为 `CreateArrayFromList(values)`。
    b. 返回 `? Call(promiseCapability.[[Resolve]], undefined, « valuesArray »)`。
15. 返回 undefined。

Promise.allSettled resolve element function 的 "length" 属性为 1𝔽。

### 27.2.4.2.3 Promise.allSettled Reject Element Functions

Promise.allSettled reject element function 是一个用于拒绝特定 Promise.allSettled 元素的匿名内置函数。每个 Promise.allSettled reject element function 具有 `[[Index]]`、`[[Values]]`、`[[Capability]]`、`[[RemainingElements]]` 和 `[[AlreadyCalled]]` 内部插槽。

当调用一个 Promise.allSettled reject element function 时，带有参数 x，执行以下步骤：

1. 令 F 为当前活动的函数对象。
2. 令 alreadyCalled 为 `F.[[AlreadyCalled]]`。
3. 如果 `alreadyCalled.[[Value]]` 为 true，则返回 undefined。
4. 将 `alreadyCalled.[[Value]]` 设置为 true。
5. 令 index 为 `F.[[Index]]`。
6. 令 values 为 `F.[[Values]]`。
7. 令 promiseCapability 为 `F.[[Capability]]`。
8. 令 remainingElementsCount 为 `F.[[RemainingElements]]`。
9. 令 obj 为 `OrdinaryObjectCreate(%Object.prototype%)`。
10. 执行 `! CreateDataPropertyOrThrow(obj, "status", "rejected")`。
11. 执行 `! CreateDataPropertyOrThrow(obj, "reason", x)`。
12. 将 `values[index]` 设置为 obj。
13. 将 `remainingElementsCount.[[Value]]` 减去 1。
14. 如果 `remainingElementsCount.[[Value]] = 0`，则
    a. 令 valuesArray 为 `CreateArrayFromList(values)`。
    b. 返回 `? Call(promiseCapability.[[Resolve]], undefined, « valuesArray »)`。
15. 返回 undefined。

Promise.allSettled reject element function 的 "length" 属性为 1𝔽。

---

### 27.2.4.3 Promise.any ( iterable )

该函数返回一个 Promise，在传入的多个 Promise 中有一个首先被 fulfilled 时成功解析，或者当所有给定的 Promise 都被 rejected 时，以包含拒绝原因的 AggregateError 拒绝。它会在运行该算法时将传入的可迭代对象的所有元素转换为 Promise。

1. 令 C 为当前的 this 值。
2. 令 promiseCapability 为 `? NewPromiseCapability(C)`。
3. 令 promiseResolve 为 `Completion(GetPromiseResolve(C))`。
4. 如果 `IfAbruptRejectPromise(promiseResolve, promiseCapability)`。
5. 令 iteratorRecord 为 `Completion(GetIterator(iterable, SYNC))`。
6. 如果 `IfAbruptRejectPromise(iteratorRecord, promiseCapability)`。
7. 令 result 为 `Completion(PerformPromiseAny(iteratorRecord, C, promiseCapability, promiseResolve))`。
8. 如果 result 是突发完成，则
   a. 如果 `iteratorRecord.[[Done]]` 为 false，则将 result 设置为 `Completion(IteratorClose(iteratorRecord, result))`。
   b. `IfAbruptRejectPromise(result, promiseCapability)`。
9. 返回 `? result`。

**注意：** 该函数要求其 this 值是一个支持 Promise 构造函数参数约定的构造函数。

### 27.2.4.3.1 PerformPromiseAny ( iteratorRecord, constructor, resultCapability, promiseResolve )

抽象操作 PerformPromiseAny 接收参数 iteratorRecord（一个迭代器记录）、constructor（一个构造函数）、resultCapability（一个 PromiseCapability 记录）和 promiseResolve（一个函数对象），并返回一个包含 ECMAScript 语言值的正常完成或抛出完成。调用时执行以下步骤：

1. 令 errors 为一个新的空列表。
2. 令 remainingElementsCount 为记录 `{ [[Value]]: 1 }`。
3. 令 index 为 0。
4. 重复以下步骤，
   a. 令 next 为 `? IteratorStepValue(iteratorRecord)`。
   b. 如果 next 为 DONE，则
      i. 将 `remainingElementsCount.[[Value]]` 减去 1。
      ii. 如果 `remainingElementsCount.[[Value]] = 0`，则
          1. 令 error 为一个新创建的 AggregateError 对象。
          2. 执行 `! DefinePropertyOrThrow(error, "errors", PropertyDescriptor { [[Configurable]]: true, [[Enumerable]]: false, [[Writable]]: true, [[Value]]: CreateArrayFromList(errors) })`。
          3. 返回 ThrowCompletion(error)。
      iii. 返回 `resultCapability.[[Promise]]`。
   c. 将 undefined 追加到 errors。
   d. 令 nextPromise 为 `? Call(promiseResolve, constructor, « next »)`。
   e. 令 stepsRejected 为 Promise.any Reject Element Functions 中定义的算法步骤。
   f. 令 lengthRejected 为 Promise.any Reject Element Functions 中函数定义的非可选参数数量。
   g. 令 onRejected 为 `CreateBuiltinFunction(stepsRejected, lengthRejected, "", « [[AlreadyCalled]], [[Index]], [[Errors]], [[Capability]], [[RemainingElements]] »)`。
   h. 将 `onRejected.[[AlreadyCalled]]` 设置为 false。
   i. 将 `onRejected.[[Index]]` 设置为 index。
   j. 将 `onRejected.[[Errors]]` 设置为 errors。
   k. 将 `onRejected.[[Capability]]` 设置为 resultCapability。
   l. 将 `onRejected.[[RemainingElements]]` 设置为 remainingElementsCount。
   m. 将 `remainingElementsCount.[[Value]]` 增加 1。
   n. 执行 `? Invoke(nextPromise, "then", « resultCapability.[[Resolve]], onRejected »)`。
   o. 将 index 增加 1。

### 27.2.4.3.2 Promise.any Reject Element Functions

Promise.any reject element function 是一个用于拒绝特定 Promise.any 元素的匿名内置函数。每个 Promise.any reject element function 具有 `[[Index]]`、`[[Errors]]`、`[[Capability]]`、`[[RemainingElements]]` 和 `[[AlreadyCalled]]` 内部插槽。

当调用一个 Promise.any reject element function 时，带有参数 x，执行以下步骤：

1. 令 F 为当前活动的函数对象。
2. 如果 `F.[[AlreadyCalled]]` 为 true，则返回 undefined。
3. 将 `F.[[AlreadyCalled]]` 设置为 true。
4. 令 index 为 `F.[[Index]]`。
5. 令 errors 为 `F.[[Errors]]`。
6. 令 promiseCapability 为 `F.[[Capability]]`。
7. 令 remainingElementsCount 为 `F.[[RemainingElements]]`。
8. 将 `errors[index]` 设置为 x。
9. 将 `remainingElementsCount.[[Value]]` 减去 1。
10. 如果 `remainingElementsCount.[[Value]] = 0`，则
    a. 令 error 为一个新创建的 AggregateError 对象。
    b. 执行 `! DefinePropertyOrThrow(error, "errors", PropertyDescriptor { [[Configurable]]: true, [[Enumerable]]: false, [[Writable]]: true, [[Value]]: CreateArrayFromList(errors) })`。
    c. 返回 `? Call(promiseCapability.[[Reject]], undefined, « error »)`。
11. 返回 undefined。

Promise.any reject element function 的 "length" 属性为 1𝔽。

---

### 27.2.4.4 Promise.prototype

Promise.prototype 的初始值是 Promise 原型对象。

该属性具有属性描述符 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }。

---

### 27.2.4.5 Promise.race ( iterable )

该函数返回一个新的 Promise，其状态与首个完成的传入 Promise 相同。它会在运行该算法时将传入的可迭代对象的所有元素转换为 Promise。

1. 令 C 为当前的 this 值。
2. 令 promiseCapability 为 `? NewPromiseCapability(C)`。
3. 令 promiseResolve 为 `Completion(GetPromiseResolve(C))`。
4. 如果 `IfAbruptRejectPromise(promiseResolve, promiseCapability)`。
5. 令 iteratorRecord 为 `Completion(GetIterator(iterable, SYNC))`。
6. 如果 `IfAbruptRejectPromise(iteratorRecord, promiseCapability)`。
7. 令 result 为 `Completion(PerformPromiseRace(iteratorRecord, C, promiseCapability, promiseResolve))`。
8. 如果 result 是突发完成，则
   a. 如果 `iteratorRecord.[[Done]]` 为 false，则将 result 设置为 `Completion(IteratorClose(iteratorRecord, result))`。
   b. `IfAbruptRejectPromise(result, promiseCapability)`。
9. 返回 `? result`。

**注意 1：** 如果可迭代对象没有产生值，或者可迭代对象中的所有 Promise 都未完成，那么该方法返回的待定 Promise 将永远不会被解决。

**注意 2：** 该函数期望其 this 值是一个支持 Promise 构造函数参数约定的构造函数，并且期望其 this 值提供一个 resolve 方法。

### 27.2.4.5.1 PerformPromiseRace ( iteratorRecord, constructor, resultCapability, promiseResolve )

### 27.2.4.5.1 PerformPromiseRace ( iteratorRecord, constructor, resultCapability, promiseResolve )

抽象操作 PerformPromiseRace 接收参数 iteratorRecord（一个迭代器记录）、constructor（一个构造函数）、resultCapability（一个 PromiseCapability 记录）和 promiseResolve（一个函数对象），并返回一个包含 ECMAScript 语言值的正常完成或抛出完成。调用时执行以下步骤：

1. 重复以下步骤：
   a. 令 next 为 `? IteratorStepValue(iteratorRecord)`。
   b. 如果 next 为 DONE，则
      i. 返回 `resultCapability.[[Promise]]`。
   c. 令 nextPromise 为 `? Call(promiseResolve, constructor, « next »)`。
   d. 执行 `? Invoke(nextPromise, "then", « resultCapability.[[Resolve]], resultCapability.[[Reject]] »)`。

---

### 27.2.4.6 Promise.reject ( r )

该函数返回一个被传入参数 r 拒绝的新 Promise。

1. 令 C 为当前的 this 值。
2. 令 promiseCapability 为 `? NewPromiseCapability(C)`。
3. 执行 `? Call(promiseCapability.[[Reject]], undefined, « r »)`。
4. 返回 `promiseCapability.[[Promise]]`。

**注意：** 该函数期望其 this 值是一个支持 Promise 构造函数参数约定的构造函数。

---

### 27.2.4.7 Promise.resolve ( x )

该函数返回一个新的 Promise，该 Promise 会根据传入的参数 x 被解决，或者如果参数 x 是由该构造函数产生的 Promise，则直接返回该参数 x。

1. 令 C 为当前的 this 值。
2. 如果 C 不是一个对象，则抛出一个 TypeError 异常。
3. 返回 `? PromiseResolve(C, x)`。

**注意：** 该函数期望其 this 值是一个支持 Promise 构造函数参数约定的构造函数。

### 27.2.4.7.1 PromiseResolve ( C, x )

抽象操作 PromiseResolve 接收参数 C（一个构造函数）和 x（一个 ECMAScript 语言值），并返回一个包含 ECMAScript 语言值的正常完成或抛出完成。它返回一个根据 x 被解决的新 Promise。调用时执行以下步骤：

1. 如果 `IsPromise(x)` 为 true，则
   a. 令 `xConstructor` 为 `? Get(x, "constructor")`。
   b. 如果 `SameValue(xConstructor, C)` 为 true，则返回 x。
2. 令 `promiseCapability` 为 `? NewPromiseCapability(C)`。
3. 执行 `? Call(promiseCapability.[[Resolve]], undefined, « x »)`。
4. 返回 `promiseCapability.[[Promise]]`。

---

### 27.2.4.8 Promise.withResolvers ( )

该函数返回一个对象，包含三个属性：一个新的 Promise，以及与之关联的 resolve 和 reject 函数。

1. 令 C 为当前的 this 值。
2. 令 `promiseCapability` 为 `? NewPromiseCapability(C)`。
3. 令 `obj` 为 `OrdinaryObjectCreate(%Object.prototype%)`。
4. 执行 `! CreateDataPropertyOrThrow(obj, "promise", promiseCapability.[[Promise]])`。
5. 执行 `! CreateDataPropertyOrThrow(obj, "resolve", promiseCapability.[[Resolve]])`。
6. 执行 `! CreateDataPropertyOrThrow(obj, "reject", promiseCapability.[[Reject]])`。
7. 返回 `obj`。

---

### 27.2.4.9 get Promise [ @@species ]

Promise[@@species] 是一个访问器属性，其设置访问器函数为 undefined。其获取访问器函数在调用时执行以下步骤：

1. 返回当前的 this 值。
该函数的 "name" 属性的值为 "get [Symbol.species]"。

**注意：** Promise 原型方法通常使用其 this 值的构造函数来创建派生对象。然而，子类构造函数可以通过重新定义其 @@species 属性来重写默认行为。

### 27.2.5 Properties of the Promise Prototype Object

Promise 原型对象：

- 是 %Promise.prototype%。
- 具有一个 [[Prototype]] 内部槽，其值为 %Object.prototype%。
- 是一个普通对象。
- 没有 [[PromiseState]] 内部槽或 Promise 实例的其他内部槽。

### 27.2.5.1 Promise.prototype.catch ( onRejected )

当调用该方法时，执行以下步骤：

1. 令 promise 为当前的 this 值。
2. 返回 `? Invoke(promise, "then", « undefined, onRejected »)`。

### 27.2.5.2 Promise.prototype.constructor

Promise.prototype.constructor 的初始值为 %Promise%。

### 27.2.5.3 Promise.prototype.finally ( onFinally )

当调用该方法时，执行以下步骤：

1. 令 promise 为当前的 this 值。
2. 如果 promise 不是一个对象，则抛出 TypeError 异常。
3. 令 C 为 `? SpeciesConstructor(promise, %Promise%)`。
4. 断言：`IsConstructor(C)` 为 true。
5. 如果 `IsCallable(onFinally)` 为 false，则
   a. 令 thenFinally 为 onFinally。
   b. 令 catchFinally 为 onFinally。
6. 否则，
   a. 令 thenFinallyClosure 为一个捕获 onFinally 和 C 的新抽象闭包，当调用时执行以下步骤：
      i. 令 result 为 `? Call(onFinally, undefined)`。
      ii. 令 p 为 `? PromiseResolve(C, result)`。
      iii. 令 returnValue 为一个不带参数的新抽象闭包，捕获 value，并在调用时执行以下步骤：
           1. 返回 value。
      iv. 令 valueThunk 为 `CreateBuiltinFunction(returnValue, 0, "", « »)`。
      v. 返回 `? Invoke(p, "then", « valueThunk »)`。
   b. 令 thenFinally 为 `CreateBuiltinFunction(thenFinallyClosure, 1, "", « »)`。
   c. 令 catchFinallyClosure 为一个捕获 onFinally 和 C 的新抽象闭包，参数为 reason，当调用时执行以下步骤：
      i. 令 result 为 `? Call(onFinally, undefined)`。
      ii. 令 p 为 `? PromiseResolve(C, result)`。
      iii. 令 throwReason 为一个不带参数的新抽象闭包，捕获 reason，并在调用时执行以下步骤：
           1. 返回 ThrowCompletion(reason)。
      iv. 令 thrower 为 `CreateBuiltinFunction(throwReason, 0, "", « »)`。
      v. 返回 `? Invoke(p, "then", « thrower »)`。
   d. 令 catchFinally 为 `CreateBuiltinFunction(catchFinallyClosure, 1, "", « »)`。
7. 返回 `? Invoke(promise, "then", « thenFinally, catchFinally »)`。

### 27.2.5.4 Promise.prototype.then ( onFulfilled, onRejected )

当调用该方法时，执行以下步骤：

1. 令 promise 为当前的 this 值。
2. 如果 `IsPromise(promise)` 为 false，则抛出 TypeError 异常。
3. 令 C 为 `? SpeciesConstructor(promise, %Promise%)`。
4. 令 resultCapability 为 `? NewPromiseCapability(C)`。
5. 返回 `PerformPromiseThen(promise, onFulfilled, onRejected, resultCapability)`。

### 27.2.5.4.1 PerformPromiseThen ( promise, onFulfilled, onRejected [ , resultCapability ] )

抽象操作 PerformPromiseThen 接受参数 promise（一个 Promise）、onFulfilled（一个 ECMAScript 语言值）、onRejected（一个 ECMAScript 语言值）以及可选参数 resultCapability（一个 PromiseCapability Record），并返回一个 ECMAScript 语言值。它使用 onFulfilled 和 onRejected 作为其完成动作来执行 promise 上的 "then" 操作。如果传递了 resultCapability，则通过更新 resultCapability 的 promise 存储结果。如果未传递 resultCapability，则 PerformPromiseThen 是由规范内部操作调用的，其结果并不重要。调用时执行以下步骤：

1. 断言：`IsPromise(promise)` 为 true。
2. 如果 resultCapability 不存在，则
   a. 将 resultCapability 设置为 undefined。
3. 如果 `IsCallable(onFulfilled)` 为 false，则
   a. 让 onFulfilledJobCallback 为 EMPTY。
4. 否则，
   a. 让 onFulfilledJobCallback 为 `HostMakeJobCallback(onFulfilled)`。
5. 如果 `IsCallable(onRejected)` 为 false，则
   a. 让 onRejectedJobCallback 为 EMPTY。
6. 否则，
   a. 让 onRejectedJobCallback 为 `HostMakeJobCallback(onRejected)`。
7. 让 fulfillReaction 为 PromiseReaction Record `{ [[Capability]]: resultCapability, [[Type]]: FULFILL, [[Handler]]: onFulfilledJobCallback }`。
8. 让 rejectReaction 为 PromiseReaction Record `{ [[Capability]]: resultCapability, [[Type]]: REJECT, [[Handler]]: onRejectedJobCallback }`。
9. 如果 promise 的 `[[PromiseState]]` 是 PENDING，则
   a. 将 fulfillReaction 追加到 promise 的 `[[PromiseFulfillReactions]]`。
   b. 将 rejectReaction 追加到 promise 的 `[[PromiseRejectReactions]]`。
10. 否则，如果 promise 的 `[[PromiseState]]` 是 FULFILLED，则
    a. 令 value 为 promise 的 `[[PromiseResult]]`。
    b. 让 fulfillJob 为 `NewPromiseReactionJob(fulfillReaction, value)`。
    c. 执行 `HostEnqueuePromiseJob(fulfillJob.[[Job]], fulfillJob.[[Realm]])`。
11. 否则，
    a. 断言：promise 的 `[[PromiseState]]` 的值是 REJECTED。
    b. 让 reason 为 promise 的 `[[PromiseResult]]`。
    c. 如果 promise 的 `[[PromiseIsHandled]]` 是 false，则执行 `HostPromiseRejectionTracker(promise, "handle")`。
    d. 让 rejectJob 为 `NewPromiseReactionJob(rejectReaction, reason)`。
    e. 执行 `HostEnqueuePromiseJob(rejectJob.[[Job]], rejectJob.[[Realm]])`。
12. 将 promise 的 `[[PromiseIsHandled]]` 设置为 true。
13. 如果 resultCapability 是 undefined，则
    a. 返回 undefined。
14. 否则，
    a. 返回 `resultCapability.[[Promise]]`。

### 27.2.5.5 Promise.prototype [ @@toStringTag ]

@@toStringTag 属性的初始值是字符串 "Promise"。

该属性具有属性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }。

### 27.2.6 Promise 实例的属性

Promise 实例是普通对象，继承自 Promise 原型对象（内部名称为 %Promise.prototype%）。Promise 实例最初使用表 87 中描述的内部槽创建。

#### 表 87：Promise 实例的内部槽

| 内部槽                  | 类型                            | 描述                                                             |
|-------------------------|---------------------------------|------------------------------------------------------------------|
| `[[PromiseState]]`      | PENDING、FULFILLED 或 REJECTED   | 控制 promise 对其 then 方法的调用反应方式                         |
| `[[PromiseResult]]`     | 一个 ECMAScript 语言值             | promise 已完成或已拒绝的值，如果有的话。仅在 `[[PromiseState]]` 不是 PENDING 时有意义。 |
| `[[PromiseFulfillReactions]]` | 一个 PromiseReaction 记录列表   | 当 promise 从 PENDING 状态转换为 FULFILLED 状态时处理的记录          |
| `[[PromiseRejectReactions]]`  | 一个 PromiseReaction 记录列表   | 当 promise 从 PENDING 状态转换为 REJECTED 状态时处理的记录           |
| `[[PromiseIsHandled]]`  | 一个布尔值                        | 表示 promise 是否曾经有过完成或拒绝处理器；用于未处理的拒绝跟踪。          |

27.3 生成器函数对象
生成器函数是通过评估生成器声明、生成器表达式和生成器方法通常创建的函数。它们也可以通过调用 %GeneratorFunction% 内部方法来创建。

图 6（信息性）：生成器对象关系
一个惊人的多样性的方框和箭头。

27.3.1 生成器函数构造函数
生成器函数构造函数：

是 %GeneratorFunction%。
是 Function 的一个子类。
在作为函数调用而非构造函数调用时创建和初始化一个新的生成器函数。因此，函数调用 GeneratorFunction(...) 等同于对象创建表达式 new GeneratorFunction(...)，传入相同的参数。
可以作为类定义的 extends 子句的值使用。打算继承指定生成器函数行为的子类构造函数必须包括一个对生成器函数构造函数的 super 调用，以创建并初始化具有内部插槽的子类实例，这些内部插槽对于内置生成器函数行为是必需的。所有 ECMAScript 定义生成器函数对象的语法形式都直接创建生成器函数的实例。没有语法手段可以创建生成器函数子类的实例。

27.3.1.1 GeneratorFunction( ...parameterArgs, bodyArg )
如果有的话，最后一个参数指定了生成器函数的主体（可执行代码）；任何前面的参数指定了形式参数。

当调用此函数时，执行以下步骤：

1. 让 C 成为当前活动函数对象。
2. 如果 bodyArg 不存在，则将 bodyArg 设置为空字符串。
3. 返回 ? CreateDynamicFunction(C, NewTarget, GENERATOR, parameterArgs, bodyArg)。

注：
参见 20.2.1.1 的注释。

27.3.2 生成器函数构造函数的属性
生成器函数构造函数：

是一个标准内置函数对象，继承自 Function 构造函数。
具有一个 [[Prototype]] 内部插槽，其值为 %Function%。
具有一个 "length" 属性，其值为 1𝔽。
具有一个 "name" 属性，其值为 "GeneratorFunction"。
具有以下属性：
27.3.2.1 GeneratorFunction.prototype
GeneratorFunction.prototype 的初始值是生成器函数原型对象。

此属性具有属性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }。

27.3.3 生成器函数原型对象的属性
生成器函数原型对象：

是 %GeneratorFunction.prototype%（见图 6）。
是一个普通对象。
不是一个函数对象，并且没有 [[ECMAScriptCode]] 内部插槽或表 30 或表 88 中列出的任何其他内部插槽。
具有一个 [[Prototype]] 内部插槽，其值为 %Function.prototype%。

27.3.3.1 GeneratorFunction.prototype.constructor
GeneratorFunction.prototype.constructor 的初始值为 %GeneratorFunction%。

此属性具有属性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }。

27.3.3.2 GeneratorFunction.prototype.prototype
GeneratorFunction.prototype.prototype 的初始值为 %GeneratorPrototype%。

此属性具有属性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }。

27.3.3.3 GeneratorFunction.prototype [ @@toStringTag ]
@@toStringTag 属性的初始值是字符串值 "GeneratorFunction"。

此属性具有属性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }。

27.3.4 生成器函数实例
每个生成器函数实例都是一个 ECMAScript 函数对象，并且具有表 30 中列出的内部插槽。所有这些实例的 [[IsClassConstructor]] 内部插槽的值都为 false。

每个生成器函数实例具有以下自有属性：

27.3.4.1 length
20.2.4.1 中给出的 Function 实例的 "length" 属性的规范也适用于生成器函数实例。

27.3.4.2 name
20.2.4.2 中给出的 Function 实例的 "name" 属性的规范也适用于生成器函数实例。

27.3.4.3 prototype
每当创建一个生成器函数实例时，还会创建另一个普通对象，作为生成器函数的 "prototype" 属性的初始值。当通过 [[Call]] 调用生成器函数对象时，原型属性的值用于初始化新创建的生成器的 [[Prototype]] 内部插槽。

此属性具有属性 { [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false }。

注：
与 Function 实例不同，作为生成器函数的 "prototype" 属性值的对象不具有 "constructor" 属性，其值为生成器函数实例。

27.4 异步生成器函数对象
异步生成器函数是通过评估异步生成器声明、异步生成器表达式和异步生成器方法语法产生通常创建的函数。它们也可以通过调用 %AsyncGeneratorFunction% 内部方法来创建。

27.4.1 异步生成器函数构造函数
异步生成器函数构造函数：

是 %AsyncGeneratorFunction%。
是 Function 的一个子类。
在作为函数调用而非构造函数调用时创建和初始化一个新的异步生成器函数。因此，函数调用 AsyncGeneratorFunction(...) 等同于对象创建表达式 new AsyncGeneratorFunction(...)，传入相同的参数。
可以作为类定义的 extends 子句的值使用。打算继承指定异步生成器函数行为的子类构造函数必须包括一个对异步生成器函数构造函数的 super 调用，以创建并初始化具有内部插槽的子类实例，这些内部插槽对于内置异步生成器函数行为是必需的。所有 ECMAScript 定义异步生成器函数对象的语法形式都直接创建异步生成器函数的实例。没有语法手段可以创建异步生成器函数子类的实例。

27.4.1.1 AsyncGeneratorFunction( ...parameterArgs, bodyArg )
如果有的话，最后一个参数指定了异步生成器函数的主体（可执行代码）；任何前面的参数指定了形式参数。

当调用此函数时，执行以下步骤：

1. 让 C 成为当前活动函数对象。
2. 如果 bodyArg 不存在，则将 bodyArg 设置为空字符串。
3. 返回 ? CreateDynamicFunction(C, NewTarget, ASYNC-GENERATOR, parameterArgs, bodyArg)。

注：
参见 20.2.1.1 的注释。

27.4.2 异步生成器函数构造函数的属性
异步生成器函数构造函数：

是一个标准内置函数对象，继承自 Function 构造函数。
具有一个 [[Prototype]] 内部插槽，其值为 %Function%。
具有一个 "length" 属性，其值为 1𝔽。
具有一个 "name" 属性，其值为 "AsyncGeneratorFunction"。
具有以下属性：
27.4.2.1 AsyncGeneratorFunction.prototype
AsyncGeneratorFunction.prototype 的初始值是异步生成器函数原型对象。

此属性具有属性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }。

27.4.3 异步生成器函数原型对象的属性
异步生成器函数原型对象：

是 %AsyncGeneratorFunction.prototype%。
是一个普通对象。
不是一个函数对象，并且没有 [[ECMAScriptCode]] 内部插槽或表 30 或表 89 中列出的任何其他内部插槽。
具有一个 [[Prototype]] 内部插槽，其值为 %Function.prototype%。

27.4.3.1 AsyncGeneratorFunction.prototype.constructor
AsyncGeneratorFunction.prototype.constructor 的初始值为 %AsyncGeneratorFunction%。

此属性具有属性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }。

27.4.3.2 AsyncGeneratorFunction.prototype.prototype
AsyncGeneratorFunction.prototype.prototype 的初始值为 %AsyncGeneratorPrototype%。

此属性具有属性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }。

27.4.3.3 AsyncGeneratorFunction.prototype [ @@toStringTag ]
@@toStringTag 属性的初始值是字符串值 "AsyncGeneratorFunction"。

此属性具有属性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }。

27.4.4 异步生成器函数实例
每个异步生成器函数实例都是一个 ECMAScript 函数对象，并且具有表 30 中列出的内部插槽。所有这些实例的 [[IsClassConstructor]] 内部插槽的值都为 false。

每个异步生成器函数实例具有以下自有属性：

27.4.4.1 length
"length" 属性的值是一个整数数字，表示异步生成器函数预期的典型参数数量。但是，语言允许函数以除了其 "length" 属性指定的参数数量外的其他参数调用。当异步生成器函数以除了其 "length" 属性指定的参数数量外的参数调用时，其行为取决于函数本身。

此属性具有属性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }。

27.4.4.2 name
20.2.4.2 中给出的 Function 实例的 "name" 属性的规范也适用于异步生成器函数实例。

27.4.4.3 prototype
每当创建一个异步生成器函数实例时，还会创建另一个普通对象，作为异步生成器函数的 "prototype" 属性的初始值。当通过 [[Call]] 调用异步生成器函数对象时，原型属性的值用于初始化新创建的异步生成器的 [[Prototype]] 内部插槽。

此属性具有属性 { [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false }。

注：
与函数实例不同，作为异步生成器函数的 "prototype" 属性值的对象不具有一个 "constructor" 属性，其值为异步生成器函数实例。

27.5 生成器对象
生成器是通过调用生成器函数创建的，符合迭代器和可迭代接口。

生成器实例直接从创建该实例的生成器函数的 "prototype" 属性的初始值继承属性。生成器实例间接从 %GeneratorPrototype% 继承属性。

27.5.1 %GeneratorPrototype% 对象
%GeneratorPrototype% 对象：

是 %GeneratorFunction.prototype.prototype%。
是一个普通对象。
不是 Generator 实例，也没有 [[GeneratorState]] 内部插槽。
具有一个 [[Prototype]] 内部插槽，其值为 %IteratorPrototype%。
具有通过所有 Generator 实例间接继承的属性。

27.5.1.1 %GeneratorPrototype%.constructor
%GeneratorPrototype%.constructor 的初始值为 %GeneratorFunction.prototype%。

此属性具有属性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }。

27.5.1.2 %GeneratorPrototype%.next ( value )
1. 返回 ? GeneratorResume(this value, value, EMPTY)。

27.5.1.3 %GeneratorPrototype%.return ( value )
当调用此方法时，执行以下步骤：

1. 让 g 为当前 this 值。
2. 让 C 为完成记录 { [[Type]]: RETURN, [[Value]]: value, [[Target]]: EMPTY }。
3. 返回 ? GeneratorResumeAbrupt(g, C, EMPTY)。

27.5.1.4 %GeneratorPrototype%.throw ( exception )
当调用此方法时，执行以下步骤：

1. 让 g 为当前 this 值。
2. 让 C 为 ThrowCompletion(exception)。
3. 返回 ? GeneratorResumeAbrupt(g, C, EMPTY)。

27.5.1.5 %GeneratorPrototype% [ @@toStringTag ]
@@toStringTag 属性的初始值为字符串值 "Generator"。

此属性具有属性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }。

27.5.2 Generator 实例的属性
Generator 实例最初创建时具有表 88 中描述的内部插槽。

表 88: Generator 实例的内部插槽
内部插槽	类型	描述
[[GeneratorState]]	undefined, SUSPENDED-START, SUSPENDED-YIELD, EXECUTING, 或 COMPLETED	生成器的当前执行状态。
[[GeneratorContext]]	执行上下文	在执行此生成器的代码时使用的执行上下文。
[[GeneratorBrand]]	字符串或 EMPTY	用于区分不同类型生成器的品牌。由 ECMAScript 源文本声明的生成器的 [[GeneratorBrand]] 始终为 EMPTY。

27.5.3 Generator 抽象操作
27.5.3.1 GeneratorStart ( generator, generatorBody )
抽象操作 GeneratorStart 接受参数 generator（一个 Generator）和 generatorBody（一个 FunctionBody 解析节点或没有参数的抽象闭包），并返回 UNUSED。调用时执行以下步骤：

1. 断言：generator.[[GeneratorState]] 的值为 undefined。
2. 让 genContext 为当前运行的执行上下文。
3. 将 genContext 的 Generator 组件设置为 generator。
4. 让闭包为一个捕获 generatorBody 的没有参数的新抽象闭包，并在调用时执行以下步骤：
   a. 让 acGenContext 为当前运行的执行上下文。
   b. 让 acGenerator 为 acGenContext 的 Generator 组件。
   c. 如果 generatorBody 是一个解析节点，则
      i. 让 result 为 Completion(Evaluation of generatorBody)。
   d. 否则，
      i. 断言：generatorBody 是一个没有参数的抽象闭包。
      ii. 让 result 为 generatorBody()。
   e. 断言：如果在此处返回，生成器可能抛出异常或执行隐式或显式返回。
   f. 从执行上下文堆栈中移除 acGenContext，并将堆栈顶部的执行上下文恢复为当前运行的执行上下文。
   g. 将 acGenerator.[[GeneratorState]] 设置为 COMPLETED。
   h. 注意：一旦生成器进入 COMPLETED 状态，它将永远不会离开，并且与之关联的执行上下文永远不会恢复。此时可以丢弃与 acGenerator 相关的任何执行状态。
   i. 如果 result 是正常完成，则
      i. 让 resultValue 为 undefined。
   j. 否则，如果 result 是返回完成，则
      i. 让 resultValue 为 result.[[Value]]。
   k. 否则，
      i. 断言：result 是一个抛出完成。
      ii. 返回 ? result。
   l. 返回 CreateIterResultObject(resultValue, true)。
5. 设置 genContext 的代码评估状态，以便在恢复该执行上下文的评估时，使用没有参数调用闭包。
6. 将 generator.[[GeneratorContext]] 设置为 genContext。
7. 将 generator.[[GeneratorState]] 设置为 SUSPENDED-START。
8. 返回 UNUSED。


### 27.5.3.2 GeneratorValidate ( generator, generatorBrand )

抽象操作 GeneratorValidate 接受参数 generator（一个 ECMAScript 语言值）和 generatorBrand（一个字符串或 EMPTY），并返回一个包含 SUSPENDED-START、SUSPENDED-YIELD 或 COMPLETED 的正常完成，或者抛出一个异常。调用时执行以下步骤：

1. 执行 ? RequireInternalSlot(generator, [[GeneratorState]]).
2. 执行 ? RequireInternalSlot(generator, [[GeneratorBrand]]).
3. 如果 generator.[[GeneratorBrand]] 不等于 generatorBrand，则抛出 TypeError 异常。
4. 断言：generator 同样具有一个 [[GeneratorContext]] 内部插槽。
5. 让 state 为 generator.[[GeneratorState]]。
6. 如果 state 为 EXECUTING，则抛出 TypeError 异常。
7. 返回 state。

### 27.5.3.3 GeneratorResume ( generator, value, generatorBrand )

抽象操作 GeneratorResume 接受参数 generator（一个 ECMAScript 语言值）、value（一个 ECMAScript 语言值或 EMPTY）和 generatorBrand（一个字符串或 EMPTY），并返回一个包含 ECMAScript 语言值的正常完成或抛出异常。调用时执行以下步骤：

1. 让 state 为 ? GeneratorValidate(generator, generatorBrand)。
2. 如果 state 为 COMPLETED，则返回 CreateIterResultObject(undefined, true)。
3. 断言：state 为 SUSPENDED-START 或 SUSPENDED-YIELD。
4. 让 genContext 为 generator.[[GeneratorContext]]。
5. 让 methodContext 为当前运行的执行上下文。
6. 挂起 methodContext。
7. 将 generator.[[GeneratorState]] 设置为 EXECUTING。
8. 将 genContext 推入执行上下文堆栈；genContext 现在为当前运行的执行上下文。
9. 恢复 genContext 的挂起评估，使用 NormalCompletion(value) 作为挂起它的操作的结果。让 result 为恢复计算返回的值。
10. 断言：当我们在此处返回时，genContext 已从执行上下文堆栈中移除，并且 methodContext 是当前运行的执行上下文。
11. 返回 ? result。

### 27.5.3.4 GeneratorResumeAbrupt ( generator, abruptCompletion, generatorBrand )

抽象操作 GeneratorResumeAbrupt 接受参数 generator（一个 ECMAScript 语言值）、abruptCompletion（一个返回完成或抛出完成）和 generatorBrand（一个字符串或 EMPTY），并返回一个包含 ECMAScript 语言值的正常完成或抛出异常。调用时执行以下步骤：

1. 让 state 为 ? GeneratorValidate(generator, generatorBrand)。
2. 如果 state 为 SUSPENDED-START，则
   a. 将 generator.[[GeneratorState]] 设置为 COMPLETED。
   b. 注意：一旦生成器进入 COMPLETED 状态，它将永远不会离开，并且与之关联的执行上下文永远不会恢复。此时可以丢弃与 generator 关联的任何执行状态。
   c. 将 state 设置为 COMPLETED。
3. 如果 state 为 COMPLETED，则
   a. 如果 abruptCompletion 是一个返回完成，则
      i. 返回 CreateIterResultObject(abruptCompletion.[[Value]], true)。
   b. 返回 ? abruptCompletion。
4. 断言：state 为 SUSPENDED-YIELD。
5. 让 genContext 为 generator.[[GeneratorContext]]。
6. 让 methodContext 为当前运行的执行上下文。
7. 挂起 methodContext。
8. 将 generator.[[GeneratorState]] 设置为 EXECUTING。
9. 将 genContext 推入执行上下文堆栈；genContext 现在为当前运行的执行上下文。
10. 恢复 genContext 的挂起评估，使用 abruptCompletion 作为挂起它的操作的结果。让 result 为恢复计算返回的完成记录。
11. 断言：当我们在此处返回时，genContext 已从执行上下文堆栈中移除，并且 methodContext 是当前运行的执行上下文。
12. 返回 ? result。

### 27.5.3.5 GetGeneratorKind ( )

抽象操作 GetGeneratorKind 不接受参数并返回 NON-GENERATOR、SYNC 或 ASYNC。调用时执行以下步骤：

1. 让 genContext 为当前运行的执行上下文。
2. 如果 genContext 没有一个 Generator 组件，则返回 NON-GENERATOR。
3. 让 generator 为 genContext 的 Generator 组件。
4. 如果 generator 具有一个 [[AsyncGeneratorState]] 内部插槽，则返回 ASYNC。
5. 否则，返回 SYNC。

### 27.5.3.6 GeneratorYield ( iterNextObj )

抽象操作 GeneratorYield 接受参数 iterNextObj（符合 IteratorResult 接口的对象），并返回一个包含 ECMAScript 语言值的正常完成或异常完成。调用时执行以下步骤：

1. 让 genContext 为当前运行的执行上下文。
2. 断言：genContext 是生成器的执行上下文。
3. 让 generator 为 genContext 的 Generator 组件的值。
4. 断言：GetGeneratorKind() 为 SYNC。
5. 将 generator.[[GeneratorState]] 设置为 SUSPENDED-YIELD。
6. 从执行上下文堆栈中移除 genContext，并将堆栈顶部的执行上下文恢复为当前运行的执行上下文。
7. 让 callerContext 为当前运行的执行上下文。
8. 使用 NormalCompletion(iterNextObj) 作为恢复调用 callerContext。如果 genContext 再次恢复，则让 resumptionValue 为其恢复时的完成记录。
9. 断言：如果控制流达到此处，则 genContext 再次是当前运行的执行上下文。
10. 返回 resumptionValue。

### 27.5.3.7 Yield ( value )

抽象操作 Yield 接受参数 value（一个 ECMAScript 语言值），并返回一个包含 ECMAScript 语言值的正常完成或异常完成。调用时执行以下步骤：

1. 让 generatorKind 为 GetGeneratorKind()。
2. 如果 generatorKind 为 ASYNC，则返回 ? AsyncGeneratorYield(? Await(value))。
3. 否则，返回 ? GeneratorYield(CreateIterResultObject(value, false))。

### 27.5.3.8 CreateIteratorFromClosure ( closure, generatorBrand, generatorPrototype )

抽象操作 CreateIteratorFromClosure 接受参数 closure（一个没有参数的抽象闭包）、generatorBrand（一个字符串或 EMPTY）和 generatorPrototype（一个对象），并返回一个 Generator。调用时执行以下步骤：

1. 注意：closure 可能包含使用 Yield 操作来生成 IteratorResult 对象。
2. 让 internalSlotsList 为 « [[GeneratorState]], [[GeneratorContext]], [[GeneratorBrand]] »。
3. 让 generator 为 OrdinaryObjectCreate(generatorPrototype, internalSlotsList)。
4. 将 generator.[[GeneratorBrand]] 设置为 generatorBrand。
5. 将 generator.[[GeneratorState]] 设置为 undefined。
6. 让 callerContext 为当前运行的执行上下文。
7. 让 calleeContext 为一个新的执行上下文。
8. 将 calleeContext 的 Function 设置为 null。
9. 将 calleeContext 的 Realm 设置为当前的 Realm 记录。
10. 将 calleeContext 的 ScriptOrModule 设置为 callerContext 的 ScriptOrModule。
11. 如果 callerContext 还没有被挂起，则挂起 callerContext。
12. 将 calleeContext 推入执行上下文堆栈；calleeContext 现在为当前运行的执行上下文。
13. 执行 GeneratorStart(generator, closure)。
14. 从执行上下文堆栈中移除 calleeContext，并将 callerContext 恢复为当前运行的执行上下文。
15. 返回 generator。

### 27.6 AsyncGenerator Objects

AsyncGenerator 是通过调用异步生成器函数创建的，并符合 AsyncIterator 和 AsyncIterable 接口。

AsyncGenerator 实例直接继承自创建该实例的异步生成器函数的 "prototype" 属性的初始值。AsyncGenerator 实例间接继承自 %AsyncGeneratorPrototype%。

### 27.6.1 The %AsyncGeneratorPrototype% Object

%AsyncGeneratorPrototype% 对象：

- 是 %AsyncGeneratorFunction.prototype.prototype%。
- 是一个普通对象。
- 不是 AsyncGenerator 实例，也没有 [[AsyncGeneratorState]] 内部插槽。
- 具有一个 [[Prototype]] 内部插槽，其值为 %AsyncIteratorPrototype%。
- 具有一些被所有 AsyncGenerator 实例间接继承的属性。

#### 27.6.1.1 %AsyncGeneratorPrototype%.constructor

%AsyncGeneratorPrototype%.constructor 的初始值为 %AsyncGeneratorFunction.prototype%。

此属性具有属性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }。

#### 27.6.1.2 %AsyncGeneratorPrototype%.next ( value )

1. 让 generator 为 this 值。
2. 让 promiseCapability 为 ! NewPromiseCapability(%Promise%)。
3. 让 result 为 Completion(AsyncGeneratorValidate(generator, EMPTY))。
4. IfAbruptRejectPromise(result, promiseCapability)。
5. 让 state 为 generator.[[AsyncGeneratorState]]。
6. 如果 state 为 COMPLETED，则
   a. 让 iteratorResult 为 CreateIterResultObject(undefined, true)。
   b. 执行 ! Call(promiseCapability.[[Resolve]], undefined, « iteratorResult »)。
   c. 返回 promiseCapability.[[Promise]]。
7. 让 completion 为 NormalCompletion(value)。
8. 执行 AsyncGeneratorEnqueue(generator, completion, promiseCapability)。
9. 如果 state 为 SUSPENDED-START 或 SUSPENDED-YIELD，则
   a. 执行 AsyncGeneratorResume(generator, completion)。
10. Else，
    a. 断言：state 为 EXECUTING 或 AWAITING-RETURN。
11. 返回 promiseCapability.[[Promise]]。

#### 27.6.1.3 %AsyncGeneratorPrototype%.return ( value )

1. 让 generator 为 this 值。
2. 让 promiseCapability 为 ! NewPromiseCapability(%Promise%)。
3. 让 result 为 Completion(AsyncGeneratorValidate(generator, EMPTY))。
4. IfAbruptRejectPromise(result, promiseCapability)。
5. 让 completion 为 Completion Record { [[Type]]: RETURN, [[Value]]: value, [[Target]]: EMPTY }。
6. 执行 AsyncGeneratorEnqueue(generator, completion, promiseCapability)。
7. 让 state 为 generator.[[AsyncGeneratorState]]。
8. 如果 state 为 SUSPENDED-START 或 COMPLETED，则
   a. 设置 generator.[[AsyncGeneratorState]] 为 AWAITING-RETURN。
   b. 执行 AsyncGeneratorAwaitReturn(generator)。
9. Else if state 为 SUSPENDED-YIELD，则
   a. 执行 AsyncGeneratorResume(generator, completion)。
10. Else，
    a. 断言：state 为 EXECUTING 或 AWAITING-RETURN。
11. 返回 promiseCapability.[[Promise]]。

#### 27.6.1.4 %AsyncGeneratorPrototype%.throw ( exception )

1. 让 generator 为 this 值。
2. 让 promiseCapability 为 ! NewPromiseCapability(%Promise%)。
3. 让 result 为 Completion(AsyncGeneratorValidate(generator, EMPTY))。
4. IfAbruptRejectPromise(result, promiseCapability)。
5. 让 state 为 generator.[[AsyncGeneratorState]]。
6. 如果 state 为 SUSPENDED-START，则
   a. 设置 generator.[[AsyncGeneratorState]] 为 COMPLETED。
   b. 设置 state 为 COMPLETED。
7. 如果 state 为 COMPLETED，则
   a. 执行 ! Call(promiseCapability.[[Reject]], undefined, « exception »)。
   b. 返回 promiseCapability.[[Promise]]。
8. 让 completion 为 ThrowCompletion(exception)。
9. 执行 AsyncGeneratorEnqueue(generator, completion, promiseCapability)。
10. 如果 state 为 SUSPENDED-YIELD，则
    a. 执行 AsyncGeneratorResume(generator, completion)。
11. Else，
    a. 断言：state 为 EXECUTING 或 AWAITING-RETURN。
12. 返回 promiseCapability.[[Promise]]。

Here's the translation of the specified content:

### 27.6.1.5 %AsyncGeneratorPrototype% [ @@toStringTag ]

@@toStringTag 属性的初始值是字符串 "AsyncGenerator"。

此属性具有属性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }。

### 27.6.2 Properties of AsyncGenerator Instances

AsyncGenerator 实例最初创建时具有以下内部插槽：

Table 89: AsyncGenerator 实例的内部插槽
Internal Slot	Type	Description
[[AsyncGeneratorState]]	undefined, SUSPENDED-START, SUSPENDED-YIELD, EXECUTING, AWAITING-RETURN, or COMPLETED	异步生成器的当前执行状态。
[[AsyncGeneratorContext]]	执行上下文	执行此异步生成器代码时使用的执行上下文。
[[AsyncGeneratorQueue]]	AsyncGeneratorRequest 记录的列表	表示恢复异步生成器的请求记录。除状态转换期间外，如果 [[AsyncGeneratorState]] 为 EXECUTING 或 AWAITING-RETURN，则它是非空的。
[[GeneratorBrand]]	字符串或 EMPTY	用于区分不同种类的异步生成器的品牌。由 ECMAScript 源文本声明的异步生成器的 [[GeneratorBrand]] 始终为空。

### 27.6.3 AsyncGenerator Abstract Operations

#### 27.6.3.1 AsyncGeneratorRequest Records

AsyncGeneratorRequest 是用于存储有关如何恢复异步生成器的信息的记录值，并包含用于完成或拒绝相应承诺的能力。

它们具有以下字段：

Table 90: AsyncGeneratorRequest 记录字段
Field Name	Value	Meaning
[[Completion]]	一个 Completion Record	应用于恢复异步生成器的完成记录。
[[Capability]]	一个 PromiseCapability Record	与此请求相关联的承诺能力。

### 27.6.3.2 AsyncGeneratorStart ( generator, generatorBody )

抽象操作 AsyncGeneratorStart 接受参数 generator（一个 AsyncGenerator）和 generatorBody（一个 FunctionBody 解析节点或没有参数的抽象闭包），并返回 UNUSED。调用时执行以下步骤：

1. 断言：generator.[[AsyncGeneratorState]] 是 undefined。
2. 让 genContext 成为运行中的执行上下文。
3. 将 genContext 的 Generator 组件设置为 generator。
4. 让闭包成为一个新的没有参数的抽象闭包，捕获 generatorBody，并在调用时执行以下步骤：
   a. 让 acGenContext 成为运行中的执行上下文。
   b. 让 acGenerator 成为 acGenContext 的 Generator 组件。
   c. 如果 generatorBody 是一个解析节点，则
      i. 让 result 成为 Completion(Evaluation of generatorBody)。
   d. 否则，
      i. 断言：generatorBody 是一个没有参数的抽象闭包。
      ii. 让 result 成为 Completion(generatorBody())。
   e. 断言：如果到这里返回，则异步生成器可能抛出异常或执行了隐式或显式返回。
   f. 从执行上下文堆栈中移除 acGenContext，并将执行上下文堆栈顶部的执行上下文恢复为运行中的执行上下文。
   g. 将 acGenerator.[[AsyncGeneratorState]] 设置为 COMPLETED。
   h. 如果 result 是正常完成，则将 result 设置为 NormalCompletion(undefined)。
   i. 如果 result 是返回完成，则将 result 设置为 NormalCompletion(result.[[Value]])。
   j. 执行 AsyncGeneratorCompleteStep(acGenerator, result, true)。
   k. 执行 AsyncGeneratorDrainQueue(acGenerator)。
   l. 返回 undefined。
5. 设置 genContext 的代码评估状态，以便在该执行上下文的评估恢复时，使用无参数调用闭包。
6. 将 generator.[[AsyncGeneratorContext]] 设置为 genContext。
7. 将 generator.[[AsyncGeneratorState]] 设置为 SUSPENDED-START。
8. 将 generator.[[AsyncGeneratorQueue]] 设置为一个新的空列表。
9. 返回 UNUSED。

### 27.6.3.3 AsyncGeneratorValidate ( generator, generatorBrand )

抽象操作 AsyncGeneratorValidate 接受参数 generator（一个 ECMAScript 语言值）和 generatorBrand（一个字符串或 EMPTY），并返回一个包含 UNUSED 的正常完成或一个抛出完成。调用时执行以下步骤：

1. 执行 ? RequireInternalSlot(generator, [[AsyncGeneratorContext]])。
2. 执行 ? RequireInternalSlot(generator, [[AsyncGeneratorState]])。
3. 执行 ? RequireInternalSlot(generator, [[AsyncGeneratorQueue]])。
4. 如果 generator.[[GeneratorBrand]] 不是 generatorBrand，则抛出 TypeError 异常。
5. 返回 UNUSED。

### 27.6.3.4 AsyncGeneratorEnqueue ( generator, completion, promiseCapability )

抽象操作 AsyncGeneratorEnqueue 接受参数 generator（一个 AsyncGenerator）、completion（一个完成记录）和 promiseCapability（一个 PromiseCapability 记录），并返回 UNUSED。调用时执行以下步骤：

1. 让 request 成为 AsyncGeneratorRequest { [[Completion]]: completion, [[Capability]]: promiseCapability }。
2. 将 request 追加到 generator.[[AsyncGeneratorQueue]]。
3. 返回 UNUSED。

Here's the translation of the specified content:

### 27.6.3.5 AsyncGeneratorCompleteStep ( generator, completion, done [ , realm ] )

抽象操作 AsyncGeneratorCompleteStep 接受参数 generator（一个 AsyncGenerator）、completion（一个完成记录）、done（一个布尔值）和可选参数 realm（一个 Realm 记录），并返回 UNUSED。调用时执行以下步骤：

1. 断言：generator.[[AsyncGeneratorQueue]] 不为空。
2. 让 next 成为 generator.[[AsyncGeneratorQueue]] 的第一个元素。
3. 移除 generator.[[AsyncGeneratorQueue]] 的第一个元素。
4. 让 promiseCapability 成为 next.[[Capability]]。
5. 让 value 成为 completion.[[Value]]。
6. 如果 completion 是一个 throw 完成，则
   a. 执行 ! Call(promiseCapability.[[Reject]], undefined, « value »)。
7. 否则，
   a. 断言：completion 是一个正常完成。
   b. 如果 realm 存在，则
      i. 让 oldRealm 成为运行中执行上下文的 Realm。
      ii. 将运行中执行上下文的 Realm 设置为 realm。
      iii. 让 iteratorResult 成为 CreateIterResultObject(value, done)。
      iv. 将运行中执行上下文的 Realm 设置为 oldRealm。
   c. 否则，
      i. 让 iteratorResult 成为 CreateIterResultObject(value, done)。
   d. 执行 ! Call(promiseCapability.[[Resolve]], undefined, « iteratorResult »)。
8. 返回 UNUSED。

### 27.6.3.6 AsyncGeneratorResume ( generator, completion )

抽象操作 AsyncGeneratorResume 接受参数 generator（一个 AsyncGenerator）和 completion（一个完成记录），并返回 UNUSED。调用时执行以下步骤：

1. 断言：generator.[[AsyncGeneratorState]] 是 SUSPENDED-START 或 SUSPENDED-YIELD。
2. 让 genContext 成为 generator.[[AsyncGeneratorContext]]。
3. 让 callerContext 成为运行中的执行上下文。
4. 暂停 callerContext。
5. 将 generator.[[AsyncGeneratorState]] 设置为 EXECUTING。
6. 将 genContext 推入执行上下文堆栈；genContext 现在是运行中的执行上下文。
7. 使用 completion 作为暂停它的操作的结果，恢复 genContext 的挂起评估。让 result 成为恢复计算返回的完成记录。
8. 断言：result 永远不会是一个突发完成。
9. 断言：当我们在这里返回时，genContext 已从执行上下文堆栈中移除，并且 callerContext 是当前运行的执行上下文。
10. 返回 UNUSED。

### 27.6.3.7 AsyncGeneratorUnwrapYieldResumption ( resumptionValue )

抽象操作 AsyncGeneratorUnwrapYieldResumption 接受参数 resumptionValue（一个完成记录），并返回一个包含 ECMAScript 语言值的正常完成或一个突发完成。调用时执行以下步骤：

1. 如果 resumptionValue 不是一个返回完成，则返回 ? resumptionValue。
2. 让 awaited 成为 Completion(Await(resumptionValue.[[Value]]))。
3. 如果 awaited 是一个 throw 完成，则返回 ? awaited。
4. 断言：awaited 是一个正常完成。
5. 返回完成记录 { [[Type]]: RETURN, [[Value]]: awaited.[[Value]], [[Target]]: EMPTY }。

Here's the translation of the specified content:

### 27.6.3.8 AsyncGeneratorYield ( value )

抽象操作 AsyncGeneratorYield 接受参数 value（一个 ECMAScript 语言值），并返回一个包含 ECMAScript 语言值的正常完成或一个突发完成。调用时执行以下步骤：

1. 让 genContext 成为运行中的执行上下文。
2. 断言：genContext 是生成器的执行上下文。
3. 让 generator 成为 genContext 的 Generator 组件的值。
4. 断言：GetGeneratorKind() 是 ASYNC。
5. 让 completion 成为 NormalCompletion(value)。
6. 断言：执行上下文堆栈至少有两个元素。
7. 让 previousContext 成为执行上下文堆栈中倒数第二个元素。
8. 让 previousRealm 成为 previousContext 的 Realm。
9. 执行 AsyncGeneratorCompleteStep(generator, completion, false, previousRealm)。
10. 让 queue 成为 generator.[[AsyncGeneratorQueue]]。
11. 如果 queue 不为空，则
    a. 注意：继续执行而不挂起生成器。
    b. 让 toYield 成为 queue 的第一个元素。
    c. 让 resumptionValue 成为 Completion(toYield.[[Completion]])。
    d. 返回 ? AsyncGeneratorUnwrapYieldResumption(resumptionValue)。
12. 否则，
    a. 将 generator.[[AsyncGeneratorState]] 设置为 SUSPENDED-YIELD。
    b. 从执行上下文堆栈中移除 genContext，并将执行上下文堆栈中顶部的执行上下文恢复为运行中的执行上下文。
    c. 让 callerContext 成为运行中的执行上下文。
    d. 使用 undefined 恢复 callerContext。如果 genContext 再次恢复，让 resumptionValue 成为其恢复时的完成记录。
    e. 断言：如果控制流程到达此处，则 genContext 再次是运行中的执行上下文。
    f. 返回 ? AsyncGeneratorUnwrapYieldResumption(resumptionValue)。

### 27.6.3.9 AsyncGeneratorAwaitReturn ( generator )

抽象操作 AsyncGeneratorAwaitReturn 接受参数 generator（一个 AsyncGenerator），并返回 UNUSED。调用时执行以下步骤：

1. 让 queue 成为 generator.[[AsyncGeneratorQueue]]。
2. 断言：queue 不为空。
3. 让 next 成为 queue 的第一个元素。
4. 让 completion 成为 next.[[Completion]] 的完成记录。
5. 断言：completion 是一个返回完成。
6. 让 promiseCompletion 成为 Completion(PromiseResolve(%Promise%, completion.[[Value]]))。
7. 如果 promiseCompletion 是一个突发完成，则
   a. 将 generator.[[AsyncGeneratorState]] 设置为 COMPLETED。
   b. 执行 AsyncGeneratorCompleteStep(generator, promiseCompletion, true)。
   c. 执行 AsyncGeneratorDrainQueue(generator)。
   d. 返回 UNUSED。
8. 断言：promiseCompletion 是一个正常完成。
9. 让 promise 成为 promiseCompletion.[[Value]]。
10. 让 fulfilledClosure 成为一个带有参数 (value) 的新抽象闭包，捕获 generator，并在调用时执行以下步骤：
    a. 将 generator.[[AsyncGeneratorState]] 设置为 COMPLETED。
    b. 让 result 成为 NormalCompletion(value)。
    c. 执行 AsyncGeneratorCompleteStep(generator, result, true)。
    d. 执行 AsyncGeneratorDrainQueue(generator)。
    e. 返回 undefined。
11. 让 onFulfilled 成为 CreateBuiltinFunction(fulfilledClosure, 1, "", « »)。
12. 让 rejectedClosure 成为一个带有参数 (reason) 的新抽象闭包，捕获 generator，并在调用时执行以下步骤：
    a. 将 generator.[[AsyncGeneratorState]] 设置为 COMPLETED。
    b. 让 result 成为 ThrowCompletion(reason)。
    c. 执行 AsyncGeneratorCompleteStep(generator, result, true)。
    d. 执行 AsyncGeneratorDrainQueue(generator)。
    e. 返回 undefined。
13. 让 onRejected 成为 CreateBuiltinFunction(rejectedClosure, 1, "", « »)。
14. 执行 PerformPromiseThen(promise, onFulfilled, onRejected)。
15. 返回 UNUSED。

### 27.6.3.10 AsyncGeneratorDrainQueue ( generator )

抽象操作 AsyncGeneratorDrainQueue 接受参数 generator（一个 AsyncGenerator），并返回 UNUSED。它会将生成器的 AsyncGeneratorQueue 排干，直到遇到持有返回完成的 AsyncGeneratorRequest。调用时执行以下步骤：

1. 断言：generator.[[AsyncGeneratorState]] 是 COMPLETED。
2. 让 queue 成为 generator.[[AsyncGeneratorQueue]]。
3. 如果 queue 是空的，则返回 UNUSED。
4. 让 done 成为 false。
5. 循环，当 done 为 false 时，
   a. 让 next 成为 queue 的第一个元素。
   b. 让 completion 成为 next.[[Completion]] 的完成记录。
   c. 如果 completion 是一个返回完成，则
      i. 将 generator.[[AsyncGeneratorState]] 设置为 AWAITING-RETURN。
      ii. 执行 AsyncGeneratorAwaitReturn(generator)。
      iii. 将 done 设置为 true。
   d. 否则，
      i. 如果 completion 是一个正常完成，则
         1. 将 completion 设置为 NormalCompletion(undefined)。
      ii. 执行 AsyncGeneratorCompleteStep(generator, completion, true)。
      iii. 如果 queue 是空的，则将 done 设置为 true。
6. 返回 UNUSED。

Here is the translation of the specified content:

### 27.6.3.11 CreateAsyncIteratorFromClosure ( closure, generatorBrand, generatorPrototype )

抽象操作 CreateAsyncIteratorFromClosure 接受参数 closure（一个不带参数的抽象闭包）、generatorBrand（一个字符串或 EMPTY）、和 generatorPrototype（一个对象），并返回一个 AsyncGenerator。调用时执行以下步骤：

1. 注意：closure 可以包含对 Await 操作的使用，以及使用 Yield 操作来产生 IteratorResult 对象。
2. 让 internalSlotsList 成为 « [[AsyncGeneratorState]], [[AsyncGeneratorContext]], [[AsyncGeneratorQueue]], [[GeneratorBrand]] »。
3. 让 generator 成为 OrdinaryObjectCreate(generatorPrototype, internalSlotsList)。
4. 将 generator.[[GeneratorBrand]] 设置为 generatorBrand。
5. 将 generator.[[AsyncGeneratorState]] 设置为 undefined。
6. 让 callerContext 成为运行中的执行上下文。
7. 让 calleeContext 成为一个新的执行上下文。
8. 将 calleeContext 的 Function 设置为 null。
9. 将 calleeContext 的 Realm 设置为当前 Realm 记录。
10. 将 calleeContext 的 ScriptOrModule 设置为 callerContext 的 ScriptOrModule。
11. 如果 callerContext 尚未挂起，挂起 callerContext。
12. 将 calleeContext 推入执行上下文堆栈；现在 calleeContext 是运行中的执行上下文。
13. 执行 AsyncGeneratorStart(generator, closure)。
14. 从执行上下文堆栈中移除 calleeContext，并将 callerContext 恢复为运行中的执行上下文。
15. 返回 generator。

### 27.7 AsyncFunction 对象

AsyncFunctions 是通常通过评估 AsyncFunctionDeclarations、AsyncFunctionExpressions、AsyncMethods 和 AsyncArrowFunctions 创建的函数。它们也可以通过调用 %AsyncFunction% 内置来创建。

27.7.1 AsyncFunction 构造函数

AsyncFunction 构造函数：

- 是 %AsyncFunction%。
- 是 Function 的子类。
- 当作为函数调用而不是作为构造函数调用时，创建并初始化新的 AsyncFunction。因此，函数调用 AsyncFunction(…) 等同于对象创建表达式 new AsyncFunction(…) 使用相同的参数。
- 可以用作类定义的 extends 子句的值。打算继承指定 AsyncFunction 行为的子类构造函数必须包含对 AsyncFunction 构造函数的 super 调用，以使用内部槽创建和初始化子类实例所需的值。所有用于定义异步函数对象的 ECMAScript 句法形式都直接创建 AsyncFunction 的实例。没有语法方法来创建 AsyncFunction 的子类实例。

27.7.1.1 AsyncFunction ( ...parameterArgs, bodyArg )

如果存在最后一个参数，则指定异步函数的主体（可执行代码）。任何前置参数指定形式参数。

调用此函数时执行以下步骤：

1. 让 C 成为活动函数对象。
2. 如果 bodyArg 不存在，则将 bodyArg 设置为空字符串。
3. 返回 ? CreateDynamicFunction(C, NewTarget, ASYNC, parameterArgs, bodyArg)。

**注意：参见 20.2.1.1 的 NOTE。**

### 27.7.2 AsyncFunction 构造函数的属性

AsyncFunction 构造函数：

- 是一个标准内置函数对象，继承自 Function 构造函数。
- 具有 [[Prototype]] 内部槽，其值为 %Function%。
- 具有 "length" 属性，其值为 1𝔽。
- 具有 "name" 属性，其值为 "AsyncFunction"。
- 具有以下属性：
  
  **27.7.2.1 AsyncFunction.prototype**

  AsyncFunction.prototype 的初始值为 AsyncFunction 原型对象。

  此属性具有属性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }。

  Here is the translation of the requested content:

### 27.7.3 AsyncFunction 原型对象的属性

AsyncFunction 原型对象：

- 是 %AsyncFunction.prototype%。
- 是一个普通对象。
- 不是一个函数对象，也没有 [[ECMAScriptCode]] 内部槽或表 30 中列出的任何其他内部槽。
- 具有 [[Prototype]] 内部槽，其值为 %Function.prototype%。

#### 27.7.3.1 AsyncFunction.prototype.constructor

AsyncFunction.prototype.constructor 的初始值为 %AsyncFunction%。

此属性具有属性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }。

#### 27.7.3.2 AsyncFunction.prototype [ @@toStringTag ]

@@toStringTag 属性的初始值为字符串值 "AsyncFunction"。

此属性具有属性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }。

### 27.7.4 AsyncFunction 实例

每个 AsyncFunction 实例都是一个 ECMAScript 函数对象，并具有表 30 中列出的内部槽。所有这些实例的 [[IsClassConstructor]] 内部槽的值都为 false。AsyncFunction 实例不是构造函数，也没有 [[Construct]] 内部方法。AsyncFunction 实例不具有 prototype 属性，因为它们不可构造。

每个 AsyncFunction 实例具有以下自有属性：

#### 27.7.4.1 length

Function 实例的 "length" 属性的规范在 20.2.4.1 中描述，同样适用于 AsyncFunction 实例。

#### 27.7.4.2 name

Function 实例的 "name" 属性的规范在 20.2.4.2 中描述，同样适用于 AsyncFunction 实例。

### 27.7.5 异步函数抽象操作

#### 27.7.5.1 AsyncFunctionStart ( promiseCapability, asyncFunctionBody )

抽象操作 AsyncFunctionStart 接受参数 promiseCapability（一个 PromiseCapability Record）和 asyncFunctionBody（一个 FunctionBody Parse Node 或一个 ExpressionBody Parse Node），并返回 UNUSED。调用时执行以下步骤：

1. 让 runningContext 成为运行中的执行上下文。
2. 让 asyncContext 成为 runningContext 的一个副本。
3. 注意：复制执行状态对于 AsyncBlockStart 来说是必需的，以便恢复其执行。恢复当前正在执行的上下文的定义是不合理的。
4. 执行 AsyncBlockStart(promiseCapability, asyncFunctionBody, asyncContext)。
5. 返回 UNUSED。

Here is the translation of the requested content:

### 27.7.5.2 AsyncBlockStart ( promiseCapability, asyncBody, asyncContext )

抽象操作 AsyncBlockStart 接受参数 promiseCapability（一个 PromiseCapability Record）、asyncBody（一个解析节点）、asyncContext（一个执行上下文），并返回 UNUSED。调用时执行以下步骤：

1. 让 runningContext 成为运行中的执行上下文。
2. 让 closure 成为一个新的不带参数的抽象闭包，捕获 promiseCapability 和 asyncBody，并在调用时执行以下步骤：
   a. 让 acAsyncContext 成为运行中的执行上下文。
   b. 让 result 成为 Completion(Evaluation of asyncBody)。
   c. 断言：如果我们在此处返回，则 async 函数可能会抛出异常或执行隐式或显式返回；所有的等待操作都已完成。
   d. 从执行上下文堆栈中移除 acAsyncContext，并恢复堆栈顶部的执行上下文作为运行中的执行上下文。
   e. 如果 result 是正常完成，则
      i. 执行 ! Call(promiseCapability.[[Resolve]], undefined, « undefined »)。
   f. 否则，如果 result 是返回完成，则
      i. 执行 ! Call(promiseCapability.[[Resolve]], undefined, « result.[[Value]] »)。
   g. 否则，
      i. 断言：result 是一个抛出完成。
      ii. 执行 ! Call(promiseCapability.[[Reject]], undefined, « result.[[Value]] »)。
   h. 返回 UNUSED。
3. 设置 asyncContext 的代码评估状态，以便当执行上下文恢复执行时，使用无参数调用 closure。
4. 将 asyncContext 推入执行上下文堆栈；asyncContext 现在是运行中的执行上下文。
5. 恢复 asyncContext 的挂起评估。让 result 成为恢复计算返回的值。
6. 断言：当我们在此处返回时，asyncContext 已从执行上下文堆栈中移除，而 runningContext 是当前运行的执行上下文。
7. 断言：result 是一个带有值为 UNUSED 的正常完成。此值可能源自 Await 操作，或者如果 async 函数没有等待任何内容，则可能源自步骤 2.h。
8. 返回 UNUSED。

### 27.7.5.3 Await ( value )

抽象操作 Await 接受参数 value（一个 ECMAScript 语言值），并返回一个包含 ECMAScript 语言值或 EMPTY 的正常完成，或者一个抛出完成。调用时执行以下步骤：

1. 让 asyncContext 成为运行中的执行上下文。
2. 让 promise 成为 ? PromiseResolve(%Promise%, value)。
3. 让 fulfilledClosure 成为一个新的带参数 (v) 的抽象闭包，捕获 asyncContext 并在调用时执行以下步骤：
   a. 让 prevContext 成为运行中的执行上下文。
   b. 挂起 prevContext。
   c. 将 asyncContext 推入执行上下文堆栈；asyncContext 现在是运行中的执行上下文。
   d. 使用 NormalCompletion(v) 作为恢复它的操作的结果，恢复 asyncContext 的挂起评估。
   e. 断言：当我们到达此步骤时，asyncContext 已从执行上下文堆栈中移除，而 prevContext 是当前运行的执行上下文。
   f. 返回 undefined。
4. 让 onFulfilled 成为 CreateBuiltinFunction(fulfilledClosure, 1, "", « »)。
5. 让 rejectedClosure 成为一个新的带参数 (reason) 的抽象闭包，捕获 asyncContext 并在调用时执行以下步骤：
   a. 让 prevContext 成为运行中的执行上下文。
   b. 挂起 prevContext。
   c. 将 asyncContext 推入执行上下文堆栈；asyncContext 现在是运行中的执行上下文。
   d. 使用 ThrowCompletion(reason) 作为恢复它的操作的结果，恢复 asyncContext 的挂起评估。
   e. 断言：当我们到达此步骤时，asyncContext 已从执行上下文堆栈中移除，而 prevContext 是当前运行的执行上下文。
   f. 返回 undefined。
6. 让 onRejected 成为 CreateBuiltinFunction(rejectedClosure, 1, "", « »)。
7. 执行 PerformPromiseThen(promise, onFulfilled, onRejected)。
8. 从执行上下文堆栈中移除 asyncContext，并将堆栈顶部的执行上下文恢复为当前运行的执行上下文。
9. 让 callerContext 成为运行中的执行上下文。
10. 恢复 callerContext，传递 EMPTY。如果 asyncContext 再次被恢复，则 completion 是它恢复时的完成记录。
11. 断言：如果控制到达此处，则 asyncContext 再次是运行中的执行上下文。
12. 返回 completion。

Here is the translation of the requested content:

### 28 反射（Reflection）

#### 28.1 反射对象（The Reflect Object）

反射对象：

- 是 %Reflect%。
- 是全局对象的 "Reflect" 属性的初始值。
- 是一个普通对象。
- 其 [[Prototype]] 内部槽的值为 %Object.prototype%。
- 不是一个函数对象。
- 没有 [[Construct]] 内部方法；不能使用 new 操作符作为构造函数使用。
- 没有 [[Call]] 内部方法；不能作为函数调用。

#### 28.1.1 Reflect.apply ( target, thisArgument, argumentsList )

调用此函数时执行以下步骤：

1. 如果 IsCallable(target) 为 false，则抛出 TypeError 异常。
2. 让 args 成为 ? CreateListFromArrayLike(argumentsList)。
3. 执行 PrepareForTailCall()。
4. 返回 ? Call(target, thisArgument, args)。

#### 28.1.2 Reflect.construct ( target, argumentsList [ , newTarget ] )

调用此函数时执行以下步骤：

1. 如果 IsConstructor(target) 为 false，则抛出 TypeError 异常。
2. 如果 newTarget 不存在，则将 newTarget 设置为 target。
3. 否则，如果 IsConstructor(newTarget) 为 false，则抛出 TypeError 异常。
4. 让 args 成为 ? CreateListFromArrayLike(argumentsList)。
5. 返回 ? Construct(target, args, newTarget)。

#### 28.1.3 Reflect.defineProperty ( target, propertyKey, attributes )

调用此函数时执行以下步骤：

1. 如果 target 不是一个对象，则抛出 TypeError 异常。
2. 让 key 成为 ? ToPropertyKey(propertyKey)。
3. 让 desc 成为 ? ToPropertyDescriptor(attributes)。
4. 返回 ? target.[[DefineOwnProperty]](key, desc)。

#### 28.1.4 Reflect.deleteProperty ( target, propertyKey )

调用此函数时执行以下步骤：

1. 如果 target 不是一个对象，则抛出 TypeError 异常。
2. 让 key 成为 ? ToPropertyKey(propertyKey)。
3. 返回 ? target.[[Delete]](key)。

#### 28.1.5 Reflect.get ( target, propertyKey [ , receiver ] )

调用此函数时执行以下步骤：

1. 如果 target 不是一个对象，则抛出 TypeError 异常。
2. 让 key 成为 ? ToPropertyKey(propertyKey)。
3. 如果 receiver 不存在，则
   a. 将 receiver 设置为 target。
4. 返回 ? target.[[Get]](key, receiver)。

#### 28.1.6 Reflect.getOwnPropertyDescriptor ( target, propertyKey )

调用此函数时执行以下步骤：

1. 如果 target 不是一个对象，则抛出 TypeError 异常。
2. 让 key 成为 ? ToPropertyKey(propertyKey)。
3. 让 desc 成为 ? target.[[GetOwnProperty]](key)。
4. 返回 FromPropertyDescriptor(desc)。

#### 28.1.7 Reflect.getPrototypeOf ( target )

调用此函数时执行以下步骤：

1. 如果 target 不是一个对象，则抛出 TypeError 异常。
2. 返回 ? target.[[GetPrototypeOf]]()。

Here is the translation of the remaining content:

### 28.1.8 Reflect.has ( target, propertyKey )

调用此函数时执行以下步骤：

1. 如果 target 不是一个对象，则抛出 TypeError 异常。
2. 让 key 成为 ? ToPropertyKey(propertyKey)。
3. 返回 ? target.[[HasProperty]](key)。

### 28.1.9 Reflect.isExtensible ( target )

调用此函数时执行以下步骤：

1. 如果 target 不是一个对象，则抛出 TypeError 异常。
2. 返回 ? target.[[IsExtensible]]()。

### 28.1.10 Reflect.ownKeys ( target )

调用此函数时执行以下步骤：

1. 如果 target 不是一个对象，则抛出 TypeError 异常。
2. 让 keys 成为 ? target.[[OwnPropertyKeys]]()。
3. 返回 CreateArrayFromList(keys)。

### 28.1.11 Reflect.preventExtensions ( target )

调用此函数时执行以下步骤：

1. 如果 target 不是一个对象，则抛出 TypeError 异常。
2. 返回 ? target.[[PreventExtensions]]()。

### 28.1.12 Reflect.set ( target, propertyKey, V [ , receiver ] )

调用此函数时执行以下步骤：

1. 如果 target 不是一个对象，则抛出 TypeError 异常。
2. 让 key 成为 ? ToPropertyKey(propertyKey)。
3. 如果 receiver 不存在，则
   a. 将 receiver 设置为 target。
4. 返回 ? target.[[Set]](key, V, receiver)。

### 28.1.13 Reflect.setPrototypeOf ( target, proto )

调用此函数时执行以下步骤：

1. 如果 target 不是一个对象，则抛出 TypeError 异常。
2. 如果 proto 不是一个对象且不是 null，则抛出 TypeError 异常。
3. 返回 ? target.[[SetPrototypeOf]](proto)。

### 28.1.14 Reflect [ @@toStringTag ]

@@toStringTag 属性的初始值是字符串值 "Reflect"。

此属性具有以下属性：{ [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }。

Here is the translation of the remaining content:

### 28.2 Proxy Objects

#### 28.2.1 The Proxy Constructor

Proxy 构造函数：

- 是 %Proxy%。
- 是全局对象的 "Proxy" 属性的初始值。
- 在作为构造函数调用时创建并初始化一个新的 Proxy 对象。
- 不打算作为函数调用，当以该方式调用时会抛出异常。

#### 28.2.1.1 Proxy ( target, handler )

调用此函数时执行以下步骤：

1. 如果 NewTarget 是 undefined，则抛出 TypeError 异常。
2. 返回 ? ProxyCreate(target, handler)。

#### 28.2.2 Properties of the Proxy Constructor

Proxy 构造函数：

- 具有一个 [[Prototype]] 内部槽，其值为 %Function.prototype%。
- 没有 "prototype" 属性，因为 Proxy 对象没有需要初始化的 [[Prototype]] 内部槽。
- 具有以下属性：

#### 28.2.2.1 Proxy.revocable ( target, handler )

此函数创建一个可撤销的 Proxy 对象。

调用此函数时执行以下步骤：

1. 让 proxy 成为 ? ProxyCreate(target, handler)。
2. 让 revokerClosure 成为一个捕获空值的新的抽象闭包，调用时执行以下步骤：
   a. 让 F 成为活动函数对象。
   b. 让 p 成为 F.[[RevocableProxy]]。
   c. 如果 p 为 null，则返回 undefined。
   d. 将 F.[[RevocableProxy]] 设置为 null。
   e. 断言：p 是一个 Proxy 异常对象。
   f. 将 p.[[ProxyTarget]] 设置为 null。
   g. 将 p.[[ProxyHandler]] 设置为 null。
   h. 返回 undefined。
3. 让 revoker 成为 CreateBuiltinFunction(revokerClosure, 0, "", « [[RevocableProxy]] »)。
4. 将 revoker.[[RevocableProxy]] 设置为 proxy。
5. 让 result 成为 OrdinaryObjectCreate(%Object.prototype%)。
6. 执行 ! CreateDataPropertyOrThrow(result, "proxy", proxy)。
7. 执行 ! CreateDataPropertyOrThrow(result, "revoke", revoker)。
8. 返回 result。

### 28.3 Module Namespace Objects

模块命名空间对象是一个模块命名空间异常对象，提供基于属性的运行时访问模块的导出绑定。没有模块命名空间对象的构造函数。相反，对于每个通过包含 NameSpaceImport 的 ImportDeclaration 导入的模块，会创建这样一个对象。

除了 10.4.6 中指定的属性外，每个模块命名空间对象具有以下自有属性：

#### 28.3.1 @@toStringTag

@@toStringTag 属性的初始值是字符串值 "Module"。

此属性具有以下属性：{ [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }。


### 29 内存模型
内存一致性模型，或称内存模型，规定了通过访问由 SharedArrayBuffer 支持的 TypedArray 实例和 Atomics 对象上的方法产生的共享数据块事件的可能顺序。当程序不存在数据竞争（如下定义）时，事件的顺序看起来是顺序一致的，即来自每个代理的动作交织在一起。当程序存在数据竞争时，共享内存操作可能呈现顺序不一致的状态。例如，程序可能展示出违反因果关系的行为和其他令人惊讶的现象。这些令人惊讶的现象源于编译器的转换和 CPU 的设计（如乱序执行和推测执行）。内存模型定义了程序展现顺序一致行为的精确条件，以及从数据竞争中读取的可能值。换言之，不存在未定义行为。

内存模型被定义为在评估过程中由 SharedArrayBuffer 的抽象操作或 Atomics 对象上的方法引入的事件的关系约束。

**注意**
本节提供了关于由 SharedArrayBuffer 的抽象操作引入的事件的公理模型。值得强调的是，与规范的其余部分不同，该模型无法以算法方式表达。事件的抽象操作的非确定性引入是 ECMAScript 评估的操作语义和内存模型的公理语义之间的接口。这些事件的语义是通过考虑评估中所有事件的图来定义的。这些事件既不是静态语义也不是运行时语义。尚未展示出算法实现，而是一组约束，确定特定事件图是否被允许或禁止。

#### 29.1 内存模型基础
共享内存访问（读取和写入）分为两组：原子访问和非原子访问，如下所定义。原子访问是顺序一致的，即所有代理在代理群体中都同意的事件的严格总排序。非原子访问没有所有代理都同意的严格总排序，即无序的。

**注释 1**
不支持比顺序一致更弱但比无序更强的排序，如 release-acquire。

一个共享数据块事件是 ReadSharedMemory、WriteSharedMemory 或 ReadModifyWriteSharedMemory 记录。

**表 91：ReadSharedMemory 事件字段**
| 字段名       | 值          | 含义                                     |
|--------------|-------------|------------------------------------------|
| [[Order]]    | SEQ-CST 或 UNORDERED | 内存模型为事件保证的最弱排序。        |
| [[NoTear]]   | 布尔值       | 是否允许此事件从与此事件相等范围内的多个写事件中读取。  |
| [[Block]]    | 共享数据块    | 事件操作的块。                           |
| [[ByteIndex]]| 非负整数      | [[Block]] 中读取的字节地址。               |
| [[ElementSize]] | 非负整数   | 读取的大小。                               |

**表 92：WriteSharedMemory 事件字段**
| 字段名       | 值                      | 含义                                     |
|--------------|-------------------------|------------------------------------------|
| [[Order]]    | SEQ-CST, UNORDERED 或 INIT | 内存模型为事件保证的最弱排序。        |
| [[NoTear]]   | 布尔值                   | 是否允许此事件从与此事件相等范围内的多个读事件中读取。  |
| [[Block]]    | 共享数据块                | 事件操作的块。                           |
| [[ByteIndex]]| 非负整数                 | [[Block]] 中写入的字节地址。               |
| [[ElementSize]] | 非负整数              | 写入的大小。                               |
| [[Payload]]  | 字节值列表               | 将被其他事件读取的字节值列表。             |

**表 93：ReadModifyWriteSharedMemory 事件字段**
| 字段名       | 值                      | 含义                                     |
|--------------|-------------------------|------------------------------------------|
| [[Order]]    | SEQ-CST                 | 读取-修改-写入事件始终顺序一致。        |
| [[NoTear]]   | true                    | 读取-修改-写入事件不会撕裂。              |
| [[Block]]    | 共享数据块                | 事件操作的块。                           |
| [[ByteIndex]]| 非负整数                 | [[Block]] 中读取-修改-写入的字节地址。      |
| [[ElementSize]] | 非负整数              | 读取-修改-写入的大小。                     |
| [[Payload]]  | 字节值列表               | 将传递给 [[ModifyOp]] 的修改操作函数的字节值列表。 |

这些事件是由抽象操作或 Atomics 对象上的方法引入的。

某些操作也可能引入 Synchronize 事件。Synchronize 事件没有字段，仅存在于直接约束其他事件的允许顺序。

除了共享数据块和 Synchronize 事件之外，还有主机特定的事件。

让 ReadSharedMemory、WriteSharedMemory 或 ReadModifyWriteSharedMemory 事件的范围为其 [[ByteIndex]] 到 [[ByteIndex]] + [[ElementSize]] - 1 的连续整数集合。当事件具有相同的 [[Block]] 并且范围逐元素相等时，两个事件的范围相等。当事件具有相同的 [[Block]]、范围不相等并且它们的交集非空时，两个事件的范围重叠。当事件不具有相同的 [[Block]] 或它们的范围既不相等也不重叠时，两个事件的范围是不交叉的。

**注释 2**
应考虑的主机特定同步事件的示例包括：在浏览器中通过 postMessage 发送 SharedArrayBuffer、启动和停止代理以及通过共享内存以外的通道在代理群体内通信。对于特定的执行，这些事件由主机通过主机-同步-严格部分顺序提供。此外，主机可以向执行的 [[EventList]] 中添加主机特定的同步事件，以参与 is-agent-order-before 关系。

事件在候选执行中由以下定义的关系排序。


### 29.2 代理事件记录
代理事件记录是一个具有以下字段的记录。

**表 94：代理事件记录字段**
| 字段名                    | 值                   | 含义                                                     |
|---------------------------|----------------------|----------------------------------------------------------|
| [[AgentSignifier]]         | 代理标识符            | 导致此排序的代理。                                         |
| [[EventList]]              | 事件列表              | 在评估过程中附加到列表中的事件。                              |
| [[AgentSynchronizesWith]]  | Synchronize 事件对列表 | 操作语义引入的同步关系。                                     |

### 29.3 选择的值记录
选择的值记录是一个具有以下字段的记录。

**表 95：选择的值记录字段**
| 字段名               | 值                        | 含义                                             |
|----------------------|---------------------------|--------------------------------------------------|
| [[Event]]            | 共享数据块事件              | 在此选择的值的评估过程中引入的 ReadSharedMemory 或 ReadModifyWriteSharedMemory 事件。 |
| [[ChosenValue]]      | 字节值列表                  | 在评估过程中非确定性选择的字节。                      |

### 29.4 候选执行
代理群体评估的候选执行是一个具有以下字段的记录。

**表 96：候选执行记录字段**
| 字段名                 | 值                         | 含义                                                       |
|------------------------|----------------------------|------------------------------------------------------------|
| [[EventsRecords]]      | 代理事件记录列表               | 将代理映射到在评估过程中附加的事件列表。                        |
| [[ChosenValues]]       | 选择的值记录列表               | 将 ReadSharedMemory 或 ReadModifyWriteSharedMemory 事件映射到在评估过程中选择的字节值列表。 |

空的候选执行是一个所有字段都是空列表的候选执行记录。

### 29.5 内存模型的抽象操作
#### 29.5.1 EventSet（执行）
抽象操作 EventSet 接受参数执行（一个候选执行），并返回一个事件集合。调用时执行以下步骤：

1. 令 events 为一个空集合。
2. 对于执行.[[EventsRecords]] 中的每个代理事件记录 aer，执行以下操作：
   a. 对于 aer.[[EventList]] 中的每个事件 E，执行以下操作：
      i. 将 E 添加到 events 中。
3. 返回 events。

#### 29.5.2 SharedDataBlockEventSet（执行）
抽象操作 SharedDataBlockEventSet 接受参数执行（一个候选执行），并返回一个事件集合。调用时执行以下步骤：

1. 令 events 为一个空集合。
2. 对于 EventSet(execution) 中的每个事件 E，执行以下操作：
   a. 如果 E 是 ReadSharedMemory、WriteSharedMemory 或 ReadModifyWriteSharedMemory 事件，则将 E 添加到 events 中。
3. 返回 events。


### 29.5.3 主机事件集合（HostEventSet）

抽象操作 HostEventSet 接受参数执行（一个候选执行），并返回一个事件集合。调用时执行以下步骤：

1. 令 events 为一个空集合。
2. 对于 EventSet(execution) 中的每个事件 E，执行以下操作：
   a. 如果 E 不在 SharedDataBlockEventSet(execution) 中，则将 E 添加到 events 中。
3. 返回 events。

### 29.5.4 组合写事件字节（ComposeWriteEventBytes）

抽象操作 ComposeWriteEventBytes 接受参数执行（一个候选执行）、byteIndex（非负整数）和 Ws（WriteSharedMemory 或 ReadModifyWriteSharedMemory 事件的列表），并返回一个字节值列表。调用时执行以下步骤：

1. 令 byteLocation 为 byteIndex。
2. 令 bytesRead 为一个新的空列表。
3. 对于 Ws 中的每个元素 W，执行以下操作：
   a. 断言：W 的范围包含 byteLocation。
   b. 令 payloadIndex 为 byteLocation - W.[[ByteIndex]]。
   c. 如果 W 是 WriteSharedMemory 事件，则
      i. 令 byte 为 W.[[Payload]][payloadIndex]。
   d. 否则，
      i. 断言：W 是 ReadModifyWriteSharedMemory 事件。
      ii. 令 bytes 为 ValueOfReadEvent(execution, W)。
      iii. 令 bytesModified 为 W.[[ModifyOp]](bytes, W.[[Payload]])。
      iv. 令 byte 为 bytesModified[payloadIndex]。
   e. 将 byte 追加到 bytesRead 中。
   f. 将 byteLocation 设置为 byteLocation + 1。
4. 返回 bytesRead。

**注释 1**
读-修改-写修改操作 [[ModifyOp]] 由 Atomics 对象上的函数属性给出，这些函数属性引入了 ReadModifyWriteSharedMemory 事件。

**注释 2**
此抽象操作将写事件列表组合成字节值列表。它在 ReadSharedMemory 和 ReadModifyWriteSharedMemory 事件的事件语义中使用。

### 29.5.5 读事件值（ValueOfReadEvent）

抽象操作 ValueOfReadEvent 接受参数执行（一个候选执行）和 R（ReadSharedMemory 或 ReadModifyWriteSharedMemory 事件），并返回一个字节值列表。调用时执行以下步骤：

1. 令 Ws 为执行中 R 的 reads-bytes-from 部分。
2. 断言：Ws 是一个 WriteSharedMemory 或 ReadModifyWriteSharedMemory 事件的列表，其长度等于 R.[[ElementSize]]。
3. 返回 ComposeWriteEventBytes(execution, R.[[ByteIndex]], Ws)。

### 29.6 候选执行的关系
以下关系和数学函数是针对特定候选执行并对其事件进行排序的。

### 29.6.1 is-agent-order-before
对于候选执行 execution，其 is-agent-order-before 关系是事件的最小关系，满足以下条件。

对于事件 E 和 D，在执行中，如果存在代理事件记录 aer，其中 aer.[[EventList]] 同时包含 E 和 D，并且 E 在 aer.[[EventList]] 的列表顺序中先于 D。

**注释**
每个代理在评估过程中引入的事件都是按照每个代理的严格总序。这是这些严格总序的并集。

### 29.6.2 reads-bytes-from
对于候选执行 execution，其 reads-bytes-from 函数是一个数学函数，将 SharedDataBlockEventSet(execution) 中的事件映射到满足以下条件的 SharedDataBlockEventSet(execution) 中事件列表。

对于 SharedDataBlockEventSet(execution) 中的每个 ReadSharedMemory 或 ReadModifyWriteSharedMemory 事件 R，reads-bytes-from(R) 在执行中是一个长度为 R.[[ElementSize]] 的事件列表，其中元素是 WriteSharedMemory 或 ReadModifyWriteSharedMemory 事件 Ws，满足以下所有条件。

- Ws 中索引为 i 的每个事件 W，其 R.[[ByteIndex]] + i 在其范围内。
- R 不在 Ws 中。

候选执行始终接受 reads-bytes-from 函数。


### 29.6.3 读取自（reads-from）

对于候选执行 execution，其 reads-from 关系是满足以下条件的事件最小关系。

对于事件 R 和 W，在执行中，如果 SharedDataBlockEventSet(execution) 同时包含 R 和 W，并且 reads-bytes-from(R) 在执行中包含 W，则 R 读取自 W。

### 29.6.4 主机同步关系（host-synchronizes-with）

对于候选执行 execution，其 host-synchronizes-with 关系是主机提供的关于主机特定事件的严格偏序，满足以下条件。

如果 E 在执行中 host-synchronizes-with D，则 HostEventSet(execution) 包含 E 和 D。
在执行中，host-synchronizes-with 和 is-agent-order-before 的并集中不存在循环。

**注释 1**
对于候选执行 execution 中的两个主机特定事件 E 和 D，如果 E 在执行中 host-synchronizes-with D，则意味着 E 在执行中 happens-before D。

**注释 2**
此关系允许主机提供额外的同步机制，例如在 HTML 工作线程之间的 postMessage。

### 29.6.5 同步关系（synchronizes-with）

对于候选执行 execution，其 synchronizes-with 关系是满足以下条件的事件最小关系。

对于事件 R 和 W，在执行中，如果 R reads-from W，并且 R.[[Order]] 是 SEQ-CST，W.[[Order]] 是 SEQ-CST，并且 R 和 W 具有相等的范围。
对于执行中的每个 eventsRecord，以下内容是真实的。
对于事件 S 和 Sw，在执行中，如果 eventsRecord.[[AgentSynchronizesWith]] 包含 (S, Sw)。
对于事件 E 和 D，在执行中，如果 execution.[[HostSynchronizesWith]] 包含 (E, D)。

**注释 1**
由于内存模型文献中的惯例，在候选执行 execution 中，写事件 synchronizes-with 读事件，而不是读事件 synchronizes-with 写事件。

**注释 2**
在候选执行 execution 中，INIT 事件不参与此关系，而是直接由 happens-before 约束。

**注释 3**
在候选执行 execution 中，并非所有由 reads-from 相关的 SEQ-CST 事件都由 synchronizes-with 相关。只有具有相等范围的事件才由 synchronizes-with 相关。

**注释 4**
对于候选执行 execution 中的 Shared Data Block 事件 R 和 W，如果 W synchronizes-with R，则 R 可以 reads-from 其他不同于 W 的写操作。

### 29.6.6 发生在之前（happens-before）

对于候选执行 execution，其 happens-before 关系是满足以下条件的事件最小关系。

对于事件 E 和 D，在执行中，如果以下任一条件为真，则 E happens-before D：

- E is-agent-order-before D 在执行中。
- E synchronizes-with D 在执行中。
- SharedDataBlockEventSet(execution) 同时包含 E 和 D，E.[[Order]] 是 INIT，并且 E 和 D 有重叠的范围。
- 存在事件 F，使得 E happens-before F 并且 F happens-before D 在执行中。

**注释**
因为 happens-before 是 agent-order 的超集，候选执行与 ECMAScript 的单线程评估语义一致。

### 29.7 有效执行的属性
#### 29.7.1 有效选择读取（Valid Chosen Reads）

候选执行 execution 具有有效选择读取，如果以下算法返回 true。

1. 对于 SharedDataBlockEventSet(execution) 中的每个 ReadSharedMemory 或 ReadModifyWriteSharedMemory 事件 R，执行以下操作：
   a. 令 chosenValueRecord 为 execution.[[ChosenValues]] 中 [[Event]] 字段为 R 的元素。
   b. 令 chosenValue 为 chosenValueRecord.[[ChosenValue]]。
   c. 令 readValue 为 ValueOfReadEvent(execution, R)。
   d. 令 chosenLen 为 chosenValue 的元素数量。
   e. 令 readLen 为 readValue 的元素数量。
   f. 如果 chosenLen ≠ readLen，则
      i. 返回 false。
   g. 如果对于某个整数 i，处于区间从 0（包括）到 chosenLen（不包括），chosenValue[i] ≠ readValue[i]，则
      i. 返回 false。
2. 返回 true。

Here is the translation of the remaining content:

### 29.7.2 一致读取（Coherent Reads）

候选执行 execution 具有一致读取，如果以下算法返回 true。

1. 对于 SharedDataBlockEventSet(execution) 中的每个 ReadSharedMemory 或 ReadModifyWriteSharedMemory 事件 R，执行以下操作：
   a. 令 Ws 为 reads-bytes-from(R) 在 execution 中的元素。
   b. 令 byteLocation 为 R.[[ByteIndex]]。
   c. 对于 Ws 中的每个元素 W，执行以下操作：
      i. 如果在执行中 R happens-before W，则
         1. 返回 false。
      ii. 如果存在一个 WriteSharedMemory 或 ReadModifyWriteSharedMemory 事件 V，其范围中包含 byteLocation，并且满足 W happens-before V 在执行中，并且 V happens-before R 在执行中，则
         1. 返回 false。
      iii. 设置 byteLocation 为 byteLocation + 1。
   2. 返回 true。

### 29.7.3 无撕裂读取（Tear Free Reads）

候选执行 execution 具有无撕裂读取，如果以下算法返回 true。

1. 对于 SharedDataBlockEventSet(execution) 中的每个 ReadSharedMemory 或 ReadModifyWriteSharedMemory 事件 R，执行以下操作：
   a. 如果 R.[[NoTear]] 为 true，则
      i. 断言：将 R.[[ByteIndex]] 除以 R.[[ElementSize]] 的余数为 0。
      ii. 对于每个事件 W，使得 R reads-from W 在执行中，并且 W.[[NoTear]] 为 true，则
         1. 如果 R 和 W 有相等的范围，并且存在一个事件 V，使得 V 和 W 有相等的范围，V.[[NoTear]] 为 true，W 和 V 不是相同的 Shared Data Block 事件，并且 R reads-from V 在执行中，则
            a. 返回 false。
   2. 返回 true。

**注释**
当一个事件的 [[NoTear]] 字段为 true 时，表示该事件是通过访问整数 TypedArray 引入的；当为 false 时，表示通过访问浮点数 TypedArray 或 DataView 引入的。

直观地说，这个要求表示当通过整数 TypedArray 对齐方式访问内存范围时，如果与其他具有相等范围的写事件发生数据竞争，必须“赢得”这个写事件。更确切地说，这个要求表示一个对齐的读事件不能读取由多个具有相等范围的写事件组成的值。然而，对于具有重叠范围的写事件，一个对齐的读事件可以从中读取。

### 29.7.4 顺序一致原子操作（Sequentially Consistent Atomics）

对于候选执行 execution，is-memory-order-before 是 EventSet(execution) 中所有事件的严格全序，满足以下条件。

对于事件 E 和 D，如果 E happens-before D 在执行中，则 E is-memory-order-before D 在执行中。
对于事件 R 和 W，使得 R reads-from W 在执行中，不存在 SharedDataBlockEventSet(execution) 中的 WriteSharedMemory 或 ReadModifyWriteSharedMemory 事件 V 满足 V.[[Order]] 是 SEQ-CST，在执行中 W is-memory-order-before V，并且 V is-memory-order-before R 在执行中，以下任一条件为真。

W synchronizes-with R 在执行中，并且 V 和 R 有相等的范围。
W happens-before R 并且 V happens-before R 在执行中，W.[[Order]] 是 SEQ-CST，并且 W 和 V 有相等的范围。
W happens-before R 并且 W happens-before V 在执行中，R.[[Order]] 是 SEQ-CST，并且 V 和 R 有相等的范围。

**注释 1**
此条款另外限制相等范围上的 SEQ-CST 事件。

对于 SharedDataBlockEventSet(execution) 中的每个 WriteSharedMemory 或 ReadModifyWriteSharedMemory 事件 W，如果 W.[[Order]] 是 SEQ-CST，则不存在一个无限数量的 ReadSharedMemory 或 ReadModifyWriteSharedMemory 事件在 SharedDataBlockEventSet(execution) 中具有相等的范围，并且 memory-order before W。

**注释 2**
此条款与代理的前进保证一起确保 SEQ-CST 写操作在有限时间内对 SEQ-CST 读操作可见。

候选执行具有顺序一致原子操作，如果它包含 is-memory-order-before 关系。

**注释 3**
虽然 is-memory-order-before 包括 EventSet(execution) 中的所有事件，但那些在执行中未受 happens-before 或 synchronizes-with 约束的事件可以在任何顺序中发生。

Here is the translation of the remaining content:

### 29.7.5 有效执行（Valid Executions）

候选执行 execution 是一个有效执行（或简称为执行），如果以下所有条件都为真。

1. 主机为执行提供了一个 host-synchronizes-with 关系。
2. execution 允许一个严格偏序的 happens-before 关系。
3. execution 具有有效的 chosen reads。
4. execution 具有一致的 reads。
5. execution 具有无撕裂的 reads。
6. execution 具有顺序一致的原子操作。
7. 所有程序至少有一个有效执行。

### 29.8 竞争（Races）

对于一个执行 execution 和事件 E、D，它们都包含在 SharedDataBlockEventSet(execution) 中，如果以下算法返回 true，则 E 和 D 存在竞争。

1. 如果 E 和 D 不是相同的 Shared Data Block 事件，则
   a. 如果不是同时在执行中 E happens-before D 和 D happens-before E，则
      i. 如果 E 和 D 都是 WriteSharedMemory 或 ReadModifyWriteSharedMemory 事件，并且 E 和 D 没有不相交的范围，则
         1. 返回 true。
      ii. 如果在执行中 E reads-from D 或 D reads-from E，则
         1. 返回 true。
   2. 返回 false。

### 29.9 数据竞争（Data Races）

对于一个执行 execution 和事件 E、D，它们都包含在 SharedDataBlockEventSet(execution) 中，如果以下算法返回 true，则 E 和 D 是数据竞争。

1. 如果在执行中 E 和 D 存在竞争，则
   a. 如果 E.[[Order]] 不是 SEQ-CST 或者 D.[[Order]] 不是 SEQ-CST，则
      i. 返回 true。
   b. 如果 E 和 D 有重叠的范围，则
      i. 返回 true。
   2. 返回 false。

### 29.10 数据竞争自由（Data Race Freedom）

一个执行 execution 是数据竞争自由的，如果在 SharedDataBlockEventSet(execution) 中不存在两个事件存在数据竞争。

一个程序是数据竞争自由的，如果它的所有执行都是数据竞争自由的。

内存模型保证数据竞争自由程序的所有事件都遵循顺序一致性。


### 29.11 共享内存指南（Shared Memory Guidelines）

**NOTE 1**
以下是 ECMAScript 程序员使用共享内存的指南。

我们建议程序保持无数据竞争，即确保在同一内存位置上不会发生并发的非原子操作。无数据竞争的程序具有交错语义，即每个代理的评估语义步骤都会交错进行。对于无数据竞争的程序，不必深入了解内存模型的细节。这些细节通常不会增进编写 ECMAScript 的直觉。

更普遍地说，即使一个程序不是无数据竞争的，它也可能具有可预测的行为，只要原子操作不参与任何数据竞争，并且参与竞争的操作都具有相同的访问大小。确保原子操作不参与竞争的最简单方法是确保原子操作和非原子操作使用不同的内存单元，并且不同大小的原子访问不会同时访问相同的单元。有效地，程序应尽可能地将共享内存视为强类型。仍然无法依赖竞争的非原子访问的顺序和时间，但如果内存被视为强类型，则竞争访问不会出现“撕裂”（其值的位不会混合）。

**NOTE 2**
以下是为使用共享内存的程序编写编译器转换的 ECMAScript 实现者的指南。

希望允许大多数程序转换，这些转换在单代理设置中是有效的，在多代理程序中也是有效的，以确保每个代理的性能与单代理设置中的性能一样好。通常这些转换很难判断。我们概述了一些关于程序转换的规则，这些规则意图成为规范性的（因为它们由内存模型暗示或强于内存模型暗示），但可能不是穷尽的。这些规则旨在适用于在引入组成 is-agent-order-before 关系的事件之前进行的程序转换。

让代理顺序片段是与单一代理相关的 is-agent-order-before 关系的子集。

让读事件的可能读取值是在所有有效执行中对该事件的 ValueOfReadEvent 的所有值的集合。

在不存在共享内存的情况下有效的代理顺序片段的任何转换，在存在共享内存的情况下也是有效的，以下是例外情况。

原子操作是不可动摇的：程序转换不能导致代理顺序片段中的 SEQ-CST 事件与其 UNORDERED 操作重新排序，也不能导致 SEQ-CST 操作与彼此重新排序，也不能使程序转换从 is-agent-order-before 关系中移除 SEQ-CST 操作。

（实际上，对重新排序的禁止迫使编译器假定每个 SEQ-CST 操作都是同步并包含在最终的 is-memory-order-before 关系中，这在无代理程序分析的情况下通常也是必须假设的。它还迫使编译器假定每次调用中，调用方对内存顺序的效果是未知的，可能包含 SEQ-CST 操作。）

读取必须稳定：每个给定的共享内存读取在执行中只能观察到单个值。

（例如，如果在程序中语义上是单个读取，而被执行多次，则程序随后只能观察到读取值中的一个。称为重生成的转换可能会违反此规则。）

写入必须稳定：所有可观察的对共享内存的写入必须符合程序的语义在执行中。

（例如，转换不能引入某些可观察的写入，例如通过在较大位置上使用读取-修改-写入操作来写入较小的数据项，写入程序无法写入的值到内存，或者将刚读取的值写回到可能在读取后被其他代理覆盖的位置。）

可能的读取值必须非空：程序转换不能导致共享内存读取的可能读取值变为空。

（令人反直觉地是，这个规则实际上限制了对写入的转换，因为写入在内存模型中的作用是使其可以被读取事件读取。例如，写入可以被移动和合并，有时可以在两个 SEQ-CST 操作之间重新排序，但转换不能移除更新位置的每个写入；必须保留一些写入。）

保持有效的转换示例包括：合并从同一位置读取的多个非原子读取，重新排序非原子读取，引入推测性的非原子读取，合并多个写入相同位置的非原子写入，重新排序到不同位置的非原子写入，并将非原子读取提升出循环，即使这影响终止。一般来说，有别名的 TypedArrays 使得证明位置不同很困难。

**NOTE 3**
以下是为共享内存访问生成机器代码的 ECMAScript 实现者的指南。

对于具有不弱于 ARM 或 Power 的内存模型的架构，非原子存储和加载可以编译为目标架构上的裸存储和加载。原子存储和加载可以编译为保证顺序一致的指令。如果不存在这样的指令，则必须使用内存屏障，例如在裸存储或加载的两侧放置屏障。读取-修改-写入操作可以编译为目标架构上的读取-修改-写入指令，例如 x86 上的带 LOCK 前缀的指令，ARM 上的 load-exclusive/store-exclusive 指令以及 Power 上的 load-link/store-conditional 指令。

具体而言，内存模型旨在允许以下代码生成。

程序中的每个原子操作都被认为是必需的。
原子操作永远不会与彼此或非原子操作重新排列。
函数总是假定执行原子操作。
原子操作永远不会实现为在较大数据上的读取-修改-写入操作，而是作为非锁定原子操作，如果平台没有适当大小的原子操作。（我们已经假设每个平台都有每个感兴趣大小的普通内存访问操作。）
朴素的代码生成使用这些模式：

常规加载和存储编译为单个加载和存储指令。
无锁原子加载和存储编译为完整（顺序一致）的屏障，一个常规加载或存储，和一个完整的屏障。
无锁原子读-修改-写入访问编译为完整的屏障，一个原子读-修改-写入指令序列，和一个完整的屏障。
非锁定原子编译为自旋锁获取，一个完整的屏障，一系列非原子加载和存储指令，一个完整的屏障，和一个自旋锁释放。
只要原子操作在地址范围上不与非原子写入或不同大小的原子操作竞争，这种映射就是正确的。然而，这是我们需要的全部：内存模型有效地将参与竞争的原子操作降级为非原子状态。另

一方面，朴素的映射非常强大：它允许原子操作被用作顺序一致的屏障，而内存模型实际上并不保证这一点。

对这些基本模式的本地改进也是允许的，但受到内存模型约束。例如：

有显而易见的依赖于平台的改进可以消除冗余的屏障。例如，在 x86 上，无锁原子加载和存储周围的屏障总是可以省略，除了在存储后的屏障之外，并且无需对无锁读-修改-写入指令使用屏障，因为这些指令都使用了 LOCK 前缀的指令。在许多平台上有几种强度的屏障，并且可以在某些上下文中使用较弱的屏障而不会破坏顺序一致性。
大多数现代平台支持 ECMAScript 原子操作所需的所有数据大小的无锁原子操作。如果需要非锁定原子操作，那么围绕原子操作体的屏障通常可以折叠到锁定和解锁步骤中。非锁定原子操作的最简单解决方案是每个 SharedArrayBuffer 有一个单独的锁定字。
也有更复杂的依赖于平台的本地改进，需要一些代码分析。例如，两个连续的屏障通常具有相同的效果，因此如果为序列中的两个原子操作生成代码，则只需要一个屏障将它们分隔开。在 x86 上，甚至可以省略在原子存储之间分隔的单个屏障，因为只有在存储后的屏障才需要分隔存储和随后的加载。









你是前端JS专家，精通JS规范和原理，也擅长翻译，请翻译下面内容===
好的。翻译我下面给的章节，注意准确性和完整性，完成就停止并说明已翻译完成，别乱写，别无中生有===
继续往后翻译，注意准确性和完整性，完成就停止并说明已翻译完成，别乱写，别无中生有
别瞎说，明明后面还有10.4.4等章节，请继续往后翻译，注意准确性和完整性，完成就停止并说明已翻译完成，别乱写，别无中生有