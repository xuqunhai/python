### 9 可执行代码和执行上下文

#### 9.1 环境记录
环境记录是一种规范类型，用于定义标识符与特定变量和函数的关联，基于 ECMAScript 代码的词法嵌套结构。通常，环境记录与 ECMAScript 代码的某些特定语法结构相关联，如 FunctionDeclaration、BlockStatement 或 TryStatement 的 Catch 子句。每次评估这些代码时，都会创建一个新的环境记录来记录由该代码创建的标识符绑定。

每个环境记录都有一个 [[OuterEnv]] 字段，它要么为 null，要么是对外部环境记录的引用。这用于模拟环境记录值的逻辑嵌套。内（inner）环境记录的外部引用是对逻辑上包围内环境记录的环境记录的引用。当然，外部环境记录也可以有它自己的外部环境记录。一个环境记录可以作为多个内环境记录的外部环境记录。例如，如果一个 FunctionDeclaration 包含两个嵌套的 FunctionDeclaration，那么每个嵌套函数的环境记录将拥有当前评估的外部函数的环境记录作为它们的外部环境记录。

环境记录纯粹是规范机制，不需要对应于 ECMAScript 实现的任何特定工件。ECMAScript 程序不可能直接访问或操作这些值。

#### 9.1.1 环境记录类型层次结构
可以认为环境记录存在于一个简单的面向对象层次结构中，其中环境记录是一个抽象类，具有三个具体子类：声明性环境记录、对象环境记录和全局环境记录。函数环境记录和模块环境记录是声明性环境记录的子类。

**环境记录 (抽象)**

声明性环境记录用于定义 ECMAScript 语言语法元素（如 FunctionDeclaration、VariableDeclaration 和 Catch 子句）的效果，这些元素直接将标识符绑定与 ECMAScript 语言值相关联。

函数环境记录对应于 ECMAScript 函数对象的调用，并包含该函数内的顶层声明绑定。它可能建立一个新的 this 绑定。它还捕获了支持 super 方法调用所需的状态。

模块环境记录包含模块的顶层声明绑定。它还包含模块显式导入的绑定。其 [[OuterEnv]] 是一个全局环境记录。

对象环境记录用于定义 ECMAScript 元素（如 WithStatement）的效果，这些元素将标识符绑定与某个对象的属性相关联。

全局环境记录用于脚本全局声明。它没有外部环境；其 [[OuterEnv]] 为 null。它可能预先填充有标识符绑定，并且包括一个关联的全局对象，其属性提供了一些全局环境的标识符绑定。随着 ECMAScript 代码的执行，可以向全局对象添加其他属性，并且可以修改初始属性。

环境记录抽象类包括表 16 中定义的抽象规范方法。这些抽象方法对每个具体子类都有不同的具体算法。

**表 16: 环境记录的抽象方法**

| 方法                   | 目的                                                                                             |
|------------------------|--------------------------------------------------------------------------------------------------|
| HasBinding(N)          | 确定环境记录是否有字符串值 N 的绑定。如果有，返回 true；否则返回 false。                           |
| CreateMutableBinding(N, D)  | 在环境记录中创建一个新的但未初始化的可变绑定。字符串值 N 是绑定名称的文本。如果布尔参数 D 为 true，则绑定可以随后被删除。  |
| CreateImmutableBinding(N, S)  | 在环境记录中创建一个新的但未初始化的不可变绑定。字符串值 N 是绑定名称的文本。如果 S 为 true，则在初始化后尝试设置它总是会抛出异常，无论引用该绑定的操作的严格模式设置如何。  |
| InitializeBinding(N, V)  | 设置环境记录中已经存在但未初始化的绑定的值。字符串值 N 是绑定名称的文本。V 是绑定的值，可以是任何 ECMAScript 语言类型的值。 |
| SetMutableBinding(N, V, S)  | 设置环境记录中已经存在的可变绑定的值。字符串值 N 是绑定名称的文本。V 是绑定的值，可以是任何 ECMAScript 语言类型的值。S 是一个布尔标志。如果 S 为 true 并且绑定不能被设置，则抛出一个 TypeError 异常。 |
| GetBindingValue(N, S)  | 从环境记录中返回已存在绑定的值。字符串值 N 是绑定名称的文本。S 用于标识来自严格模式代码或其他需要严格模式引用语义的引用。如果 S 为 true 并且绑定不存在，则抛出一个 ReferenceError 异常。如果绑定存在但未初始化，无论 S 的值如何，都会抛出一个 ReferenceError。 |
| DeleteBinding(N)  | 从环境记录中删除绑定。字符串值 N 是绑定名称的文本。如果存在 N 的绑定，删除绑定并返回 true。如果绑定存在但不能被删除，返回 false。如果绑定不存在，返回 true。 |
| HasThisBinding()  | 确定环境记录是否建立了一个 this 绑定。如果是，返回 true；否则返回 false。 |
| HasSuperBinding()  | 确定环境记录是否建立了一个 super 方法绑定。如果是，返回 true；否则返回 false。 |
| WithBaseObject()  | 如果此环境记录与一个 with 语句相关联，则返回 with 对象。否则，返回 undefined。 |

#### 9.1.1.1 声明性环境记录
每个声明性环境记录都与包含变量、常量、let、class、module、import 和/或函数声明的 ECMAScript 程序范围相关联。声明性环境记录绑定其范围内包含的声明定义的标识符集。

声明性环境记录的具体规范方法的行为由以下算法定义。

##### 9.1.1.1.1 HasBinding ( N )
声明性环境记录 envRec 的 HasBinding 具体方法接受参数 N（一个字符串）并返回包含一个布尔值的正常完成。它确定参数标识符是否是记录绑定的标识符之一。调用时执行以下步骤：

1. 如果 envRec 有 N 的绑定，返回 true。
2. 返回 false。

##### 9.1.1.1.2 CreateMutableBinding ( N, D )
声明性环境记录 envRec 的 CreateMutableBinding 具体方法接受参数 N（一个字符串）和 D（一个布尔值），并返回包含 UNUSED 的正常完成。它为名称 N 创建一个新的未初始化的可变绑定。在此环境记录中不应已有 N 的绑定。如果 D 为 true，则新绑定被标记为可以被随后删除。调用时执行以下步骤：

1. 断言：envRec 尚未有 N 的绑定。
2. 在 envRec 中创建一个 N 的可变绑定，并记录它是未初始化的。如果 D 为 true，则记录新创建的绑定可以被后续的 DeleteBinding 调用删除。
3. 返回 UNUSED。

##### 9.1.1.1.3 CreateImmutableBinding ( N, S )
声明性环境记录 envRec 的 CreateImmutableBinding 具体方法接受参数 N（一个字符串）和 S（一个布尔值），并返回包含 UNUSED 的正常完成。它为名称 N 创建一个新的未初始化的不可变绑定。在此环境记录中不应已有 N 的绑定。如果 S 为 true，则新绑定被标记为严格绑定。调用时执行以下步骤：

1. 断言：envRec 尚未有 N 的绑定。
2. 在 envRec 中创建一个 N 的不可变绑定，并记录它是未初始化的。如果 S 为 true，则记录新创建的绑定是严格绑定。
3. 返回 UNUSED。

##### 9.1.1.1.4 InitializeBinding ( N, V )
声明性环境记录 envRec 的 InitializeBinding 具体方法接受参数 N（一个字符串）和 V（一个 ECMAScript 语言值），并返回包含 UNUSED 的正常完成。它用于将名称为 N 的标识符当前绑定的值设置为 V。必须已存在一个未初始化的 N 的绑定。调用时执行以下步骤：

1. 断言：envRec 必须有一个未初始化的 N 的绑定。
2. 将 envRec 中 N 的绑定值设置为 V。
3. 记录 envRec 中 N 的绑定已被初始化。
4. 返回 UNUSED。

##### 9.1.1.1.5 SetMutableBinding ( N, V, S )
声明性环境记录 envRec 的 SetMutableBinding 具体方法接受参数 N（一个字符串）、V（一个 ECMAScript 语言值）和 S（一个布尔值），并返回包含 UNUSED 或一个抛出完成。它试图将名称为 N 的标识符当前绑定的值更改为 V。通常已经存在一个 N 的绑定，但在少数情况下可能没有。如果绑定是不可变绑定，并且 S 为 true，则抛出 TypeError。如果调用时执行以下步骤：

1. 如果 envRec 没有 N 的绑定，
  a. 如果 S 为 true，则抛出一个 ReferenceError 异常。
  b. 执行 ! envRec.CreateMutableBinding(N, true)。
  c. 执行 ! envRec.InitializeBinding(N, V)。
  d. 返回 UNUSED。
2. 如果 envRec 中 N 的绑定是一个严格绑定，则将 S 设置为true。
3. 如果 envRec 中 N 的绑定尚未初始化，
  a. 抛出一个 ReferenceError 异常。
4. 否则，如果 envRec 中 N 的绑定是一个可变绑定，
  a. 将其绑定值更改为 V。
5. 否则，
  a. 断言：这是试图更改不可变绑定的值。
  b. 如果 S 为 true，抛出一个 TypeError 异常。
6. 返回 UNUSED。

##### 9.1.1.1.6 GetBindingValue ( N, S )
声明性环境记录 envRec 的 GetBindingValue 具体方法接受参数 N（一个字符串）和 S（一个布尔值），并返回包含一个 ECMAScript 语言值的正常完成或一个抛出完成。它返回名称为 N 的绑定标识符的值。如果绑定存在但未初始化，则抛出 ReferenceError 异常，无论 S 的值如何。调用时执行以下步骤：

1. 断言：envRec 有 N 的绑定。
2. 如果 envRec 中 N 的绑定是一个未初始化的绑定，抛出一个 ReferenceError 异常。
3. 返回当前绑定到 envRec 中 N 的值。

##### 9.1.1.1.7 DeleteBinding ( N )
声明性环境记录 envRec 的 DeleteBinding 具体方法接受参数 N（一个字符串），并返回包含一个布尔值的正常完成。它只能删除明确指定为可删除的绑定。调用时执行以下步骤：

1. 断言：envRec 有 N 的绑定。
2. 如果 envRec 中 N 的绑定不能被删除，返回 false。
3. 从 envRec 中移除 N 的绑定。
4. 返回 true。

##### 9.1.1.1.8 HasThisBinding ( )
声明性环境记录 envRec 的 HasThisBinding 具体方法不接受参数并返回 false。调用时执行以下步骤：

1. 返回 false。

注意：常规声明性环境记录（即既不是函数环境记录也不是模块环境记录）不提供 this 绑定。

##### 9.1.1.1.9 HasSuperBinding ( )
声明性环境记录 envRec 的 HasSuperBinding 具体方法不接受参数并返回 false。调用时执行以下步骤：

1. 返回 false。

注意：常规声明性环境记录（即既不是函数环境记录也不是模块环境记录）不提供 super 绑定。

##### 9.1.1.1.10 WithBaseObject ( )
声明性环境记录 envRec 的 WithBaseObject 具体方法不接受参数并返回 undefined。调用时执行以下步骤：

1. 返回 undefined。

#### 9.1.1.2 对象环境记录
每个对象环境记录都与一个称为绑定对象的对象相关联。对象环境记录绑定的字符串标识符名称集合直接对应于其绑定对象的属性名称。非字符串形式的属性键不包括在绑定的标识符集合中。无论 [[Enumerable]] 属性的设置如何，既包括自己的属性，也包括继承的属性。由于可以动态添加和删除对象的属性，因此对象环境记录绑定的标识符集合可能会随任何添加或删除属性的操作而改变。由于这种副作用创建的任何绑定即使对应属性的 Writable 属性为 false，也被视为可变绑定。对象环境记录中不存在不可变绑定。

为 with 语句（14.11）创建的对象环境记录可以将其绑定对象作为隐式的 this 值用于函数调用。此功能由一个布尔 [[IsWithEnvironment]] 字段控制。

对象环境记录具有表 17 中列出的附加状态字段。

**表 17: 对象环境记录的附加字段**

| 字段名称                 | 值         | 含义                              |
|-------------------------|------------|----------------------------------|
| [[BindingObject]]       | 一个对象    | 此环境记录的绑定对象。             |
| [[IsWithEnvironment]]   | 一个布尔值  | 表示此环境记录是否为 with 语句创建。 |

对象环境记录的具体规范方法的行为由以下算法定义。

##### 9.1.1.2.1 HasBinding ( N )
对象环境记录 envRec 的 HasBinding 具体方法接受参数 N（一个字符串）并返回包含一个布尔值的正常完成或一个抛出完成。它确定其关联的绑定对象是否具有名称为 N 的属性。调用时执行以下步骤：

1. 令 bindingObject 为 envRec.[[BindingObject]]。
2. 令 foundBinding 为 ? HasProperty(bindingObject, N)。
3. 如果 foundBinding 为 false，返回 false。
4. 如果 envRec.[[IsWithEnvironment]] 为 false，返回 true。
5. 令 unscopables 为 ? Get(bindingObject, @@unscopables)。
6. 如果 unscopables 是一个对象，
  a. 令 blocked 为 ToBoolean(? Get(unscopables, N))。
  b. 如果 blocked 为 true，返回 false。
7. 返回 true。

##### 9.1.1.2.2 CreateMutableBinding ( N, D )
对象环境记录 envRec 的 CreateMutableBinding 具体方法接受参数 N（一个字符串）和 D（一个布尔值），并返回包含 UNUSED 的正常完成或一个抛出完成。它在环境记录的关联绑定对象中创建一个名称为 N 的属性，并将其初始化为 undefined。如果 D 为 true，则新属性的 [[Configurable]] 属性设置为 true；否则设置为 false。调用时执行以下步骤：

1. 令 bindingObject 为 envRec.[[BindingObject]]。
2. 执行 ? DefinePropertyOrThrow(bindingObject, N, PropertyDescriptor { [[Value]]: undefined, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: D })。
3. 返回 UNUSED。

注意：通常 envRec 不会有 N 的绑定，但如果有，DefinePropertyOrThrow 的语义可能会导致现有绑定被替换或遮蔽，或导致返回一个抛出完成。

##### 9.1.1.2.3 CreateImmutableBinding ( N, S )
对象环境记录的 CreateImmutableBinding 具体方法在本规范中从未使用。

##### 9.1.1.2.4 InitializeBinding ( N, V )
对象环境记录 envRec 的 InitializeBinding 具体方法接受参数 N（一个字符串）和 V（一个 ECMAScript 语言值），并返回包含 UNUSED 的正常完成或一个抛出完成。它用于将名称为 N 的标识符当前绑定的值设置为 V。调用时执行以下步骤：

1. 执行 ? envRec.SetMutableBinding(N, V, false)。
2. 返回 UNUSED。

注意：在本规范中，所有为对象环境记录使用的 CreateMutableBinding 都会紧接着调用 InitializeBinding，因此本规范不会显式跟踪对象环境记录中的绑定初始化状态。

##### 9.1.1.2.5 SetMutableBinding ( N, V, S )
对象环境记录 envRec 的 SetMutableBinding 具体方法接受参数 N（一个字符串）、V（一个 ECMAScript 语言值）和 S（一个布尔值），并返回包含 UNUSED 的正常完成或一个抛出完成。它尝试将环境记录的关联绑定对象的名称为 N 的属性的值设置为 V。通常已经存在一个名称为 N 的属性，但如果不存在或当前不可写，错误处理由 S 决定。调用时执行以下步骤：

1. 令 bindingObject 为 envRec.[[BindingObject]]。
2. 令 stillExists 为 ? HasProperty(bindingObject, N)。
3. 如果 stillExists 为 false 且 S 为 true，抛出一个 ReferenceError 异常。
4. 执行 ? Set(bindingObject, N, V, S)。
5. 返回 UNUSED。

##### 9.1.1.2.6 GetBindingValue ( N, S )
对象环境记录 envRec 的 GetBindingValue 具体方法接受参数 N（一个字符串）和 S（一个布尔值），并返回包含一个 ECMAScript 语言值的正常完成或一个抛出完成。它返回其关联绑定对象的名称为 N 的属性的值。属性应该已经存在，但如果不存在，结果取决于 S。调用时执行以下步骤：

1. 令 bindingObject 为 envRec.[[BindingObject]]。
2. 令 value 为 ? HasProperty(bindingObject, N)。
3. 如果 value 为 false，
  a. 如果 S 为 false，返回 undefined；否则抛出一个 ReferenceError 异常。
4. 返回 ? Get(bindingObject, N)。

##### 9.1.1.2.7 DeleteBinding ( N )
对象环境记录 envRec 的 DeleteBinding 具体方法接受参数 N（一个字符串），并返回包含一个布尔值的正常完成或一个抛出完成。它只能删除对应于环境对象属性且其 [[Configurable]] 属性为 true 的绑定。调用时执行以下步骤：

1. 令 bindingObject 为 envRec.[[BindingObject]]。
2. 返回 ? bindingObject.[[Delete]](N)。

##### 9.1.1.2.8 HasThisBinding ( )
对象环境记录 envRec 的 HasThisBinding 具体方法不接受参数并返回 false。调用时执行以下步骤：

1. 返回 false。

注意：对象环境记录不提供 this 绑定。

##### 9.1.1.2.9 HasSuperBinding ( )
对象环境记录 envRec 的 HasSuperBinding 
具体方法不接受参数并返回 false。调用时执行以下步骤：

1. 返回 false。

注意：对象环境记录不提供 super 绑定。

##### 9.1.1.2.10 WithBaseObject ( )
对象环境记录 envRec 的 WithBaseObject 具体方法不接受参数，并返回一个对象或 undefined。调用时执行以下步骤：

1. 如果 envRec.[[IsWithEnvironment]] 为 true，返回 envRec.[[BindingObject]]。
2. 否则，返回 undefined。

#### 9.1.1.3 函数环境记录
函数环境记录是一个声明性环境记录，用于表示函数的顶级作用域，并且如果该函数不是箭头函数，还提供一个 this 绑定。如果一个函数不是箭头函数并且引用了 super，那么它的函数环境记录还包含用于在函数内部执行 super 方法调用的状态。

函数环境记录具有表 18 中列出的附加状态字段。

**表 18: 函数环境记录的附加字段**

| 字段名称              | 值                           | 含义                                     |
|----------------------|------------------------------|----------------------------------------|
| [[ThisValue]]        | 一个 ECMAScript 语言值       | 此函数调用中使用的 this 值。               |
| [[ThisBindingStatus]]| LEXICAL, INITIALIZED, UNINITIALIZED | 如果值为 LEXICAL，则这是一个箭头函数，没有本地的 this 值。 |
| [[FunctionObject]]   | 一个 ECMAScript 函数对象      | 导致创建此环境记录的函数对象。              |
| [[NewTarget]]        | 一个对象或 undefined          | 如果此环境记录是由 [[Construct]] 内部方法创建的，[[NewTarget]] 是 [[Construct]] newTarget 参数的值。否则，其值为 undefined。 |

函数环境记录支持表 16 中列出的所有声明性环境记录方法，并且除了 HasThisBinding 和 HasSuperBinding 方法外，所有这些方法的规范都相同。此外，函数环境记录还支持表 19 中列出的方法：

**表 19: 函数环境记录的附加方法**

| 方法              | 目的                                                                 |
|------------------|----------------------------------------------------------------------|
| BindThisValue(V) | 设置 [[ThisValue]] 并记录它已被初始化。                                |
| GetThisBinding() | 返回此环境记录的 this 绑定的值。如果 this 绑定尚未初始化，则抛出 ReferenceError 异常。 |
| GetSuperBase()   | 返回在此环境记录中绑定的 super 属性访问的基础对象。值为 undefined 表示这种访问将产生运行时错误。 |

函数环境记录附加的具体规范方法的行为由以下算法定义：

##### 9.1.1.3.1 BindThisValue ( V )
函数环境记录 envRec 的 BindThisValue 具体方法接受参数 V（一个 ECMAScript 语言值），并返回包含一个 ECMAScript 语言值的正常完成或一个抛出完成。调用时执行以下步骤：

1. 断言：envRec.[[ThisBindingStatus]] 不是 LEXICAL。
2. 如果 envRec.[[ThisBindingStatus]] 是 INITIALIZED，抛出一个 ReferenceError 异常。
3. 将 envRec.[[ThisValue]] 设置为 V。
4. 将 envRec.[[ThisBindingStatus]] 设置为 INITIALIZED。
5. 返回 V。

##### 9.1.1.3.2 HasThisBinding ( )
函数环境记录 envRec 的 HasThisBinding 具体方法不接受参数并返回一个布尔值。调用时执行以下步骤：

1. 如果 envRec.[[ThisBindingStatus]] 是 LEXICAL，返回 false；否则，返回 true。

##### 9.1.1.3.3 HasSuperBinding ( )
函数环境记录 envRec 的 HasSuperBinding 具体方法不接受参数并返回一个布尔值。调用时执行以下步骤：

1. 如果 envRec.[[ThisBindingStatus]] 是 LEXICAL，返回 false。
2. 如果 envRec.[[FunctionObject]].[[HomeObject]] 是 undefined，返回 false；否则，返回 true。

##### 9.1.1.3.4 GetThisBinding ( )
函数环境记录 envRec 的 GetThisBinding 具体方法不接受参数并返回包含一个 ECMAScript 语言值的正常完成或一个抛出完成。调用时执行以下步骤：

1. 断言：envRec.[[ThisBindingStatus]] 不是 LEXICAL。
2. 如果 envRec.[[ThisBindingStatus]] 是 UNINITIALIZED，抛出一个 ReferenceError 异常。
3. 返回 envRec.[[ThisValue]]。

##### 9.1.1.3.5 GetSuperBase ( )
函数环境记录 envRec 的 GetSuperBase 具体方法不接受参数并返回包含一个对象、null 或 undefined 的正常完成或一个抛出完成。调用时执行以下步骤：

1. 令 home 为 envRec.[[FunctionObject]].[[HomeObject]]。
2. 如果 home 是 undefined，返回 undefined。
3. 断言：home 是一个对象。
4. 返回 ? home.[[GetPrototypeOf]]()。

#### 9.1.1.4 全局环境记录
全局环境记录用于表示所有在同一领域中处理的 ECMAScript 脚本元素共享的最外层作用域。全局环境记录提供内建全局（第 19 章）、全局对象的属性和所有在全局代码中出现的顶级声明（8.2.9，8.2.11）的绑定。

全局环境记录逻辑上是一个单独的记录，但它被指定为一个复合体，封装了一个对象环境记录和一个声明性环境记录。对象环境记录的基础对象是关联领域记录的全局对象。这个全局对象是全局环境记录的 GetThisBinding 具体方法返回的值。全局环境记录的对象环境记录部分包含所有内建全局（第 19 章）和在全局代码中包含的 FunctionDeclaration、GeneratorDeclaration、AsyncFunctionDeclaration、AsyncGeneratorDeclaration 或 VariableStatement 的绑定。所有其他 ECMAScript 声明在全局代码中的绑定包含在全局环境记录的声明性环境记录部分中。

可以直接在全局对象上创建属性。因此，全局环境记录的对象环境记录部分可能包含显式由 FunctionDeclaration、GeneratorDeclaration、AsyncFunctionDeclaration、AsyncGeneratorDeclaration 或 VariableDeclaration 声明创建的绑定，也可能包含隐式作为全局对象的属性创建的绑定。为了识别哪些绑定是使用声明显式创建的，全局环境记录维护一个名称列表，用于记录其 CreateGlobalVarBinding 和 CreateGlobalFunctionBinding 具体方法绑定的名称。

全局环境记录具有表 20 中列出的附加字段和表 21 中列出的附加方法。

**表 20: 全局环境记录的附加字段**

| 字段名称            | 值                     | 含义                                                                                               |
|--------------------|------------------------|--------------------------------------------------------------------------------------------------|
| [[ObjectRecord]]   | 一个对象环境记录        | 绑定对象是全局对象。它包含全局内建绑定以及在关联领域的全局代码中的 FunctionDeclaration、GeneratorDeclaration、AsyncFunctionDeclaration、AsyncGeneratorDeclaration 和 VariableDeclaration 绑定。 |
| [[GlobalThisValue]]| 一个对象               | 在全局作用域中由 this 返回的值。宿主可以提供任何 ECMAScript 对象值。                                                 |
| [[DeclarativeRecord]] | 一个声明性环境记录    | 包含关联领域的全局代码中除 FunctionDeclaration、GeneratorDeclaration、AsyncFunctionDeclaration、AsyncGeneratorDeclaration 和 VariableDeclaration 绑定之外的所有声明绑定。 |
| [[VarNames]]       | 一个字符串列表          | 由 FunctionDeclaration、GeneratorDeclaration、AsyncFunctionDeclaration、AsyncGeneratorDeclaration 和 VariableDeclaration 声明在全局代码中绑定的字符串名称。 |

**表 21: 全局环境记录的附加方法**

| 方法                      | 目的                                                                                                                                                                                                                                                                   |
|---------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| GetThisBinding()          | 返回此环境记录的 this 绑定的值。                                                                                                                                                                                                                                         |
| HasVarDeclaration(N)      | 确定参数标识符是否在此环境记录中具有由 VariableDeclaration、FunctionDeclaration、GeneratorDeclaration、AsyncFunctionDeclaration 或 AsyncGeneratorDeclaration 创建的绑定。                                                                                               |
| HasLexicalDeclaration(N)  | 确定参数标识符是否在此环境记录中具有由词法声明（如 LexicalDeclaration 或 ClassDeclaration）创建的绑定。                                                                                                                                                                 |
| HasRestrictedGlobalProperty(N) | 确定参数是否是全局对象属性的名称，这些属性不能被全局词法绑定所遮蔽。                                                                                                                                                                                                  |
| CanDeclareGlobalVar(N)    | 确定如果为相同参数 N 调用相应的 CreateGlobalVarBinding 调用是否会成功。允许冗余的 var 声明和预先存在的全局对象属性的 var 声明。                                                                                                                                              |
| CanDeclareGlobalFunction(N)| 确定如果为相同参数 N 调用相应的 CreateGlobalFunctionBinding 调用是否会成功。                                                                                                                                                                                              |
| CreateGlobalVarBinding(N, D)| 在 [[ObjectRecord]] 组件的全局环境记录中创建并初始化为 undefined 的全局 var 绑定。绑定将是一个可变绑定。对应的全局对象属性将具有适合 var 的属性值。字符串值 N 是绑定名称。如果 D 为 true，则绑定可以被删除。逻辑上等同于 CreateMutableBinding 之后跟随 SetMutableBinding，但它允许 var 声明获得特殊处理。|
| CreateGlobalFunctionBinding(N, V, D) | 在 [[ObjectRecord]] 组件的全局环境记录中创建并初始化一个全局函数绑定。绑定将是一个可变绑定。对应的全局对象属性将具有适合函数的属性值。字符串值 N 是绑定名称。V 是初始化值。如果布尔参数 D 为 true，则绑定可以被删除。逻辑上等同于 CreateMutableBinding 之后跟随 SetMutableBinding，但它允许函数声明获得特殊处理。|

全局环境记录的具体规范方法的行为由以下算法定义。

##### 9.1.1.4.1 HasBinding ( N )
全局环境记录 envRec 的 HasBinding 具体方法接受参数 N（一个字符串）并返回包含一个布尔值的正常完成或一个抛出完成。它确定参数标识符是否是记录绑定的标识符之一。调用时执行以下步骤：

1. 令 DclRec 为 envRec.[[DeclarativeRecord]]。
2. 如果 ! DclRec.HasBinding(N) 为 true，返回 true。
3. 令 ObjRec 为 envRec.[[ObjectRecord]]。
4. 返回 ? ObjRec.HasBinding(N)。

##### 9.1.1.4.2 CreateMutableBinding ( N, D )
全局环境记录 envRec 的 CreateMutableBinding 具体方法接受参数 N（一个字符串）和 D（一个布尔值），并返回包含 UNUSED 的正常完成或一个抛出完成。它为名称 N 创建一个新的未初始化的可变绑定。绑定在关联的 DeclarativeRecord 中创建。此 DeclarativeRecord 中不应已有 N 的绑定。如果 D 为 true，则新绑定被标记为可以被删除。调用时执行以下步骤：

1. 令 DclRec 为 envRec.[[DeclarativeRecord]]。
2. 如果 ! DclRec.HasBinding(N) 为 true，抛出一个 TypeError 异常。
3. 返回 ! DclRec.CreateMutableBinding(N, D)。

##### 9.1.1.4.3 CreateImmutableBinding ( N, S )
全局环境记录 envRec 的 CreateImmutableBinding 具体方法接受参数 N（一个字符串）和 S（一个布尔值），并返回包含 UNUSED 的正常完成或一个抛出完成。它为名称 N 创建一个新的未初始化的不可变绑定。在此环境记录中不应已有 N 的绑定。如果 S 为 true，则新绑定被标记为严格绑定。调用时执行以下步骤：

1. 令 DclRec 为 envRec.[[DeclarativeRecord]]。
2. 如果 ! DclRec.HasBinding(N) 为 true，抛出一个 TypeError 异常。
3. 返回 ! DclRec.CreateImmutableBinding(N, S)。

##### 9.1.1.4.4 InitializeBinding ( N, V )
全局环境记录 envRec 的 InitializeBinding 具体方法接受参数 N（一个字符串）和 V（一个 ECMAScript 语言值），并返回包含 UNUSED 的正常完成或一个抛出完成。它用于将名称为 N 的标识符当前绑定的值设置为 V。必须已存在一个未初始化的 N 的绑定。调用时执行以下步骤：

1. 令 DclRec 为 envRec.[[DeclarativeRecord]]。
2. 如果 ! DclRec.HasBinding(N) 为 true，
  a. 返回 ! DclRec.InitializeBinding(N, V)。
3. 断言：如果绑定存在，它必须在对象环境记录中。
4. 令 ObjRec 为 envRec.[[ObjectRecord]]。
5. 返回 ? ObjRec.InitializeBinding(N, V)。

##### 9.1.1.4.5 SetMutableBinding ( N, V, S )
全局环境记录 envRec 的 SetMutableBinding 具体方法接受参数 N（一个字符串）、V（一个 ECMAScript 语言值）和 S（一个布尔值），并返回包含 UNUSED 的正常完成或一个抛出完成。它尝试将名称为 N 的标识符当前绑定的值更改为 V。如果绑定是不可变绑定并且 S 为 true，则抛出 TypeError。调用时执行以下步骤：

1. 令 DclRec 为 envRec.[[DeclarativeRecord]]。
2. 如果 ! DclRec.HasBinding(N) 为 true，
  a. 返回 ? DclRec.SetMutableBinding(N, V, S)。
3. 令 ObjRec 为 envRec.[[ObjectRecord]]。
4. 返回 ? ObjRec.SetMutableBinding(N, V, S)。

##### 9.1.1.4.6 GetBindingValue ( N, S )
全局环境记录 envRec 的 GetBindingValue 具体方法接受参数 N（一个字符串）和 S（一个布尔值），并返回包含一个 ECMAScript 语言值的正常完成或一个抛出完成。它返回名称为 N 的绑定标识符的值。如果绑定是未初始化的绑定，则抛出 ReferenceError 异常。调用时执行以下步骤：

1. 令 DclRec 为 envRec.[[DeclarativeRecord]]。
2. 如果 ! DclRec.HasBinding(N) 为 true，
  a. 返回 ? DclRec.GetBindingValue(N, S)。
3. 令 ObjRec 为 envRec.[[ObjectRecord]]。
4. 返回 ? ObjRec.GetBindingValue(N, S)。

##### 9.1.1.4.7 DeleteBinding ( N )
全局环境记录 envRec 的 DeleteBinding 具体方法接受参数 N（一个字符串），并返回包含一个布尔值的正常完成或一个抛出完成。它只能删除明确指定为可删除的绑定。调用时执行以下步骤：

1. 令 DclRec 为 envRec.[[DeclarativeRecord]]。
2. 如果 ! DclRec.HasBinding(N) 为 true，
  a. 返回 ! DclRec.DeleteBinding(N)。
3. 令 ObjRec 为 envRec.[[ObjectRecord]]。
4. 令 globalObject 为 ObjRec.[[BindingObject]]。
5. 令 existingProp 为 ? HasOwnProperty(globalObject, N)。
6. 如果 existingProp 为 true，
  a. 令 status 为 ? ObjRec.DeleteBinding(N)。
  b. 如果 status 为 true 且 envRec.[[VarNames]] 包含 N，
    i. 从 envRec.[[VarNames]] 中移除 N。
  c. 返回 status。
7. 返回 true。

##### 9.1.1.4.8 HasThisBinding ( )
全局环境记录 envRec 的 HasThisBinding 具体方法不接受参数并返回 true。调用时执行以下步骤：

1. 返回 true。

注意：全局环境记录始终提供 this 绑定。

##### 9.1.1.4.9 HasSuperBinding ( )
全局环境记录 envRec 的 HasSuperBinding 具体方法不接受参数并返回 false。调用时执行以下步骤：

1. 返回 false。

注意：全局环境记录不提供 super 绑定。

##### 9.1.1.4.10 WithBaseObject ( )
全局环境记录 envRec 的 WithBaseObject 具体方法不接受参数并返回 undefined。调用时执行以下步骤：

1. 返回 undefined。

##### 9.1.1.4.11 GetThisBinding ( )
全局环境记录 envRec 的 GetThisBinding 具体方法不接受参数并返回一个对象的正常完成。调用时执行以下步骤：

1. 返回 envRec.[[GlobalThisValue]]。

##### 9.1.1.4.12 HasVarDeclaration ( N )
全局环境记录 envRec 的 HasVarDeclaration 具体方法接受参数 N（一个字符串）并返回一个布尔值。它确定参数标识符是否在此记录中具有由 VariableDeclaration、FunctionDeclaration、GeneratorDeclaration、AsyncFunctionDeclaration 或 AsyncGeneratorDeclaration 创建的绑定。调用时执行以下步骤：

1. 令 varDeclaredNames 为 envRec.[[VarNames]]。
2. 如果 varDeclaredNames 包含 N，返回 true。
3. 返回 false。

##### 9.1.1.4.13 HasLexicalDeclaration ( N )
全局环境记录 envRec 的 HasLexicalDeclaration 具体方法接受参数 N（一个字符串）并返回一个布尔值。它确定参数标识符是否在此记录中具有由词法声明（如 LexicalDeclaration 或 ClassDeclaration）创建的绑定。调用时执行以下步骤：

1. 令 DclRec 为 envRec.[[DeclarativeRecord]]。
2. 返回 ! DclRec.HasBinding(N)。

##### 9.1.1.4.14 HasRestrictedGlobalProperty ( N )
全局环境记录 envRec 的 HasRestrictedGlobalProperty 具体方法接受参数 N（一个字符串）并返回包含一个布尔值的正常完成或一个抛出完成。它确定参数标识符是否是全局对象的属性名称，这些属性不能被全局词法绑定所遮蔽。调用时执行以下步骤：

1. 令 ObjRec 为 envRec.[[ObjectRecord]]。
2. 令 globalObject 为 ObjRec.[[BindingObject]]。
3. 令 existingProp 为 ? globalObject.[[GetOwnProperty]](N)。
4. 如果 existingProp 为 undefined，返回 false。
5. 如果 existingProp.[[Configurable]] 为 true，返回 false。
6. 返回 true。

注意：属性可能直接在全局对象上创建，而不是通过 var 或 function 声明创建。不能创建与全局对象不可配置属性同名的全局词法绑定。“undefined” 就是这种属性的一个例子。

##### 9.1.1.4.15 CanDeclareGlobalVar ( N )
全局环境记录 envRec 的 CanDeclareGlobalVar 具体方法接受参数 N（一个字符串），并返回包含一个布尔值的正常完成或一个抛出完成。它确定如果为相同参数 N 调用相应的 CreateGlobalVarBinding 是否会成功。允许冗余的 var 声明和已有的全局对象属性的 var 声明。调用时执行以下步骤：

1. 令 ObjRec 为 envRec.[[ObjectRecord]]。
2. 令 globalObject 为 ObjRec.[[BindingObject]]。
3. 令 hasProperty 为 ? HasOwnProperty(globalObject, N)。
4. 如果 hasProperty 为 true，返回 true。
5. 返回 ? IsExtensible(globalObject)。

##### 9.1.1.4.16 CanDeclareGlobalFunction ( N )
全局环境记录 envRec 的 CanDeclareGlobalFunction 具体方法接受参数 N（一个字符串），并返回包含一个布尔值的正常完成或一个抛出完成。它确定如果为相同参数 N 调用相应的 CreateGlobalFunctionBinding 是否会成功。调用时执行以下步骤：

1. 令 ObjRec 为 envRec.[[ObjectRecord]]。
2. 令 globalObject 为 ObjRec.[[BindingObject]]。
3. 令 existingProp 为 ? globalObject.[[GetOwnProperty]](N)。
4. 如果 existingProp 为 undefined，返回 ? IsExtensible(globalObject)。
5. 如果 existingProp.[[Configurable]] 为 true，返回 true。
6. 如果 IsDataDescriptor(existingProp) 为 true 且 existingProp 的属性值为 { [[Writable]]: true, [[Enumerable]]: true }，返回 true。
7. 返回 false。

##### 9.1.1.4.17 CreateGlobalVarBinding ( N, D )
全局环境记录 envRec 的 CreateGlobalVarBinding 具体方法接受参数 N（一个字符串）和 D（一个布尔值），并返回包含 UNUSED 的正常完成或一个抛出完成。它在关联的对象环境记录中创建并初始化一个全局 var 绑定，并在关联的 [[VarNames]] 列表中记录绑定名称。如果已存在绑定，则重用它并假设它已初始化。调用时执行以下步骤：

1. 令 ObjRec 为 envRec.[[ObjectRecord]]。
2. 令 globalObject 为 ObjRec.[[BindingObject]]。
3. 令 hasProperty 为 ? HasOwnProperty(globalObject, N)。
4. 令 extensible 为 ? IsExtensible(globalObject)。
5. 如果 hasProperty 为 false 且 extensible 为 true，
  a. 执行 ? ObjRec.CreateMutableBinding(N, D)。
  b. 执行 ? ObjRec.InitializeBinding(N, undefined)。
6. 如果 envRec.[[VarNames]] 不包含 N，
  a. 将 N 添加到 envRec.[[VarNames]] 中。
7. 返回 UNUSED。

##### 9.1.1.4.18 CreateGlobalFunctionBinding ( N, V, D )
全局环境记录 envRec 的 CreateGlobalFunctionBinding 具体方法接受参数 N（一个字符串）、V（一个 ECMAScript 语言值）和 D（一个布尔值），并返回包含 UNUSED 的正常完成或一个抛出完成。它在关联的对象环境记录中创建并初始化一个全局函数绑定，并在关联的 [[VarNames]] 列表中记录绑定名称。如果已存在绑定，则替换它。调用时执行以下步骤：

1. 令 ObjRec 为 envRec.[[ObjectRecord]]。
2. 令 globalObject 为 ObjRec.[[BindingObject]]。
3. 令 existingProp 为 ? globalObject.[[GetOwnProperty]](N)。
4. 如果 existingProp 为 undefined 或 existingProp.[[Configurable]] 为 true，
  a. 令 desc 为 PropertyDescriptor { [[Value]]: V, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: D }。
5. 否则，
  a. 令 desc 为 PropertyDescriptor { [[Value]]: V }。
6. 执行 ? DefinePropertyOrThrow(globalObject, N, desc)。
7. 执行 ? Set(globalObject, N, V, false)。
8. 如果 envRec.[[VarNames]] 不包含 N，
  a. 将 N 添加到 envRec.[[VarNames]] 中。
9. 返回 UNUSED。

注意：全局函数声明始终表示为全局对象的自有属性。如果可能，现有的自有属性将被重新配置以具有一组标准属性值。第 7 步等同于调用 InitializeBinding 具体方法所做的，并且如果 globalObject 是一个代理，将产生相同的代理陷阱调用序列。

##### 9.1.1.5 模块环境记录
模块环境记录是一个声明性环境记录，用于表示 ECMAScript 模块的外部作用域。除了常规的可变和不可变绑定外，模块环境记录还提供不可变的导入绑定，这些绑定提供对另一个环境记录中存在的目标绑定的间接访问。

模块环境记录支持表 16 中列出的所有声明性环境记录方法，并且除了 GetBindingValue、DeleteBinding、HasThisBinding 和 GetThisBinding 之外，所有这些方法的规范都相同。此外，模块环境记录还支持表 22 中列出的方法：

**表 22: 模块环境记录的附加方法**

| 方法                     | 目的                                                                                       |
|-------------------------|------------------------------------------------------------------------------------------|
| CreateImportBinding(N, M, N2) | 在模块环境记录中创建一个不可变的间接绑定。字符串值 N 是绑定名称的文本。M 是一个模块记录，N2 是 M 的模块环境记录中存在的绑定。   |
| GetThisBinding()        | 返回此环境记录的 this 绑定的值。                                                           |

模块环境记录附加的具体规范方法的行为由以下算法定义：

##### 9.1.1.5.1 GetBindingValue ( N, S )
模块环境记录 envRec 的 GetBindingValue 具体方法接受参数 N（一个字符串）和 S（一个布尔值），并返回包含一个 ECMAScript 语言值的正常完成或一个抛出完成。它返回名称为 N 的绑定标识符的值。但是，如果绑定是一个间接绑定，则返回目标绑定的值。如果绑定存在但未初始化，则抛出 ReferenceError 异常。调用时执行以下步骤：

1. 断言：S 为 true。
2. 断言：envRec 有 N 的绑定。
3. 如果 N 的绑定是一个间接绑定，
  a. 令 M 和 N2 为创建此 N 绑定时提供的间接值。
  b. 令 targetEnv 为 M.[[Environment]]。
  c. 如果 targetEnv 是 EMPTY，抛出一个 ReferenceError 异常。
  d. 返回 ? targetEnv.GetBindingValue(N2, true)。
4. 如果 envRec 中 N 的绑定是一个未初始化的绑定，抛出一个 ReferenceError 异常。
5. 返回当前绑定到 N 的值在 envRec 中。

注意：S 始终为 true，因为模块始终是严格模式代码。

##### 9.1.1.5.2 DeleteBinding ( N )
模块环境记录的 DeleteBinding 具体方法在本规范中从未使用。

注意：模块环境记录仅在严格代码中使用，并且一个早期错误规则阻止在严格代码中对解析为模块环境记录绑定的引用记录应用 delete 操作符。见 13.5.1.1。

##### 9.1.1.5.3 HasThisBinding ( )
模块环境记录 envRec 的 HasThisBinding 具体方法不接受参数并返回 true。调用时执行以下步骤：

1. 返回 true。

注意：模块环境记录始终提供 this 绑定。

##### 9.1.1.5.4 GetThisBinding ( )
模块环境记录 envRec 的 GetThisBinding 具体方法不接受参数并返回一个包含 undefined 的正常完成。调用时执行以下步骤：

1. 返回 undefined。

##### 9.1.1.5.5 CreateImportBinding ( N, M, N2 )
模块环境记录 envRec 的 CreateImportBinding 具体方法接受参数 N（一个字符串）、M（一个模块记录）和 N2（一个字符串），并返回 UNUSED。它为名称 N 创建一个新的已初始化的不可变间接绑定。在此环境记录中不应已有 N 的绑定。N2 是 M 的模块环境记录中存在的绑定名称。对新绑定值的访问将间接访问目标绑定的值。调用时执行以下步骤：

1. 断言：envRec 尚未有 N 的绑定。
2. 断言：当 M.[[Environment]] 实例化时，它将有一个对 N2 的直接绑定。
3. 在 envRec 中为 N 创建一个不可变的间接绑定，该绑定引用 M 和 N2 作为其目标绑定，并记录该绑定已初始化。
4. 返回 UNUSED。

#### 9.1.2 环境记录操作
本规范中使用以下抽象操作来操作环境记录：

##### 9.1.2.1 GetIdentifierReference ( env, name, strict )
抽象操作 GetIdentifierReference接受参数 env（一个环境记录或 null）、name（一个字符串）和 strict（一个布尔值），并返回包含一个引用记录的正常完成或一个抛出完成。调用时执行以下步骤：

1. 如果 env 为 null，
  a. 返回引用记录 { [[Base]]: UNRESOLVABLE, [[ReferencedName]]: name, [[Strict]]: strict, [[ThisValue]]: EMPTY }。
2. 令 exists 为 ? env.HasBinding(name)。
3. 如果 exists 为 true，
  a. 返回引用记录 { [[Base]]: env, [[ReferencedName]]: name, [[Strict]]: strict, [[ThisValue]]: EMPTY }。
4. 否则，
  a. 令 outer 为 env.[[OuterEnv]]。
  b. 返回 ? GetIdentifierReference(outer, name, strict)。

##### 9.1.2.2 NewDeclarativeEnvironment ( E )
抽象操作 NewDeclarativeEnvironment 接受参数 E（一个环境记录或 null），并返回一个声明性环境记录。调用时执行以下步骤：

1. 令 env 为一个新的声明性环境记录，不包含任何绑定。
2. 将 env.[[OuterEnv]] 设置为 E。
3. 返回 env。

##### 9.1.2.3 NewObjectEnvironment ( O, W, E )
抽象操作 NewObjectEnvironment 接受参数 O（一个对象）、W（一个布尔值）和 E（一个环境记录或 null），并返回一个对象环境记录。调用时执行以下步骤：

1. 令 env 为一个新的对象环境记录。
2. 将 env.[[BindingObject]] 设置为 O。
3. 将 env.[[IsWithEnvironment]] 设置为 W。
4. 将 env.[[OuterEnv]] 设置为 E。
5. 返回 env。

##### 9.1.2.4 NewFunctionEnvironment ( F, newTarget )
抽象操作 NewFunctionEnvironment 接受参数 F（一个 ECMAScript 函数对象）和 newTarget（一个对象或 undefined），并返回一个函数环境记录。调用时执行以下步骤：

1. 令 env 为一个新的函数环境记录，不包含任何绑定。
2. 将 env.[[FunctionObject]] 设置为 F。
3. 如果 F.[[ThisMode]] 为 LEXICAL，将 env.[[ThisBindingStatus]] 设置为 LEXICAL。
4. 否则，将 env.[[ThisBindingStatus]] 设置为 UNINITIALIZED。
5. 将 env.[[NewTarget]] 设置为 newTarget。
6. 将 env.[[OuterEnv]] 设置为 F.[[Environment]]。
7. 返回 env。

##### 9.1.2.5 NewGlobalEnvironment ( G, thisValue )
抽象操作 NewGlobalEnvironment 接受参数 G（一个对象）和 thisValue（一个对象），并返回一个全局环境记录。调用时执行以下步骤：

1. 令 objRec 为 NewObjectEnvironment(G, false, null)。
2. 令 dclRec 为 NewDeclarativeEnvironment(null)。
3. 令 env 为一个新的全局环境记录。
4. 将 env.[[ObjectRecord]] 设置为 objRec。
5. 将 env.[[GlobalThisValue]] 设置为 thisValue。
6. 将 env.[[DeclarativeRecord]] 设置为 dclRec。
7. 将 env.[[VarNames]] 设置为一个新的空列表。
8. 将 env.[[OuterEnv]] 设置为 null。
9. 返回 env。

##### 9.1.2.6 NewModuleEnvironment ( E )
抽象操作 NewModuleEnvironment 接受参数 E（一个环境记录），并返回一个模块环境记录。调用时执行以下步骤：

1. 令 env 为一个新的模块环境记录，不包含任何绑定。
2. 将 env.[[OuterEnv]] 设置为 E。
3. 返回 env。

### 9.2 私有环境记录

私有环境记录是一种规范机制，用于根据 ECMAScript 代码中的类声明（ClassDeclarations）和类表达式（ClassExpressions）的词法嵌套结构来跟踪私有名称（Private Names）。它们类似于环境记录，但有所不同。每个私有环境记录与一个类声明或类表达式相关联。每次评估这样的类时，都会创建一个新的私有环境记录，以记录该类声明的私有名称。

每个私有环境记录都有表 23 中定义的字段。

#### 表 23: 私有环境记录字段

| 字段名称                  | 值类型                          | 含义                                                  |
| ----------------------- | ---------------------------- | --------------------------------------------------- |
| [[OuterPrivateEnvironment]] | 私有环境记录或 null              | 最近的包含类的私有环境记录。如果该私有环境记录关联的类不包含在任何其他类中，则为 null。 |
| [[Names]]                 | 私有名称列表                    | 该类声明的私有名称。                                        |

#### 9.2.1 私有环境记录操作

在本规范中使用以下抽象操作来操作私有环境记录：

##### 9.2.1.1 NewPrivateEnvironment ( outerPrivEnv )
抽象操作 NewPrivateEnvironment 接受参数 outerPrivEnv（一个私有环境记录或 null），并返回一个私有环境记录。调用时执行以下步骤：

1. 令 names 为一个新的空列表。
2. 返回私有环境记录 { [[OuterPrivateEnvironment]]: outerPrivEnv, [[Names]]: names }。

##### 9.2.1.2 ResolvePrivateIdentifier ( privEnv, identifier )
抽象操作 ResolvePrivateIdentifier 接受参数 privEnv（一个私有环境记录）和 identifier（一个字符串），并返回一个私有名称。调用时执行以下步骤：

1. 令 names 为 privEnv.[[Names]]。
2. 对于 names 中的每个私有名称 pn，执行
   a. 如果 pn.[[Description]] 为 identifier，则
      i. 返回 pn。
3. 令 outerPrivEnv 为 privEnv.[[OuterPrivateEnvironment]]。
4. 断言：outerPrivEnv 不是 null。
5. 返回 ResolvePrivateIdentifier(outerPrivEnv, identifier)。

### 9.3 范围（Realms）

在评估之前，所有 ECMAScript 代码必须与一个范围相关联。从概念上讲，一个范围由一组内在对象、一个 ECMAScript 全局环境、在该全局环境范围内加载的所有 ECMAScript 代码以及其他相关状态和资源组成。

在本规范中，一个范围表示为一个范围记录（Realm Record），其字段在表 24 中规定：

#### 表 24: 范围记录字段

| 字段名称             | 值                             | 含义                                                        |
| ----------------- | --------------------------- | --------------------------------------------------------- |
| [[AgentSignifier]] | 一个代理标识符                  | 拥有该范围的代理                                            |
| [[Intrinsics]]     | 一个记录，其字段名称为内在键，其值为对象 | 与该范围相关的代码使用的内在值                                  |
| [[GlobalObject]]   | 一个对象或 undefined         | 该范围的全局对象                                              |
| [[GlobalEnv]]      | 一个全局环境记录                | 该范围的全局环境                                              |
| [[TemplateMap]]    | 一个记录列表，字段 [[Site]]（一个模板文字解析节点）和 [[Array]]（一个数组） | 模板对象分别为每个范围使用其范围记录的 [[TemplateMap]] 进行规范化。每个 [[Site]] 值是一个模板文字解析节点。关联的 [[Array]] 值是传递给标签函数的相应模板对象。 |
| [[LoadedModules]]  | 一个记录列表，字段 [[Specifier]]（一个字符串）和 [[Module]]（一个模块记录） | 从此范围导入的说明符字符串到已解析模块记录的映射。列表中不包含具有相同 [[Specifier]] 的两个不同记录。    |
| [[HostDefined]]    | 任意值（默认值为 undefined）   | 保留供需要与范围记录关联其他信息的主机使用的字段。                          |

#### 9.3.1 InitializeHostDefinedRealm ( )
抽象操作 InitializeHostDefinedRealm 不接受任何参数，返回包含 UNUSED 的正常完成或抛出完成。调用时执行以下步骤：

1. 令 realm 为一个新的范围记录。
2. 执行 CreateIntrinsics(realm)。
3. 将 realm.[[AgentSignifier]] 设置为 AgentSignifier()。
4. 将 realm.[[GlobalObject]] 设置为 undefined。
5. 将 realm.[[GlobalEnv]] 设置为 undefined。
6. 将 realm.[[TemplateMap]] 设置为一个新的空列表。
7. 令 newContext 为一个新的执行上下文。
8. 将 newContext 的 Function 设置为 null。
9. 将 newContext 的 Realm 设置为 realm。
10. 将 newContext 的 ScriptOrModule 设置为 null。
11. 将 newContext 推入执行上下文栈；newContext 现在是正在运行的执行上下文。
12. 如果主机需要使用一个异质对象作为 realm 的全局对象，
   a. 令 global 为以主机定义的方式创建的这样的对象。
13. 否则，
   a. 令 global 为 OrdinaryObjectCreate(realm.[[Intrinsics]].[[%Object.prototype%]])。
14. 如果主机需要 realm 的全局范围内的 this 绑定返回全局对象以外的对象，
   a. 令 thisValue 为以主机定义的方式创建的这样的对象。
15. 否则，
   a. 令 thisValue 为 global。
16. 将 realm.[[GlobalObject]] 设置为 global。
17. 将 realm.[[GlobalEnv]] 设置为 NewGlobalEnvironment(global, thisValue)。
18. 执行 ? SetDefaultGlobalBindings(realm)。
19. 在 global 上创建任何主机定义的全局对象属性。
20. 返回 UNUSED。

#### 9.3.2 CreateIntrinsics ( realmRec )
抽象操作 CreateIntrinsics 接受参数 realmRec（一个范围记录），并返回 UNUSED。调用时执行以下步骤：

1. 将 realmRec.[[Intrinsics]] 设置为一个新的记录。
2. 使用表 6 中列出的值设置 realmRec.[[Intrinsics]] 的字段。字段名称是表第一列中列出的名称。每个字段的值是一个新的对象值，完全且递归地填充了该对象在第 19 到 28 节中定义的属性值。所有对象属性值都是新创建的对象值。所有内置函数对象的值都是通过执行 CreateBuiltinFunction(steps, length, name, slots, realmRec, prototype) 创建的，其中 steps 是本规范提供的该函数的定义，name 是该函数 "name" 属性的初始值，length 是该函数 "length" 属性的初始值，slots 是函数指定的内部插槽的名称列表（如果有），prototype 是函数的 [[Prototype]] 内部插槽的指定值。内在对象及其属性的创建顺序必须避免对尚未创建的对象的依赖。
3. 执行 AddRestrictedFunctionProperties(realmRec.[[Intrinsics]].[[%Function.prototype%]], realmRec)。
4. 返回 UNUSED。

#### 9.3.3 SetDefaultGlobalBindings ( realmRec )
抽象操作 SetDefaultGlobalBindings 接受参数 realmRec（一个范围记录），并返回包含 UNUSED 的正常完成或抛出完成。调用时执行以下步骤：

1. 令 global 为 realmRec.[[GlobalObject]]。
2. 对于第 19 节中指定的全局对象的每个属性，执行
   a. 令 name 为属性名称的字符串值。
   b. 令 desc 为该属性的完全填充的数据属性描述符，包含该属性的指定属性。对于 19.2、19.3 或 19.4 中列出的属性，[[Value]] 属性的值是 realmRec 中相应的内在对象。
   c. 执行 ? DefinePropertyOrThrow(global, name, desc)。
3. 返回 UNUSED。

### 9.4 执行上下文

执行上下文是一个规范设备，用于跟踪 ECMAScript 实现代码的运行时评估。在任何时候，每个代理最多只有一个实际执行代码的执行上下文。这被称为代理的运行执行上下文。本规范中所有对运行执行上下文的引用均表示周围代理的运行执行上下文。

执行上下文栈用于跟踪执行上下文。运行执行上下文始终是该栈的顶元素。每当控制从当前运行执行上下文关联的可执行代码转移到与该上下文不关联的可执行代码时，都会创建一个新的执行上下文。新创建的执行上下文被推入栈中并成为运行执行上下文。

执行上下文包含跟踪其关联代码的执行进度所需的任何实现特定状态。每个执行上下文至少包含表 25 中列出的状态组件。

#### 表 25: 所有执行上下文的状态组件

| 组件                      | 目的                                                                 |
| ----------------------- | ------------------------------------------------------------------ |
| 代码评估状态               | 执行与此执行上下文关联的代码所需的任何状态，包括暂停和恢复评估。                               |
| 函| 组件            | 目的                                                                 |
| ------------- | ------------------------------------------------------------------ |
| 函数            | 如果此执行上下文正在评估一个函数对象的代码，那么该组件的值是该函数对象。如果上下文正在评估一个脚本或模块的代码，该值为 null。 |
| Realm         | 该上下文所关联代码访问 ECMAScript 资源的范围记录。                                |
| ScriptOrModule| 该上下文所关联代码的模块记录或脚本记录。如果没有关联的脚本或模块，例如在 InitializeHostDefinedRealm 创建的初始执行上下文的情况，该值为 null。 |

通过运行执行上下文的代码评估可以在本规范定义的各种点暂停。一旦运行执行上下文被暂停，另一个执行上下文可能成为运行执行上下文并开始评估其代码。在稍后的某个时间，已暂停的执行上下文可能再次成为运行执行上下文并从先前暂停的点继续评估其代码。运行执行上下文状态在执行上下文之间的转换通常以堆栈的后进先出方式进行。然而，一些 ECMAScript 特性需要非 LIFO 的运行执行上下文转换。

运行执行上下文的 Realm 组件的值也称为当前范围记录。运行执行上下文的函数组件的值也称为活动函数对象。

ECMAScript 代码执行上下文有表 26 中列出的其他状态组件。

#### 表 26: ECMAScript 代码执行上下文的其他状态组件

| 组件               | 目的                                                                      |
| ---------------- | ----------------------------------------------------------------------- |
| 词法环境（LexicalEnvironment） | 标识用于在此执行上下文中解析标识符引用的环境记录。                                       |
| 变量环境（VariableEnvironment） | 标识在此执行上下文中由 VariableStatements 创建的绑定的环境记录。                        |
| 私有环境（PrivateEnvironment）  | 标识由最近包含的类中的 ClassElements 创建的私有名称的私有环境记录。如果没有包含类，则为 null。 |

词法环境和变量环境组件始终是环境记录。

代表生成器评估的执行上下文有表 27 中列出的其他状态组件。

#### 表 27: 生成器执行上下文的其他状态组件

| 组件       | 目的                                      |
| -------- | --------------------------------------- |
| 生成器       | 此执行上下文正在评估的生成器。                         |

在大多数情况下，只有运行执行上下文（执行上下文栈的顶部）由本规范中的算法直接操作。因此，当术语“词法环境”和“变量环境”不加修饰地使用时，它们是指运行执行上下文的这些组件。

执行上下文纯粹是一个规范机制，不必对应于 ECMAScript 实现的任何特定工件。ECMAScript 代码无法直接访问或观察执行上下文。

#### 9.4.1 GetActiveScriptOrModule ( )
抽象操作 GetActiveScriptOrModule 不接受任何参数，返回一个脚本记录、模块记录或 null。它用于根据运行执行上下文确定正在运行的脚本或模块。调用时执行以下步骤：

1. 如果执行上下文栈为空，返回 null。
2. 令 ec 为执行上下文栈中顶层的 ScriptOrModule 组件不为 null 的执行上下文。
3. 如果不存在这样的执行上下文，返回 null。否则，返回 ec 的 ScriptOrModule。

#### 9.4.2 ResolveBinding ( name [ , env ] )
抽象操作 ResolveBinding 接受参数 name（一个字符串）和可选参数 env（一个环境记录或 undefined），返回一个包含参考记录的正常完成或抛出完成。它用于确定 name 的绑定。env 可用于显式提供要搜索绑定的环境记录。调用时执行以下步骤：

1. 如果未提供 env 或 env 为 undefined，
   a. 将 env 设置为运行执行上下文的词法环境。
2. 断言：env 是一个环境记录。
3. 令 strict 为正在评估的语法生成的 IsStrict。
4. 返回 ? GetIdentifierReference(env, name, strict)。

注意：ResolveBinding 的结果始终是一个其 [[ReferencedName]] 字段为 name 的参考记录。

#### 9.4.3 GetThisEnvironment ( )
抽象操作 GetThisEnvironment 不接受任何参数，返回一个环境记录。它查找当前提供 this 绑定的环境记录。调用时执行以下步骤：

1. 令 env 为运行执行上下文的词法环境。
2. 重复，
   a. 令 exists 为 env.HasThisBinding()。
   b. 如果 exists 为 true，返回 env。
   c. 令 outer 为 env.[[OuterEnv]]。
   d. 断言：outer 不是 null。
   e. 将 env 设置为 outer。

注意：步骤 2 中的循环总会终止，因为环境列表总是以提供 this 绑定的全局环境结束。

#### 9.4.4 ResolveThisBinding ( )
抽象操作 ResolveThisBinding 不接受任何参数，返回一个包含 ECMAScript 语言值的正常完成或抛出完成。它使用运行执行上下文的词法环境确定 this 的绑定。调用时执行以下步骤：

1. 令 envRec 为 GetThisEnvironment()。
2. 返回 ? envRec.GetThisBinding()。

#### 9.4.5 GetNewTarget ( )
抽象操作 GetNewTarget 不接受任何参数，返回一个对象或 undefined。它使用运行执行上下文的词法环境确定 NewTarget 的值。调用时执行以下步骤：

1. 令 envRec 为 GetThisEnvironment()。
2. 断言：envRec 具有 [[NewTarget]] 字段。
3. 返回 envRec.[[NewTarget]]。

#### 9.4.6 GetGlobalObject ( )
抽象操作 GetGlobalObject 不接受任何参数，返回一个对象。它返回当前运行执行上下文使用的全局对象。调用时执行以下步骤：

1. 令 currentRealm 为当前范围记录。
2. 返回 currentRealm.[[GlobalObject]]。


### 9.5 任务和主机操作来安排任务

任务是一个没有参数的抽象闭包，当没有其他 ECMAScript 计算正在进行时启动一个 ECMAScript 计算。

ECMAScript 主机环境在特定代理中安排任务执行。本规范描述了用于安排任务的主机钩子 `HostEnqueueGenericJob`、`HostEnqueueFinalizationRegistryCleanupJob`、`HostEnqueuePromiseJob` 和 `HostEnqueueTimeoutJob`。本规范中的主机钩子根据对任务安排施加的额外约束进行组织。主机可以定义其他安排任务的抽象操作。这些操作接受一个任务抽象闭包和一个 realm（一个 Realm 记录或 null）作为参数。如果提供了 Realm 记录，这些操作会安排在提供的 Realm 中在其拥有的代理上执行任务。如果提供的是 null，那么任务不会评估 ECMAScript 代码。它们的实现必须符合以下要求：

在将来的某个时间点，当任务安排的代理中没有运行上下文且该代理的执行上下文堆栈为空时，实施必须：
1. 执行任何主机定义的准备步骤。
2. 调用任务抽象闭包。
3. 执行任何主机定义的清理步骤，之后执行上下文堆栈必须为空。
4. 在任何时间点，一个代理中只能有一个任务在进行评估。
5. 一旦任务评估开始，必须在评估任何其他任务之前完成。
6. 抽象闭包必须返回正常完成，自己处理错误。

**注意 1**：主机环境不需要统一对待任务安排。例如，Web 浏览器和 Node.js 将 Promise 处理任务视为比其他工作更高的优先级；未来的特性可能会添加不被如此优先对待的任务。

在特定时间点，如果以下所有条件为真，则 scriptOrModule（一个脚本记录、一个模块记录或 null）是活动的脚本或模块：
1. `GetActiveScriptOrModule()` 是 scriptOrModule。
2. 如果 scriptOrModule 是一个脚本记录或模块记录，则令 ec 为执行上下文堆栈中顶层的执行上下文，其 ScriptOrModule 组件为 scriptOrModule。ec 的 Realm 组件是 scriptOrModule.[[Realm]]。

在特定时间点，如果以下所有条件为真，则一个执行准备评估 ECMAScript 代码：
1. 执行上下文堆栈不为空。
2. 执行上下文堆栈顶层的执行上下文的 Realm 组件是一个 Realm 记录。

**注意 2**：主机环境可以通过将执行上下文推送到执行上下文堆栈来准备评估代码。具体步骤由实现定义。

特定的 Realm 选择由主机环境决定。这个初始执行上下文和 Realm 仅在任何回调函数被调用之前使用。当与任务相关的回调函数（如 Promise 处理程序）被调用时，调用会推送其自身的执行上下文和 Realm。

特定类型的任务有额外的合规要求。

### 9.5.1 JobCallback 记录

JobCallback 记录是一个用于存储函数对象和主机定义值的记录值。通过主机安排的任务调用的函数对象可能有额外的主机定义上下文。为了传递状态，任务抽象闭包不应直接捕获和调用函数对象。相反，使用 `HostMakeJobCallback` 和 `HostCallJobCallback`。

**注意**：例如，WHATWG HTML 规范（<https://html.spec.whatwg.org/>）使用主机定义值来传递 Promise 回调的现有设置对象。

JobCallback 记录有表 28 中列出的字段。

#### 表 28: JobCallback 记录字段

| 字段名         | 值                 | 含义                         |
| ------------- | ------------------ | -------------------------- |
| [[Callback]]  | 一个函数对象       | 当任务被调用时调用的函数。      |
| [[HostDefined]] | 任意值（默认值为空） | 预留给主机使用的字段。          |

### 9.5.2 HostMakeJobCallback ( callback )

主机定义的抽象操作 `HostMakeJobCallback` 接受参数 callback（一个函数对象）并返回一个 JobCallback 记录。

`HostMakeJobCallback` 的实现必须符合以下要求：
1. 它必须返回一个 JobCallback 记录，其 [[Callback]] 字段是 callback。

默认的 `HostMakeJobCallback` 实现执行以下步骤：

1. 返回 JobCallback 记录 { [[Callback]]: callback, [[HostDefined]]: EMPTY }。

非 Web 浏览器的 ECMAScript 主机必须使用默认的 `HostMakeJobCallback` 实现。

**注意**：在将回调传递给负责最终安排和运行的函数时调用此操作。例如，`promise.then(thenAction)` 在调用 `Promise.prototype.then` 时对 thenAction 调用 `MakeJobCallback`，而不是在安排反应任务时。

### 9.5.3 HostCallJobCallback ( jobCallback, V, argumentsList )

主机定义的抽象操作 `HostCallJobCallback` 接受参数 jobCallback（一个 JobCallback 记录）、V（一个 ECMAScript 语言值）和 argumentsList（一个 ECMAScript 语言值的列表），返回一个包含 ECMAScript 语言值的正常完成或抛出完成。

`HostCallJobCallback` 的实现必须符合以下要求：
1. 它必须执行并返回 `Call(jobCallback.[[Callback]], V, argumentsList)` 的结果。

**注意**：此要求意味着主机不能更改本规范中定义的函数对象的 [[Call]] 行为。

默认的 `HostCallJobCallback` 实现执行以下步骤：

1. 断言：`IsCallable(jobCallback.[[Callback]])` 为 true。
2. 返回 `? Call(jobCallback.[[Callback]], V, argumentsList)`。

非 Web 浏览器的 ECMAScript 主机必须使用默认的 `HostCallJobCallback` 实现。

### 9.5.4 HostEnqueueGenericJob ( job, realm )

主机定义的抽象操作 `HostEnqueueGenericJob` 接受参数 job（一个任务抽象闭包）和 realm（一个 Realm 记录）并返回 UNUSED。它在 realm 代表的代理中安排在某个未来时间执行任务。与此算法一起使用的抽象闭包旨在安排而没有额外的约束，例如优先级和排序。

`HostEnqueueGenericJob` 的实现必须符合 9.5 中的要求。

### 9.5.5 HostEnqueuePromiseJob ( job, realm )

主机定义的抽象操作 `HostEnqueuePromiseJob` 接受参数 job（一个任务抽象闭包）和 realm（一个 Realm 记录或 null）并返回 UNUSED。它安排任务在某个未来时间执行。与此算法一起使用的抽象闭包旨在与 Promise 处理操作相关或以与 Promise 处理操作相等的优先级安排。

`HostEnqueuePromiseJob` 的实现必须符合 9.5 中的要求以及以下要求：

1. 如果 realm 不是 null，每次调用 job 时，实施必须执行实现定义的步骤，以便在调用 job 时准备好评估 ECMAScript 代码。
2. 令 scriptOrModule 为调用 `HostEnqueuePromiseJob` 时的 `GetActiveScriptOrModule()`。如果 realm 不是 null，每次调用 job 时，实施必须执行实现定义的步骤，以便在调用 job 时 scriptOrModule 是活动的脚本或模块。
3. 任务必须按照安排它们的 `HostEnqueuePromiseJob` 调用的顺序运行。

**注意**：`NewPromiseResolveThenableJob` 返回的任务的 realm 通常是调用 then 函数对象上的 `GetFunctionRealm` 的结果。`NewPromiseReactionJob` 返回的任务的 realm 通常是调用处理程序（如果处理程序不是 undefined）上的 `GetFunctionRealm` 的结果。如果处理程序是 undefined，realm 为 null。对于这两种任务，当 `GetFunctionRealm` 异常完成时（例如，在被撤销的 Proxy 上调用），realm 是 `GetFunctionRealm` 调用时的当前 Realm 记录。当 realm 为 null 时，不会评估用户 ECMAScript 代码，也不会创建新的 ECMAScript 对象（例如错误对象）。例如，WHATWG HTML 规范（<https://html.spec.whatwg.org/>）使用 realm 检查运行脚本的能力和入口概念。

### 9.5.6 HostEnqueueTimeoutJob ( timeoutJob, realm, milliseconds )

主机定义的抽象操作 `HostEnqueueTimeoutJob` 接受参数 timeoutJob（一个任务抽象闭包）、realm（一个 Realm 记录）和 milliseconds（一个非负有限数字）并返回 UNUSED。它在 realm 代表的代理中安排在至少 milliseconds 毫秒后执行任务。

`HostEnqueueTimeoutJob` 的实现必须符合 9.5 中的要求。

### 9.6 代理

代理包括一组 ECMAScript 执行上下文、一个执行上下文堆栈、一个运行执行上下文、一个代理记录和一个执行线程。除了执行线程，代理的组成部分专属于该代理。

代理的执行线程独立于其他代理执行### 代理的执行上下文，除非某个代理共享的执行线程具有多个代理，并且没有代理记录的 [[CanBlock]] 字段为 true。

**注意 1**：例如，一些 Web 浏览器在多个不相关的浏览器窗口选项卡之间共享单个执行线程。

当代理的执行线程正在执行算法步骤时，该代理是这些步骤的周围代理。这些步骤使用周围代理访问代理内持有的规范级执行对象：运行执行上下文、执行上下文堆栈和代理记录的字段。

代理标识符是一个全局唯一的、不透明的值，用于标识一个代理。

#### 表 29：代理记录字段

| 字段名            | 值                | 含义                                                                 |
| ----------------- | ----------------- | -------------------------------------------------------------------- |
| [[LittleEndian]]  | 布尔值            | 当算法 GetValueFromBuffer 和 SetValueInBuffer 需要时计算的 isLittleEndian 参数的默认值。选择是实现定义的，应选择对实现最有效的替代方案。一旦观察到该值，它就不能更改。       |
| [[CanBlock]]      | 布尔值            | 确定代理是否可以阻塞。                                               |
| [[Signifier]]     | 代理标识符        | 唯一标识代理集群中的代理。                                           |
| [[IsLockFree1]]   | 布尔值            | 如果对一个字节值的原子操作是无锁的，则为 true，否则为 false。         |
| [[IsLockFree2]]   | 布尔值            | 如果对两个字节值的原子操作是无锁的，则为 true，否则为 false。         |
| [[IsLockFree8]]   | 布尔值            | 如果对八个字节值的原子操作是无锁的，则为 true，否则为 false。         |
| [[CandidateExecution]] | 候选执行记录  | 参见内存模型。                                                      |
| [[KeptAlive]]     | 对象或符号的列表 | 最初是一个新的空列表，表示直到当前任务结束为止要保持活跃的对象和/或符号的列表。 |

一旦集群中的任何代理观察到 [[Signifier]]、[[IsLockFree1]] 和 [[IsLockFree2]] 的值，它们就不能更改。

**注意 2**：[[IsLockFree1]] 和 [[IsLockFree2]] 的值不一定由硬件决定，还可能反映实现选择，这些选择可能会随时间和 ECMAScript 实现而有所不同。

没有 [[IsLockFree4]] 字段：4 字节的原子操作始终是无锁的。

实际上，如果原子操作使用任何类型的锁，该操作就不是无锁的。无锁不意味着无等待：没有上限，说明完成无锁原子操作可能需要多少机器步骤。

原子访问大小 n 的无锁性并不暗示非原子访问大小 n 的（感知的）原子性，具体来说，非原子访问可能仍作为多个独立的内存访问序列执行。有关详细信息，请参阅 ReadSharedMemory 和 WriteSharedMemory。

**注意 3**：代理是一个规范机制，不必对应于任何特定的 ECMAScript 实现工件。

### 9.6.1 AgentSignifier ( )

抽象操作 AgentSignifier 不接受参数并返回一个代理标识符。它在调用时执行以下步骤：

1. 令 AR 为周围代理的代理记录。
2. 返回 AR.[[Signifier]]。

### 9.6.2 AgentCanSuspend ( )

抽象操作 AgentCanSuspend 不接受参数并返回一个布尔值。它在调用时执行以下步骤：

1. 令 AR 为周围代理的代理记录。
2. 返回 AR.[[CanBlock]]。

**注意**：在某些环境中，某个代理可能无法合理地挂起。例如，在 Web 浏览器环境中，可能不允许挂起文档的主事件处理线程，而允许挂起工人的事件处理线程。

### 9.7 代理集群

代理集群是可以通过操作共享内存进行通信的代理的最大集合。

**注意 1**：不同代理中的程序可能通过未指定的方法共享内存。最小化，共享数组缓冲区的底层内存可以在集群中的代理之间共享。

可能有一些代理可以通过消息传递进行通信，但不能共享内存；它们永远不会在同一个代理集群中。

每个代理正好属于一个代理集群。

**注意 2**：集群中的代理不必在特定时间点全部活跃。如果代理 A 创建了另一个代理 B，随后 A 终止且 B 创建了代理 C，则这三个代理处于同一个集群中，如果 A 可以与 B 共享一些内存且 B 可以与 C 共享一些内存。

集群中的所有代理必须在各自代理记录的 [[LittleEndian]] 字段中具有相同的值。

**注意 3**：如果代理集群中的不同代理具有不同的 [[LittleEndian]] 值，共享内存进行多字节数据处理会变得困难。

集群中的所有代理必须在各自代理记录的 [[IsLockFree1]] 字段中具有相同的值；类似地，对于 [[IsLockFree2]] 字段。

集群中的所有代理必须在各自代理记录的 [[Signifier]] 字段中具有不同的值。

嵌入可以在不通知或配合代理的情况下停用（停止前进进程）或激活（恢复前进进程）代理。如果嵌入这样做，它不得无限期地让集群中的某些代理保持活跃而让其他代理停用。

**注意 4**：上述限制的目的是避免代理死锁或饿死的情况。例如，如果一个 HTML 共享工人的生命周期独立于任何窗口中的文档，并且允许它与此类独立文档的专用工人共享内存，而文档及其专用工人停用时（例如，文档被推入其窗口的历史中），如果专用工人持有锁并且共享工人尝试获取锁，则共享工人将被阻塞，直到专用工人再次激活（如果有的话）。与此同时，尝试从其他窗口访问共享工人的其他工人将饿死。

上述限制意味着，无法在嵌入中共享内存的代理之间共享内存。

嵌入可以在没有集群其他代理事先通知或配合的情况下终止代理。如果代理不是通过其自身或集群中其他代理的程序动作终止，而是通过集群外部的力量终止，则嵌入必须选择两种策略之一：要么终止集群中的所有代理，要么提供可靠的 API，使集群中的代理能够协调，以便至少一个剩余成员能够检测到终止，终止数据包含足够的信息来识别被终止的代理。

**注意 5**：这种类型终止的示例包括：操作系统或用户终止运行在单独进程中的代理；当每代理资源计数指示代理失控时，嵌入本身终止与其他代理在同一进程中运行的代理。

以下每个规范值及其传递可达的值正好属于一个代理集群：

- 候选执行记录
- 共享数据块
- 等待者列表记录

在集群中的任何代理评估任何 ECMAScript 代码之前，所有代理的代理记录中的 [[CandidateExecution]] 字段设置为初始候选执行。初始候选执行是一个空候选执行，其 [[EventsRecords]] 字段是一个包含每个代理的代理事件记录的列表，每个代理事件记录的 [[AgentSignifier]] 字段是该代理的代理标识符，其 [[EventList]] 和 [[AgentSynchronizesWith]] 字段为空列表。

**注意 6**：集群中的所有代理在其代理记录的 [[CandidateExecution]] 字段中共享相同的候选执行。候选执行是内存模型使用的规范机制。

**注意 7**：代理集群是一个规范机制，不必对应于任何特定的 ECMAScript 实现工件。

### 9.8 前进进度

代理进行前进进度是指其根据本规范执行评估步骤。

当代理的运行执行上下文同步且无限期地等待外部事件时，该代理被阻塞。只有代理记录的 [[CanBlock]] 字段为 true 的代理才能以这种方式被阻塞。未阻塞的代理是未被阻塞的代理。

实施必须确保：

- 每个具有专用执行线程的未阻塞代理最终进行前进进度
- 在共享执行线程的一组代理中，一个代理最终进行前进进度
- 除非通过显式 API 提供阻塞，否则代理不会导致另一个代理被阻塞

**注意**：这与内存模型中的活性保证一起，确保所有 SEQ-CST 写入最终对所有代理可观察。

### 9.9 弱引用和终结注册表目标的处理模型

#### 9.9.1 目标

本规范不保证任何对象或符号将被垃圾回收。非活动对象或符号可能在长时间后释放，也可能永远不会释放。因此，本规范在描述由垃圾回收触发的行为时使用了“可能”一词。

弱引用和终结注册表的语义基于在特定时间点发生的两个操作：

1. 当调用 `WeakRef.prototype.deref` 时，引用对象（如果未返回 undefined）将保持活跃，以便后续同步访问也返回相同的值。当通过 `ClearKeptObjects` 抽象操作进行同步工作时，此列表将被重置。
2. 当一个对象或符号与一个终结注册表关联变得不可访问时，可能会在同步 ECMAScript 执行完成后最终调用终结注册表的清理回调。终结注册表清理通过 `CleanupFinalizationRegistry` 抽象操作进行。

这些操作（`ClearKeptObjects` 或 `CleanupFinalizationRegistry`）都不得中断同步 ECMAScript 执行。由于主机可以组合更长的同步 ECMAScript 执行运行，本规范将 `ClearKeptObjects` 和 `CleanupFinalizationRegistry` 的调度推迟到主机环境。

一些 ECMAScript 实现包括在后台运行的垃圾收集器，包括 ECMAScript 空闲时运行的垃圾收集器。让主机环境调度 `CleanupFinalizationRegistry` 允许它恢复 ECMAScript 执行以运行终结器工作，这可能释放持有的值，减少整体内存使用。

#### 9.9.2 活跃性

对于对象和/或符号集 S，一个假设的弱引用无关的执行（相对于 S）是一个执行，其中 `WeakRefDeref` 对一个弱引用，其引用对象是 S 的元素，总是返回 undefined。

**注意 1**：弱引用无关性与活跃性捕捉了两个概念。首先，弱引用本身不会保持其引用对象活跃。其次，活跃性中的循环并不意味着值是活跃的。具体来说，如果确定 v 的活跃性依赖于确定弱引用引用对象 r 的活跃性，r 的活跃性不能假设 v 的活跃性，否则将是循环推理。

**注意 2**：弱引用无关性是针对对象或符号集而不是单个值定义的，以处理循环。如果定义在单个值上，则在循环中的弱引用引用对象将被视为活跃，即使它的身份仅通过循环中的其他弱引用引用对象观察到。

**注意 3**：通俗地说，如果包含某个值的每个集合都是活跃的，则我们说该单个对象或符号是活跃的。

在评估期间的任何时候，如果对象和/或符号集 S 满足以下任一条件，则 S 被认为是活跃的：

- S 中的任何元素包含在任何代理的 `[[KeptAlive]]` 列表中。
- 存在一个有效的未来假设弱引用无关的执行，相对于 S，该执行观察到 S 中任何值的身份。

**注意 4**：上述第二个条件旨在捕捉这样一种直觉，即如果一个值的身份通过非弱引用手段可观察，则该值是活跃的。通过观察严格相等比较或观察将该值用作 Map 的键，可以观察到一个值的身份。

**注意 5**：值在字段、内部插槽或属性中的存在并不意味着该值是活跃的。例如，如果该值从未传递回程序，则无法观察到它。这是弱映射中的键、弱集合的成员以及终结注册表单元记录的 `[[WeakRefTarget]]` 和 `[[UnregisterToken]]` 字段的情况。

上述定义意味着，如果弱映射中的键不是活跃的，则其对应的值也不一定是活跃的。

**注意 6**：活跃性是保证哪些弱引用引擎不得清空的下限。此处定义的活跃性是不可判定的。实际上，引擎使用保守的近似，如可达性。预计会有显著的实现余地。

#### 9.9.3 执行

在任何时候，如果对象和/或符号集 S 不是活跃的，则 ECMAScript 实现可能原子地执行以下步骤：

1. 对于 S 的每个元素值，执行以下步骤：
   a. 对于每个弱引用 ref，使 ref.[[WeakRefTarget]] 为 value，执行以下步骤：
      i. 将 ref.[[WeakRefTarget]] 设置为 EMPTY。
   b. 对于每个终结注册表 fg，使 fg.[[Cells]] 包含记录 cell，其 [[WeakRefTarget]] 为 value，执行以下步骤：
      i. 将 cell.[[WeakRefTarget]] 设置为 EMPTY。
      ii. 可选地，执行 `HostEnqueueFinalizationRegistryCleanupJob(fg)`。
   c. 对于每个弱映射 map，使 map.[[WeakMapData]] 包含记录 r，其 [[Key]] 为 value，执行以下步骤：
      i. 将 r.[[Key]] 设置为 EMPTY。
      ii. 将 r.[[Value]] 设置为 EMPTY。
   d. 对于每个弱集合 set，使 set.[[WeakSetData]] 包含 value，执行以下步骤：
      i. 将 set.[[WeakSetData]] 中值为 value 的元素替换为值为 EMPTY 的元素。

**注意 1**：结合活跃性的定义，此条款规定了实现可以应用的关于弱引用的优化。

可以访问对象而不观察其身份。对非逃逸对象的属性进行标量替换和死变量消除等优化是允许的，这些优化因此允许可观察地清空指向这些对象的弱引用。

另一方面，如果对象的身份是可观察的，并且该对象位于弱引用的 `[[WeakRefTarget]]` 内部插槽中，则禁止可观察地清空该弱引用的优化，如重新物化。

由于调用 `HostEnqueueFinalizationRegistryCleanupJob` 是可选的，注册在终结注册表中的对象不会必然保持该终结注册表活跃。实现可以由于任何原因省略终结注册表回调，例如，如果终结注册表本身变为非活动，或如果应用程序正在关闭。

**注意 2**：实现没有义务为非活跃对象或符号的最大集合清空弱引用。

如果实现选择了一个非活跃的集合 S 以清空弱引用，此定义要求它同时清空 S 中所有值的弱引用。换句话说，实现不可符合规范地仅清空指向值 v 的弱引用，而不清空其他可能导致观察到 v 值的弱引用。

#### 9.9.4 主机钩子

##### 9.9.4.1 HostEnqueueFinalizationRegistryCleanupJob ( finalizationRegistry )

主机定义的抽象操作 `HostEnqueueFinalizationRegistryCleanupJob` 接受参数 finalizationRegistry（一个终结注册表）并返回 UNUSED。

令 cleanupJob 为一个没有参数的新任务抽象闭包，该闭包捕获 finalizationRegistry 并在调用时执行以下步骤：

1. 令 cleanupResult 为 `Completion(CleanupFinalizationRegistry(finalizationRegistry))`。
2. 如果 cleanupResult 是一个异常完成，则执行任何主机定义的错误报告步骤。
3. 返回 UNUSED。

`HostEnqueueFinalizationRegistryCleanupJob` 的实现安排 cleanupJob 在某个将来的时间执行（如果可能）。它还必须符合 9.5 中的要求。

### 9.10 ClearKeptObjects ( )

抽象操作 `ClearKeptObjects` 不接受参数并返回 UNUSED。预期 ECMAScript 实现会在同步 ECMAScript 执行序列完成时调用 `ClearKeptObjects`。它在调用时执行以下步骤：

1. 令 agentRecord 为周围代理的代理记录。
2. 将 agentRecord.[[KeptAlive]] 设置为一个新的空列表。
3. 返回 UNUSED。

### 9.11 AddToKeptObjects ( value )

抽象操作 `AddToKeptObjects` 接受参数 value（一个对象或符号）并返回 UNUSED。它在调用时执行以下步骤：

1. 令 agentRecord 为周围代理的代理记录。
2. 将 value 附加到 agentRecord.[[KeptAlive]]。
3. 返回 UNUSED。

**注意**：当抽象操作 `AddToKeptObjects` 被调用并传递一个目标对象或符号时，它将目标添加到一个列表中，该列表在调用 `ClearKeptObjects` 之前将强烈指向目标。

### 9.12 CleanupFinalizationRegistry ( finalizationRegistry )

抽象操作 `CleanupFinalizationRegistry` 接受参数 finalizationRegistry（一个终结注册表）并返回包含 UNUSED 的正常完成或抛出完成。它在调用时执行以下步骤：

1. 断言：finalizationRegistry 有 `[[Cells]]` 和 `[[CleanupCallback]]` 内部插槽。
2. 令 callback 为 finalizationRegistry.[[CleanupCallback]]。
3. 当 finalizationRegistry.[[Cells]] 包含一个记录 cell 且 cell.[[WeakRefTarget]] 为 EMPTY 时，实现可以执行以下步骤：
   a. 选择任何此类 cell。
   b. 从 finalizationRegistry.[[Cells]] 中移除 cell。
   c. 执行 `?HostCallJobCallback(callback, undefined, « cell.[[HeldValue]] »)`。
4. 返回 UNUSED。

### 9.13 CanBeHeldWeakly ( v )

抽象操作 `CanBeHeldWeakly` 接受参数 v（一个 ECMAScript 语言值）并返回一个布尔值。它在调用时执行以下步骤：

1. 如果 v 是一个对象，返回 true。
2. 如果 v 是一个符号且 `KeyForSymbol(v)` 为 undefined，返回 true。
3. 返回 false。

**注意**：没有语言身份的语言值无法被引用，且不适合作为弱引用。例如，Symbol 值是通过 `Symbol.for` 生成的，与其他 Symbol 值不同，没有语言身份且不适合作为弱引用。众所周知的符号可能永远不会被回收，但仍然被视为适合作为弱引用，因为它们数量有限，可以通过多种实现方法进行管理。然而，任何关联到活跃弱映射中的众所周知符号的值都不太可能被回收，并可能在实现中“泄漏”内存资源。

### 10. 普通对象和异变对象的行为

### 10.1 普通对象的内部方法和内部槽

所有普通对象都有一个名为 `[[Prototype]]` 的内部槽。该内部槽的值要么是 `null` 要么是一个对象，用于实现继承。假设普通对象 O 缺少名为 P 的属性，但其 `[[Prototype]]` 对象上存在 P 属性。如果 P 是 `[[Prototype]]` 对象上的数据属性，则 O 继承它的获取访问行为，使得 P 看起来像是 O 的属性。如果 P 是 `[[Prototype]]` 对象上的可写数据属性，则在 O 上设置 P 会创建一个名为 P 的新数据属性。如果 P 是 `[[Prototype]]` 对象上的不可写数据属性，则在 O 上设置 P 会失败。如果 P 是 `[[Prototype]]` 对象上的访问器属性，则 O 会继承该访问器的获取和设置访问。

每个普通对象都有一个布尔值的 `[[Extensible]]` 内部槽，用于满足 6.1.7.3 中指定的与扩展性相关的内部方法不变量。即，一旦对象的 `[[Extensible]]` 内部槽的值被设置为 `false`，就无法再向该对象添加属性、修改该对象的 `[[Prototype]]` 内部槽的值或将 `[[Extensible]]` 的值更改为 `true`。

在以下算法描述中，假设 O 是一个普通对象，P 是一个属性键值，V 是任何 ECMAScript 语言值，Desc 是一个属性描述符记录。

每个普通对象的内部方法都委托给一个类似命名的抽象操作。如果这样的抽象操作依赖于另一个内部方法，则在 O 上调用内部方法，而不是直接调用类似命名的抽象操作。这些语义确保当普通对象内部方法应用于异变对象时，异变对象的重载内部方法会被调用。

#### 10.1.1 `[[GetPrototypeOf]] ( )`
普通对象 O 的 `[[GetPrototypeOf]]` 内部方法不接受参数，返回一个包含对象或 `null` 的正常完成。调用时执行以下步骤：

1. 返回 `OrdinaryGetPrototypeOf(O)`。

#### 10.1.1.1 `OrdinaryGetPrototypeOf ( O )`
抽象操作 `OrdinaryGetPrototypeOf` 接受参数 O（一个对象），返回一个对象或 `null`。调用时执行以下步骤：

1. 返回 O.`[[Prototype]]`。

#### 10.1.2 `[[SetPrototypeOf]] ( V )`
普通对象 O 的 `[[SetPrototypeOf]]` 内部方法接受参数 V（一个对象或 `null`），返回一个包含布尔值的正常完成。调用时执行以下步骤：

1. 返回 `OrdinarySetPrototypeOf(O, V)`。

#### 10.1.2.1 `OrdinarySetPrototypeOf ( O, V )`
抽象操作 `OrdinarySetPrototypeOf` 接受参数 O（一个对象）和 V（一个对象或 `null`），返回一个布尔值。调用时执行以下步骤：

1. 令 current 为 O.`[[Prototype]]`。
2. 如果 `SameValue(V, current)` 为 `true`，返回 `true`。
3. 令 extensible 为 O.`[[Extensible]]`。
4. 如果 extensible 为 `false`，返回 `false`。
5. 令 p 为 V。
6. 令 done 为 `false`。
7. 重复，直到 done 为 `false`，
   a. 如果 p 为 `null`，则
      i. 令 done 为 `true`。
   b. 否则如果 `SameValue(p, O)` 为 `true`，则
      i. 返回 `false`。
   c. 否则，
      i. 如果 p.`[[GetPrototypeOf]]` 不是 10.1.1 中定义的普通对象内部方法，令 done 为 `true`。
      ii. 否则，令 p 为 p.`[[Prototype]]`。
8. 将 O.`[[Prototype]]` 设置为 V。
9. 返回 `true`。

**注意**：第 7 步中的循环保证了任何仅包含使用普通对象定义 `[[GetPrototypeOf]]` 和 `[[SetPrototypeOf]]` 的对象的原型链中不会有循环。

#### 10.1.3 `[[IsExtensible]] ( )`
普通对象 O 的 `[[IsExtensible]]` 内部方法不接受参数，返回一个包含布尔值的正常完成。调用时执行以下步骤：

1. 返回 `OrdinaryIsExtensible(O)`。

#### 10.1.3.1 `OrdinaryIsExtensible ( O )`
抽象操作 `OrdinaryIsExtensible` 接受参数 O（一个对象），返回一个布尔值。调用时执行以下步骤：

1. 返回 O.`[[Extensible]]`。

#### 10.1.4 `[[PreventExtensions]] ( )`
普通对象 O 的 `[[PreventExtensions]]` 内部方法不接受参数，返回一个包含 `true` 的正常完成。调用时执行以下步骤：

1. 返回 `OrdinaryPreventExtensions(O)`。

#### 10.1.4.1 `OrdinaryPreventExtensions ( O )`
抽象操作 `OrdinaryPreventExtensions` 接受参数 O（一个对象），返回 `true`。调用时执行以下步骤：

1. 将 O.`[[Extensible]]` 设置为 `false`。
2. 返回 `true`。

#### 10.1.5 `[[GetOwnProperty]] ( P )`
普通对象 O 的 `[[GetOwnProperty]]` 内部方法接受参数 P（一个属性键），返回一个包含属性描述符或未定义的正常完成。调用时执行以下步骤：

1. 返回 `OrdinaryGetOwnProperty(O, P)`。

#### 10.1.5.1 `OrdinaryGetOwnProperty ( O, P )`
抽象操作 `OrdinaryGetOwnProperty` 接受参数 O（一个对象）和 P（一个属性键），返回一个属性描述符或未定义。调用时执行以下步骤：

1. 如果 O 没有键值为 P 的自有属性，返回未定义。
2. 令 D 为一个新创建的没有字段的属性描述符。
3. 令 X 为 O 的键值为 P 的自有属性。
4. 如果 X 是一个数据属性，则
   a. 将 D.`[[Value]]` 设置为 X 的 `[[Value]]` 属性的值。
   b. 将 D.`[[Writable]]` 设置为 X 的 `[[Writable]]` 属性的值。
5. 否则，
   a. 断言：X 是一个访问器属性。
   b. 将 D.`[[Get]]` 设置为 X 的 `[[Get]]` 属性的值。
   c. 将 D.`[[Set]]` 设置为 X 的 `[[Set]]` 属性的值。
6. 将 D.`[[Enumerable]]` 设置为 X 的 `[[Enumerable]]` 属性的值。
7. 将 D.`[[Configurable]]` 设置为 X 的 `[[Configurable]]` 属性的值。
8. 返回 D。

#### 10.1.6 `[[DefineOwnProperty]] ( P, Desc )`
普通对象 O 的 `[[DefineOwnProperty]]` 内部方法接受参数 P（一个属性键）和 Desc（一个属性描述符），返回一个包含布尔值的正常完成或一个抛出完成。调用时执行以下步骤：

1. 返回 `? OrdinaryDefineOwnProperty(O, P, Desc)`。

#### 10.1.6.1 `OrdinaryDefineOwnProperty ( O, P, Desc )`
抽象操作 `OrdinaryDefineOwnProperty` 接受参数 O（一个对象），P（一个属性键）和 Desc（一个属性描述符），返回一个包含布尔值的正常完成或一个抛出完成。调用时执行以下步骤：

1. 令 current 为 `? O.[[GetOwnProperty]](P)`。
2. 令 extensible 为 `? IsExtensible(O)`。
3. 返回 `ValidateAndApplyPropertyDescriptor(O, P, extensible, Desc, current)`。

#### 10.1.6.2 `IsCompatiblePropertyDescriptor ( Extensible, Desc, Current )`
抽象操作 `IsCompatiblePropertyDescriptor` 接受参数 Extensible（一个布尔值），Desc（一个属性描述符）和 Current（一个属性描述符或未定义），返回一个布尔值。调用时执行以下步骤：

1. 返回 `ValidateAndApplyPropertyDescriptor(undefined, "", Extensible, Desc, Current)`。

#### 10.1.6.3 `ValidateAndApplyPropertyDescriptor ( O, P, extensible, Desc, current )`
抽象操作 `ValidateAndApplyPropertyDescriptor` 接受参数 O（一个对象或未定义），P（一个属性键），extensible（一个布尔值），Desc（一个属性描述符）和 current（一个属性描述符或未定义），返回一个布尔值。当且仅当 Desc 可以在保持不变量的情况下作为具有指定扩展性和当前属性 current 的对象的属性应用时，返回 `true`。当这种应用可能且 O 不为未定义时，它会为名为 P 的属性执行（如果需要的话创建该属性）。调用时执行以下步骤：

1. 断言：P 是一个属性键1. 断言：P 是一个属性键。
2. 如果 current 为 undefined，则
   a. 如果 extensible 为 false，返回 false。
   b. 如果 O 为 undefined，返回 true。
   c. 如果 IsAccessorDescriptor(Desc) 为 true，则
      i. 创建对象 O 的名为 P 的自有访问器属性，其 `[[Get]]`、`[[Set]]`、`[[Enumerable]]` 和 `[[Configurable]]` 属性设置为 Desc 中相应字段的值，如果 Desc 没有该字段，则设置为属性的默认值。
   d. 否则，
      i. 创建对象 O 的名为 P 的自有数据属性，其 `[[Value]]`、`[[Writable]]`、`[[Enumerable]]` 和 `[[Configurable]]` 属性设置为 Desc 中相应字段的值，如果 Desc 没有该字段，则设置为属性的默认值。
   e. 返回 true。
3. 断言：current 是一个完全填充的属性描述符。
4. 如果 Desc 没有任何字段，返回 true。
5. 如果 current.`[[Configurable]]` 为 false，则
   a. 如果 Desc 有 `[[Configurable]]` 字段且 Desc.`[[Configurable]]` 为 true，返回 false。
   b. 如果 Desc 有 `[[Enumerable]]` 字段且 Desc.`[[Enumerable]]` 不等于 current.`[[Enumerable]]`，返回 false。
   c. 如果 IsGenericDescriptor(Desc) 为 false 且 IsAccessorDescriptor(Desc) 不等于 IsAccessorDescriptor(current)，返回 false。
   d. 如果 IsAccessorDescriptor(current) 为 true，则
      i. 如果 Desc 有 `[[Get]]` 字段且 `SameValue(Desc.[[Get]], current.[[Get]])` 为 false，返回 false。
      ii. 如果 Desc 有 `[[Set]]` 字段且 `SameValue(Desc.[[Set]], current.[[Set]])` 为 false，返回 false。
   e. 否则，如果 current.`[[Writable]]` 为 false，则
      i. 如果 Desc 有 `[[Writable]]` 字段且 Desc.`[[Writable]]` 为 true，返回 false。
      ii. 如果 Desc 有 `[[Value]]` 字段且 `SameValue(Desc.[[Value]], current.[[Value]])` 为 false，返回 false。
6. 如果 O 不为 undefined，则
   a. 如果 IsDataDescriptor(current) 为 true 且 IsAccessorDescriptor(Desc) 为 true，则
      i. 如果 Desc 有 `[[Configurable]]` 字段，令 configurable 为 Desc.`[[Configurable]]`；否则令 configurable 为 current.`[[Configurable]]`。
      ii. 如果 Desc 有 `[[Enumerable]]` 字段，令 enumerable 为 Desc.`[[Enumerable]]`；否则令 enumerable 为 current.`[[Enumerable]]`。
      iii. 用一个访问器属性替换对象 O 的名为 P 的属性，其 `[[Configurable]]` 和 `[[Enumerable]]` 属性设置为 configurable 和 enumerable，且其 `[[Get]]` 和 `[[Set]]` 属性设置为 Desc 中相应字段的值，如果 Desc 没有该字段，则设置为属性的默认值。
   b. 否则如果 IsAccessorDescriptor(current) 为 true 且 IsDataDescriptor(Desc) 为 true，则
      i. 如果 Desc 有 `[[Configurable]]` 字段，令 configurable 为 Desc.`[[Configurable]]`；否则令 configurable 为 current.`[[Configurable]]`。
      ii. 如果 Desc 有 `[[Enumerable]]` 字段，令 enumerable 为 Desc.`[[Enumerable]]`；否则令 enumerable 为 current.`[[Enumerable]]`。
      iii. 用一个数据属性替换对象 O 的名为 P 的属性，其 `[[Configurable]]` 和 `[[Enumerable]]` 属性设置为 configurable 和 enumerable，且其 `[[Value]]` 和 `[[Writable]]` 属性设置为 Desc 中相应字段的值，如果 Desc 没有该字段，则设置为属性的默认值。
   c. 否则，
      i. 对于 Desc 的每个字段，将对象 O 的名为 P 的属性的相应属性设置为该字段的值。
7. 返回 true。

#### 10.1.7 `[[HasProperty]] ( P )`
普通对象 O 的 `[[HasProperty]]` 内部方法接受参数 P（一个属性键），返回一个包含布尔值的正常完成或一个抛出完成。调用时执行以下步骤：

1. 返回 `? OrdinaryHasProperty(O, P)`。

#### 10.1.7.1 `OrdinaryHasProperty ( O, P )`
抽象操作 `OrdinaryHasProperty` 接受参数 O（一个对象）和 P（一个属性键），返回一个包含布尔值的正常完成或一个抛出完成。调用时执行以下步骤：

1. 令 hasOwn 为 `? O.[[GetOwnProperty]](P)`。
2. 如果 hasOwn 不为 undefined，返回 true。
3. 令 parent 为 `? O.[[GetPrototypeOf]]()`。
4. 如果 parent 不为 null，则
   a. 返回 `? parent.[[HasProperty]](P)`。
5. 返回 false。

#### 10.1.8 `[[Get]] ( P, Receiver )`
普通对象 O 的 `[[Get]]` 内部方法接受参数 P（一个属性键）和 Receiver（一个 ECMAScript 语言值），返回一个包含 ECMAScript 语言值的正常完成或一个抛出完成。调用时执行以下步骤：

1. 返回 `? OrdinaryGet(O, P, Receiver)`。

#### 10.1.8.1 `OrdinaryGet ( O, P, Receiver )`
抽象操作 `OrdinaryGet` 接受参数 O（一个对象）、P（一个属性键）和 Receiver（一个 ECMAScript 语言值），返回一个包含 ECMAScript 语言值的正常完成或一个抛出完成。调用时执行以下步骤：

1. 令 desc 为 `? O.[[GetOwnProperty]](P)`。
2. 如果 desc 为 undefined，则
   a. 令 parent 为 `? O.[[GetPrototypeOf]]()`。
   b. 如果 parent 为 null，返回 undefined。
   c. 返回 `? parent.[[Get]](P, Receiver)`。
3. 如果 IsDataDescriptor(desc) 为 true，返回 desc.`[[Value]]`。
4. 断言：IsAccessorDescriptor(desc) 为 true。
5. 令 getter 为 desc.`[[Get]]`。
6. 如果 getter 为 undefined，返回 undefined。
7. 返回 `? Call(getter, Receiver)`。

#### 10.1.9 `[[Set]] ( P, V, Receiver )`
普通对象 O 的 `[[Set]]` 内部方法接受参数 P（一个属性键）、V（一个 ECMAScript 语言值）和 Receiver（一个 ECMAScript 语言值），返回一个包含布尔值的正常完成或一个抛出完成。调用时执行以下步骤：

1. 返回 `? OrdinarySet(O, P, V, Receiver)`。

#### 10.1.9.1 `OrdinarySet ( O, P, V, Receiver )`
抽象操作 `OrdinarySet` 接受参数 O（一个对象）、P（一个属性键）、V（一个 ECMAScript 语言值）和 Receiver（一个 ECMAScript 语言值），返回一个包含布尔值的正常完成或一个抛出完成。调用时执行以下步骤：

1. 令 ownDesc 为 `? O.[[GetOwnProperty]](P)`。
2. 返回 `? OrdinarySetWithOwnDescriptor(O, P, V, Receiver, ownDesc)`。

#### 10.1.9.2 `OrdinarySetWithOwnDescriptor ( O, P, V, Receiver, ownDesc )`
抽象操作 `OrdinarySetWithOwnDescriptor` 接受参数 O（一个对象）、P（一个属性键）、V（一个 ECMAScript 语言值）、Receiver（一个 ECMAScript 语言值）和 ownDesc（一个属性描述符或未定义），返回一个包含布尔值的正常完成或一个抛出完成。调用时执行以下步骤：

1. 如果 ownDesc 为 undefined，则
   a. 令 parent 为 `? O.[[GetPrototypeOf]]()`。
   b. 如果 parent 不为 null，则
      i. 返回 `? parent.[[Set]](P, V, Receiver)`。
   c. 否则，
      i. 将 ownDesc 设置为属性描述符 `{ [[Value]]: undefined, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true }`。
2. 如果 IsDataDescriptor(ownDesc) 为 true，则
   a. 如果 ownDesc.`[[Writable]]` 为 false，返回 false。
   b. 如果 Receiver 不是一个对象，返回 false。
   c. 令 existingDescriptor 为 `? Receiver.[[GetOwnProperty]](P)`。
   d. 如果 existingDescriptor 不为 undefined，则
      i. 如果 IsAccessorDescriptor(existingDescriptor) 为 true，返回 false。
      ii. 如果 existingDescriptor.`[[Writable]]` 为 false，返回 false。
      iii. 令 valueDesc 为属性描述符 `{ [[Value]]: V }`。
      iv. 返回 `? Receiver.[[DefineOwnProperty]](P, valueDesc)`。
   e. 否则，
      i. 断言：Receiver 当前没有属性 P。
      ii. 返回 `? CreateDataProperty(Receiver, P, V)`。
3. 断断言：IsAccessorDescriptor(ownDesc) 为 true。
4. 令 setter 为 ownDesc.`[[Set]]`。
5. 如果 setter 为 undefined，返回 false。
6. 执行 `? Call(setter, Receiver, « V »)`。
7. 返回 true。

#### 10.1.10 `[[Delete]] ( P )`
普通对象 O 的 `[[Delete]]` 内部方法接受参数 P（一个属性键），返回一个包含布尔值的正常完成或一个抛出完成。调用时执行以下步骤：

1. 返回 `? OrdinaryDelete(O, P)`。

#### 10.1.10.1 `OrdinaryDelete ( O, P )`
抽象操作 `OrdinaryDelete` 接受参数 O（一个对象）和 P（一个属性键），返回一个包含布尔值的正常完成或一个抛出完成。调用时执行以下步骤：

1. 令 desc 为 `? O.[[GetOwnProperty]](P)`。
2. 如果 desc 为 undefined，返回 true。
3. 如果 desc.`[[Configurable]]` 为 true，则
   a. 从 O 中移除键名为 P 的自有属性。
   b. 返回 true。
4. 返回 false。

#### 10.1.11 `[[OwnPropertyKeys]] ( )`
普通对象 O 的 `[[OwnPropertyKeys]]` 内部方法不接受参数，返回一个包含属性键列表的正常完成。调用时执行以下步骤：

1. 返回 `OrdinaryOwnPropertyKeys(O)`。

#### 10.1.11.1 `OrdinaryOwnPropertyKeys ( O )`
抽象操作 `OrdinaryOwnPropertyKeys` 接受参数 O（一个对象），返回一个属性键列表。调用时执行以下步骤：

1. 令 keys 为一个新的空列表。
2. 对于 O 的每个键名为 P 的自有属性，按数组索引递增顺序，
   a. 将 P 添加到 keys。
3. 对于 O 的每个键名为 P 的字符串属性，按属性创建的时间顺序，
   a. 将 P 添加到 keys。
4. 对于 O 的每个键名为 P 的符号属性，按属性创建的时间顺序，
   a. 将 P 添加到 keys。
5. 返回 keys。

#### 10.1.12 `OrdinaryObjectCreate ( proto [ , additionalInternalSlotsList ] )`
抽象操作 `OrdinaryObjectCreate` 接受参数 proto（一个对象或 `null`）和可选参数 additionalInternalSlotsList（一个内部槽名称列表），返回一个对象。它用于指定创建新普通对象的运行时过程。additionalInternalSlotsList 包含对象必须定义的额外内部槽的名称，除了 `[[Prototype]]` 和 `[[Extensible]]`。如果没有提供 additionalInternalSlotsList，则使用一个新的空列表。调用时执行以下步骤：

1. 令 internalSlotsList 为 « `[[Prototype]]`, `[[Extensible]]` »。
2. 如果提供了 additionalInternalSlotsList，将 internalSlotsList 设置为 internalSlotsList 和 additionalInternalSlotsList 的列表连接。
3. 令 O 为 `MakeBasicObject(internalSlotsList)`。
4. 将 O.`[[Prototype]]` 设置为 proto。
5. 返回 O。

**注意**：尽管 `OrdinaryObjectCreate` 做的只是调用 `MakeBasicObject`，其使用传达了创建普通对象而非异变对象的意图。因此，在本规范中，它不被任何随后修改对象内部方法以使结果变为非普通对象的算法调用。创建异变对象的操作直接调用 `MakeBasicObject`。

#### 10.1.13 `OrdinaryCreateFromConstructor ( constructor, intrinsicDefaultProto [ , internalSlotsList ] )`
抽象操作 `OrdinaryCreateFromConstructor` 接受参数 constructor（一个构造函数）和 intrinsicDefaultProto（一个字符串），以及可选参数 internalSlotsList（内部槽名称列表），返回一个包含对象的正常完成或一个抛出完成。它创建一个普通对象，其 `[[Prototype]]` 值从构造函数的 "prototype" 属性中获取（如果存在）。否则，使用 intrinsicDefaultProto 指定的内在对象作为 `[[Prototype]]`。internalSlotsList 包含必须作为对象一部分定义的额外内部槽的名称。如果没有提供 internalSlotsList，则使用一个新的空列表。调用时执行以下步骤：

1. 断言：intrinsicDefaultProto 是本规范中一个内在对象的名称。相应的对象必须是用于作为对象的 `[[Prototype]]` 值的内在对象。
2. 令 proto 为 `? GetPrototypeFromConstructor(constructor, intrinsicDefaultProto)`。
3. 如果提供了 internalSlotsList，令 slotsList 为 internalSlotsList。
4. 否则，令 slotsList 为一个新的空列表。
5. 返回 `OrdinaryObjectCreate(proto, slotsList)`。

#### 10.1.14 `GetPrototypeFromConstructor ( constructor, intrinsicDefaultProto )`
抽象操作 `GetPrototypeFromConstructor` 接受参数 constructor（一个函数对象）和 intrinsicDefaultProto（一个字符串），返回一个包含对象的正常完成或一个抛出完成。它确定应当用于创建与特定构造函数对应的对象的 `[[Prototype]]` 值。该值从构造函数的 "prototype" 属性中获取（如果存在）。否则，使用 intrinsicDefaultProto 指定的内在对象作为 `[[Prototype]]`。调用时执行以下步骤：

1. 断言：intrinsicDefaultProto 是本规范中一个内在对象的名称。相应的对象必须是用于作为对象的 `[[Prototype]]` 值的内在对象。
2. 令 proto 为 `? Get(constructor, "prototype")`。
3. 如果 proto 不是一个对象，则
   a. 令 realm 为 `? GetFunctionRealm(constructor)`。
   b. 将 proto 设置为 realm 的名为 intrinsicDefaultProto 的内在对象。
4. 返回 proto。

**注意**：如果构造函数未提供 `[[Prototype]]` 值，使用的默认值是从构造函数函数的 realm 获取的，而不是从运行执行上下文获取的。

#### 10.1.15 `RequireInternalSlot ( O, internalSlot )`
抽象操作 `RequireInternalSlot` 接受参数 O（一个 ECMAScript 语言值）和 internalSlot（一个内部槽名称），返回一个包含 UNUSED 的正常完成或一个抛出完成。除非 O 是一个对象并且有给定的内部槽，否则它会抛出异常。调用时执行以下步骤：

1. 如果 O 不是一个对象，抛出一个 TypeError 异常。
2. 如果 O 没有 internalSlot 内部槽，抛出一个 TypeError 异常。
3. 返回 UNUSED。

### 10.3 内置函数对象

内置函数对象是一个普通对象；它必须满足 10.1 中规定的普通对象的要求。

除了每个普通对象所需的内部槽（参见 10.1）之外，内置函数对象还必须具有以下内部槽：

- `[[Realm]]`，表示创建函数的领域的领域记录。
- `[[InitialName]]`，一个字符串，是函数的初始名称。它在 20.2.3.5 中使用。

除非另有说明，内置函数对象的 `[[Prototype]]` 内部槽的初始值为 %Function.prototype%。

内置函数对象必须有一个符合 10.3.1 中定义的 `[[Call]]` 内部方法。

只有当一个内置函数对象被描述为“构造函数”或者本规范中的某些算法明确设置了其 `[[Construct]]` 内部方法时，该对象才具有 `[[Construct]]` 内部方法。这样的 `[[Construct]]` 内部方法必须符合 10.3.2 中的定义。

实现可以提供本规范中未定义的额外内置函数对象。

#### 10.3.1 `[[Call]] ( thisArgument, argumentsList )`
内置函数对象 F 的 `[[Call]]` 内部方法接受参数 `thisArgument`（一个 ECMAScript 语言值）和 `argumentsList`（一个 ECMAScript 语言值的列表），并返回一个包含 ECMAScript 语言值的正常完成或一个抛出完成。调用时执行以下步骤：

1. 返回 `? BuiltinCallOrConstruct(F, thisArgument, argumentsList, undefined)`。

#### 10.3.2 `[[Construct]] ( argumentsList, newTarget )`
内置函数对象 F 的 `[[Construct]]` 内部方法（当该方法存在时）接受参数 `argumentsList`（一个 ECMAScript 语言值的列表）和 `newTarget`（一个构造函数），并返回一个包含对象的正常完成或一个抛出完成。调用时执行以下步骤：

1. 返回 `? BuiltinCallOrConstruct(F, UNINITIALIZED, argumentsList, newTarget)`。

#### 10.3.3 `BuiltinCallOrConstruct ( F, thisArgument, argumentsList, newTarget )`
抽象操作 `BuiltinCallOrConstruct` 接受参数 F（一个内置函数对象），`thisArgument`（一个 ECMAScript 语言值或 UNINITIALIZED），`argumentsList`（一个 ECMAScript 语言值的列表），以及 `newTarget`（一个构造函数或 undefined），并返回一个包含 ECMAScript 语言值的正常完成或一个抛出完成。调用时执行以下步骤：

1. 令 `callerContext` 为正在运行的执行上下文。
2. 如果 `callerContext` 尚未被挂起，则挂起 `callerContext`。
3. 令 `calleeContext` 为一个新的执行上下文。
4. 将 `calleeContext` 的函数设置为 F。
5. 令 `calleeRealm` 为 F 的 `[[Realm]]`。
6. 将 `calleeContext` 的领域设置为 `calleeRealm`。
7. 将 `calleeContext` 的 `ScriptOrModule` 设置为 null。
8. 执行任何必要的实现定义的 `calleeContext` 初始化。
9. 将 `calleeContext` 压入执行上下文栈；`calleeContext` 现在是正在运行的执行上下文。
10. 令 `result` 为评估 F 的结果的完成记录，结果应当符合 F 的规范。如果 `thisArgument` 为 UNINITIALIZED，则 `this` 值未初始化；否则，`thisArgument` 提供 `this` 值。`argumentsList` 提供命名参数。`newTarget` 提供 `NewTarget` 值。
11. **注意**：如果 F 在本文档中定义，“F 的规范”是通过算法步骤或其他方式为其指定的行为。
12. 从执行上下文栈中移除 `calleeContext` 并恢复 `callerContext` 作为正在运行的执行上下文。
13. 返回 `? result`。

**注意**：当 `calleeContext` 从执行上下文栈中移除时，如果它已经被挂起并由一个可访问的生成器保留以供稍后恢复，则不能销毁它。

#### 10.3.4 `CreateBuiltinFunction ( behaviour, length, name, additionalInternalSlotsList [ , realm [ , prototype [ , prefix ] ] ] )`
抽象操作 `CreateBuiltinFunction` 接受参数 `behaviour`（一个抽象闭包、一组算法步骤或本规范中提供的其他函数行为定义）、`length`（一个非负整数或 +∞）、`name`（一个属性键或私有名称）和 `additionalInternalSlotsList`（一个内部槽名称列表），以及可选参数 `realm`（一个领域记录）、`prototype`（一个对象或 null）和 `prefix`（一个字符串），并返回一个函数对象。`additionalInternalSlotsList` 包含必须定义为对象一部分的额外内部槽的名称。此操作创建一个内置函数对象。调用时执行以下步骤：

1. 如果未提供 `realm`，将 `realm` 设置为当前领域记录。
2. 如果未提供 `prototype`，将 `prototype` 设置为 `realm.[[Intrinsics]].[[%Function.prototype%]]`。
3. 令 `internalSlotsList` 为一个包含即将创建的内置函数对象的所有内部槽名称的列表。
4. 将 `additionalInternalSlotsList` 的元素追加到 `internalSlotsList`。
5. 令 `func` 为一个新的内置函数对象，当被调用时，它使用 `behaviour` 描述的行为并使用提供的参数作为 `behaviour` 指定的对应参数的值。新函数对象具有内部槽，其名称是 `internalSlotsList` 的元素，以及一个 `[[InitialName]]` 内部槽。
6. 将 `func.[[Prototype]]` 设置为 `prototype`。
7. 将 `func.[[Extensible]]` 设置为 true。
8. 将 `func.[[Realm]]` 设置为 `realm`。
9. 将 `func.[[InitialName]]` 设置为 null。
10. 执行 `SetFunctionLength(func, length)`。
11. 如果未提供 `prefix`，则
    a. 执行 `SetFunctionName(func, name)`。
12. 否则，
    a. 执行 `SetFunctionName(func, name, prefix)`。
13. 返回 `func`。

本规范中定义的每个内置函数都是通过调用 `CreateBuiltinFunction` 抽象操作创建的。

### 10.4 内置异变对象的内部方法和槽
本规范定义了几种内置异变对象。这些对象通常在大多数情况下行为类似于普通对象，除了某些特定情况。以下异变对象使用普通对象的内部方法，除非下面明确规定了例外情况：

#### 10.4.1 绑定函数异变对象
绑定函数异变对象是包装另一个函数对象的异变对象。绑定函数异变对象是可调用的（它具有 `[[Call]]` 内部方法，并且可能具有 `[[Construct]]` 内部方法）。调用绑定函数异变对象通常会调用其包装的函数。

如果一个对象的 `[[Call]]` 方法和（如果适用）`[[Construct]]` 方法使用以下实现，并且其其他基本内部方法使用 10.1 中的定义，则该对象是一个绑定函数异变对象。这些方法是在 `BoundFunctionCreate` 中安装的。

绑定函数异变对象没有表 30 中列出的 ECMAScript 函数对象的内部槽。相反，它们具有表 31 中列出的内部槽，除了 `[[Prototype]]` 和 `[[Extensible]]`。

表 31：绑定函数异变对象的内部槽
| 内部槽 | 类型 | 描述 |
| --- | --- | --- |
| `[[BoundTargetFunction]]` | 一个可调用的对象 | 包装的函数对象。 |
| `[[BoundThis]]` | 一个 ECMAScript 语言值 | 调用包装函数时始终传递的 `this` 值。 |
| `[[BoundArguments]]` | 一个 ECMAScript 语言值的列表 | 用作调用包装函数的第一个参数的值列表。 |

##### 10.4.1.1 `[[Call]] ( thisArgument, argumentsList )`
绑定函数异变对象 F 的 `[[Call]]` 内部方法接受参数 `thisArgument`（一个 ECMAScript 语言值）和 `argumentsList`（一个 ECMAScript 语言值的列表），并返回一个包含 ECMAScript 语言值的正常完成或一个抛出完成。调用时执行以下步骤：

1. 令 `target` 为 F 的 `[[BoundTargetFunction]]`。
2. 令 `boundThis` 为 F 的 `[[BoundThis]]`。
3. 令 `boundArgs` 为 F 的 `[[BoundArguments]]`。
4. 令 `args` 为 `boundArgs` 和 `argumentsList` 的列表连接。
5. 返回 `? Call(target, boundThis, args)`。

##### 10.4.1.2 `[[Construct]] ( argumentsList, newTarget )`
绑定函数异变对象 F 的 `[[Construct]]` 内方法接受参数 `argumentsList`（一个 ECMAScript 语言值的列表）和 `newTarget`（一个构造函数），并返回一个包含对象的正常完成或一个抛出完成。调用时执行以下步骤：

1. 令 `target` 为 F 的 `[[BoundTargetFunction]]`。
2. 断言：`IsConstructor(target)` 为 true。
3. 令 `boundArgs` 为 F 的 `[[BoundArguments]]`。
4. 令 `args` 为 `boundArgs` 和 `argumentsList` 的列表连接。
5. 如果 `SameValue(F, newTarget)` 为 true，则将 `newTarget` 设置为 `target`。
6. 返回 `? Construct(target, args, newTarget)`。

##### 10.4.1.3 `BoundFunctionCreate ( targetFunction, boundThis, boundArgs )`
抽象操作 `BoundFunctionCreate` 接受参数 `targetFunction`（一个函数对象）、`boundThis`（一个 ECMAScript 语言值）和 `boundArgs`（一个 ECMAScript 语言值的列表），并返回一个包含函数对象的正常完成或一个抛出完成。此操作用于指定创建新的绑定函数异变对象。调用时执行以下步骤：

1. 令 `proto` 为 `? targetFunction.[[GetPrototypeOf]]()`。
2. 令 `internalSlotsList` 为 `« [[Prototype]], [[Extensible]] »` 和表 31 中列出的内部槽的列表连接。
3. 令 `obj` 为 `MakeBasicObject(internalSlotsList)`。
4. 将 `obj.[[Prototype]]` 设置为 `proto`。
5. 按照 10.4.1.1 中的描述设置 `obj.[[Call]]`。
6. 如果 `IsConstructor(targetFunction)` 为 true，则
   a. 按照 10.4.1.2 中的描述设置 `obj.[[Construct]]`。
7. 将 `obj.[[BoundTargetFunction]]` 设置为 `targetFunction`。
8. 将 `obj.[[BoundThis]]` 设置为 `boundThis`。
9. 将 `obj.[[BoundArguments]]` 设置为 `boundArgs`。
10. 返回 `obj`。

#### 10.4.2 数组异变对象
数组是一种对数组索引属性键（见 6.1.7）进行特殊处理的异变对象。属性名为数组索引的属性也称为元素。每个数组都有一个不可配置的“length”属性，其值始终是小于 2**32 的非负整数。数组的“length”属性值在数学上大于每个自身属性的数组索引名；每当创建或更改数组的自身属性时，其他属性会相应调整以保持此不变量。具体来说，每当添加一个名为数组索引的自身属性时，“length”属性的值如果有必要将变为比该数组索引大一；每当更改“length”属性的值时，所有名为数组索引且值不小于新长度的自身属性将被删除。此约束仅适用于数组的自身属性，并且不受从其原型继承的“length”或数组索引属性的影响。

如果一个对象的 `[[DefineOwnProperty]]` 内部方法使用以下实现，并且其其他基本内部方法使用 10.1 中的定义，则该对象是一个数组异变对象（或简称数组）。这些方法是在 `ArrayCreate` 中安装的。

##### 10.4.2.1 `[[DefineOwnProperty]] ( P, Desc )`
数组异变对象 A 的 `[[DefineOwnProperty]]` 内部方法接受参数 P（一个属性键）和 Desc（一个属性描述符），并返回一个包含布尔值的正常完成或一个抛出完成。调用时执行以下步骤：

1. 如果 P 是 "length"，则
   a. 返回 `? ArraySetLength(A, Desc)`。
2. 否则如果 P 是数组索引，则
   a. 令 `lengthDesc` 为 `OrdinaryGetOwnProperty(A, "length")`。
   b. 断言：`IsDataDescriptor(lengthDesc)` 为 true。
   c. 断言：`lengthDesc.[[Configurable]]` 为 false。
   d. 令 `length` 为 `lengthDesc.[[Value]]`。
   e. 断言：`length` 是一个非负整数。
   f. 令 `index` 为 `! ToUint32(P)`。
   g. 如果 `index ≥ length` 并且 `lengthDesc.[[Writable]]` 为 false，则返回 false。
   h. 令 `succeeded` 为 `! OrdinaryDefineOwnProperty(A, P, Desc)`。
   i. 如果 `succeeded` 为 false，则返回 false。
   j. 如果 `index ≥ length`，则
      i. 将 `lengthDesc.[[Value]]` 设置为 `index + 1𝔽`。
      ii. 将 `succeeded` 设置为 `! OrdinaryDefineOwnProperty(A, "length", lengthDesc)`。
      iii. 断言：`succeeded` 为 true。
   k. 返回 true。
3. 返回 `? OrdinaryDefineOwnProperty(A, P, Desc)`。

##### 10.4.2.2 `ArrayCreate ( length [ , proto ] )`
抽象操作 `ArrayCreate` 接受参数 `length`（一个非负整数）和可选参数 `proto`（一个对象），并返回一个包含数组异变对象的正常完成或一个抛出完成。此操作用于指定创建新的数组。调用时执行以下步骤：

1. 如果 `length > 2**32 - 1`，则抛出一个 `RangeError` 异常。
2. 如果未提供 `proto`，则将 `proto` 设置为 `%Array.prototype%`。
3. 令 `A` 为 `MakeBasicObject(« [[Prototype]], [[Extensible]] »)`。
4. 将 `A.[[Prototype]]` 设置为 `proto`。
5. 按照 10.4.2.1 中的描述设置 `A.[[DefineOwnProperty]]`。
6. 执行 `! OrdinaryDefineOwnProperty(A, "length", PropertyDescriptor { [[Value]]: 𝔽(length), [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false })`。
7. 返回 `A`。

##### 10.4.2.3 `ArraySpeciesCreate ( originalArray, length )`
抽象操作 `ArraySpeciesCreate` 接受参数 `originalArray`（一个对象）和 `length`（一个非负整数），并返回一个包含对象的正常完成或一个抛出完成。此操作用于指定使用从 `originalArray` 派生的构造函数创建新的数组或类似对象。它不强制构造函数返回一个数组。调用时执行以下步骤：

1. 令 `isArray` 为 `? IsArray(originalArray)`。
2. 如果 `isArray` 为 false，则返回 `? ArrayCreate(length)`。
3. 令 `C` 为 `? Get(originalArray, "constructor")`。
4. 如果 `IsConstructor(C)` 为 true，则
   a. 令 `thisRealm` 为当前的领域记录。
   b. 令 `realmC` 为 `? GetFunctionRealm(C)`。
   c. 如果 `thisRealm` 和 `realmC` 不是同一个领域记录，则
      i. 如果 `SameValue(C, realmC.[[Intrinsics]].[[%Array%]])` 为 true，则将 `C` 设置为 undefined。
5. 如果 `C` 是一个对象，则
   a. 将 `C` 设置为 `? Get(C, @@species)`。
   b. 如果 `C` 为 null，则将 `C` 设置为 undefined。
6. 如果 `C` 为 undefined，则返回 `? ArrayCreate(length)`。
7. 如果 `IsConstructor(C)` 为 false，则抛出一个 `TypeError` 异常。
8. 返回 `? Construct(C, « 𝔽(length) »)`。

**注意**：如果 `originalArray` 是使用标准内置数组构造函数创建的，并且其领域不是正在运行的执行上下文的领域，则使用正在运行的执行上下文的领域创建一个新的数组。这保持了与过去 Web 浏览器的兼容性，这些浏览器历史上对现在使用 `ArraySpeciesCreate` 定义的 `Array.prototype` 方法具有这种行为。

##### 10.4.2.4 `ArraySetLength ( A, Desc )`
抽象操作 `ArraySetLength` 接受参数 `A`（一个数组）和 `Desc`（一个属性描述符），并返回一个包含布尔值的正常完成或一个抛出完成。调用时执行以下步骤：

1. 如果 `Desc` 没有 `[[Value]]` 字段，则
   a. 返回 `! OrdinaryDefineOwnProperty(A, "length", Desc)`。
2. 令 `newLenDesc` 为 `Desc` 的副本。
3. 令 `newLen` 为 `? ToUint32(Desc.[[Value]])`。
4. 令 `numberLen` 为 `? ToNumber(Desc.[[Value]])`。
5. 如果 `SameValueZero(newLen, numberLen)` 为 false，则抛出一个 `RangeError` 异常。
6. 将`newLenDesc.[[Value]]` 设置为 `newLen`。
7. 令 `oldLenDesc` 为 `OrdinaryGetOwnProperty(A, "length")`。
8. 断言：`IsDataDescriptor(oldLenDesc)` 为 true。
9. 断言：`oldLenDesc.[[Configurable]]` 为 false。
10. 令 `oldLen` 为 `oldLenDesc.[[Value]]`。
11. 如果 `newLen ≥ oldLen`，则
    a. 返回 `! OrdinaryDefineOwnProperty(A, "length", newLenDesc)`。
12. 如果 `oldLenDesc.[[Writable]]` 为 false，则返回 false。
13. 如果 `newLenDesc` 没有 `[[Writable]]` 字段或 `newLenDesc.[[Writable]]` 为 true，则
    a. 令 `newWritable` 为 true。
14. 否则，
    a. **注意**：将 `[[Writable]]` 属性设置为 false 被延后，以防某些元素无法删除。
    b. 令 `newWritable` 为 false。
    c. 将 `newLenDesc.[[Writable]]` 设置为 true。
15. 令 `succeeded` 为 `! OrdinaryDefineOwnProperty(A, "length", newLenDesc)`。
16. 如果 `succeeded` 为 false，则返回 false。
17. 对于 `A` 的每个自身属性键 `P`，如果 `P` 是数组索引并且 `! ToUint32(P) ≥ newLen`，按降序数值索引顺序执行以下步骤：
    a. 令 `deleteSucceeded` 为 `! A.[[Delete]](P)`。
    b. 如果 `deleteSucceeded` 为 false，则
        i. 将 `newLenDesc.[[Value]]` 设置为 `! ToUint32(P) + 1𝔽`。
        ii. 如果 `newWritable` 为 false，则将 `newLenDesc.[[Writable]]` 设置为 false。
        iii. 执行 `! OrdinaryDefineOwnProperty(A, "length", newLenDesc)`。
        iv. 返回 false。
18. 如果 `newWritable` 为 false，则
    a. 令 `succeeded` 为 `! OrdinaryDefineOwnProperty(A, "length", PropertyDescriptor { [[Writable]]: false })`。
    b. 断言：`succeeded` 为 true。
19. 返回 true。

**注意**：在步骤 3 和 4 中，如果 `Desc.[[Value]]` 是一个对象，则其 `valueOf` 方法会被调用两次。这是从本规范第 2 版开始指定的具有此效果的遗留行为。

#### 10.4.3 字符串异变对象
字符串对象是一种封装字符串值并暴露与字符串值的各个代码单元元素相对应的虚拟整数索引数据属性的异变对象。字符串异变对象始终具有名为“length”的数据属性，其值为所封装的字符串值的长度。代码单元数据属性和“length”属性都是不可写和不可配置的。

如果一个对象的 `[[GetOwnProperty]]`、`[[DefineOwnProperty]]` 和 `[[OwnPropertyKeys]]` 内部方法使用以下实现，并且其其他基本内部方法使用 10.1 中的定义，则该对象是一个字符串异变对象（或简称字符串对象）。这些方法是在 `StringCreate` 中安装的。

字符串异变对象具有与普通对象相同的内部槽。它们还具有一个 `[[StringData]]` 内部槽。

##### 10.4.3.1 `[[GetOwnProperty]] ( P )`
字符串异变对象 S 的 `[[GetOwnProperty]]` 内部方法接受参数 P（一个属性键），并返回一个包含属性描述符或 undefined 的正常完成。调用时执行以下步骤：

1. 令 `desc` 为 `OrdinaryGetOwnProperty(S, P)`。
2. 如果 `desc` 不为 undefined，则返回 `desc`。
3. 返回 `StringGetOwnProperty(S, P)`。

##### 10.4.3.2 `[[DefineOwnProperty]] ( P, Desc )`
字符串异变对象 S 的 `[[DefineOwnProperty]]` 内部方法接受参数 P（一个属性键）和 Desc（一个属性描述符），并返回一个包含布尔值的正常完成。调用时执行以下步骤：

1. 令 `stringDesc` 为 `StringGetOwnProperty(S, P)`。
2. 如果 `stringDesc` 不为 undefined，则
    a. 令 `extensible` 为 `S.[[Extensible]]`。
    b. 返回 `IsCompatiblePropertyDescriptor(extensible, Desc, stringDesc)`。
3. 返回 `! OrdinaryDefineOwnProperty(S, P, Desc)`。

##### 10.4.3.3 `[[OwnPropertyKeys]] ( )`
字符串异变对象 O 的 `[[OwnPropertyKeys]]` 内部方法不接受任何参数，返回一个包含属性键列表的正常完成。调用时执行以下步骤：

1. 令 `keys` 为一个新的空列表。
2. 令 `str` 为 `O.[[StringData]]`。
3. 断言：`str` 是一个字符串。
4. 令 `len` 为 `str` 的长度。
5. 对于每个整数 `i`，如果 `0 ≤ i < len`，按升序执行以下步骤：
    a. 将 `! ToString(𝔽(i))` 追加到 `keys`。
6. 对于 `O` 的每个自身属性键 `P`，如果 `P` 是数组索引并且 `! ToIntegerOrInfinity(P) ≥ len`，按升序数值索引顺序执行以下步骤：
    a. 将 `P` 追加到 `keys`。
7. 对于 `O` 的每个自身属性键 `P`，如果 `P` 是字符串并且 `P` 不是数组索引，按属性创建的时间顺序升序执行以下步骤：
    a. 将 `P` 追加到 `keys`。
8. 对于 `O` 的每个自身属性键 `P`，如果 `P` 是符号，按属性创建的时间顺序升序执行以下步骤：
    a. 将 `P` 追加到 `keys`。
9. 返回 `keys`。

##### 10.4.3.4 `StringCreate ( value, prototype )`
抽象操作 `StringCreate` 接受参数 `value`（一个字符串）和 `prototype`（一个对象），并返回一个字符串异变对象。此操作用于指定创建新的字符串异变对象。调用时执行以下步骤：

1. 令 `S` 为 `MakeBasicObject(« [[Prototype]], [[Extensible]], [[StringData]] »)`。
2. 将 `S.[[Prototype]]` 设置为 `prototype`。
3. 将 `S.[[StringData]]` 设置为 `value`。
4. 按照 10.4.3.1 中的描述设置 `S.[[GetOwnProperty]]`。
5. 按照 10.4.3.2 中的描述设置 `S.[[DefineOwnProperty]]`。
6. 按照 10.4.3.3 中的描述设置 `S.[[OwnPropertyKeys]]`。
7. 令 `length` 为 `value` 的长度。
8. 执行 `! DefinePropertyOrThrow(S, "length", PropertyDescriptor { [[Value]]: 𝔽(length), [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false })`。
9. 返回 `S`。

##### 10.4.3.5 `StringGetOwnProperty ( S, P )`
抽象操作 `StringGetOwnProperty` 接受参数 `S`（一个具有 `[[StringData]]` 内部槽的对象）和 `P`（一个属性键），并返回一个属性描述符或 undefined。调用时执行以下步骤：

1. 如果 `P` 不是字符串，则返回 undefined。
2. 令 `index` 为 `CanonicalNumericIndexString(P)`。
3. 如果 `index` 为 undefined，则返回 undefined。
4. 如果 `index` 不是整数，则返回 undefined。
5. 如果 `index` 为 -0𝔽，则返回 undefined。
6. 令 `str` 为 `S.[[StringData]]`。
7. 断言：`str` 是一个字符串。
8. 令 `len` 为 `str` 的长度。
9. 如果 ℝ(index) < 0 或 `len ≤ ℝ(index)`，则返回 undefined。
10. 令 `resultStr` 为从 ℝ(index) 到 ℝ(index) + 1 的 `str` 子字符串。
11. 返回属性描述符 `{ [[Value]]: resultStr, [[Writable]]: false, [[Enumerable]]: true, [[Configurable]]: false }`。

好的，我会继续翻译以下的章节内容。

### 10.4.4 参数异变对象
大多数 ECMAScript 函数都会为其代码提供一个 `arguments` 对象。根据函数定义的特性，其 `arguments` 对象要么是普通对象，要么是参数异变对象。参数异变对象是一种异变对象，其数组索引属性键映射到与其关联的 ECMAScript 函数调用的形式参数绑定。

如果一个对象的内部方法使用以下实现，则该对象是参数异变对象，而未指定的方法则使用 10.1 中的定义。这些方法是在 `CreateMappedArgumentsObject` 中安装的。

**注意 1**：尽管 `CreateUnmappedArgumentsObject` 归类在此条款中，它创建的是普通对象，而不是参数异变对象。

参数异变对象具有与普通对象相同的内部槽。它们还具有一个 `[[ParameterMap]]` 内部槽。普通的 `arguments` 对象也具有一个 `[[ParameterMap]]` 内部槽，其值始终为 `undefined`。对于普通的 `arguments` 对象，`[[ParameterMap]]` 内部槽仅用于 `Object.prototype.toString`（20.1.3.6）以标识它们。

**注意 2**：参数异变对象的整数索引数据属性，其数值名称值小于对应函数对象的形式参数数量，最初与函数的执行上下文中的相应参数绑定共享其值。这意味着更改属性会更改相应参数绑定的值，反之亦然。如果删除此类属性然后重新定义，或将其更改为访问器属性，则这种对应关系将被打破。如果 `arguments` 对象是普通对象，则其属性值只是传递给函数的参数的副本，并且属性值与形式参数值之间没有动态链接。

**注意 3**：`ParameterMap` 对象及其属性值用于指定 `arguments` 对象与参数绑定的对应关系。`ParameterMap` 对象及其属性值并不会从 ECMAScript 代码中直接可观察到。ECMAScript 实现不需要实际创建或使用此类对象来实现指定的语义。

**注意 4**：普通 `arguments` 对象定义了一个名为 `callee` 的不可配置访问器属性，在访问时会抛出 `TypeError` 异常。对于参数异变对象，该属性的定义仅适用于某些非严格模式的函数。普通变体中的 `callee` 属性的定义存在是为了确保符合 ECMAScript 实现不会以任何其他方式定义它。

**注意 5**：ECMAScript 实现的参数异变对象历史上包含一个名为 `caller` 的访问器属性。在 ECMAScript 2017 之前，本规范包括了对普通 `arguments` 对象上的 `caller` 属性的抛出定义。由于实现不再包含此扩展，因此 ECMAScript 2017 删除了对抛出 `caller` 访问器的要求。

#### 10.4.4.1 `[[GetOwnProperty]] ( P )`
参数异变对象 `args` 的 `[[GetOwnProperty]]` 内部方法接受参数 `P`（一个属性键），并返回一个包含属性描述符或 `undefined` 的正常完成。调用时执行以下步骤：

1. 令 `desc` 为 `OrdinaryGetOwnProperty(args, P)`。
2. 如果 `desc` 为 `undefined`，则返回 `undefined`。
3. 令 `map` 为 `args.[[ParameterMap]]`。
4. 令 `isMapped` 为 `! HasOwnProperty(map, P)`。
5. 如果 `isMapped` 为 true，则
    a. 将 `desc.[[Value]]` 设置为 `! Get(map, P)`。
6. 返回 `desc`。

#### 10.4.4.2 `[[DefineOwnProperty]] ( P, Desc )`
参数异变对象 `args` 的 `[[DefineOwnProperty]]` 内部方法接受参数 `P`（一个属性键）和 `Desc`（一个属性描述符），并返回一个包含布尔值的正常完成。调用时执行以下步骤：

1. 令 `map` 为 `args.[[ParameterMap]]`。
2. 令 `isMapped` 为 `! HasOwnProperty(map, P)`。
3. 令 `newArgDesc` 为 `Desc`。
4. 如果 `isMapped` 为 true 并且 `IsDataDescriptor(Desc)` 为 true，则
    a. 如果 `Desc` 没有 `[[Value]]` 字段、`Desc` 具有 `[[Writable]]` 字段且 `Desc.[[Writable]]` 为 false，则
        i. 将 `newArgDesc` 设置为 `Desc` 的副本。
        ii. 将 `newArgDesc.[[Value]]` 设置为 `! Get(map, P)`。
5. 令 `allowed` 为 `! OrdinaryDefineOwnProperty(args, P, newArgDesc)`。
6. 如果 `allowed` 为 false，则返回 false。
7. 如果 `isMapped` 为 true，则
    a. 如果 `Desc` 是访问器描述符，则
        i. 执行 `! map.[[Delete]](P)`。
    b. 否则，
        i. 如果 `Desc` 具有 `[[Value]]` 字段，则
            1. 断言：由于参数异变对象映射的形式参数始终是可写的，因此以下 `Set` 将成功。
            2. 执行 `! Set(map, P, Desc.[[Value]], false)`。
        ii. 如果 `Desc` 具有 `[[Writable]]` 字段且 `Desc.[[Writable]]` 为 false，则
            1. 执行 `! map.[[Delete]](P)`。
8. 返回 true。

#### 10.4.4.3 `[[Get]] ( P, Receiver )`
参数异变对象 `args` 的 `[[Get]]` 内部方法接受参数 `P`（一个属性键）和 `Receiver`（一个 ECMAScript 语言值），并返回一个包含 ECMAScript 语言值或抛出完成的正常完成。调用时执行以下步骤：

1. 令 `map` 为 `args.[[ParameterMap]]`。
2. 令 `isMapped` 为 `! HasOwnProperty(map, P)`。
3. 如果 `isMapped` 为 false，则
    a. 返回 `? OrdinaryGet(args, P, Receiver)`。
4. 否则，
    a. 断言：`map` 包含 `P` 的形式参数映射。
    b. 返回 `! Get(map, P)`。

#### 10.4.4.4 `[[Set]] ( P, V, Receiver )`
参数异变对象 `args` 的 `[[Set]]` 内部方法接受参数 `P`（一个属性键）、`V`（一个 ECMAScript 语言值）和 `Receiver`（一个 ECMAScript 语言值），并返回一个包含布尔值或抛出完成的正常完成。调用时执行以下步骤：

1. 如果 `SameValue(args, Receiver)` 为 false，则
    a. 令 `isMapped` 为 false。
2. 否则，
    a. 令 `map` 为 `args.[[ParameterMap]]`。
    b. 令 `isMapped` 为 `! HasOwnProperty(map, P)`。
3. 如果 `isMapped` 为 true，则
    a. 断言：由于参数异变对象映射的形式参数始终是可写的，因此以下 `Set` 将成功。
    b. 执行 `! Set(map, P, V, false)`。
4. 返回 `? OrdinarySet(args, P, V, Receiver)`。

#### 10.4.4.5 `[[Delete]] ( P )`
参数异变对象 `args` 的 `[[Delete]]` 内部方法接受参数 `P`（一个属性键），并返回一个包含布尔值或抛出完成的正常完成。调用时执行以下步骤：

1. 令 `map` 为 `args.[[ParameterMap]]`。
2. 令 `isMapped` 为 `! HasOwnProperty(map, P)`。
3. 令 `result` 为 `? OrdinaryDelete(args, P)`。
4. 如果 `result` 为 true 并且 `isMapped` 为 true，则
    a. 执行 `! map.[[Delete]](P)`。
5. 返回 `result`。

#### 10.4.4.6 `CreateUnmappedArgumentsObject ( argumentsList )`
抽象操作 `CreateUnmappedArgumentsObject` 接受参数 `argumentsList`（一个 ECMAScript 语言值列表），并返回一个普通对象。调用时执行以下步骤：

1. 令 `len` 为 `argumentsList` 中元素的数量。
2. 令 `obj` 为 `OrdinaryObjectCreate(%Object.prototype%, « [[ParameterMap]] »)`。
3. 将 `obj.[[ParameterMap]]` 设置为 `undefined`。
4. 执行 `! DefinePropertyOrThrow(obj, "length", PropertyDescriptor { [[Value]]: 𝔽(len), [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true })`。
5. 令 `index` 为 0。
6. 重复好的，继续翻译：

6. 重复执行以下步骤，直到 `index` 等于 `len`:
    a. 令 `val` 为 `argumentsList[index]`。
    b. 执行 `! CreateDataPropertyOrThrow(obj, ! ToString(𝔽(index)), val)`。
    c. 将 `index` 增加 1。

7. 执行 `! DefinePropertyOrThrow(obj, @@iterator, PropertyDescriptor { [[Value]]: %Array.prototype.values%, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true })`。
8. 执行 `! DefinePropertyOrThrow(obj, "callee", PropertyDescriptor { [[Get]]: %ThrowTypeError%, [[Set]]: %ThrowTypeError%, [[Enumerable]]: false, [[Configurable]]: false })`。
9. 返回 `obj`。

#### 10.4.4.7 `CreateMappedArgumentsObject ( func, formals, argumentsList, env )`
抽象操作 `CreateMappedArgumentsObject` 接受参数 `func`（一个对象）、`formals`（一个解析节点）、`argumentsList`（一个 ECMAScript 语言值列表）和 `env`（一个环境记录），并返回一个参数异变对象。调用时执行以下步骤：

1. 断言：`formals` 不包含剩余参数、任何绑定模式或任何初始化器。它可能包含重复的标识符。
2. 令 `len` 为 `argumentsList` 中元素的数量。
3. 令 `obj` 为 `MakeBasicObject(« [[Prototype]], [[Extensible]], [[ParameterMap]] »)`。
4. 设置 `obj.[[GetOwnProperty]]` 为 10.4.4.1 中的规范。
5. 设置 `obj.[[DefineOwnProperty]]` 为 10.4.4.2 中的规范。
6. 设置 `obj.[[Get]]` 为 10.4.4.3 中的规范。
7. 设置 `obj.[[Set]]` 为 10.4.4.4 中的规范。
8. 设置 `obj.[[Delete]]` 为 10.4.4.5 中的规范。
9. 设置 `obj.[[Prototype]]` 为 `%Object.prototype%`。
10. 令 `map` 为 `OrdinaryObjectCreate(null)`。
11. 将 `obj.[[ParameterMap]]` 设置为 `map`。
12. 令 `parameterNames` 为 `formals` 的绑定名称。
13. 令 `numberOfParameters` 为 `parameterNames` 中元素的数量。
14. 令 `index` 为 0。
15. 重复执行以下步骤，直到 `index` 等于 `len`:
    a. 令 `val` 为 `argumentsList[index]`。
    b. 执行 `! CreateDataPropertyOrThrow(obj, ! ToString(𝔽(index)), val)`。
    c. 将 `index` 增加 1。

16. 执行 `! DefinePropertyOrThrow(obj, "length", PropertyDescriptor { [[Value]]: 𝔽(len), [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true })`。
17. 令 `mappedNames` 为一个新的空列表。
18. 将 `index` 设置为 `numberOfParameters - 1`。
19. 重复执行以下步骤，直到 `index` 小于 0:
    a. 令 `name` 为 `parameterNames[index]`。
    b. 如果 `mappedNames` 不包含 `name`，则
        i. 将 `name` 附加到 `mappedNames`。
        ii. 如果 `index` 小于 `len`，则
            1. 令 `g` 为 `MakeArgGetter(name, env)`。
            2. 令 `p` 为 `MakeArgSetter(name, env)`。
            3. 执行 `! map.[[DefineOwnProperty]](! ToString(𝔽(index)), PropertyDescriptor { [[Set]]: p, [[Get]]: g, [[Enumerable]]: false, [[Configurable]]: true })`。
    c. 将 `index` 减少 1。

20. 执行 `! DefinePropertyOrThrow(obj, @@iterator, PropertyDescriptor { [[Value]]: %Array.prototype.values%, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true })`。
21. 执行 `! DefinePropertyOrThrow(obj, "callee", PropertyDescriptor { [[Value]]: func, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true })`。
22. 返回 `obj`。

##### 10.4.4.7.1 `MakeArgGetter ( name, env )`
抽象操作 `MakeArgGetter` 接受参数 `name`（一个字符串）和 `env`（一个环境记录），并返回一个函数对象。它创建了一个内置函数对象，该函数执行时返回在 `env` 中绑定的 `name` 的值。调用时执行以下步骤：

1. 令 `getterClosure` 为一个新的抽象闭包，没有参数，捕获 `name` 和 `env`，并在调用时执行以下步骤：
    a. 返回 `env.GetBindingValue(name, false)`。

2. 令 `getter` 为 `CreateBuiltinFunction(getterClosure, 0, "", « »)`。
3. **注意**：`getter` 不会直接暴露给 ECMAScript 代码。
4. 返回 `getter`。

##### 10.4.4.7.2 `MakeArgSetter ( name, env )`
抽象操作 `MakeArgSetter` 接受参数 `name`（一个字符串）和 `env`（一个环境记录），并返回一个函数对象。它创建了一个内置函数对象，该函数执行时在 `env` 中设置 `name` 的值。调用时执行以下步骤：

1. 令 `setterClosure` 为一个新的抽象闭包，参数为 `(value)`，捕获 `name` 和 `env`，并在调用时执行以下步骤：
    a. 返回 `! env.SetMutableBinding(name, value, false)`。

2. 令 `setter` 为 `CreateBuiltinFunction(setterClosure, 1, "", « »)`。
3. **注意**：`setter` 不会直接暴露给 ECMAScript 代码。
4. 返回 `setter`。

#### 10.4.5 类型化数组异变对象
类型化数组是一种对整数索引属性键进行特殊处理的异变对象。

类型化数组具有与普通对象相同的内部槽，另外还包括 `[[ViewedArrayBuffer]]`、`[[ArrayLength]]`、`[[ByteOffset]]`、`[[ContentType]]` 和 `[[TypedArrayName]]` 内部槽。

如果一个对象的 `[[GetOwnProperty]]`、`[[HasProperty]]`、`[[DefineOwnProperty]]`、`[[Get]]`、`[[Set]]`、`[[Delete]]` 和 `[[OwnPropertyKeys]]` 内部方法使用本节中的定义，并且其其他基本内部方法使用 10.1 中的定义，则该对象是类型化数组。这些方法是在 `TypedArrayCreate` 中安装的。

##### 10.4.5.1 `[[GetOwnProperty]] ( P )`
类型化数组 `O` 的 `[[GetOwnProperty]]` 内部方法接受参数 `P`（一个属性键），并返回一个包含属性描述符或 `undefined` 的正常完成。调用时执行以下步骤：

1. 如果 `P` 是字符串，则
    a. 令 `numericIndex` 为 `CanonicalNumericIndexString(P)`。
    b. 如果 `numericIndex` 不为 `undefined`，则
        i. 令 `value` 为 `TypedArrayGetElement(O, numericIndex)`。
        ii. 如果 `value` 为 `undefined`，则返回 `undefined`。
        iii. 返回属性描述符 `{ [[Value]]: value, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true }`。

2. 返回 `OrdinaryGetOwnProperty(O, P)`。

##### 10.4.5.2 `[[HasProperty]] ( P )`
类型化数组 `O` 的 `[[HasProperty]]` 内部方法接受参数 `P`（一个属性键），并返回一个包含布尔值的正常完成。调用时执行以下步骤：

1. 如果 `P` 是字符串，则
    a. 令 `numericIndex` 为 `CanonicalNumericIndexString(P)`。
    b. 如果 `numericIndex` 不为 `undefined`，返回 `IsValidIntegerIndex(O, numericIndex)`。

2. 返回 `? OrdinaryHasProperty(O, P)`。

##### 10.4.5.3 `[[DefineOwnProperty]] ( P, Desc )`
类型化数组 `O` 的 `[[DefineOwnProperty]]` 内部方法接受参数 `P`（一个属性键）和 `Desc`（一个属性描述符），并返回一个包含布尔值的正常完成。调用时执行以下步骤：

1. 如果 `P` 是字符串，则
    a. 令 `numericIndex` 为 `CanonicalNumericIndexString(P)`。
    b. 如果 `numericIndex` 不为 `undefined`，则
        i. 如果 `IsValidIntegerIndex(O, numericIndex)` 为 false，返回 false。
       

 ii. 如果 `Desc` 具有 `[[Configurable]]` 字段且 `Desc.[[Configurable]]` 为 false，返回 false。
        iii. 如果 `Desc` 具有 `[[Enumerable]]` 字段且 `Desc.[[Enumerable]]` 为 false，返回 false。
        iv. 如果 `IsAccessorDescriptor(Desc)` 为 true，返回 false。
        v. 如果 `Desc` 具有 `[[Writable]]` 字段且 `Desc.[[Writable]]` 为 false，返回 false。
        vi. 如果 `Desc` 具有 `[[Value]]` 字段，执行 `? TypedArraySetElement(O, numericIndex, Desc.[[Value]])`。
        vii. 返回 true。

2. 返回 `! OrdinaryDefineOwnProperty(O, P, Desc)`。

##### 10.4.5.4 `[[Get]] ( P, Receiver )`
类型化数组 `O` 的 `[[Get]]` 内部方法接受参数 `P`（一个属性键）和 `Receiver`（一个 ECMAScript 语言值），并返回一个包含 ECMAScript 语言值或抛出完成的正常完成。调用时执行以下步骤：

1. 如果 `P` 是字符串，则
    a. 令 `numericIndex` 为 `CanonicalNumericIndexString(P)`。
    b. 如果 `numericIndex` 不为 `undefined`，则
        i. 返回 `TypedArrayGetElement(O, numericIndex)`。

2. 返回 `? OrdinaryGet(O, P, Receiver)`。

##### 10.4.5.5 `[[Set]] ( P, V, Receiver )`
类型化数组 `O` 的 `[[Set]]` 内部方法接受参数 `P`（一个属性键）、`V`（一个 ECMAScript 语言值）和 `Receiver`（一个 ECMAScript 语言值），并返回一个包含布尔值或抛出完成的正常完成。调用时执行以下步骤：

1. 如果 `P` 是字符串，则
    a. 令 `numericIndex` 为 `CanonicalNumericIndexString(P)`。
    b. 如果 `numericIndex` 不为 `undefined`，则
        i. 如果 `SameValue(O, Receiver)` 为 true，则
            1. 执行 `? TypedArraySetElement(O, numericIndex, V)`。
            2. 返回 true。
        ii. 如果 `IsValidIntegerIndex(O, numericIndex)` 为 false，返回 true。

2. 返回 `? OrdinarySet(O, P, V, Receiver)`。

##### 10.4.5.6 `[[Delete]] ( P )`
类型化数组 `O` 的 `[[Delete]]` 内部方法接受参数 `P`（一个属性键），并返回一个包含布尔值的正常完成。调用时执行以下步骤：

1. 如果 `P` 是字符串，则
    a. 令 `numericIndex` 为 `CanonicalNumericIndexString(P)`。
    b. 如果 `numericIndex` 不为 `undefined`，则
        i. 如果 `IsValidIntegerIndex(O, numericIndex)` 为 false，返回 true；否则返回 false。

2. 返回 `! OrdinaryDelete(O, P)`。

##### 10.4.5.7 `[[OwnPropertyKeys]] ( )`
类型化数组 `O` 的 `[[OwnPropertyKeys]]` 内部方法不接受参数，并返回一个包含属性键列表的正常完成。调用时执行以下步骤：

1. 令 `taRecord` 为 `MakeTypedArrayWithBufferWitnessRecord(O, SEQ-CST)`。
2. 令 `keys` 为一个新的空列表。
3. 如果 `IsTypedArrayOutOfBounds(taRecord)` 为 false，则
    a. 令 `length` 为 `TypedArrayLength(taRecord)`。
    b. 对于每个整数 `i`，使 0 ≤ i < length，以升序顺序执行以下步骤：
        i. 将 `! ToString(𝔽(i))` 附加到 `keys`。

4. 对于 `O` 的每个自己的属性键 `P`，如果 `P` 是字符串且 `P` 不是整数索引，则按属性创建的时间顺序升序执行以下步骤：
    a. 将 `P` 附加到 `keys`。

5. 对于 `O` 的每个自己的属性键 `P`，如果 `P` 是符号，则按属性创建的时间顺序升序执行以下步骤：
    a. 将 `P` 附加到 `keys`。

6. 返回 `keys`。

##### 10.4.5.8 `TypedArray With Buffer Witness Records`
`TypedArray With Buffer Witness Record` 是一种记录值，用于封装一个类型化数组以及视图缓冲区的缓存字节长度。当视图缓冲区是可增长的 `SharedArrayBuffer` 时，它有助于确保单个共享内存读取事件的数据块字节长度。

`TypedArray With Buffer Witness Records` 具有表 32 中列出的字段。

**表 32：TypedArray With Buffer Witness Record 字段**

| 字段名                | 值               | 含义                                                |
| -------------------- | --------------- | -------------------------------------------------- |
| `[[Object]]`         | 一个类型化数组   | 加载其缓冲区字节长度的类型化数组。                  |
| `[[CachedBufferByteLength]]` | 非负整数或 `DETACHED` | 创建记录时对象的 `[[ViewedArrayBuffer]]` 的字节长度。|

##### 10.4.5.9 `MakeTypedArrayWithBufferWitnessRecord ( obj, order )`
抽象操作 `MakeTypedArrayWithBufferWitnessRecord` 接受参数 `obj`（一个类型化数组）和 `order`（SEQ-CST 或 UNORDERED），并返回一个 `TypedArray With Buffer Witness Record`。调用时执行以下步骤：

1. 令 `buffer` 为 `obj.[[ViewedArrayBuffer]]`。
2. 如果 `IsDetachedBuffer(buffer)` 为 true，则
    a. 将 `byteLength` 设置为 `DETACHED`。
3. 否则，
    a. 将 `byteLength` 设置为 `ArrayBufferByteLength(buffer, order)`。

4. 返回 `TypedArray With Buffer Witness Record { [[Object]]: obj, [[CachedBufferByteLength]]: byteLength }`。

##### 10.4.5.10 `TypedArrayCreate ( prototype )`
抽象操作 `TypedArrayCreate` 接受参数 `prototype`（一个对象），并返回一个类型化数组。调用时执行以下步骤：

1. 令 `internalSlotsList` 为 `« [[Prototype]], [[Extensible]], [[ViewedArrayBuffer]], [[TypedArrayName]], [[ContentType]], [[ByteLength]], [[ByteOffset]], [[ArrayLength]] »`。
2. 令 `A` 为 `MakeBasicObject(internalSlotsList)`。
3. 设置 `A.[[GetOwnProperty]]` 为 10.4.5.1 中的规范。
4. 设置 `A.[[HasProperty]]` 为 10.4.5.2 中的规范。
5. 设置 `A.[[DefineOwnProperty]]` 为 10.4.5.3 中的规范。
6. 设置 `A.[[Get]]` 为 10.4.5.4 中的规范。
7. 设置 `A.[[Set]]` 为 10.4.5.5 中的规范。
8. 设置 `A.[[Delete]]` 为 10.4.5.6 中的规范。
9. 设置 `A.[[OwnPropertyKeys]]` 为 10.4.5.7 中的规范。
10. 设置 `A.[[Prototype]]` 为 `prototype`。
11. 返回 `A`。

##### 10.4.5.11 `TypedArrayByteLength ( taRecord )`
抽象操作 `TypedArrayByteLength` 接受参数 `taRecord`（一个 `TypedArray With Buffer Witness Record`），并返回一个非负整数。调用时执行以下步骤：

1. 如果 `IsTypedArrayOutOfBounds(taRecord)` 为 true，返回 0。
2. 令 `length` 为 `TypedArrayLength(taRecord)`。
3. 如果 `length` 等于 0，返回 0。
4. 令 `O` 为 `taRecord.[[Object]]`。
5. 如果 `O.[[ByteLength]]` 不是 `AUTO`，返回 `O.[[ByteLength]]`。
6. 令 `elementSize` 为 `TypedArrayElementSize(O)`。
7. 返回 `length × elementSize`。

##### 10.4.5.12 `TypedArrayLength ( taRecord )`
抽象操作 `TypedArrayLength` 接受参数 `taRecord`（一个 `TypedArray With Buffer Witness Record`），并返回一个非负整数。调用时执行以下步骤：

1. 断言：`IsTypedArrayOutOfBounds(taRecord)` 为 false。
2. 令 `O` 为 `taRecord.[[Object]]`。
3. 如果 `O.[[ArrayLength]]` 不是 `AUTO`，返回 `O.[[ArrayLength]]`。
4. 断言：`IsFixedLengthArrayBuffer(O.[[ViewedArrayBuffer]])` 为 false。
5. 令 `byteOffset` 为 `O.[[ByteOffset]]`。
6. 令 `elementSize` 为 `TypedArrayElementSize(O)`。
7. 令 `byteLength` 为 `taRecord.[[CachedBufferByteLength]]`

。
8. 断言：`byteLength` 不是 `DETACHED`。
9. 返回 `floor((byteLength - byteOffset) / elementSize)`。

##### 10.4.5.13 `IsTypedArrayOutOfBounds ( taRecord )`
抽象操作 `IsTypedArrayOutOfBounds` 接受参数 `taRecord`（一个 `TypedArray With Buffer Witness Record`），并返回一个布尔值。它检查对象的任何数字属性是否引用了不包含在底层缓冲区范围内的索引值。调用时执行以下步骤：

1. 令 `O` 为 `taRecord.[[Object]]`。
2. 令 `bufferByteLength` 为 `taRecord.[[CachedBufferByteLength]]`。
3. 断言：如果 `IsDetachedBuffer(O.[[ViewedArrayBuffer]])` 为 true，则 `bufferByteLength` 为 `DETACHED`。
4. 如果 `bufferByteLength` 为 `DETACHED`，返回 true。
5. 令 `byteOffsetStart` 为 `O.[[ByteOffset]]`。
6. 如果 `O.[[ArrayLength]]` 为 `AUTO`，则
    a. 令 `byteOffsetEnd` 为 `bufferByteLength`。
7. 否则，
    a. 令 `elementSize` 为 `TypedArrayElementSize(O)`。
    b. 令 `byteOffsetEnd` 为 `byteOffsetStart + O.[[ArrayLength]] × elementSize`。

8. 如果 `byteOffsetStart > bufferByteLength` 或 `byteOffsetEnd > bufferByteLength`，返回 true。
9. **注意**：长度为 0 的类型化数组不被认为是越界的。
10. 返回 false。

##### 10.4.5.14 `IsValidIntegerIndex ( O, index )`
抽象操作 `IsValidIntegerIndex` 接受参数 `O`（一个类型化数组）和 `index`（一个数字），并返回一个布尔值。调用时执行以下步骤：

1. 如果 `IsDetachedBuffer(O.[[ViewedArrayBuffer]])` 为 true，返回 false。
2. 如果 `index` 不是整数数字，返回 false。
3. 如果 `index` 为 -0𝔽，返回 false。
4. 令 `taRecord` 为 `MakeTypedArrayWithBufferWitnessRecord(O, UNORDERED)`。
5. **注意**：当 `O` 的后备缓冲区是可增长的 `SharedArrayBuffer` 时，边界检查不是同步操作。
6. 如果 `IsTypedArrayOutOfBounds(taRecord)` 为 true，返回 false。
7. 令 `length` 为 `TypedArrayLength(taRecord)`。
8. 如果 ℝ(index) < 0 或 ℝ(index) ≥ length，返回 false。
9. 返回 true。

##### 10.4.5.15 `TypedArrayGetElement ( O, index )`
抽象操作 `TypedArrayGetElement` 接受参数 `O`（一个类型化数组）和 `index`（一个数字），并返回一个数字、BigInt 或 `undefined`。调用时执行以下步骤：

1. 如果 `IsValidIntegerIndex(O, index)` 为 false，返回 `undefined`。
2. 令 `offset` 为 `O.[[ByteOffset]]`。
3. 令 `elementSize` 为 `TypedArrayElementSize(O)`。
4. 令 `byteIndexInBuffer` 为 `(ℝ(index) × elementSize) + offset`。
5. 令 `elementType` 为 `TypedArrayElementType(O)`。
6. 返回 `GetValueFromBuffer(O.[[ViewedArrayBuffer]], byteIndexInBuffer, elementType, true, UNORDERED)`。

##### 10.4.5.16 `TypedArraySetElement ( O, index, value )`
抽象操作 `TypedArraySetElement` 接受参数 `O`（一个类型化数组）、`index`（一个数字）和 `value`（一个 ECMAScript 语言值），并返回一个包含 `UNUSED` 或抛出完成的正常完成。调用时执行以下步骤：

1. 如果 `O.[[ContentType]]` 为 `BIGINT`，令 `numValue` 为 `? ToBigInt(value)`。
2. 否则，令 `numValue` 为 `? ToNumber(value)`。
3. 如果 `IsValidIntegerIndex(O, index)` 为 true，则
    a. 令 `offset` 为 `O.[[ByteOffset]]`。
    b. 令 `elementSize` 为 `TypedArrayElementSize(O)`。
    c. 令 `byteIndexInBuffer` 为 `(ℝ(index) × elementSize) + offset`。
    d. 令 `elementType` 为 `TypedArrayElementType(O)`。
    e. 执行 `SetValueInBuffer(O.[[ViewedArrayBuffer]], byteIndexInBuffer, elementType, numValue, true, UNORDERED)`。

4. 返回 `UNUSED`。

**注意**：此操作总是看似成功，但尝试写入类型化数组末尾之后或写入由分离的 `ArrayBuffer` 支持的类型化数组时无效。

##### 10.4.5.17 `IsArrayBufferViewOutOfBounds ( O )`
抽象操作 `IsArrayBufferViewOutOfBounds` 接受参数 `O`（一个类型化数组或 `DataView`），并返回一个布尔值。它检查类型化数组的任何数字属性或 `DataView` 对象的方法是否可以引用底层数据块边界之外的值。此抽象操作存在作为上游规范的便利。调用时执行以下步骤：

1. 如果 `O` 具有 `[[DataView]]` 内部槽，则
    a. 令 `viewRecord` 为 `MakeDataViewWithBufferWitnessRecord(O, SEQ-CST)`。
    b. 返回 `IsViewOutOfBounds(viewRecord)`。

2. 令 `taRecord` 为 `MakeTypedArrayWithBufferWitnessRecord(O, SEQ-CST)`。
3. 返回 `IsTypedArrayOutOfBounds(taRecord)`。

#### 10.4.6 模块命名空间异变对象
模块命名空间异变对象是一种异变对象，用于公开从 ECMAScript 模块导出的绑定（参见 16.2.3）。模块命名空间异变对象的字符串键自己的属性与模块导出的绑定名称一一对应。导出的绑定包括使用 `export *` 导出项间接导出的任何绑定。每个字符串值自己的属性键是对应导出绑定名称的 `StringValue`。这些是模块命名空间异变对象的唯一字符串键属性。每个这样的属性具有 `{ [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: false }` 属性。模块命名空间异变对象不可扩展。

如果一个对象的 `[[GetPrototypeOf]]`、`[[SetPrototypeOf]]`、`[[IsExtensible]]`、`[[PreventExtensions]]`、`[[GetOwnProperty]]`、`[[DefineOwnProperty]]`、`[[HasProperty]]`、`[[Get]]`、`[[Set]]`、`[[Delete]]` 和 `[[OwnPropertyKeys]]` 内部方法使用本节中的定义，并且其其他基本内部方法使用 10.1 中的定义，则该对象是模块命名空间异变对象。这些方法是在 `ModuleNamespaceCreate` 中安装的。

模块命名空间异变对象具有表 33 中定义的内部槽。

**表 33：模块命名空间异变对象的内部槽**

| 内部槽      | 类型            | 描述                                     |
| ---------- | --------------- | --------------------------------------- |
| `[[Module]]` | 一个模块记录     | 该模块记录，其导出此命名空间公开。       |
| `[[Exports]]` | 一个字符串列表   | 元素是作为此对象自己的属性公开的导出名称的字符串值的列表。列表按字典代码单元顺序排序。 |

##### 10.4.6.1 `[[GetPrototypeOf]] ( )`
模块命名空间异变对象的 `[[GetPrototypeOf]]` 内部方法不接受参数，并返回一个包含 `null` 的正常完成。调用时执行以下步骤：

1. 返回 `null`。

##### 10.4.6.2 `[[SetPrototypeOf]] ( V )`
模块命名空间异变对象 `O` 的 `[[SetPrototypeOf]]` 内部方法接受参数 `V`（一个对象或 `null`），并返回一个包含布尔值的正常完成。调用时执行以下步骤：

1. 返回 `! SetImmutablePrototype(O, V)`。

##### 10.4.6.3 `[[IsExtensible]] ( )`
模块命名空间异变对象的 `[[IsExtensible]]` 内部方法不接受参数，并返回一个包含 `false` 的正常完成。调用时执行以下步骤：

1. 返回 `false`。

##### 10.4.6.4 `[[PreventExtensions]] ( )`
模块命名空间异变对象的 `[[PreventExtensions]]` 内部方法不接受参数，并返回一个包含 `true` 的正常完成。调用时执行以下步骤：

1. 返回 `true`。

##### 10.4.6.5 `[[GetOwnProperty]] ( P )`
模块命名空间异变对象 `O` 的 `[[GetOwnProperty]]` 内部方法接受

参数 `P`（一个属性键），并返回一个包含属性描述符或 `undefined` 的正常完成或抛出完成。调用时执行以下步骤：

1. 如果 `P` 是符号，返回 `OrdinaryGetOwnProperty(O, P)`。
2. 令 `exports` 为 `O.[[Exports]]`。
3. 如果 `exports` 不包含 `P`，返回 `undefined`。
4. 令 `value` 为 `? O.[[Get]](P, O)`。
5. 返回属性描述符 `{ [[Value]]: value, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: false }`。

##### 10.4.6.6 `[[DefineOwnProperty]] ( P, Desc )`
模块命名空间异变对象 `O` 的 `[[DefineOwnProperty]]` 内部方法接受参数 `P`（一个属性键）和 `Desc`（一个属性描述符），并返回一个包含布尔值的正常完成或抛出完成。调用时执行以下步骤：

1. 如果 `P` 是符号，返回 `! OrdinaryDefineOwnProperty(O, P, Desc)`。
2. 令 `current` 为 `? O.[[GetOwnProperty]](P)`。
3. 如果 `current` 为 `undefined`，返回 false。
4. 如果 `Desc` 具有 `[[Configurable]]` 字段且 `Desc.[[Configurable]]` 为 true，返回 false。
5. 如果 `Desc` 具有 `[[Enumerable]]` 字段且 `Desc.[[Enumerable]]` 为 false，返回 false。
6. 如果 `IsAccessorDescriptor(Desc)` 为 true，返回 false。
7. 如果 `Desc` 具有 `[[Writable]]` 字段且 `Desc.[[Writable]]` 为 false，返回 false。
8. 如果 `Desc` 具有 `[[Value]]` 字段，返回 `SameValue(Desc.[[Value]], current.[[Value]])`。
9. 返回 true。

##### 10.4.6.7 `[[HasProperty]] ( P )`
模块命名空间异变对象 `O` 的 `[[HasProperty]]` 内部方法接受参数 `P`（一个属性键），并返回一个包含布尔值的正常完成。调用时执行以下步骤：

1. 如果 `P` 是符号，返回 `! OrdinaryHasProperty(O, P)`。
2. 令 `exports` 为 `O.[[Exports]]`。
3. 如果 `exports` 包含 `P`，返回 true。
4. 返回 false。

##### 10.4.6.8 `[[Get]] ( P, Receiver )`
模块命名空间异变对象 `O` 的 `[[Get]]` 内部方法接受参数 `P`（一个属性键）和 `Receiver`（一个 ECMAScript 语言值），并返回一个包含 ECMAScript 语言值或抛出完成的正常完成。调用时执行以下步骤：

1. 如果 `P` 是符号，则
    a. 返回 `! OrdinaryGet(O, P, Receiver)`。

2. 令 `exports` 为 `O.[[Exports]]`。
3. 如果 `exports` 不包含 `P`，返回 `undefined`。
4. 令 `m` 为 `O.[[Module]]`。
5. 令 `binding` 为 `m.ResolveExport(P)`。
6. 断言：`binding` 是一个已解析的绑定记录。
7. 令 `targetModule` 为 `binding.[[Module]]`。
8. 断言：`targetModule` 不为 `undefined`。
9. 如果 `binding.[[BindingName]]` 为 `NAMESPACE`，则
    a. 返回 `GetModuleNamespace(targetModule)`。

10. 令 `targetEnv` 为 `targetModule.[[Environment]]`。
11. 如果 `targetEnv` 为 `EMPTY`，抛出 `ReferenceError` 异常。
12. 返回 `? targetEnv.GetBindingValue(binding.[[BindingName]], true)`。

**注意**：`ResolveExport` 无副作用。每次使用特定的 `exportName` 和 `resolveSet` 参数调用此操作时，它必须返回相同的结果。实现可能选择预先计算或缓存 `ResolveExport` 对模块命名空间异变对象的 `[[Exports]]` 的结果。

##### 10.4.6.9 `[[Set]] ( P, V, Receiver )`
模块命名空间异变对象的 `[[Set]]` 内部方法接受参数 `P`（一个属性键）、`V`（一个 ECMAScript 语言值）和 `Receiver`（一个 ECMAScript 语言值），并返回一个包含 `false` 的正常完成。调用时执行以下步骤：

1. 返回 false。

##### 10.4.6.10 `[[Delete]] ( P )`
模块命名空间异变对象 `O` 的 `[[Delete]]` 内部方法接受参数 `P`（一个属性键），并返回一个包含布尔值的正常完成。调用时执行以下步骤：

1. 如果 `P` 是符号，则
    a. 返回 `! OrdinaryDelete(O, P)`。

2. 令 `exports` 为 `O.[[Exports]]`。
3. 如果 `exports` 包含 `P`，返回 false。
4. 返回 true。

##### 10.4.6.11 `[[OwnPropertyKeys]] ( )`
模块命名空间异变对象 `O` 的 `[[OwnPropertyKeys]]` 内部方法不接受参数，并返回一个包含属性键列表的正常完成。调用时执行以下步骤：

1. 令 `exports` 为 `O.[[Exports]]`。
2. 令 `symbolKeys` 为 `OrdinaryOwnPropertyKeys(O)`。
3. 返回 `exports` 和 `symbolKeys` 的列表连接。

##### 10.4.6.12 `ModuleNamespaceCreate ( module, exports )`
抽象操作 `ModuleNamespaceCreate` 接受参数 `module`（一个模块记录）和 `exports`（一个字符串列表），并返回一个模块命名空间异变对象。调用时执行以下步骤：

1. 断言：`module.[[Namespace]]` 为空。
2. 令 `internalSlotsList` 为表 33 中列出的内部槽。
3. 令 `M` 为 `MakeBasicObject(internalSlotsList)`。
4. 将 `M` 的基本内部方法设置为 10.4.6 中指定的定义。
5. 将 `M.[[Module]]` 设置为 `module`。
6. 令 `sortedExports` 为一个列表，其元素是按字典代码单元顺序排序的 `exports` 的元素。
7. 将 `M.[[Exports]]` 设置为 `sortedExports`。
8. 创建与 28.3 中的定义相对应的 `M` 的自己的属性。
9. 将 `module.[[Namespace]]` 设置为 `M`。
10. 返回 `M`。

#### 10.4.7 不可变原型异变对象
不可变原型异变对象是一种异变对象，其 `[[Prototype]]` 内部槽在初始化后不会更改。

如果一个对象的 `[[SetPrototypeOf]]` 内部方法使用以下实现（其其他基本内部方法可能使用任何实现，取决于具体的不可变原型异变对象），则该对象是不可变原型异变对象。

**注意**：与其他异变对象不同，不可变原型异变对象没有提供专用的创建抽象操作。这是因为它们仅用于 `%Object.prototype%` 和主机环境，在主机环境中，相关对象可能以其他方式是异变的，因此需要专用的创建操作。

##### 10.4.7.1 `[[SetPrototypeOf]] ( V )`
不可变原型异变对象 `O` 的 `[[SetPrototypeOf]]` 内部方法接受参数 `V`（一个对象或 `null`），并返回一个包含布尔值或抛出完成的正常完成。调用时执行以下步骤：

1. 返回 `? SetImmutablePrototype(O, V)`。

##### 10.4.7.2 `SetImmutablePrototype ( O, V )`
抽象操作 `SetImmutablePrototype` 接受参数 `O`（一个对象）和 `V`（一个对象或 `null`），并返回一个包含布尔值或抛出完成的正常完成。调用时执行以下步骤：

1. 令 `current` 为 `? O.[[GetPrototypeOf]]()`。
2. 如果 `SameValue(V, current)` 为 true，返回 true。
3. 返回 false。

### 10.5 代理对象的内部方法和内部槽

代理对象是一种特殊的对象，其基本内部方法部分由 ECMAScript 代码实现。每个代理对象都有一个名为 `[[ProxyHandler]]` 的内部槽。`[[ProxyHandler]]` 的值是一个对象，称为代理的处理程序对象，或者为 null。处理程序对象的方法（见表 34）可用于增强一个或多个代理对象的内部方法的实现。每个代理对象还有一个名为 `[[ProxyTarget]]` 的内部槽，其值要么是一个对象，要么是 null 值。这个对象被称为代理的目标对象。

如果一个对象的基本内部方法（包括 `[[Call]]` 和 `[[Construct]]`，如果适用）使用本节中的定义，则该对象是一个代理特殊对象。这些内部方法在 `ProxyCreate` 中被安装。

**表 34：代理处理程序方法**

| 内部方法                     | 处理程序方法              |
|-----------------------------|---------------------------|
| `[[GetPrototypeOf]]`        | getPrototypeOf            |
| `[[SetPrototypeOf]]`        | setPrototypeOf            |
| `[[IsExtensible]]`          | isExtensible              |
| `[[PreventExtensions]]`     | preventExtensions         |
| `[[GetOwnProperty]]`        | getOwnPropertyDescriptor  |
| `[[DefineOwnProperty]]`     | defineProperty            |
| `[[HasProperty]]`           | has                       |
| `[[Get]]`                   | get                       |
| `[[Set]]`                   | set                       |
| `[[Delete]]`                | deleteProperty            |
| `[[OwnPropertyKeys]]`       | ownKeys                   |
| `[[Call]]`                  | apply                     |
| `[[Construct]]`             | construct                 |

当调用处理程序方法来实现代理对象的内部方法时，处理程序方法会将代理的目标对象作为参数传递。代理的处理程序对象不一定具有对应于每个基本内部方法的方法。如果处理程序对象没有与内部陷阱对应的方法，则在代理上调用内部方法会调用代理目标对象上的相应内部方法。

代理对象的 `[[ProxyHandler]]` 和 `[[ProxyTarget]]` 内部槽在对象创建时总是被初始化，并且通常不允许修改。某些代理对象的创建方式允许它们在创建后被撤销。当代理被撤销时，其 `[[ProxyHandler]]` 和 `[[ProxyTarget]]` 内部槽被设置为 null，导致随后在该代理对象上调用内部方法时抛出 TypeError 异常。

由于代理对象允许通过任意 ECMAScript 代码来实现内部方法，因此可以定义一个其处理程序方法违反 6.1.7.3 中定义的不变量的代理对象。6.1.7.3 中定义的一些内部方法不变量是基本完整性不变量。这些不变量由本节中指定的代理对象内部方法明确执行。ECMAScript 实现必须能够在所有可能的不变量违反情况下保持健壮。

在以下算法描述中，假定 `O` 是一个 ECMAScript 代理对象，`P` 是一个属性键值，`V` 是任何 ECMAScript 语言值，`Desc` 是一个属性描述符记录。

#### 10.5.1 `[[GetPrototypeOf]] ( )`
代理特殊对象 `O` 的 `[[GetPrototypeOf]]` 内部方法不接受参数，并返回一个包含一个对象或 null 的正常完成，或者返回一个抛出完成。调用时执行以下步骤：

1. 执行 `? ValidateNonRevokedProxy(O)`。
2. 令 `target` 为 `O.[[ProxyTarget]]`。
3. 令 `handler` 为 `O.[[ProxyHandler]]`。
4. 断言：`handler` 是一个对象。
5. 令 `trap` 为 `? GetMethod(handler, "getPrototypeOf")`。
6. 如果 `trap` 是 undefined，
    a. 返回 `? target.[[GetPrototypeOf]]()`。
7. 令 `handlerProto` 为 `? Call(trap, handler, « target »)`。
8. 如果 `handlerProto` 不是一个对象且 `handlerProto` 不是 null，抛出 TypeError 异常。
9. 令 `extensibleTarget` 为 `? IsExtensible(target)`。
10. 如果 `extensibleTarget` 为 true，返回 `handlerProto`。
11. 令 `targetProto` 为 `? target.[[GetPrototypeOf]]()`。
12. 如果 `SameValue(handlerProto, targetProto)` 为 false，抛出 TypeError 异常。
13. 返回 `handlerProto`。

**注意** `[[GetPrototypeOf]]` 对代理对象执行以下不变量：

- `[[GetPrototypeOf]]` 的结果必须是一个对象或 null。
- 如果目标对象不可扩展，则对代理对象应用 `[[GetPrototypeOf]]` 必须返回与对代理对象的目标对象应用 `[[GetPrototypeOf]]` 相同的值。

#### 10.5.2 `[[SetPrototypeOf]] ( V )`
代理特殊对象 `O` 的 `[[SetPrototypeOf]]` 内部方法接受参数 `V`（一个对象或 null），并返回一个包含布尔值的正常完成，或者返回一个抛出完成。调用时执行以下步骤：

1. 执行 `? ValidateNonRevokedProxy(O)`。
2. 令 `target` 为 `O.[[ProxyTarget]]`。
3. 令 `handler` 为 `O.[[ProxyHandler]]`。
4. 断言：`handler` 是一个对象。
5. 令 `trap` 为 `? GetMethod(handler, "setPrototypeOf")`。
6. 如果 `trap` 是 undefined，
    a. 返回 `? target.[[SetPrototypeOf]](V)`。
7. 令 `booleanTrapResult` 为 `ToBoolean(? Call(trap, handler, « target, V »))`。
8. 如果 `booleanTrapResult` 为 false，返回 false。
9. 令 `extensibleTarget` 为 `? IsExtensible(target)`。
10. 如果 `extensibleTarget` 为 true，返回 true。
11. 令 `targetProto` 为 `? target.[[GetPrototypeOf]]()`。
12. 如果 `SameValue(V, targetProto)` 为 false，抛出 TypeError 异常。
13. 返回 true。

**注意** `[[SetPrototypeOf]]` 对代理对象执行以下不变量：

- `[[SetPrototypeOf]]` 的结果是一个布尔值。
- 如果目标对象不可扩展，参数值必须与应用于目标对象的 `[[GetPrototypeOf]]` 的结果相同。

#### 10.5.3 `[[IsExtensible]] ( )`
代理特殊对象 `O` 的 `[[IsExtensible]]` 内部方法不接受参数，并返回一个包含布尔值的正常完成，或者返回一个抛出完成。调用时执行以下步骤：

1. 执行 `? ValidateNonRevokedProxy(O)`。
2. 令 `target` 为 `O.[[ProxyTarget]]`。
3. 令 `handler` 为 `O.[[ProxyHandler]]`。
4. 断言：`handler` 是一个对象。
5. 令 `trap` 为 `? GetMethod(handler, "isExtensible")`。
6. 如果 `trap` 是 undefined，
    a. 返回 `? IsExtensible(target)`。
7. 令 `booleanTrapResult` 为 `ToBoolean(? Call(trap, handler, « target »))`。
8. 令 `targetResult` 为 `? IsExtensible(target)`。
9. 如果 `booleanTrapResult` 不等于 `targetResult`，抛出 TypeError 异常。
10. 返回 `booleanTrapResult`。

**注意** `[[IsExtensible]]` 对代理对象执行以下不变量：

- `[[IsExtensible]]` 的结果是一个布尔值。
- 对代理对象应用 `[[IsExtensible]]` 必须返回与对代理对象的目标对象应用 `[[IsExtensible]]` 相同的值。

#### 10.5.4 `[[PreventExtensions]] ( )`
代理特殊对象 `O` 的 `[[PreventExtensions]]` 内部方法不接受参数，并返回一个包含布尔值的正常完成，或者返回一个抛出完成。调用时执行以下步骤：

1. 执行 `? ValidateNonRevokedProxy(O)`。
2. 令 `target` 为 `O.[[ProxyTarget]]`。
3. 令 `handler` 为 `O.[[ProxyHandler]]`。
4. 断言：`handler` 是一个对象。
5. 令 `trap` 为 `? GetMethod(handler, "preventExtensions")`。
6. 如果 `trap` 是 undefined，
    a. 返回 `? target.[[PreventExtensions]]()`。
7. 令 `booleanTrapResult` 为 `ToBoolean(? Call(trap, handler, « target »))`。
8. 如果 `booleanTrapResult` 为 true，
    a. 令 `extensibleTarget` 为 `? IsExtensible(target)`。
    b. 如果 `extensibleTarget` 为 true，抛出 TypeError 异常。
9. 返回 `booleanTrapResult`。

**注意** `[[PreventExtensions]]` 对代理对象执行以下不变量：

- `[[PreventExtensions]]` 的结果

是一个布尔值。
- 只有当对代理对象的目标对象应用 `[[IsExtensible]]` 为 false 时，才会对代理对象应用 `[[PreventExtensions]]` 返回 true。

#### 10.5.5 `[[GetOwnProperty]] ( P )`
代理特殊对象 `O` 的 `[[GetOwnProperty]]` 内部方法接受参数 `P`（一个属性键），并返回一个包含一个属性描述符或 undefined 的正常完成，或者返回一个抛出完成。调用时执行以下步骤：

1. 执行 `? ValidateNonRevokedProxy(O)`。
2. 令 `target` 为 `O.[[ProxyTarget]]`。
3. 令 `handler` 为 `O.[[ProxyHandler]]`。
4. 断言：`handler` 是一个对象。
5. 令 `trap` 为 `? GetMethod(handler, "getOwnPropertyDescriptor")`。
6. 如果 `trap` 是 undefined，
    a. 返回 `? target.[[GetOwnProperty]](P)`。
7. 令 `trapResultObj` 为 `? Call(trap, handler, « target, P »)`。
8. 如果 `trapResultObj` 不是一个对象且 `trapResultObj` 不是 undefined，抛出 TypeError 异常。
9. 令 `targetDesc` 为 `? target.[[GetOwnProperty]](P)`。
10. 如果 `trapResultObj` 是 undefined，
    a. 如果 `targetDesc` 是 undefined，返回 undefined。
    b. 如果 `targetDesc.[[Configurable]]` 为 false，抛出 TypeError 异常。
    c. 令 `extensibleTarget` 为 `? IsExtensible(target)`。
    d. 如果 `extensibleTarget` 为 false，抛出 TypeError 异常。
    e. 返回 undefined。
11. 令 `extensibleTarget` 为 `? IsExtensible(target)`。
12. 令 `resultDesc` 为 `? ToPropertyDescriptor(trapResultObj)`。
13. 执行 `CompletePropertyDescriptor(resultDesc)`。
14. 令 `valid` 为 `IsCompatiblePropertyDescriptor(extensibleTarget, resultDesc, targetDesc)`。
15. 如果 `valid` 为 false，抛出 TypeError 异常。
16. 如果 `resultDesc.[[Configurable]]` 为 false，
    a. 如果 `targetDesc` 是 undefined 或 `targetDesc.[[Configurable]]` 为 true，则
        i. 抛出 TypeError 异常。
    b. 如果 `resultDesc` 有 `[[Writable]]` 字段且 `resultDesc.[[Writable]]` 为 false，则
        i. 断言：`targetDesc` 有 `[[Writable]]` 字段。
        ii. 如果 `targetDesc.[[Writable]]` 为 true，抛出 TypeError 异常。
17. 返回 `resultDesc`。

**注意** `[[GetOwnProperty]]` 对代理对象执行以下不变量：

- `[[GetOwnProperty]]` 的结果必须是一个对象或 undefined。
- 如果目标对象的一个属性是不可配置的自有属性，则该属性不能被报告为不存在。
- 如果目标对象不可扩展，则一个属性不能被报告为不存在，除非它不存在于目标对象的自有属性中。
- 一个属性不能被报告为不可配置，除非它存在于目标对象的不可配置的自有属性中。
- 一个属性不能被报告为既不可配置又不可写，除非它存在于目标对象的既不可配置又不可写的自有属性中。

### 注解
Proxy对象的[[GetOwnProperty]]强制执行以下不变量：

1. [[GetOwnProperty]]的结果必须是一个对象或未定义（undefined）。
2. 如果目标对象（target object）存在一个不可配置的自有属性，则该属性不能被报告为不存在。
3. 如果目标对象不可扩展且存在一个自有属性，则该属性不能被报告为不存在。
4. 如果目标对象不存在一个自有属性且目标对象不可扩展，则该属性不能被报告为存在。
5. 除非目标对象存在一个不可配置的自有属性，否则该属性不能被报告为不可配置。
6. 除非目标对象存在一个不可配置且不可写的自有属性，否则该属性不能被报告为既不可配置又不可写。

### 10.5.6 [[DefineOwnProperty]] ( P, Desc )
Proxy特殊对象O的[[DefineOwnProperty]]内部方法接受参数P（属性键）和Desc（属性描述符），并返回一个包含布尔值的正常完成或一个抛出完成。它在调用时执行以下步骤：

1. 执行 ? ValidateNonRevokedProxy(O)。
2. 令target为O.[[ProxyTarget]]。
3. 令handler为O.[[ProxyHandler]]。
4. 断言：handler是一个对象。
5. 令trap为 ? GetMethod(handler, "defineProperty")。
6. 如果trap是未定义的，则
    a. 返回 ? target.[[DefineOwnProperty]](P, Desc)。
7. 令descObj为FromPropertyDescriptor(Desc)。
8. 令booleanTrapResult为ToBoolean(? Call(trap, handler, « target, P, descObj »))。
9. 如果booleanTrapResult为false，返回false。
10. 令targetDesc为 ? target.[[GetOwnProperty]](P)。
11. 令extensibleTarget为 ? IsExtensible(target)。
12. 如果Desc有一个[[Configurable]]字段且Desc.[[Configurable]]为false，则
    a. 令settingConfigFalse为true。
13. 否则，
    a. 令settingConfigFalse为false。
14. 如果targetDesc为未定义，则
    a. 如果extensibleTarget为false，抛出一个TypeError异常。
    b. 如果settingConfigFalse为true，抛出一个TypeError异常。
15. 否则，
    a. 如果IsCompatiblePropertyDescriptor(extensibleTarget, Desc, targetDesc)为false，抛出一个TypeError异常。
    b. 如果settingConfigFalse为true且targetDesc.[[Configurable]]为true，抛出一个TypeError异常。
    c. 如果IsDataDescriptor(targetDesc)为true，targetDesc.[[Configurable]]为false，且targetDesc.[[Writable]]为true，则
        i. 如果Desc有一个[[Writable]]字段且Desc.[[Writable]]为false，抛出一个TypeError异常。
16. 返回true。

### 注解
Proxy对象的[[DefineOwnProperty]]强制执行以下不变量：

1. [[DefineOwnProperty]]的结果是一个布尔值。
2. 如果目标对象不可扩展，则不能添加属性。
3. 除非存在对应的不可配置自有属性，否则属性不能为不可配置。
4. 除非存在对应的不可配置且不可写的自有属性，否则不可配置的属性不能为不可写。
5. 如果属性有对应的目标对象属性，则使用[[DefineOwnProperty]]将该属性的属性描述符应用于目标对象不会抛出异常。

### 10.5.7 [[HasProperty]] ( P )
Proxy特殊对象O的[[HasProperty]]内部方法接受参数P（属性键），并返回一个包含布尔值的正常完成或一个抛出完成。它在调用时执行以下步骤：

1. 执行 ? ValidateNonRevokedProxy(O)。
2. 令target为O.[[ProxyTarget]]。
3. 令handler为O.[[ProxyHandler]]。
4. 断言：handler是一个对象。
5. 令trap为 ? GetMethod(handler, "has")。
6. 如果trap是未定义的，则
    a. 返回 ? target.[[HasProperty]](P)。
7. 令booleanTrapResult为ToBoolean(? Call(trap, handler, « target, P »))。
8. 如果booleanTrapResult为false，则
    a. 令targetDesc为 ? target.[[GetOwnProperty]](P)。
    b. 如果targetDesc不是未定义的，则
        i. 如果targetDesc.[[Configurable]]为false，抛出一个TypeError异常。
        ii. 令extensibleTarget为 ? IsExtensible(target)。
        iii. 如果extensibleTarget为false，抛出一个TypeError异常。
9. 返回booleanTrapResult。

### 注解
Proxy对象的[[HasProperty]]强制执行以下不变量：

1. [[HasProperty]]的结果是一个布尔值。
2. 如果目标对象存在一个不可配置的自有属性，则该属性不能被报告为不存在。
3. 如果目标对象不可扩展且存在一个自有属性，则该属性不能被报告为不存在。

### 10.5.8 [[Get]] ( P, Receiver )

Proxy特殊对象O的[[Get]]内部方法接受参数P（属性键）和Receiver（一个ECMAScript语言值），并返回一个包含ECMAScript语言值的正常完成或一个抛出完成。调用时执行以下步骤：

1. 执行 ? ValidateNonRevokedProxy(O)。
2. 令target为O.[[ProxyTarget]]。
3. 令handler为O.[[ProxyHandler]]。
4. 断言：handler是一个对象。
5. 令trap为 ? GetMethod(handler, "get")。
6. 如果trap是未定义的，
    a. 返回 ? target.[[Get]](P, Receiver)。
7. 令trapResult为 ? Call(trap, handler, « target, P, Receiver »)。
8. 令targetDesc为 ? target.[[GetOwnProperty]](P)。
9. 如果targetDesc不是未定义且targetDesc.[[Configurable]]为false，
    a. 如果IsDataDescriptor(targetDesc)为true且targetDesc.[[Writable]]为false，
        i. 如果SameValue(trapResult, targetDesc.[[Value]])为false，抛出一个TypeError异常。
    b. 如果IsAccessorDescriptor(targetDesc)为true且targetDesc.[[Get]]是未定义，
        i. 如果trapResult不是未定义，抛出一个TypeError异常。
10. 返回trapResult。

### 注解
Proxy对象的[[Get]]强制执行以下不变量：

1. 如果目标对象的属性是一个不可写的、不可配置的自有数据属性，则报告的属性值必须与该属性值相同。
2. 如果目标对象的属性是一个不可配置的自有访问器属性，并且其[[Get]]属性是未定义，则报告的属性值必须是未定义。

### 10.5.9 [[Set]] ( P, V, Receiver )

Proxy特殊对象O的[[Set]]内部方法接受参数P（属性键）、V（一个ECMAScript语言值）和Receiver（一个ECMAScript语言值），并返回一个包含布尔值的正常完成或一个抛出完成。调用时执行以下步骤：

1. 执行 ? ValidateNonRevokedProxy(O)。
2. 令target为O.[[ProxyTarget]]。
3. 令handler为O.[[ProxyHandler]]。
4. 断言：handler是一个对象。
5. 令trap为 ? GetMethod(handler, "set")。
6. 如果trap是未定义的，
    a. 返回 ? target.[[Set]](P, V, Receiver)。
7. 令booleanTrapResult为ToBoolean(? Call(trap, handler, « target, P, V, Receiver »))。
8. 如果booleanTrapResult为false，返回false。
9. 令targetDesc为 ? target.[[GetOwnProperty]](P)。
10. 如果targetDesc不是未定义且targetDesc.[[Configurable]]为false，
    a. 如果IsDataDescriptor(targetDesc)为true且targetDesc.[[Writable]]为false，
        i. 如果SameValue(V, targetDesc.[[Value]])为false，抛出一个TypeError异常。
    b. 如果IsAccessorDescriptor(targetDesc)为true，
        i. 如果targetDesc.[[Set]]是未定义，抛出一个TypeError异常。
11. 返回true。

### 注解
Proxy对象的[[Set]]强制执行以下不变量：

1. [[Set]]的结果是一个布尔值。
2. 如果对应的目标对象属性是一个不可写的、不可配置的自有数据属性，则不能将属性值更改为与该属性值不同。
3. 如果对应的目标对象属性是一个不可配置的自有访问器属性，并且其[[Set]]属性是未定义，则不能设置属性值。

### 10.5.10 [[Delete]] ( P )

Proxy特殊对象O的[[Delete]]内部方法接受参数P（属性键），并返回一个包含布尔值的正常完成或一个抛出完成。调用时执行以下步骤：

1. 执行 ? ValidateNonRevokedProxy(O)。
2. 令target为O.[[ProxyTarget]]。
3. 令handler为O.[[ProxyHandler]]。
4. 断言：handler是一个对象。
5. 令trap为 ? GetMethod(handler, "deleteProperty")。
6. 如果trap是未定义的，
    a. 返回 ? target.[[Delete]](P)。
7. 令booleanTrapResult为ToBoolean(? Call(trap, handler, « target, P »))。
8. 如果booleanTrapResult为false，返回false。
9. 令targetDesc为 ? target.[[GetOwnProperty]](P)。
10. 如果targetDesc是未定义的，返回true。
11. 如果targetDesc.[[Configurable]]为false，抛出一个TypeError异常。
12. 令extensibleTarget为 ? IsExtensible(target)。
13. 如果extensibleTarget为false，抛出一个TypeError异常。
14. 返回true。

### 注解
Proxy对象的[[Delete]]强制执行以下不变量：

1. [[Delete]]的结果是一个布尔值。
2. 如果目标对象存在一个不可配置的自有属性，则该属性不能被报告为已删除。
3. 如果目标对象不可扩展且存在一个自有属性，则该属性不能被报告为已删除。

### 10.5.11 [[OwnPropertyKeys]] ( )

Proxy特殊对象O的[[OwnPropertyKeys]]内部方法不接受任何参数，并返回一个包含属性键列表的正常完成或一个抛出完成。调用时执行以下步骤：

1. 执行 ? ValidateNonRevokedProxy(O)。
2. 令target为O.[[ProxyTarget]]。
3. 令handler为O.[[ProxyHandler]]。
4. 断言：handler是一个对象。
5. 令trap为 ? GetMethod(handler, "ownKeys")。
6. 如果trap是未定义的，
    a. 返回 ? target.[[OwnPropertyKeys]]()。
7. 令trapResultArray为 ? Call(trap, handler, « target »)。
8. 令trapResult为 ? CreateListFromArrayLike(trapResultArray, « String, Symbol »)。
9. 如果trapResult包含任何重复条目，抛出一个TypeError异常。
10. 令extensibleTarget为 ? IsExtensible(target)。
11. 令targetKeys为 ? target.[[OwnPropertyKeys]]()。
12. 断言：targetKeys是一个属性键列表。
13. 断言：targetKeys不包含重复条目。
14. 令targetConfigurableKeys为一个新的空列表。
15. 令targetNonconfigurableKeys为一个新的空列表。
16. 对于targetKeys的每个元素key，执行
    a. 令desc为 ? target.[[GetOwnProperty]](key)。
    b. 如果desc不是未定义且desc.[[Configurable]]为false，
        i. 将key添加到targetNonconfigurableKeys。
    c. 否则，
        i. 将key添加到targetConfigurableKeys。
17. 如果extensibleTarget为true且targetNonconfigurableKeys为空，
    a. 返回trapResult。
18. 令uncheckedResultKeys为一个列表，其元素为trapResult的元素。
19. 对于targetNonconfigurableKeys的每个元素key，执行
    a. 如果uncheckedResultKeys不包含key，抛出一个TypeError异常。
    b. 从uncheckedResultKeys中移除key。
20. 如果extensibleTarget为true，返回trapResult。
21. 对于targetConfigurableKeys的每个元素key，执行
    a. 如果uncheckedResultKeys不包含key，抛出一个TypeError异常。
    b. 从uncheckedResultKeys中移除key。
22. 如果uncheckedResultKeys不为空，抛出一个TypeError异常。
23. 返回trapResult。

### 注解
Proxy对象的[[OwnPropertyKeys]]强制执行以下不变量：

1. [[OwnPropertyKeys]]的结果是一个列表。
2. 返回的列表不包含重复条目。
3. 每个结果列表元素的类型是String或Symbol。
4. 结果列表必须包含目标对象所有不可配置的自有属性的键。
5. 如果目标对象不可扩展，则结果列表必须包含目标对象所有自有属性的键且不包含其他值。

### 10.5.12 [[Call]] ( thisArgument, argumentsList )

Proxy特殊对象O的[[Call]]内部方法接受参数thisArgument（一个ECMAScript语言值）和argumentsList（一个ECMAScript语言值的列表），并返回一个包含ECMAScript语言值的正常完成或一个抛出完成。调用时执行以下步骤：

1. 执行 ? ValidateNonRevokedProxy(O)。
2. 令target为O.[[ProxyTarget]]。
3. 令handler为O.[[ProxyHandler]]。
4. 断言：handler是一个对象。
5. 令trap为 ? GetMethod(handler, "apply")。
6. 如果trap是未定义的，
    a. 返回 ? Call(target, thisArgument, argumentsList)。
7. 令argArray为CreateArrayFromList(argumentsList)。
8. 返回 ? Call(trap, handler, « target, thisArgument, argArray »)。

### 注解
只有当其[[ProxyTarget]]内部槽的初始值是一个具有[[Call]]内部方法的对象时，Proxy特殊对象才具有[[Call]]内部方法。

### 10.5.13 [[Construct]] ( argumentsList, newTarget )

Proxy特殊对象O的[[Construct]]内部方法接受参数argumentsList（一个ECMAScript语言值的列表）和newTarget（一个构造函数），并返回一个包含对象的正常完成或一个抛出完成。调用时执行以下步骤：

1. 执行 ? ValidateNonRevokedProxy(O)。
2. 令target为O.[[ProxyTarget]]。
3. 断言：IsConstructor(target)为true。
4. 令handler为O.[[ProxyHandler]]。
5. 断言：handler是一个对象。
6. 令trap为 ? GetMethod(handler, "construct")。
7. 如果trap是未定义的，
    a. 返回 ? Construct(target, argumentsList, newTarget)。
8. 令argArray为CreateArrayFromList(argumentsList)。
9. 令newObj为 ? Call(trap, handler, « target, argArray, newTarget »)。
10. 如果newObj不是一个对象，抛出一个TypeError异常。
11. 返回newObj。

### 注解1
只有当其[[ProxyTarget]]内部槽的初始值是一个具有[[Construct]]内部方法的对象时，Proxy特殊对象才具有[[Construct]]内部方法。

### 注解2
Proxy对象的[[Construct]]强制执行以下不变量：

1. [[Construct]]的结果必须是一个对象。

### 10.5.14 ValidateNonRevokedProxy ( proxy )

抽象操作ValidateNonRevokedProxy接受参数proxy（一个Proxy特殊对象），并返回一个包含UNUSED的正常完成或一个抛出完成。如果proxy已被撤销，则抛出一个TypeError异常。调用时执行以下步骤：

1. 如果proxy.[[ProxyTarget]]为null，抛出一个TypeError异常。
2. 断言：proxy.[[ProxyHandler]]不是null。
3. 返回UNUSED。

### 10.5.15 ProxyCreate ( target, handler )

抽象操作ProxyCreate接受参数target（一个ECMAScript语言值）和handler（一个ECMAScript语言值），并返回一个包含Proxy特殊对象的正常完成或一个抛出完成。它用于指定新Proxy对象的创建。调用时执行以下步骤：

1. 如果target不是一个对象，抛出一个TypeError异常。
2. 如果handler不是一个对象，抛出一个TypeError异常。
3. 令P为MakeBasicObject(« [[ProxyHandler]], [[ProxyTarget]] »)。
4. 将P的基本内部方法（除[[Call]]和[[Construct]]外）设置为10.5中指定的定义。
5. 如果IsCallable(target)为true，
    a. 设置P.[[Call]]如10.5.12中指定的。
    b. 如果IsConstructor(target)为true，
        i. 设置P.[[Construct]]如10.5.13中指定的。
6. 将P.[[ProxyTarget]]设置为target。
7. 将P.[[ProxyHandler]]设置为handler。
8. 返回P。

### 11 ECMAScript语言：源文本
### 11.1 源文本
#### 语法
SourceCharacter ::
任意Unicode码点

ECMAScript源文本是Unicode码点的序列。从U+0000到U+10FFFF的所有Unicode码点值，包括代理码点，均可出现在ECMAScript源文本中，只要符合ECMAScript语法。用于存储和交换ECMAScript源文本的实际编码与本规范无关。不论外部源文本编码如何，符合规范的ECMAScript实现都将源文本处理为等效的SourceCharacter值序列，每个SourceCharacter都是一个Unicode码点。符合规范的ECMAScript实现不需要对源文本进行任何规范化处理，或者表现得好像它们在对源文本进行规范化处理。

组合字符序列的组成部分被视为单独的Unicode码点，即使用户可能将整个序列视为一个单一字符。

#### 注解
在字符串字面量、正则表达式字面量、模板字面量和标识符中，任何Unicode码点也可以使用显式表达码点数值的Unicode转义序列表示。在注释中，这样的转义序列实际上被忽略，作为注释的一部分。

ECMAScript与Java编程语言在Unicode转义序列的行为上有所不同。在Java程序中，如果Unicode转义序列\u000A出现在单行注释中，它被解释为行终止符（Unicode码点U+000A是换行符（LF）），因此下一个码点不属于注释。同样地，如果Unicode转义序列\u000A出现在Java程序中的字符串字面量中，它同样被解释为行终止符，这在字符串字面量中是不允许的——必须写为\n才能使换行符（LF）成为字符串字面量的字符串值的一部分。在ECMAScript程序中，出现在注释中的Unicode转义序列从不被解释，因此不会导致注释终止。同样地，出现在ECMAScript程序中的字符串字面量中的Unicode转义序列始终构成字面量的一部分，从不被解释为行终止符或可能终止字符串字面量的码点。

### 11.1.1 静态语义：UTF16EncodeCodePoint（cp）
抽象操作UTF16EncodeCodePoint接受参数cp（一个Unicode码点）并返回一个字符串。调用时执行以下步骤：

1. 断言：0 ≤ cp ≤ 0x10FFFF。
2. 如果cp ≤ 0xFFFF，返回由数值为cp的码元组成的字符串值。
3. 令cu1为数值为floor((cp - 0x10000) / 0x400) + 0xD800的码元。
4. 令cu2为数值为((cp - 0x10000) modulo 0x400) + 0xDC00的码元。
5. 返回cu1和cu2的字符串连接。

### 11.1.2 静态语义：CodePointsToString（text）
抽象操作CodePointsToString接受参数text（一个Unicode码点序列）并返回一个字符串。它将text转换为一个字符串值，如6.1.4所述。调用时执行以下步骤：

1. 令result为空字符串。
2. 对于text中的每个码点cp，执行
   a. 将result设置为result和UTF16EncodeCodePoint(cp)的字符串连接。
3. 返回result。

### 11.1.3 静态语义：UTF16SurrogatePairToCodePoint（lead，trail）
抽象操作UTF16SurrogatePairToCodePoint接受参数lead（一个码元）和trail（一个码元）并返回一个码点。将形成UTF-16代理对的两个码元转换为一个码点。调用时执行以下步骤：

1. 断言：lead是前导代理，trail是后续代理。
2. 令cp为(lead - 0xD800) × 0x400 + (trail - 0xDC00) + 0x10000。
3. 返回码点cp。

### 11.1.4 静态语义：CodePointAt（string，position）
抽象操作CodePointAt接受参数string（一个字符串）和position（一个非负整数）并返回一个包含字段[[CodePoint]]（一个码点）、[[CodeUnitCount]]（一个正整数）和[[IsUnpairedSurrogate]]（一个布尔值）的记录。它将string解释为UTF-16编码的码点序列，如6.1.4所述，并从索引位置position开始读取一个码点。调用时执行以下步骤：

1. 令size为string的长度。
2. 断言：position ≥ 0且position < size。
3. 令first为string中索引位置为position的码元。
4. 令cp为数值等于first数值的码点。
5. 如果first既不是前导代理也不是后续代理，则
   a. 返回记录{ [[CodePoint]]: cp, [[CodeUnitCount]]: 1, [[IsUnpairedSurrogate]]: false }。
6. 如果first是后续代理或position + 1 = size，则
   a. 返回记录{ [[CodePoint]]: cp, [[CodeUnitCount]]: 1, [[IsUnpairedSurrogate]]: true }。
7. 令second为string中索引位置为position + 1的码元。
8. 如果second不是后续代理，则
   a. 返回记录{ [[CodePoint]]: cp, [[CodeUnitCount]]: 1, [[IsUnpairedSurrogate]]: true }。
9. 将cp设置为UTF16SurrogatePairToCodePoint(first, second)。
10. 返回记录{ [[CodePoint]]: cp, [[CodeUnitCount]]: 2, [[IsUnpairedSurrogate]]: false }。

### 11.1.5 静态语义：StringToCodePoints（string）
抽象操作StringToCodePoints接受参数string（一个字符串）并返回一个码点列表。它返回将string解释为UTF-16编码的Unicode文本所得到的Unicode码点序列，如6.1.4所述。调用时执行以下步骤：

1. 令codePoints为一个新的空列表。
2. 令size为string的长度。
3. 令position为0。
4. 重复，直到position < size，
   a. 令cp为CodePointAt(string, position)。
   b. 将cp.[[CodePoint]]追加到codePoints。
   c. 将position设置为position + cp.[[CodeUnitCount]]。
5. 返回codePoints。

### 11.1.6 静态语义：ParseText（sourceText，goalSymbol）
抽象操作ParseText接受参数sourceText（一个字符串或Unicode码点序列）和goalSymbol（ECMAScript语法中的一个非终结符）并返回一个解析节点或一个非空的SyntaxError对象列表。调用时执行以下步骤：

1. 如果sourceText是一个字符串，将sourceText设置为StringToCodePoints(sourceText)。
2. 尝试使用goalSymbol作为目标符号解析sourceText，并分析解析结果中的任何早期错误条件。解析和早期错误检测可以以实现定义的方式交错进行。
3. 如果解析成功且未发现早期错误，则返回解析树根部的解析节点（goalSymbol的一个实例）。
4. 否则，返回一个或多个SyntaxError对象列表，表示解析错误和/或早期错误。如果存在多个解析错误或早期错误，则列表中错误对象的数量和顺序是实现定义的，但至少要有一个。

### 注解1
考虑一个文本在特定点有一个早期错误，并且在后续点有一个语法错误。一个先解析后检测早期错误的实现可能报告语法错误，而不进行早期错误检测。一个交错进行这两种活动的实现可能报告早期错误，而不继续发现语法错误。第三种实现可能报告这两种错误。所有这些行为都是符合规范的。

### 注解2
另见第17条款。

### 11.2 源代码的类型
ECMAScript代码有四种类型：

- 全局代码是作为ECMAScript脚本处理的源文本。特定脚本的全局代码不包括作为FunctionDeclaration、FunctionExpression、GeneratorDeclaration、GeneratorExpression、AsyncFunctionDeclaration、AsyncFunctionExpression、AsyncGeneratorDeclaration、AsyncGeneratorExpression、MethodDefinition、ArrowFunction、AsyncArrowFunction、ClassDeclaration或ClassExpression一部分解析的任何源文本。
- Eval代码是提供给内置eval函数的源文本。更准确地说，如果内置eval函数的参数是一个字符串，则其被视为ECMAScript脚本。特定eval调用的eval代码是该脚本的全局代码部分。
- 函数代码是解析以提供ECMAScript函数对象的[[ECMAScriptCode]]和[[FormalParameters]]内部槽（见10.2）的值的源文本。特定ECMAScript函数的函数代码不包括作为嵌套的FunctionDeclaration、FunctionExpression、GeneratorDeclaration、GeneratorExpression、AsyncFunctionDeclaration、AsyncFunctionExpression、AsyncGeneratorDeclaration、AsyncGeneratorExpression、MethodDefinition、ArrowFunction、AsyncArrowFunction、ClassDeclaration或ClassExpression的函数代码解析的任何源文本。

此外，如果上述源文本被解析为：
- FunctionDeclaration或FunctionExpression的FormalParameters和FunctionBody，
- GeneratorDeclaration或GeneratorExpression的FormalParameters和GeneratorBody，
- AsyncFunctionDeclaration或AsyncFunctionExpression的FormalParameters和AsyncFunctionBody，或
- AsyncGeneratorDeclaration或AsyncGeneratorExpression的FormalParameters和AsyncGeneratorBody，

那么与该声明或表达式的BindingIdentifier（如果有）匹配的源文本也包括在相应函数的函数代码中。

- 模块代码是提供为ModuleBody的源文本。它是模块初始化时直接评估的代码。特定模块的模块代码不包括作为嵌套的FunctionDeclaration、FunctionExpression、GeneratorDeclaration、GeneratorExpression、AsyncFunctionDeclaration、AsyncFunctionExpression、AsyncGeneratorDeclaration、AsyncGeneratorExpression、MethodDefinition、ArrowFunction、AsyncArrowFunction、ClassDeclaration或ClassExpression一部分解析的任何源文本。

#### 注解1
函数代码通常作为函数定义（15.2）、箭头函数定义（15.3）、方法定义（15.4）、生成器函数定义（15.5）、异步函数定义（15.8）、异步生成器函数定义（15.6）和异步箭头函数（15.9）的主体提供。函数代码也源自Function构造函数（20.2.1.1）、GeneratorFunction构造函数（27.3.1.1）和AsyncFunction构造函数（27.7.1.1）的参数。

#### 注解2
将BindingIdentifier包括在函数代码中的实际效果是，即使周围代码不是严格模式代码，严格模式代码的早期错误也适用于包含“use strict”指令的函数名为BindingIdentifier的代码。

### 11.2.1 指令序列和使用严格指令
指令序列是FunctionBody、ScriptBody或ModuleBody的初始StatementListItems或ModuleItems中出现的最长的ExpressionStatements序列，并且序列中的每个ExpressionStatement完全由StringLiteral标记和分号组成。分号可以显式出现，也可以通过自动分号插入（12.10）插入。指令序列可以是一个空序列。

使用严格指令是指令序列中的一个ExpressionStatement，其StringLiteral是“use strict”或'use strict'的确切码点序列。使用严格指令不得包含EscapeSequence或LineContinuation。

指令序列可能包含多个使用严格指令。但是，如果出现这种情况，实现可能会发出警告。

#### 注解
在包含生成的评估过程中，指令序列的ExpressionStatements通常被正常评估。实现可能会为不是使用严格指令且出现在指令序列中的ExpressionStatements定义实现特定的含义。如果存在适当的通知机制，遇到不是使用严格指令且没有由实现定义含义的ExpressionStatement时，实现应发出警告。

### 11.2.2 严格模式代码
ECMAScript语法单元可以使用无限制或严格模式语法和语义（4.3.2）进行处理。在以下情况下，代码被解释为严格模式代码：

- 如果全局代码以包含使用严格指令的指令序列开始，则全局代码是严格模式代码。
- 模块代码始终是严格模式代码。
- ClassDeclaration或ClassExpression的所有部分都是严格模式代码。
- 如果eval代码以包含使用严格指令的指令序列开始，或调用eval的直接eval包含在严格模式代码中，则eval代码是严格模式代码。
- 如果相关的FunctionDeclaration、FunctionExpression、GeneratorDeclaration、GeneratorExpression、AsyncFunctionDeclaration、AsyncFunctionExpression、AsyncGeneratorDeclaration、AsyncGeneratorExpression、MethodDefinition、ArrowFunction或AsyncArrowFunction包含在严格模式代码中，或生成函数[[ECMAScriptCode]]内部槽值的代码以包含使用严格指令的指令序列开始，则函数代码是严格模式代码。
- 如果提供给内置Function、Generator、AsyncFunction和AsyncGenerator构造函数的参数是一个字符串，当处理时是以包含使用严格指令的指令序列开始的FunctionBody，则函数代码是严格模式代码。

非严格模式代码称为非严格代码。

### 11.2.2.1 静态语义：IsStrict（node）
抽象操作IsStrict接受参数node（一个解析节点）并返回一个布尔值。调用时执行以下步骤：

1. 如果node匹配的源文本是严格模式代码，返回true；否则返回false。

### 11.2.3 非ECMAScript函数
ECMAScript实现可能支持评估其评估行为以某种主机定义的可执行代码形式（非ECMAScript源文本）表示的函数特殊对象。从ECMAScript代码调用或被这种函数对象调用的角度来看，函数对象是ECMAScript代码中定义的还是内置函数是不可观察的。

### 12 ECMAScript语言：词法语法
ECMAScript脚本或模块的源文本首先被转换为输入元素序列，这些元素是标记、行终止符、注释或空白。源文本从左到右扫描，反复将最长可能的码点序列作为下一个输入元素。

在某些情况下，词法输入元素的识别对消耗输入元素的语法上下文是敏感的。这需要多个词法语法的目标符号。InputElementHashbangOrRegExp目标用于脚本或模块的开始。InputElementRegExpOrTemplateTail目标用于允许RegularExpressionLiteral、TemplateMiddle或TemplateTail的语法上下文。InputElementRegExp目标符号用于所有允许RegularExpressionLiteral但不允许TemplateMiddle或TemplateTail的语法上下文。InputElementTemplateTail目标用于所有允许TemplateMiddle或TemplateTail但不允许RegularExpressionLiteral的语法上下文。在所有其他上下文中，InputElementDiv作为词法目标符号使用。

#### 注解
使用多个词法目标确保没有影响自动分号插入的词法歧义。例如，没有语法上下文允许同时存在前导除法或除法赋值和前导RegularExpressionLiteral。这不受分号插入影响（见12.10）；在以下示例中：

```javascript
a = b
/hi/g.exec(c).map(d);
```

其中第一个非空白、非注释码点在LineTerminator之后是U+002F（SOLIDUS），且语法上下文允许除法或除法赋值，在LineTerminator处不插入分号。即，上述示例解释为：

```javascript
a = b / hi / g.exec(c).map(d);
```

#### 语法
```plaintext
InputElementDiv ::
  WhiteSpace
  LineTerminator
  Comment
  CommonToken
  DivPunctuator
  RightBracePunctuator

InputElementRegExp ::
  WhiteSpace
  LineTerminator
  Comment
  CommonToken
  RightBracePunctuator
  RegularExpressionLiteral

InputElementRegExpOrTemplateTail ::
  WhiteSpace
  LineTerminator
  Comment
  CommonToken
  RegularExpressionLiteral
  TemplateSubstitutionTail

InputElementTemplateTail ::
  WhiteSpace
  LineTerminator
  Comment
  CommonToken
  DivPunctuator
  TemplateSubstitutionTail

InputElementHashbangOrRegExp ::
  WhiteSpace
  LineTerminator
  Comment
  CommonToken
  HashbangComment
  RegularExpressionLiteral
```

### 12.1 Unicode格式控制字符
Unicode格式控制字符（即Unicode字符数据库中类别为“Cf”的字符，如LEFT-TO-RIGHT MARK或RIGHT-TO-LEFT MARK）是用于在没有更高级别协议（如标记语言）的情况下控制一段文本格式的控制代码。

允许在源文本中使用格式控制字符以方便编辑和显示是有用的。所有格式控制字符可以在注释、字符串字面量、模板字面量和正则表达式字面量中使用。

U+FEFF（零宽度不换行空格）是主要用于文本开头的格式控制字符，用于标记文本为Unicode并允许检测文本的编码和字节顺序。用于此目的的<ZWNBSP>字符有时也会在文本开头之后出现，例如由于文件连接的结果。在ECMAScript源文本中，<ZWNBSP>码点在注释、字符串字面量、模板字面量和正则表达式字面量之外被视为空白字符（见12.2）。

### 12.2 空白
空白码点用于提高源文本的可读性并将标记（不可分割的词法单位）彼此分隔开，但除此之外没有其他意义。空白码点可以出现在任何两个标记之间以及输入的开头或结尾。空白码点可以出现在StringLiteral、RegularExpressionLiteral、Template或TemplateSubstitutionTail中，在这些地方它们被视为组成字面量值一部分的有效码点。它们也可以出现在注释中，但不能出现在任何其他种类的标记中。

ECMAScript的空白码点列于表35中。

#### 表35：空白码点
| 码点     | 名称                  | 缩写      |
|----------|----------------------|-----------|
| U+0009   | 字符制表符           | <TAB>     |
| U+000B   | 行制表符             | <VT>      |
| U+000C   | 进纸符（FF）         | <FF>      |
| U+FEFF   | 零宽度不换行空格     | <ZWNBSP>  |
| 任何一般类别为“Space_Separator”的码点 | <USP> |

#### 注解1
U+0020（空格）和U+00A0（不换行空格）码点是<USP>的一部分。

#### 注解2
除了表35中列出的码点外，ECMAScript空白有意排除所有具有Unicode“White_Space”属性但不属于一般类别“Space_Separator”（“Zs”）的码点。

#### 语法
```plaintext
WhiteSpace ::
  <TAB>
  <VT>
  <FF>
  <ZWNBSP>
  <USP>
```

### 12.3 行终止符
像空白码点一样，行终止符码点用于提高源文本的可读性并将标记（不可分割的词法单位）彼此分隔开。然而，与空白码点不同，行终止符对语法的行为有一些影响。一般来说，行终止符可以出现在任何两个标记之间，但在某些地方语法禁止它们出现。行终止符还影响自动分号插入过程（见12.10）。行终止符不能出现在任何标记中，除了StringLiteral、Template或TemplateSubstitutionTail。<LF>和<CR>行终止符不能出现在StringLiteral标记中，除非作为LineContinuation的一部分。

行终止符可以出现在多行注释中，但不能出现在单行注释中。

### 12.3 行终止符（续）
行终止符包含在正则表达式中的\s类匹配的空白字符集合中。

ECMAScript的行终止符码点列于表36中。

#### 表36：行终止符码点
| 码点   | Unicode名称      | 缩写  |
|--------|------------------|-------|
| U+000A | 换行符（LF）     | <LF>  |
| U+000D | 回车符（CR）     | <CR>  |
| U+2028 | 行分隔符         | <LS>  |
| U+2029 | 段落分隔符       | <PS>  |

只有表36中的Unicode码点被视为行终止符。其他新的行或换行Unicode码点不被视为行终止符，但如果它们符合表35中的要求，则被视为空白字符。<CR><LF>序列通常用作行终止符。为了报告行号的目的，它应被视为单个SourceCharacter。

#### 语法
```plaintext
LineTerminator ::
  <LF>
  <CR>
  <LS>
  <PS>

LineTerminatorSequence ::
  <LF>
  <CR> [lookahead ≠ <LF>]
  <LS>
  <PS>
  <CR> <LF>
```

### 12.4 注释
注释可以是单行或多行。多行注释不能嵌套。

由于单行注释可以包含任何Unicode码点，除了行终止符码点，并且根据一般规则，标记总是尽可能长，因此单行注释总是由//标记到行尾的所有码点组成。然而，行尾的行终止符不被视为单行注释的一部分；它由词法语法单独识别并成为语法语法输入元素流的一部分。这一点非常重要，因为它意味着单行注释的存在与否不会影响自动分号插入过程（见12.10）。

注释的行为类似于空白字符，被丢弃，但如果多行注释包含行终止符码点，则整个注释在语法解析时被视为一个行终止符。

#### 语法
```plaintext
Comment ::
  MultiLineComment
  SingleLineComment

MultiLineComment ::
  /* MultiLineCommentCharsopt */

MultiLineCommentChars ::
  MultiLineNotAsteriskChar MultiLineCommentCharsopt
  * PostAsteriskCommentCharsopt

PostAsteriskCommentChars ::
  MultiLineNotForwardSlashOrAsteriskChar MultiLineCommentCharsopt
  * PostAsteriskCommentCharsopt

MultiLineNotAsteriskChar ::
  SourceCharacter but not *

MultiLineNotForwardSlashOrAsteriskChar ::
  SourceCharacter but not one of / or *

SingleLineComment ::
  // SingleLineCommentCharsopt

SingleLineCommentChars ::
  SingleLineCommentChar SingleLineCommentCharsopt

SingleLineCommentChar ::
  SourceCharacter but not LineTerminator
```

本节中的一些产生式在B.1.1节中有替代定义。

### 12.5 哈希符注释
哈希符注释是位置敏感的，并且像其他类型的注释一样从语法语法的输入元素流中丢弃。

#### 语法
```plaintext
HashbangComment ::
  #! SingleLineCommentCharsopt
```

### 12.6 标记
#### 语法
```plaintext
CommonToken ::
  IdentifierName
  PrivateIdentifier
  Punctuator
  NumericLiteral
  StringLiteral
  Template
```

注：DivPunctuator、RegularExpressionLiteral、RightBracePunctuator和TemplateSubstitutionTail产生额外的标记，不包括在CommonToken产生式中。

### 12.7 名称和关键字
IdentifierName和ReservedWord是根据Unicode标准附件#31《标识符和模式语法》中的默认标识符语法解释的标记，但有一些小的修改。ReservedWord是IdentifierName的枚举子集。语法语法将Identifier定义为不是ReservedWord的IdentifierName。Unicode标识符语法基于Unicode标准指定的字符属性。所有符合规范的ECMAScript实现必须将最新版本的Unicode标准中指定类别的Unicode码点视为那些类别。ECMAScript实现可以识别在后续版本的Unicode标准中定义的标识符码点。

#### 注解1
本标准指定了特定的码点补充：U+0024（美元符号）和U+005F（下划线）在IdentifierName中的任何位置都是允许的。

#### 语法
```plaintext
PrivateIdentifier ::
  # IdentifierName

IdentifierName ::
  IdentifierStart
  IdentifierName IdentifierPart

IdentifierStart ::
  IdentifierStartChar
  \ UnicodeEscapeSequence

IdentifierPart ::
  IdentifierPartChar
  \ UnicodeEscapeSequence

IdentifierStartChar ::
  UnicodeIDStart
  $
  _

IdentifierPartChar ::
  UnicodeIDContinue
  $
  AsciiLetter :: one of
    a b c d e f g h i j k l m n o p q r s t u v w x y z A B C D E F G H I J K L M N O P Q R S T U V W X Y Z

UnicodeIDStart ::
  any Unicode code point with the Unicode property “ID_Start”

UnicodeIDContinue ::
  any Unicode code point with the Unicode property “ID_Continue”
```

非终结符UnicodeEscapeSequence的定义见12.9.4。

#### 注解2
非终结符IdentifierPart通过UnicodeIDContinue派生出_。

#### 注解3
具有Unicode属性“ID_Start”和“ID_Continue”的码点集合分别包括具有Unicode属性“Other_ID_Start”和“Other_ID_Continue”的码点。

### 12.7.1 标识符名称
Unicode转义序列在IdentifierName中是允许的，它们贡献一个等于UnicodeEscapeSequence的IdentifierCodePoint的单一Unicode码点。UnicodeEscapeSequence之前的\不贡献任何码点。UnicodeEscapeSequence不能用于贡献给IdentifierName一个否则无效的码点。换句话说，如果将\ UnicodeEscapeSequence序列替换为它贡献的SourceCharacter，结果仍必须是一个有效的IdentifierName，其SourceCharacter元素的顺序与原始IdentifierName完全相同。此规范中的所有IdentifierName解释基于它们的实际码点，无论是否使用转义序列贡献了任何特定码点。

根据Unicode标准，两个规范等效的IdentifierName在被替换每个UnicodeEscapeSequence后，除非它们由完全相同的码点序列表示，否则不相等。

#### 12.7.1.1 静态语义：早期错误
IdentifierStart :: \ UnicodeEscapeSequence
如果UnicodeEscapeSequence的IdentifierCodePoint不是由IdentifierStartChar词法语法产生式匹配的某个Unicode码点，则这是一个语法错误。

IdentifierPart :: \ UnicodeEscapeSequence
如果UnicodeEscapeSequence的IdentifierCodePoint不是由IdentifierPartChar词法语法产生式匹配的某个Unicode码点，则这是一个语法错误。

#### 12.7.1.2 静态语义：IdentifierCodePoints
语法导向操作IdentifierCodePoints不接受参数，返回一个码点列表。它在以下产生式上逐段定义：

```plaintext
IdentifierName :: IdentifierStart
  1. 令cp为IdentifierStart的IdentifierCodePoint。
  2. 返回« cp »。

IdentifierName :: IdentifierName IdentifierPart
  1. 令cps为派生的IdentifierName的IdentifierCodePoints。
  2. 令cp为IdentifierPart的IdentifierCodePoint。
  3. 返回cps和« cp »的列表连接。
```

#### 12.7.1.3 静态语义：IdentifierCodePoint
语法导向操作IdentifierCodePoint不接受参数，返回一个码点。它在以下产生式上逐段定义：

```plaintext
IdentifierStart :: IdentifierStartChar
  1. 返回由IdentifierStartChar匹配的码点。

IdentifierPart :: IdentifierPartChar
  1. 返回由IdentifierPartChar匹配的码点。

UnicodeEscapeSequence :: u Hex4Digits
  1. 返回数值等于Hex4Digits的MV的码点。

UnicodeEscapeSequence :: u{ CodePoint }
  1. 返回数值等于CodePoint的MV的码点。
```

### 12.7.2 关键字和保留字

关键字是与IdentifierName匹配但也有语法用途的标记；即，它以固定宽度字体出现在某些语法产生式中。ECMAScript的关键字包括if、while、async、await等。

保留字是不能用作标识符的IdentifierName。许多关键字是保留字，但有些不是，有些仅在某些上下文中是保留字。if和while是保留字。await仅在异步函数和模块中保留。async不是保留字；它可以毫无限制地用作变量名或语句标签。

本规范使用语法产生式和早期错误规则的组合来指定哪些名称是有效标识符，哪些是保留字。以下保留字列表中的所有标记，除了await和yield，都是无条件保留的。对于await和yield的例外情况，见13.1，通过参数化的语法产生式。最后，若干早期错误规则限制了有效标识符的集合。见13.1.1、14.3.1.1、14.7.5.1和15.7.1。总之，标识符名称有五类：

1. 始终允许作为标识符且不是关键字的，如Math、window、toString和_。
2. 从不允许作为标识符的，即下列保留字列表中的标记，除await和yield外。
3. 上下文允许作为标识符的，即await和yield。
4. 上下文不允许作为标识符的，在严格模式代码中：let、static、implements、interface、package、private、protected和public。
5. 始终允许作为标识符，但在某些语法产生式中也作为关键字，在这些地方Identifier是不允许的：as、async、from、get、meta、of、set和target。

有时使用条件关键字或上下文关键字一词来指代落入后三类的关键字，因此在某些上下文中可以用作标识符，在其他上下文中则用作关键字。

#### 语法
```plaintext
ReservedWord :: one of
  await break case catch class const continue debugger default delete do else enum export extends false finally for function if import in instanceof new null return super switch this throw true try typeof var void while with yield
```

#### 注解1
根据5.1.5，语法中的关键字匹配特定SourceCharacter元素的字面序列。关键字中的码点不能通过\ UnicodeEscapeSequence表示。

IdentifierName可以包含\ UnicodeEscapeSequences，但不能通过拼写els\u{65}声明一个名为"else"的变量。13.1.1中的早期错误规则排除了与保留字同样StringValue的标识符。

#### 注解2
enum目前在本规范中不作为关键字使用。它是一个未来保留字，预留用于未来的语言扩展。

类似地，implements、interface、package、private、protected和public是严格模式代码中的未来保留字。

#### 注解3
名称arguments和eval不是关键字，但在严格模式代码中有一些限制。见13.1.1、8.6.4、15.2.1、15.5.1、15.6.1和15.8.1。

### 12.8 标点符号

#### 语法
```plaintext
Punctuator ::
  OptionalChainingPunctuator
  OtherPunctuator

OptionalChainingPunctuator ::
  ?. [lookahead ∉ DecimalDigit]

OtherPunctuator :: one of
  { ( ) [ ] . ... ; , < > <= >= == != === !== + - * % ** ++ -- << >> >>> & | ^ ! ~ && || ?? ? : = += -= *= %= **= <<= >>= >>>= &= |= ^= &&= ||= ??= =>

DivPunctuator ::
  / /=

RightBracePunctuator ::
  }
```

### 12.9 字面量
#### 12.9.1 空字面量

#### 语法
```plaintext
NullLiteral ::
  null
```

#### 12.9.2 布尔字面量

#### 语法
```plaintext
BooleanLiteral ::
  true
  false
```

#### 12.9.3 数字字面量

#### 语法
```plaintext
NumericLiteralSeparator ::
  _

NumericLiteral ::
  DecimalLiteral
  DecimalBigIntegerLiteral
  NonDecimalIntegerLiteral[+Sep]
  NonDecimalIntegerLiteral[+Sep] BigIntLiteralSuffix
  LegacyOctalIntegerLiteral

DecimalBigIntegerLiteral ::
  0 BigIntLiteralSuffix
  NonZeroDigit DecimalDigits[+Sep]opt BigIntLiteralSuffix
  NonZeroDigit NumericLiteralSeparator DecimalDigits[+Sep] BigIntLiteralSuffix

NonDecimalIntegerLiteral[Sep] ::
  BinaryIntegerLiteral[?Sep]
  OctalIntegerLiteral[?Sep]
  HexIntegerLiteral[?Sep]

BigIntLiteralSuffix ::
  n

DecimalLiteral ::
  DecimalIntegerLiteral . DecimalDigits[+Sep]opt ExponentPart[+Sep]opt
  . DecimalDigits[+Sep] ExponentPart[+Sep]opt
  DecimalIntegerLiteral ExponentPart[+Sep]opt

DecimalIntegerLiteral ::
  0
  NonZeroDigit
  NonZeroDigit NumericLiteralSeparatoropt DecimalDigits[+Sep]
  NonOctalDecimalIntegerLiteral

DecimalDigits[Sep] ::
  DecimalDigit
  DecimalDigits[?Sep] DecimalDigit
  [+Sep] DecimalDigits[+Sep] NumericLiteralSeparator DecimalDigit

DecimalDigit :: one of
  0 1 2 3 4 5 6 7 8 9

NonZeroDigit :: one of
  1 2 3 4 5 6 7 8 9

ExponentPart[Sep] ::
  ExponentIndicator SignedInteger[?Sep]

ExponentIndicator :: one of
  e E

SignedInteger[Sep] ::
  DecimalDigits[?Sep]
  + DecimalDigits[?Sep]
  - DecimalDigits[?Sep]

BinaryIntegerLiteral[Sep] ::
  0b BinaryDigits[?Sep]
  0B BinaryDigits[?Sep]

BinaryDigits[Sep] ::
  BinaryDigit
  BinaryDigits[?Sep] BinaryDigit
  [+Sep] BinaryDigits[+Sep] NumericLiteralSeparator BinaryDigit

BinaryDigit :: one of
  0 1

OctalIntegerLiteral[Sep] ::
  0o OctalDigits[?Sep]
  0O OctalDigits[?Sep]

OctalDigits[Sep] ::
  OctalDigit
  OctalDigits[?Sep] OctalDigit
  [+Sep] OctalDigits[+Sep] NumericLiteralSeparator OctalDigit

LegacyOctalIntegerLiteral ::
  0 OctalDigit
  LegacyOctalIntegerLiteral OctalDigit

NonOctalDecimalIntegerLiteral ::
  0 NonOctalDigit
  LegacyOctalLikeDecimalIntegerLiteral NonOctalDigit
  NonOctalDecimalIntegerLiteral DecimalDigit

LegacyOctalLikeDecimalIntegerLiteral ::
  0 OctalDigit
  LegacyOctalLikeDecimalIntegerLiteral OctalDigit

OctalDigit :: one of
  0 1 2 3 4 5 6 7

NonOctalDigit :: one of
  8 9

HexIntegerLiteral[Sep] ::
  0x HexDigits[?Sep]
  0X HexDigits[?Sep]

HexDigits[Sep] ::
  HexDigit
  HexDigits[?Sep] HexDigit
  [+Sep] HexDigits[+Sep] NumericLiteralSeparator HexDigit

HexDigit :: one of
  0 1 2 3 4 5 6 7 8 9 a b c d e f A B C D E F
```

NumericLiteral后面的SourceCharacter不能是IdentifierStart或DecimalDigit。

#### 注解
例如：3in是错误的，而不是两个输入元素3和in。

### 12.9.3.1 静态语义：早期错误

#### 语法
```plaintext
NumericLiteral :: LegacyOctalIntegerLiteral
DecimalIntegerLiteral :: NonOctalDecimalIntegerLiteral
```

如果IsStrict(this production)为true，这是一个语法错误。

#### 注解
在非严格代码中，此语法是遗留的。

### 12.9.3.2 静态语义：MV
数字字面量代表Number类型或BigInt类型的值。

- DecimalLiteral :: DecimalIntegerLiteral . DecimalDigits 的 MV 是 DecimalIntegerLiteral 的 MV 加上 (DecimalDigits 的 MV × 10**-n)，其中 n 是 DecimalDigits 中的码点数，不包括所有出现的 NumericLiteralSeparator。
- DecimalLiteral :: DecimalIntegerLiteral . ExponentPart 的 MV 是 DecimalIntegerLiteral 的 MV × 10**e，其中 e 是 ExponentPart 的 MV。
- DecimalLiteral :: DecimalIntegerLiteral . DecimalDigits ExponentPart 的 MV 是 (DecimalIntegerLiteral 的 MV 加上 (DecimalDigits 的 MV × 10**-n)) × 10**e，其中 n 是 DecimalDigits 中的码点数，不包括所有出现的 NumericLiteralSeparator，e 是 ExponentPart 的 MV。
- DecimalLiteral :: . DecimalDigits 的 MV 是 DecimalDigits 的 MV × 10**-n，其中 n 是 DecimalDigits 中的码点数，不包括所有出现的 NumericLiteralSeparator。
- DecimalLiteral :: . DecimalDigits ExponentPart 的 MV 是 DecimalDigits 的 MV × 10**(e - n)，其中 n 是 DecimalDigits 中的码点数，不包括所有出现的 NumericLiteralSeparator，e 是 ExponentPart 的 MV。
- DecimalLiteral :: DecimalIntegerLiteral ExponentPart 的 MV 是 DecimalIntegerLiteral 的 MV × 10**e，其中 e 是 ExponentPart 的 MV。
- DecimalIntegerLiteral :: 0 的 MV 是 0。
- DecimalIntegerLiteral :: NonZeroDigit NumericLiteralSeparatoropt DecimalDigits 的 MV 是 (NonZeroDigit 的 MV × 10**n) 加上 DecimalDigits 的 MV，其中 n 是 DecimalDigits 中的码点数，不包括所有出现的 NumericLiteralSeparator。
- DecimalDigits :: DecimalDigits DecimalDigit 的 MV 是 (DecimalDigits 的 MV × 10) 加上 DecimalDigit 的 MV。
- DecimalDigits :: DecimalDigits NumericLiteralSeparator DecimalDigit 的 MV 是 (DecimalDigits 的 MV × 10) 加上 DecimalDigit 的 MV。
- ExponentPart :: ExponentIndicator SignedInteger 的 MV 是 SignedInteger 的 MV。
- SignedInteger :: - DecimalDigits 的 MV 是 DecimalDigits 的 MV 的负值。
- DecimalDigit :: 0 或 HexDigit :: 0 或 OctalDigit :: 0 或 LegacyOctalEscapeSequence :: 0 或 BinaryDigit :: 0 的 MV 是 0。
- DecimalDigit :: 1 或 NonZeroDigit :: 1 或 HexDigit :: 1 或 OctalDigit :: 1 或 BinaryDigit :: 1 的 MV 是 1。
- DecimalDigit :: 2 或 NonZeroDigit :: 2 或 HexDigit :: 2 或 OctalDigit :: 2 的 MV 是 2。
- DecimalDigit :: 3 或 NonZeroDigit :: 3 或 HexDigit :: 3 或 OctalDigit :: 3 的 MV 是 3。
- DecimalDigit :: 4 或 NonZeroDigit :: 4 或 HexDigit :: 4 或 OctalDigit :: 4 的 MV 是 4。
- DecimalDigit :: 5 或 NonZeroDigit :: 5 或 HexDigit :: 5 或 OctalDigit :: 5 的 MV 是 5。
- DecimalDigit :: 6 或 NonZeroDigit :: 6 或 HexDigit :: 6 或 OctalDigit :: 6 的 MV 是 6。
- DecimalDigit :: 7 或 NonZeroDigit :: 7 或 HexDigit :: 7 或 OctalDigit :: 7 的 MV 是 7。
- DecimalDigit :: 8 或 NonZeroDigit :: 8 或 NonOctalDigit :: 8 或 HexDigit :: 8 的 MV 是 8。
- DecimalDigit :: 9 或 NonZeroDigit :: 9 或 NonOctalDigit :: 9 或 HexDigit :: 9 的 MV 是 9。
- HexDigit :: a 或 HexDigit :: A 的 MV 是 10。
- HexDigit :: b 或 HexDigit :: B 的 MV 是 11。
- HexDigit :: c 或 HexDigit :: C 的 MV 是 12。
- HexDigit :: d 或 HexDigit :: D 的 MV 是 13。
- HexDigit :: e 或 HexDigit :: E 的 MV 是 14。
- HexDigit :: f 或 HexDigit :: F 的 MV 是 15。
- BinaryDigits :: BinaryDigits BinaryDigit 的 MV 是 (BinaryDigits 的 MV × 2) 加上 BinaryDigit 的 MV。
- BinaryDigits :: BinaryDigits NumericLiteralSeparator BinaryDigit 的 MV 是 (BinaryDigits 的 MV × 2) 加上 BinaryDigit 的 MV。
- OctalDigits :: OctalDigits OctalDigit 的 MV 是 (OctalDigits 的 MV × 8) 加上 OctalDigit 的 MV。
- OctalDigits :: OctalDigits NumericLiteralSeparator OctalDigit 的 MV 是 (OctalDigits 的 MV × 8) 加上 OctalDigit 的 MV。
- LegacyOctalIntegerLiteral :: LegacyOctalIntegerLiteral OctalDigit 的 MV 是 (LegacyOctalIntegerLiteral 的 MV × 8) 加上 OctalDigit 的 MV。
- NonOctalDecimalIntegerLiteral :: LegacyOctalLikeDecimalIntegerLiteral NonOctalDigit 的 MV 是 (LegacyOctalLikeDecimalIntegerLiteral 的 MV × 10) 加上 NonOctalDigit 的 MV。
- NonOctalDecimalIntegerLiteral :: NonOctalDecimalIntegerLiteral DecimalDigit 的 MV 是 (NonOctalDecimalIntegerLiteral 的 MV × 10) 加上 DecimalDigit 的 MV。
- LegacyOctalLikeDecimalIntegerLiteral :: LegacyOctalLikeDecimalIntegerLiteral OctalDigit 的 MV 是 (LegacyOctalLikeDecimalIntegerLiteral 的 MV × 10) 加上 OctalDigit 的 MV。
- HexDigits :: HexDigits HexDigit 的 MV 是 (HexDigits 的 MV × 16) 加上 HexDigit 的 MV。
- HexDigits :: HexDigits NumericLiteralSeparator HexDigit 的 MV 是 (HexDigits 的 MV × 16) 加上 HexDigit 的 MV。

### 12.9.3.3 静态语义：NumericValue

语法导向操作NumericValue不接受参数，返回一个Number或BigInt。它在以下产生式上逐段定义：

- NumericLiteral :: DecimalLiteral
  1. 返回RoundMVResult(DecimalLiteral的MV)。
- NumericLiteral :: NonDecimalIntegerLiteral
  1. 返回𝔽(NonDecimalIntegerLiteral的MV)。
- NumericLiteral :: LegacyOctalIntegerLiteral
  1. 返回𝔽(LegacyOctalIntegerLiteral的MV)。
- NumericLiteral :: NonDecimalIntegerLiteral BigIntLiteralSuffix
  1. 返回NonDecimalIntegerLiteral的MV的BigInt值。
- DecimalBigIntegerLiteral :: 0 BigIntLiteralSuffix
  1. 返回0ℤ。
- DecimalBigIntegerLiteral :: NonZeroDigit BigIntLiteralSuffix
  1. 返回NonZeroDigit的MV的BigInt值。
- DecimalBigIntegerLiteral ::
  NonZeroDigit DecimalDigits BigIntLiteralSuffix
  NonZeroDigit NumericLiteralSeparator DecimalDigits BigIntLiteralSuffix
  1. 令n为DecimalDigits中的码点数，不包括所有出现的NumericLiteralSeparator。
  2. 令mv为(NonZeroDigit的MV × 10**n)加上DecimalDigits的MV。
  3. 返回ℤ(mv)。

### 12.9.4 字符串字面量

#### 注解1

字符串字面量是用单引号或双引号括起来的0或多个Unicode码点。Unicode码点也可以用转义序列表示。所有码点在字符串字面量中都可以出现，除了闭合引号码点、U+005C（反斜杠）、U+000D（回车符）和U+000A（换行符）。任何码点都可以以转义序列的形式出现。字符串字面量评估为ECMAScript字符串值。在生成这些字符串值时，Unicode码点按11.1.1中定义的UTF-16编码。属于基本多语言平面的码点编码为字符串的单个代码单元元素。所有其他码点编码为字符串的两个代码单元元素。

#### 语法

```plaintext
StringLiteral ::
  " DoubleStringCharactersopt "
  ' SingleStringCharactersopt '

DoubleStringCharacters ::
  DoubleStringCharacter DoubleStringCharactersopt

SingleStringCharacters ::
  SingleStringCharacter SingleStringCharactersopt

DoubleStringCharacter ::
  SourceCharacter but not one of " or \ or LineTerminator
  <LS>
  <PS>
  \ EscapeSequence
  LineContinuation

SingleStringCharacter ::
  SourceCharacter but not one of ' or \ or LineTerminator
  <LS>
  <PS>
  \ EscapeSequence
  LineContinuation

LineContinuation ::
  \ LineTerminatorSequence

EscapeSequence ::
  CharacterEscapeSequence
  0 [lookahead ∉ DecimalDigit]
  LegacyOctalEscapeSequence
  NonOctalDecimalEscapeSequence
  HexEscapeSequence
  UnicodeEscapeSequence

CharacterEscapeSequence ::
  SingleEscapeCharacter
  NonEscapeCharacter

SingleEscapeCharacter :: one of
  ' " \ b f n r t v

NonEscapeCharacter ::
  SourceCharacter but not one of EscapeCharacter or LineTerminator

EscapeCharacter ::
  SingleEscapeCharacter
  DecimalDigit
  x
  u

LegacyOctalEscapeSequence ::
  0 [lookahead ∈ { 8, 9 }]
  NonZeroOctalDigit [lookahead ∉ OctalDigit]
  ZeroToThree OctalDigit [lookahead ∉ OctalDigit]
  FourToSeven OctalDigit
  ZeroToThree OctalDigit OctalDigit

NonZeroOctalDigit ::
  OctalDigit but not 0

ZeroToThree :: one of
  0 1 2 3

FourToSeven :: one of
  4 5 6 7

NonOctalDecimalEscapeSequence :: one of
  8 9

HexEscapeSequence ::
  x HexDigit HexDigit

UnicodeEscapeSequence ::
  u Hex4Digits
  u{ CodePoint }

Hex4Digits ::
  HexDigit HexDigit HexDigit HexDigit
```

非终结符HexDigit的定义见12.9.3。SourceCharacter定义在11.1中。

#### 注解2

<LF>和<CR>不能出现在字符串字面量中，除非作为LineContinuation的一部分以产生空码点序列。在字符串字面量的String值中包含它们的正确方法是使用转义序列，如\n或\u000A。

### 12.9.4.1 静态语义：早期错误

```plaintext
EscapeSequence ::
  LegacyOctalEscapeSequence
  NonOctalDecimalEscapeSequence
```

如果IsStrict(this production)为true，这是一个语法错误。

#### 注解1

在非严格代码中，此语法是遗留的。

#### 注解2

字符串字面量可能出现在放置封闭代码为严格模式的Use Strict Directive之前，实施必须注意强制执行上述规则。例如，以下源文本包含语法错误：

```plaintext
function invalid() { "\7"; "use strict"; }
```

### 12.9.4.2 静态语义：SV

语法导向操作SV不接受参数，返回一个字符串。

字符串字面量代表String类型的值。SV通过递归应用于字符串字面量的各个部分来生成字符串值。在此过程中，字符串字面量中的某些Unicode码点被解释为具有数学值，如下所述或在12.9.3中描述。

- StringLiteral :: " " 的 SV 是空字符串。
- StringLiteral :: ' ' 的 SV 是空字符串。
- DoubleStringCharacters :: DoubleStringCharacter DoubleStringCharacters 的 SV 是 DoubleStringCharacter 的 SV 和 DoubleStringCharacters 的 SV 的字符串连接。
- SingleStringCharacters :: SingleStringCharacter SingleStringCharacters 的 SV 是 SingleStringCharacter 的 SV 和 SingleStringCharacters 的 SV 的字符串连接。
- DoubleStringCharacter :: SourceCharacter but not one of " or \ or LineTerminator 的 SV 是对SourceCharacter匹配的码点执行UTF16EncodeCodePoint的结果。
- DoubleStringCharacter :: <LS> 的 SV 是由代码单元0x2028（行分隔符）组成的字符串值。
- DoubleStringCharacter :: <PS> 的 SV 是由代码单元0x2029（段落分隔符）组成的字符串值。
- DoubleStringCharacter :: LineContinuation 的 SV 是空字符串。
- SingleStringCharacter :: SourceCharacter but not one of ' or \ or LineTerminator 的 SV 是对SourceCharacter匹配的码点执行UTF16EncodeCodePoint的结果。
- SingleStringCharacter :: <LS> 的 SV 是由代码单元0x2028（行分隔符）组成的字符串值。
- SingleStringCharacter :: <PS> 的 SV 是由代码单元0x2029（段落分隔符）组成的字符串值。
- SingleStringCharacter :: LineContinuation 的 SV 是空字符串。
- EscapeSequence :: 0 的 SV 是由代码单元0x0000（NULL）组成的字符串值。
- CharacterEscapeSequence :: SingleEscapeCharacter 的 SV 是由单一转义字符的数值决定的代码单元组成的字符串值，见表37。

#### 表37：字符串单字符转义序列

| 转义序列 | 代码单元值 | Unicode字符名称 | 符号  |
|----------|------------|------------------|-------|
| \b       | 0x0008     | 退格符           | <BS>  |
| \t       | 0x0009     | 制表符           | <HT>  |
| \n       | 0x000A     | 换行符           | <LF>  |
| \v       | 0x000B     | 行制表符         | <VT>  |
| \f       | 0x000C     | 换页符           | <FF>  |
| \r       | 0x000D     | 回车符           | <CR>  |
| \"       | 0x0022     | 引号             | "     |
| \'       | 0x0027     | 撇号             | '     |
| \\       | 0x005C     | 反斜杠           | \     |

- NonEscapeCharacter :: SourceCharacter but not one of EscapeCharacter or LineTerminator 的 SV 是对SourceCharacter匹配的码点执行UTF16EncodeCodePoint的结果。
- EscapeSequence :: LegacyOctalEscapeSequence 的 SV 是由LegacyOctalEscapeSequence的MV组成的代码单元的字符串值。
- NonOctalDecimalEscapeSequence :: 8 的 SV 是由代码单元0x0038（数字8）组成的字符串值。
- NonOctalDecimalEscapeSequence :: 9 的 SV 是由代码单元0x0039（数字9）组成的字符串值。
- HexEscapeSequence :: x HexDigit HexDigit 的 SV 是由数值等于HexEscapeSequence的MV的代码单元组成的字符串值。
- Hex4Digits :: HexDigit HexDigit HexDigit HexDigit 的 SV 是由数值等于Hex4Digits的MV的代码单元组成的字符串值。
- UnicodeEscapeSequence :: u{ CodePoint } 的 SV 是对 CodePoint 的 MV 执行 UTF16EncodeCodePoint 的结果。
- TemplateEscapeSequence :: 0 的 SV 是由代码单元 0x0000（NULL）组成的字符串值。

### 12.9.4.3 静态语义：MV

- LegacyOctalEscapeSequence :: ZeroToThree OctalDigit 的 MV 是 (8 × ZeroToThree 的 MV) 加上 OctalDigit 的 MV。
- LegacyOctalEscapeSequence :: FourToSeven OctalDigit 的 MV 是 (8 × FourToSeven 的 MV) 加上 OctalDigit 的 MV。
- LegacyOctalEscapeSequence :: ZeroToThree OctalDigit OctalDigit 的 MV 是 (64，即 8**2，× ZeroToThree 的 MV) 加上 (8 × 第一个 OctalDigit 的 MV) 加上第二个 OctalDigit 的 MV。
- ZeroToThree :: 0 的 MV 是 0。
- ZeroToThree :: 1 的 MV 是 1。
- ZeroToThree :: 2 的 MV 是 2。
- ZeroToThree :: 3 的 MV 是 3。
- FourToSeven :: 4 的 MV 是 4。
- FourToSeven :: 5 的 MV 是 5。
- FourToSeven :: 6 的 MV 是 6。
- FourToSeven :: 7 的 MV 是 7。
- HexEscapeSequence :: x HexDigit HexDigit 的 MV 是 (16 × 第一个 HexDigit 的 MV) 加上第二个 HexDigit 的 MV。
- Hex4Digits :: HexDigit HexDigit HexDigit HexDigit 的 MV 是 (0x1000 × 第一个 HexDigit 的 MV) 加上 (0x100 × 第二个 HexDigit 的 MV) 加上 (0x10 × 第三个 HexDigit 的 MV) 加上第四个 HexDigit 的 MV。

### 12.9.5 正则表达式字面量

#### 注释1

正则表达式字面量是一个输入元素，每次对该字面量进行求值时都会转换为一个RegExp对象（见22.2）。即使程序中的两个正则表达式字面量内容相同，它们求值后的正则表达式对象也不会在 === 比较中相等。可以在运行时通过 new RegExp 或调用 RegExp 构造函数作为函数（见22.2.4）来创建 RegExp 对象。

下列产生式描述了正则表达式字面量的语法，输入元素扫描器使用它们来找到正则表达式字面量的结束。由 RegularExpressionBody 和 RegularExpressionFlags 组成的源文本随后使用更严格的 ECMAScript 正则表达式语法（22.2.1）再次解析。

实现可以扩展22.2.1中定义的ECMAScript正则表达式语法，但不能扩展下列定义的 RegularExpressionBody 和 RegularExpressionFlags 产生式或这些产生式使用的产生式。

#### 语法

```plaintext
RegularExpressionLiteral ::
  / RegularExpressionBody / RegularExpressionFlags

RegularExpressionBody ::
  RegularExpressionFirstChar RegularExpressionChars

RegularExpressionChars ::
  [empty]
  RegularExpressionChars RegularExpressionChar

RegularExpressionFirstChar ::
  RegularExpressionNonTerminator but not one of * or \ or / or [
  RegularExpressionBackslashSequence
  RegularExpressionClass

RegularExpressionChar ::
  RegularExpressionNonTerminator but not one of \ or / or [
  RegularExpressionBackslashSequence
  RegularExpressionClass

RegularExpressionBackslashSequence ::
  \ RegularExpressionNonTerminator

RegularExpressionNonTerminator ::
  SourceCharacter but not LineTerminator

RegularExpressionClass ::
  [ RegularExpressionClassChars ]

RegularExpressionClassChars ::
  [empty]
  RegularExpressionClassChars RegularExpressionClassChar

RegularExpressionClassChar ::
  RegularExpressionNonTerminator but not one of ] or \
  RegularExpressionBackslashSequence

RegularExpressionFlags ::
  [empty]
  RegularExpressionFlags IdentifierPartChar
```

#### 注释2

正则表达式字面量不能为空；如果输入序列 // 出现，它表示一个单行注释，而不是一个空的正则表达式字面量。要表示一个空的正则表达式，请使用：/ (?:) /。

### 12.9.5.1 静态语义：BodyText

语法导向操作 BodyText 不接受参数，返回源文本。它在以下产生式上逐段定义：

```plaintext
RegularExpressionLiteral :: / RegularExpressionBody / RegularExpressionFlags
  1. 返回被识别为 RegularExpressionBody 的源文本。
```

### 12.9.5.2 静态语义：FlagText

语法导向操作 FlagText 不接受参数，返回源文本。它在以下产生式上逐段定义：

```plaintext
RegularExpressionLiteral :: / RegularExpressionBody / RegularExpressionFlags
  1. 返回被识别为 RegularExpressionFlags 的源文本。
```

### 12.9.6 模板字面量词法组件

#### 语法

```plaintext
Template ::
  NoSubstitutionTemplate
  TemplateHead

NoSubstitutionTemplate ::
  ` TemplateCharactersopt `

TemplateHead ::
  ` TemplateCharactersopt ${

TemplateSubstitutionTail ::
  TemplateMiddle
  TemplateTail

TemplateMiddle ::
  } TemplateCharactersopt ${

TemplateTail ::
  } TemplateCharactersopt `

TemplateCharacters ::
  TemplateCharacter TemplateCharactersopt

TemplateCharacter ::
  $ [lookahead ≠ {]
  \ TemplateEscapeSequence
  \ NotEscapeSequence
  LineContinuation
  LineTerminatorSequence
  SourceCharacter but not one of ` or \ or $ or LineTerminator

TemplateEscapeSequence ::
  CharacterEscapeSequence
  0 [lookahead ∉ DecimalDigit]
  HexEscapeSequence
  UnicodeEscapeSequence

NotEscapeSequence ::
  0 DecimalDigit
  DecimalDigit but not 0
  x [lookahead ∉ HexDigit]
  x HexDigit [lookahead ∉ HexDigit]
  u [lookahead ∉ HexDigit] [lookahead ≠ {]
  u HexDigit [lookahead ∉ HexDigit]
  u HexDigit HexDigit [lookahead ∉ HexDigit]
  u HexDigit HexDigit HexDigit [lookahead ∉ HexDigit]
  u { [lookahead ∉ HexDigit]
  u { NotCodePoint [lookahead ∉ HexDigit]
  u { CodePoint [lookahead ∉ HexDigit] [lookahead ≠ }]

NotCodePoint ::
  HexDigits[~Sep] but only if the MV of HexDigits > 0x10FFFF

CodePoint ::
  HexDigits[~Sep] but only if the MV of HexDigits ≤ 0x10FFFF
```

#### 注释
TemplateSubstitutionTail 由 InputElementTemplateTail 替代词法目标使用。

### 12.9.6.1 静态语义：TV

语法导向操作 TV 不接受参数，返回一个字符串或未定义。模板字面量组件由 TV 解释为字符串类型的值。TV 用于构建模板对象的索引组件（俗称模板值）。在 TV 中，转义序列由转义序列表示的 Unicode 代码点的 UTF-16 代码单元替换。

- NoSubstitutionTemplate :: ` ` 的 TV 是空字符串。
- TemplateHead :: ` ${ 的 TV 是空字符串。
- TemplateMiddle :: } ${ 的 TV 是空字符串。
- TemplateTail :: } ` 的 TV 是空字符串。
- TemplateCharacters :: TemplateCharacter TemplateCharacters 的 TV 是 undefined，如果 TemplateCharacter 的 TV 是 undefined 或 TemplateCharacters 的 TV 是 undefined。否则，它是 TemplateCharacter 的 TV 和 TemplateCharacters 的 TV 的字符串连接。
- TemplateCharacter :: SourceCharacter but not one of ` or \ or $ or LineTerminator 的 TV 是对 SourceCharacter 匹配的代码点执行 UTF16EncodeCodePoint 的结果。
- TemplateCharacter :: $ 的 TV 是由代码单元 0x0024（美元符号）组成的字符串值。
- TemplateCharacter :: \ TemplateEscapeSequence 的 TV 是 TemplateEscapeSequence 的 SV。
- TemplateCharacter :: \ NotEscapeSequence 的 TV 是 undefined。
- TemplateCharacter :: LineTerminatorSequence 的 TV 是 LineTerminatorSequence 的 TRV。
- LineContinuation :: \ LineTerminatorSequence 的 TV 是空字符串。

### 12.9.6.2 静态语义：TRV

语法导向操作 TRV 不接受参数，返回一个字符串。模板字面量组件由 TRV 解释为字符串类型的值。TRV 用于构建模板对象的原始组件（俗称模板原始值）。TRV 类似于 TV，区别在于 TRV 中，转义序列按照它们在字面量中出现的形式解释。

- NoSubstitutionTemplate :: ` ` 的 TRV 是空字符串。
- TemplateHead :: ` ${ 的 TRV 是空字符串。
- TemplateMiddle :: } ${ 的 TRV 是空字符串。
- TemplateTail :: } ` 的 TRV 是空字符串。
- TemplateCharacters :: TemplateCharacter TemplateCharacters 的 TRV 是 TemplateCharacter 的 TRV 和 TemplateCharacters 的 TRV 的字符串连接。
- TemplateCharacter :: SourceCharacter but not one of ` or \ or $ or LineTerminator 的 TRV 是对 SourceCharacter 匹配的代码点执行 UTF16EncodeCodePoint 的结果。
- TemplateCharacter :: $ 的 TRV 是由代码单元 0x0024（美元符号）组成的字符串值。
- TemplateCharacter :: \ TemplateEscapeSequence 的 TRV 是代码单元 0x005C（反斜杠）和 TemplateEscapeSequence 的 TRV 的字符串连接。
- TemplateCharacter :: \ NotEscapeSequence 的 TRV 是代码单元 0x005C（反斜杠）和 NotEscapeSequence 的 TRV 的字符串连接。
- TemplateEscapeSequence :: 0 的 TRV 是由代码单元 0x0030（数字零）组成的字符串值。
- NotEscapeSequence :: 0 DecimalDigit 的 TRV 是代码单元 0x0030（数字零）和 DecimalDigit 的 TRV 的字符串连接。
- NotEscapeSequence :: x [lookahead ∉ HexDigit] 的 TRV 是由代码单元 0x0078（拉丁小写字母x）组成的字符串值。
- NotEscapeSequence :: x HexDigit [lookahead ∉ HexDigit] 的 TRV 是代码单元 0x0078（拉丁小写字母x）和 HexDigit 的 TRV 的字符串连接。
- NotEscapeSequence :: u [lookahead ∉ HexDigit] [lookahead ≠ {] 的 TRV 是由代码单元 0x0075（拉丁小写字母u）组成的字符串值。
- NotEscapeSequence :: u HexDigit [lookahead ∉ HexDigit] 的 TRV 是代码单元 0x0075（拉丁小写字母u）和 HexDigit 的 TRV 的字符串连接。
- NotEscapeSequence :: u HexDigit HexDigit [lookahead ∉ HexDigit] 的 TRV 是代码单元 0x0075（拉丁小写字母u）、第一个 HexDigit 的 TRV 和第二个 HexDigit 的 TRV 的字符串连接。
- NotEscapeSequence :: u HexDigit HexDigit HexDigit [lookahead ∉ HexDigit] 的 TRV 是代码单元 0x0075（拉丁小写字母u）、第一个 HexDigit 的 TRV、第二个 HexDigit 的 TRV 和第三个 HexDigit 的 TRV 的字符串连接。
- NotEscapeSequence :: u { [lookahead ∉ HexDigit] 的 TRV 是代码单元 0x0075（拉丁小写字母u）和代码单元 0x007B（左花括号）的字符串连接。
- NotEscapeSequence :: u { NotCodePoint [lookahead ∉ HexDigit] 的 TRV 是代码单元 0x0075（拉丁小写字母u）、代码单元 0x007B（左花括号）和 NotCodePoint 的 TRV 的字符串连接。
- NotEscapeSequence :: u { CodePoint [lookahead ∉ HexDigit] [lookahead ≠ }] 的 TRV 是代码单元 0x0075（拉丁小写字母u）、代码单元 0x007B（左花括号）和 CodePoint 的 TRV 的字符串连接。
- DecimalDigit :: 0 1 2 3 4 5 6 7 8 9 的 TRV 是对该产生式匹配的单个代码点执行 UTF16EncodeCodePoint 的结果。
- CharacterEscapeSequence :: NonEscapeCharacter 的 TRV 是 NonEscapeCharacter 的 SV。
- SingleEscapeCharacter :: ' " \ b f n r t v 的 TRV 是对该产生式匹配的单个代码点执行 UTF16EncodeCodePoint 的结果。
- HexEscapeSequence :: x HexDigit HexDigit 的 TRV 是代码单元 0x0078（拉丁小写字母x）、第一个 HexDigit 的 TRV 和第二个 HexDigit 的 TRV 的字符串连接。
- UnicodeEscapeSequence :: u Hex4Digits 的 TRV 是代码单元 0x0075（拉丁小写字母u）和 Hex4Digits 的 TRV 的字符串连接。
- UnicodeEscapeSequence :: u{ CodePoint } 的 TRV 是代码单元 0x0075（拉丁小写字母u）、代码单元 0x007B（左花括号）、CodePoint 的 TRV 和代码单元 0x007D（右花括号）的字符串连接。
- Hex4Digits :: HexDigit HexDigit HexDigit HexDigit 的 TRV 是第一个 HexDigit 的 TRV、第二个 HexDigit 的 TRV、第三个 HexDigit 的 TRV 和第四个 HexDigit 的 TRV 的字符串连接。
- HexDigits :: HexDigits HexDigit 的 TRV 是 HexDigits 的 TRV 和 HexDigit 的 TRV 的字符串连接。
- HexDigit :: 0 1 2 3 4 5 6 7 8 9 a b c d e f A B C D E F 的 TRV 是对该产生式匹配的单个代码点执行 UTF16EncodeCodePoint 的结果。
- LineContinuation :: \ LineTerminatorSequence 的 TRV 是代码单元 0x005C（反斜杠）和 LineTerminatorSequence 的 TRV 的字符串连接
- LineContinuation（行续接）:: \ LineTerminatorSequence 的 TRV 是由代码单元 0x005C（反斜杠）和 LineTerminatorSequence 的 TRV 字符串连接而成。
- LineTerminatorSequence（行终止符序列）:: <LF> 的 TRV 是由代码单元 0x000A（换行符）组成的字符串值。
- LineTerminatorSequence（行终止符序列）:: <CR> 的 TRV 是由代码单元 0x000A（换行符）组成的字符串值。
- LineTerminatorSequence（行终止符序列）:: <LS> 的 TRV 是由代码单元 0x2028（行分隔符）组成的字符串值。
- LineTerminatorSequence（行终止符序列）:: <PS> 的 TRV 是由代码单元 0x2029（段落分隔符）组成的字符串值。
- LineTerminatorSequence（行终止符序列）:: <CR> <LF> 的 TRV 是由代码单元 0x000A（换行符）组成的字符串值。

注：
TV（模板值）排除了行续接的代码单元，而 TRV（模板原始值）包括了它们。<CR><LF> 和 <CR> 行终止符序列在 TV 和 TRV 中都被规范化为 <LF>。要包括 <CR> 或 <CR><LF> 序列，需要显式的 TemplateEscapeSequence（模板转义序列）。

### 12.10 自动分号插入

大多数 ECMAScript 语句和声明必须以分号结束。这些分号可以明确出现在源文本中。然而，为了方便，某些情况下可以省略这些分号。这些情况通过说明在这些情况下分号自动插入到源代码标记流中来描述。

#### 12.10.1 自动分号插入规则

在以下规则中，“标记”指的是使用当前词法目标符号识别的实际词法标记，如第 12 节所述。

分号插入的三个基本规则是：

1. 当从左到右解析源文本时，遇到一个不被语法的任何生成式允许的标记（称为违规标记）时，如果以下条件之一成立，则在违规标记之前自动插入一个分号：
   - 违规标记与前一个标记之间至少隔一个行终止符。
   - 违规标记是 `}`。
   - 前一个标记是 `)`，并且插入的分号将被解析为 `do-while` 语句（14.7.2）的结束分号。

2. 当从左到右解析源文本时，遇到标记流的末尾且解析器无法将输入标记流解析为目标非终结符的单个实例时，则在输入流末尾自动插入一个分号。

3. 当从左到右解析源文本时，遇到一个语法生成式允许的标记，但该生成式是受限生成式，并且该标记将是紧跟在 `[no LineTerminator here]` 注释之后的终结符或非终结符的第一个标记（因此该标记称为受限标记），并且受限标记与前一个标记之间至少隔一个行终止符，则在受限标记之前自动插入一个分号。

但是，以上规则有一个附加的优先条件：如果自动插入的分号将被解析为空语句，或者该分号将成为 `for` 语句（见 14.7.4）头部的两个分号之一，则不会自动插入分号。

**注**：
以下是语法中唯一的受限生成式：

- UpdateExpression[Yield, Await] :
  - LeftHandSideExpression[?Yield, ?Await] [no LineTerminator here] ++
  - LeftHandSideExpression[?Yield, ?Await] [no LineTerminator here] --
  
- ContinueStatement[Yield, Await] :
  - continue ;
  - continue [no LineTerminator here] LabelIdentifier[?Yield, ?Await] ;
  
- BreakStatement[Yield, Await] :
  - break ;
  - break [no LineTerminator here] LabelIdentifier[?Yield, ?Await] ;
  
- ReturnStatement[Yield, Await] :
  - return ;
  - return [no LineTerminator here] Expression[+In, ?Yield, ?Await] ;
  
- ThrowStatement[Yield, Await] :
  - throw [no LineTerminator here] Expression[+In, ?Yield, ?Await] ;
  
- YieldExpression[In, Await] :
  - yield
  - yield [no LineTerminator here] AssignmentExpression[?In, +Yield, ?Await]
  - yield [no LineTerminator here] * AssignmentExpression[?In, +Yield, ?Await]
  
- ArrowFunction[In, Yield, Await] :
  - ArrowParameters[?Yield, ?Await] [no LineTerminator here] => ConciseBody[?In]
  
- AsyncFunctionDeclaration[Yield, Await, Default] :
  - async [no LineTerminator here] function BindingIdentifier[?Yield, ?Await] ( FormalParameters[~Yield, +Await] ) { AsyncFunctionBody }
  - [+Default] async [no LineTerminator here] function ( FormalParameters[~Yield, +Await] ) { AsyncFunctionBody }
  
- AsyncFunctionExpression :
  - async [no LineTerminator here] function BindingIdentifier[~Yield, +Await]opt ( FormalParameters[~Yield, +Await] ) { AsyncFunctionBody }
  
- AsyncMethod[Yield, Await] :
  - async [no LineTerminator here] ClassElementName[?Yield, ?Await] ( UniqueFormalParameters[~Yield, +Await] ) { AsyncFunctionBody }
  
- AsyncGeneratorDeclaration[Yield, Await, Default] :
  - async [no LineTerminator here] function * BindingIdentifier[?Yield, ?Await] ( FormalParameters[+Yield, +Await] ) { AsyncGeneratorBody }
  - [+Default] async [no LineTerminator here] function * ( FormalParameters[+Yield, +Await] ) { AsyncGeneratorBody }
  
- AsyncGeneratorExpression :
  - async [no LineTerminator here] function * BindingIdentifier[+Yield, +Await]opt ( FormalParameters[+Yield, +Await] ) { AsyncGeneratorBody }
  
- AsyncGeneratorMethod[Yield, Await] :
  - async [no LineTerminator here] * ClassElementName[?Yield, ?Await] ( UniqueFormalParameters[+Yield, +Await] ) { AsyncGeneratorBody }
  
- AsyncArrowFunction[In, Yield, Await] :
  - async [no LineTerminator here] AsyncArrowBindingIdentifier[?Yield] [no LineTerminator here] => AsyncConciseBody[?In]
  - CoverCallExpressionAndAsyncArrowHead[?Yield, ?Await] [no LineTerminator here] => AsyncConciseBody[?In]
  
- AsyncArrowHead :
  - async [no LineTerminator here] ArrowFormalParameters[~Yield, +Await]

这些受限生成式的实际效果如下：

- 当解析器将 `++` 或 `--` 标记视为后缀运算符，并且在前一个标记与 `++` 或 `--` 标记之间至少有一个行终止符时，则在 `++` 或 `--` 标记之前自动插入分号。
- 当遇到 `continue`、`break`、`return`、`throw` 或 `yield` 标记，并且在下一个标记之前遇到行终止符时，则在 `continue`、`break`、`return`、`throw` 或 `yield` 标记之后自动插入分号。
- 当箭头函数的参数后面紧跟行终止符，而不是 `=>` 标记时，自动插入分号，并且标点符号导致语法错误。
- 当 `async` 标记后面紧跟行终止符，而不是 `function`、`IdentifierName` 或 `(` 标记时，自动插入分号，并且 `async` 标记不会被视为与后续标记属于同一表达式或类元素。
- 当 `async` 标记后面紧跟行终止符，而不是 `*` 标记时，自动插入分号，并且标点符号导致语法错误。

对 ECMAScript 程序员的实际建议是：

- 后缀 `++` 或 `--` 运算符应与其操作数在同一行。
- `return` 或 `throw` 语句中的表达式，或 `yield` 表达式中的赋值表达式，应从 `return`、`throw` 或 `yield` 标记所在的同一行开始。
- `break` 或 `continue` 语句中的 `LabelIdentifier` 应与 `break` 或 `continue` 标记在同一行。
- 箭头函数参数的结尾和 `=>` 应在同一行。
- `async` 标记应与紧跟的异步函数或方法在同一行。

### 12.10.2 自动分号插入的例子

本节为非规范性内容。

源代码

```
{ 1 2 } 3
```

即使在自动分号插入规则下，也不是 ECMAScript 语法中的有效句子。相反，源代码

```
{ 1
2 } 3
```

也不是有效的 ECMAScript 句子，但通过自动分号插入会被转换为以下内容：

```
{ 1
;2 ;} 3;
```

这是一个有效的 ECMAScript 句子。

源代码

```
for (a; b
)
```

不是一个有效的 ECMAScript 句子，自动分号插入也不会更改它，因为 `for` 语句的头部需要分号。自动分号插入从不会插入 `for` 语句头部的两个分号之一。

源代码

```
return
a + b
```

通过自动分号插入转换为以下内容：

```
return;
a + b;
```

**注1**：表达式 `a + b` 不被视为 `return` 语句返回的值，因为 `return` 标记和它之间有一个行终止符。

源代码

```
a = b
++c
```

通过自动分号插入转换为以下内容：

```
a = b;
++c;
```

**注2**：标记 `++` 不被视为应用于变量 `b` 的后缀运算符，因为 `b` 和 `++` 之间有一个行终止符。

源代码

```
if (a > b)
else c = d
```

不是一个有效的 ECMAScript 句子，自动分号插入在 `else` 标记之前也不会更改它，即使在此点没有适用的语法生成式，因为自动插入的分号会被解析为空语句。

源代码

```
a = b + c
(d + e).print()
```

不会被自动分号插入更改，因为第二行开始的括号表达式可以被解释为函数调用的参数列表：

```
a = b + c(d + e).print()
```

在需要赋值语句以左括号开始的情况下，程序员最好在前一个语句的结尾提供一个显式分号，而不是依赖于自动分号插入。

### 12.10.3 自动分号插入的有趣情况

本节为非规范性内容。

ECMAScript 程序可以依赖自动分号插入来编写很少分号的风格。如上所述，分号不会在每个换行符处插入，自动分号插入可能依赖于跨行终止符的多个标记。

随着新的语法特性的添加，可能会添加额外的语法生成式，从而在解析时导致依赖于前面的自动分号插入的行改变语法生成式。

对于本节的目的，如果一个地方的分号可能插入或不插入，这取决于之前的源文本，则该自动分号插入的情况被视为有趣的。本节的其余部分描述了此版本 ECMAScript 中一些有趣的自动分号插入情况。

#### 12.10.3.1 语句列表中的有趣自动分号插入情况

在 `StatementList` 中，许多 `StatementListItems` 以分号结束，可以使用自动分号插入省略分号。根据上述规则，在表达式结束的行末尾，如果下一行以以下任意一种开始，则需要分号：

- 一个左括号 `(`。没有分号，这两行一起被视为 `CallExpression`。
- 一个方括号 `[`。没有分号，这两行一起被视为属性访问，而不是 `ArrayLiteral` 或 `ArrayAssignmentPattern`。
- 一个模板字面量 `` ` ``。没有分号，这两行一起被解释为一个标记的模板（见 13.3.11），前一个表达式作为 `MemberExpression`。
- 一元 `+` 或 `-`。没有分号，这两行一起被解释为相应的二元运算符的使用。
- 一个正则表达式字面量。没有分号，这两行一起可能被解析为 `/` 乘法运算符，例如如果正则表达式有标志。

#### 12.10.3.2 自动分号插入和“[no LineTerminator here]”的情况

本节为非规范性内容。

ECMAScript 包含语法生成式，其中包括“[no LineTerminator here]”。这些生成式有时是语法中有可选操作数的一种方式。在这些位置引入行终止符将通过使用没有可选操作数的语法生成式来改变源文本的语法生成式。

本节的其余部分描述了此版本 ECMAScript 中使用“[no LineTerminator here]”的一些生成式。

#### 12.10.3.2.1 带有可选操作数和“[no LineTerminator here]”的语法生成式列表

- UpdateExpression
- ContinueStatement
- BreakStatement
- ReturnStatement
- YieldExpression
- Async Function Definitions (15.8) 与 Function Definitions (15.2) 的关系

### 13 ECMAScript 语言：表达式

#### 13.1 标识符

#### 语法
```
IdentifierReference[Yield, Await] :
    Identifier
    [~Yield] yield
    [~Await] await

BindingIdentifier[Yield, Await] :
    Identifier
    yield
    await

LabelIdentifier[Yield, Await] :
    Identifier
    [~Yield] yield
    [~Await] await

Identifier :
    IdentifierName but not ReservedWord
```

**注意**：`yield` 和 `await` 作为语法中的 `BindingIdentifier` 是允许的，并在以下静态语义中被禁止，以防止在以下情况下自动分号插入：

```javascript
let
await 0;
```

#### 13.1.1 静态语义：早期错误
```
BindingIdentifier : Identifier
```
如果 `IsStrict(this production)` 为真并且 `Identifier` 的 `StringValue` 为 "arguments" 或 "eval"，则这是一个语法错误。

```
IdentifierReference : yield
BindingIdentifier : yield
LabelIdentifier : yield
```
如果 `IsStrict(this production)` 为真，则这是一个语法错误。

```
IdentifierReference : await
BindingIdentifier : await
LabelIdentifier : await
```
如果语法的目标符号是 `Module`，则这是一个语法错误。

```
BindingIdentifier[Yield, Await] : yield
```
如果此生成式具有 `[Yield]` 参数，则这是一个语法错误。

```
BindingIdentifier[Yield, Await] : await
```
如果此生成式具有 `[Await]` 参数，则这是一个语法错误。

```
IdentifierReference[Yield, Await] : Identifier
BindingIdentifier[Yield, Await] : Identifier
LabelIdentifier[Yield, Await] : Identifier
```
如果此生成式具有 `[Yield]` 参数并且 `Identifier` 的 `StringValue` 为 "yield"，则这是一个语法错误。
如果此生成式具有 `[Await]` 参数并且 `Identifier` 的 `StringValue` 为 "await"，则这是一个语法错误。

```
Identifier : IdentifierName but not ReservedWord
```
如果 `IsStrict(this phrase)` 为真并且 `IdentifierName` 的 `StringValue` 是 "implements"、"interface"、"let"、"package"、"private"、"protected"、"public"、"static" 或 "yield" 之一，则这是一个语法错误。
如果语法的目标符号是 `Module` 并且 `IdentifierName` 的 `StringValue` 是 "await"，则这是一个语法错误。
如果 `IdentifierName` 的 `StringValue` 是任何 `ReservedWord` 的 `StringValue`（除了 `yield` 或 `await`），则这是一个语法错误。

**注意**：`IdentifierName` 的 `StringValue` 会将 `IdentifierName` 中的任何 Unicode 转义序列规范化，因此不能使用这些转义序列来编写代码点序列与 `ReservedWord` 相同的标识符。

#### 13.1.2 静态语义：StringValue
语法导向操作 `StringValue` 不接受参数并返回一个字符串。它按以下生成式逐段定义：

```
IdentifierName ::
    IdentifierStart
    IdentifierName IdentifierPart
```
1. 设 `idTextUnescaped` 为 `IdentifierName` 的 `IdentifierCodePoints`。
2. 返回 `CodePointsToString(idTextUnescaped)`。

```
IdentifierReference : yield
BindingIdentifier : yield
LabelIdentifier : yield
```
1. 返回 `"yield"`。

```
IdentifierReference : await
BindingIdentifier : await
LabelIdentifier : await
```
1. 返回 `"await"`。

```
Identifier : IdentifierName but not ReservedWord
```
1. 返回 `IdentifierName` 的 `StringValue`。

```
PrivateIdentifier ::
    # IdentifierName
```
1. 返回 `0x0023`（NUMBER SIGN）和 `IdentifierName` 的 `StringValue` 的字符串连接。

```
ModuleExportName : StringLiteral
```
1. 返回 `StringLiteral` 的 `SV`。

#### 13.1.3 运行时语义：求值
```
IdentifierReference : Identifier
```
1. 返回 `? ResolveBinding(StringValue of Identifier)`。

```
IdentifierReference : yield
```
1. 返回 `? ResolveBinding("yield")`。

```
IdentifierReference : await
```
1. 返回 `? ResolveBinding("await")`。

**注1**：求值 `IdentifierReference` 的结果总是类型 `Reference` 的值。

**注2**：在非严格代码中，关键字 `yield` 可以作为标识符使用。求值 `IdentifierReference` 时将解析 `yield` 的绑定，仿佛它是一个标识符。早期错误限制确保这种求值只能发生在非严格代码中。

### 13 ECMAScript 语言：表达式

#### 13.2 基本表达式

##### 语法
```
PrimaryExpression[Yield, Await] :
    this
    IdentifierReference[?Yield, ?Await]
    Literal
    ArrayLiteral[?Yield, ?Await]
    ObjectLiteral[?Yield, ?Await]
    FunctionExpression
    ClassExpression[?Yield, ?Await]
    GeneratorExpression
    AsyncFunctionExpression
    AsyncGeneratorExpression
    RegularExpressionLiteral
    TemplateLiteral[?Yield, ?Await, ~Tagged]
    CoverParenthesizedExpressionAndArrowParameterList[?Yield, ?Await]

CoverParenthesizedExpressionAndArrowParameterList[Yield, Await] :
    ( Expression[+In, ?Yield, ?Await] )
    ( Expression[+In, ?Yield, ?Await] , )
    ( )
    ( ... BindingIdentifier[?Yield, ?Await] )
    ( ... BindingPattern[?Yield, ?Await] )
    ( Expression[+In, ?Yield, ?Await] , ... BindingIdentifier[?Yield, ?Await] )
    ( Expression[+In, ?Yield, ?Await] , ... BindingPattern[?Yield, ?Await] )
```

##### 补充语法
当处理生成式 `PrimaryExpression[Yield, Await] : CoverParenthesizedExpressionAndArrowParameterList[?Yield, ?Await]` 的实例时，使用以下语法细化对 `CoverParenthesizedExpressionAndArrowParameterList` 的解释：

```
ParenthesizedExpression[Yield, Await] :
    ( Expression[+In, ?Yield, ?Await] )
```

#### 13.2.1 `this` 关键字

##### 13.2.1.1 运行时语义：求值
```
PrimaryExpression : this
    1. 返回 `? ResolveThisBinding()`。
```

#### 13.2.2 标识符引用
详见 13.1 中的 `IdentifierReference`。

#### 13.2.3 字面量

##### 语法
```
Literal :
    NullLiteral
    BooleanLiteral
    NumericLiteral
    StringLiteral
```

##### 13.2.3.1 运行时语义：求值
```
Literal : NullLiteral
    1. 返回 `null`。

Literal : BooleanLiteral
    1. 如果 `BooleanLiteral` 是 `false` 令牌，返回 `false`。
    2. 如果 `BooleanLiteral` 是 `true` 令牌，返回 `true`。

Literal : NumericLiteral
    1. 返回 `NumericLiteral` 的 `NumericValue`，详见 12.9.3。

Literal : StringLiteral
    1. 返回 `StringLiteral` 的 `SV`，详见 12.9.4.2。
```

#### 13.2.4 数组初始化器

**注意**：`ArrayLiteral` 是描述数组初始化的表达式，使用零个或多个表示数组元素的表达式列表，括在方括号内。元素不一定是字面量；每次评估数组初始化器时，这些元素都会被求值。

数组元素可以在元素列表的开头、中间或末尾被省略。每当元素列表中的逗号前没有 `AssignmentExpression`（即开头或另一个逗号后面的逗号）时，缺失的数组元素会增加数组的长度并增加后续元素的索引。省略的数组元素未定义。如果数组末尾有省略的元素，则该元素不会贡献数组的长度。

##### 语法
```
ArrayLiteral[Yield, Await] :
    [ Elisionopt ]
    [ ElementList[?Yield, ?Await] ]
    [ ElementList[?Yield, ?Await] , Elisionopt ]

ElementList[Yield, Await] :
    Elisionopt AssignmentExpression[+In, ?Yield, ?Await]
    Elisionopt SpreadElement[?Yield, ?Await]
    ElementList[?Yield, ?Await] , Elisionopt AssignmentExpression[+In, ?Yield, ?Await]
    ElementList[?Yield, ?Await] , Elisionopt SpreadElement[?Yield, ?Await]

Elision :
    ,
    Elision ,

SpreadElement[Yield, Await] :
    ... AssignmentExpression[+In, ?Yield, ?Await]
```

##### 13.2.4.1 运行时语义：数组积累
语法导向操作 `ArrayAccumulation` 接受参数 `array`（一个数组）和 `nextIndex`（一个整数），并返回一个包含整数的正常完成或中断完成。它在以下生成式上逐段定义：

```
Elision : ,
    1. 设 `len` 为 `nextIndex + 1`。
    2. 执行 `? Set(array, "length", 𝔽(len), true)`。
    3. 注意：如果 `len` 超过 `2**32 - 1`，上述步骤会抛出异常。
    4. 返回 `len`。

Elision : Elision ,
    1. 返回 `? ArrayAccumulation`，参数为 `Elision` 和 `nextIndex + 1`。

ElementList : Elisionopt AssignmentExpression
    1. 如果存在 `Elision`，则
        a. 使用参数 `array` 和 `nextIndex` 执行 `? ArrayAccumulation`，设置 `nextIndex`。
    2. 令 `initResult` 为 `AssignmentExpression` 的 `? Evaluation`。
    3. 令 `initValue` 为 `? GetValue(initResult)`。
    4. 执行 `! CreateDataPropertyOrThrow(array, ! ToString(𝔽(nextIndex)), initValue)`。
    5. 返回 `nextIndex + 1`。

ElementList : Elisionopt SpreadElement
    1. 如果存在 `Elision`，则
        a. 使用参数 `array` 和 `nextIndex` 执行 `? ArrayAccumulation`，设置 `nextIndex`。
    2. 返回 `? ArrayAccumulation`，参数为 `SpreadElement`、`array` 和 `nextIndex`。

ElementList : ElementList , Elisionopt AssignmentExpression
    1. 使用参数 `array` 和 `nextIndex` 执行 `? ArrayAccumulation`，设置 `nextIndex`。
    2. 如果存在 `Elision`，则
        a. 使用参数 `array` 和 `nextIndex` 执行 `? ArrayAccumulation`，设置 `nextIndex`。
    3. 令 `initResult` 为 `AssignmentExpression` 的 `? Evaluation`。
    4. 令 `initValue` 为 `? GetValue(initResult)`。
    5. 执行 `! CreateDataPropertyOrThrow(array, ! ToString(𝔽(nextIndex)), initValue)`。
    6. 返回 `nextIndex + 1`。

ElementList : ElementList , Elisionopt SpreadElement
    1. 使用参数 `array` 和 `nextIndex` 执行 `? ArrayAccumulation`，设置 `nextIndex`。
    2. 如果存在 `Elision`，则
        a. 使用参数 `array` 和 `nextIndex` 执行 `? ArrayAccumulation`，设置 `nextIndex`。
    3. 返回 `? ArrayAccumulation`，参数为 `SpreadElement`、`array` 和 `nextIndex`。

SpreadElement : ... AssignmentExpression
    1. 令 `spreadRef` 为 `AssignmentExpression` 的 `? Evaluation`。
    2. 令 `spreadObj` 为 `? GetValue(spreadRef)`。
    3. 令 `iteratorRecord` 为 `? GetIterator(spreadObj, SYNC)`。
    4. 重复，
        a. 令 `next` 为 `? IteratorStepValue(iteratorRecord)`。
        b. 如果 `next` 是 `DONE`，返回 `nextIndex`。
        c. 执行 `! CreateDataPropertyOrThrow(array, ! ToString(𝔽(nextIndex)), next)`。
        d. 将 `nextIndex` 设置为 `nextIndex + 1`。
```
**注意**：使用 `CreateDataPropertyOrThrow` 来确保为数组定义自身属性，即使标准内置的数组原型对象已被修改，从而妨碍使用 `[[Set]]` 创建新自身属性。

##### 13.2.4.2 运行时语义：求值
```
ArrayLiteral : [ Elisionopt ]
    1. 令 `array` 为 `! ArrayCreate(0)`。
    2. 如果存在 `Elision`，则
        a. 使用参数 `array` 和 `0` 执行 `? ArrayAccumulation`。
    3. 返回 `array`。

ArrayLiteral : [ ElementList ]
    1. 令 `array` 为 `! ArrayCreate(0)`。
    2. 使用参数 `array` 和 `0` 执行 `? ArrayAccumulation`。
    3. 返回 `array`。

ArrayLiteral : [ ElementList , Elisionopt ]
    1. 令 `array` 为 `! ArrayCreate(0)`。
    2. 使用参数 `array` 和 `0` 执行 `? ArrayAccumulation`，设置 `nextIndex`。
    3. 如果

存在 `Elision`，则
        a. 使用参数 `array` 和 `nextIndex` 执行 `? ArrayAccumulation`。
    4. 返回 `array`。
```

### 13.2.5 对象初始化器

#### 注意 1
对象初始化器是一种描述对象初始化的表达式，形式类似于字面量。它是一个由零个或多个属性键和值对组成的列表，用花括号括起来。值不一定是字面量；每次评估对象初始化器时，这些值都会被求值。

#### 语法
```
ObjectLiteral[Yield, Await] :
    { }
    { PropertyDefinitionList[?Yield, ?Await] }
    { PropertyDefinitionList[?Yield, ?Await] , }

PropertyDefinitionList[Yield, Await] :
    PropertyDefinition[?Yield, ?Await]
    PropertyDefinitionList[?Yield, ?Await] , PropertyDefinition[?Yield, ?Await]

PropertyDefinition[Yield, Await] :
    IdentifierReference[?Yield, ?Await]
    CoverInitializedName[?Yield, ?Await]
    PropertyName[?Yield, ?Await] : AssignmentExpression[+In, ?Yield, ?Await]
    MethodDefinition[?Yield, ?Await]
    ... AssignmentExpression[+In, ?Yield, ?Await]

PropertyName[Yield, Await] :
    LiteralPropertyName
    ComputedPropertyName[?Yield, ?Await]

LiteralPropertyName :
    IdentifierName
    StringLiteral
    NumericLiteral

ComputedPropertyName[Yield, Await] :
    [ AssignmentExpression[+In, ?Yield, ?Await] ]

CoverInitializedName[Yield, Await] :
    IdentifierReference[?Yield, ?Await] Initializer[+In, ?Yield, ?Await]

Initializer[In, Yield, Await] :
    = AssignmentExpression[?In, ?Yield, ?Await]
```

#### 注意 2
`MethodDefinition` 定义见 15.4。

#### 注意 3
在某些上下文中，`ObjectLiteral` 用作更受限的次级语法的覆盖语法。`CoverInitializedName` 生成式是必要的，以完全覆盖这些次级语法。然而，在正常上下文中，当预期实际对象初始化器时，使用此生成式会导致早期语法错误。

#### 13.2.5.1 静态语义：早期错误
```
PropertyDefinition : MethodDefinition
    如果 `MethodDefinition` 的 `HasDirectSuper` 为 `true`，则为语法错误。
    如果 `MethodDefinition` 的 `PrivateBoundIdentifiers` 不为空，则为语法错误。
```
除了描述实际的对象初始化器外，`ObjectLiteral` 生成式还用作 `ObjectAssignmentPattern` 的覆盖语法，并且可能作为 `CoverParenthesizedExpressionAndArrowParameterList` 的一部分被识别。当 `ObjectLiteral` 出现在需要 `ObjectAssignmentPattern` 的上下文中时，不适用以下早期错误规则。此外，当初次解析 `CoverParenthesizedExpressionAndArrowParameterList` 或 `CoverCallExpressionAndAsyncArrowHead` 时，也不适用这些规则。

```
PropertyDefinition : CoverInitializedName
    如果此生成式匹配任何源文本，则为语法错误。
```
#### 注意 1
该生成式存在是为了让 `ObjectLiteral` 可以作为 `ObjectAssignmentPattern` 的覆盖语法。它不能出现在实际的对象初始化器中。

```
ObjectLiteral :
    { PropertyDefinitionList }
    { PropertyDefinitionList , }
    如果 `PropertyDefinitionList` 的 `PropertyNameList` 包含任何 "__proto__" 的重复条目，并且至少两个条目来自形式 `PropertyDefinition : PropertyName : AssignmentExpression` 的生成式，则为语法错误。如果此 `ObjectLiteral` 包含在为 `JSON.parse` 解析的脚本中，则不适用此规则（参见 `JSON.parse` 的步骤 4）。
```
#### 注意 2
`PropertyNameList` 返回的列表不包括使用 `ComputedPropertyName` 定义的属性名称。

#### 13.2.5.2 静态语义：是否计算属性键
语法导向操作 `IsComputedPropertyKey` 不接受参数，返回一个布尔值。它在以下生成式上逐段定义：

```
PropertyName : LiteralPropertyName
    1. 返回 `false`。

PropertyName : ComputedPropertyName
    1. 返回 `true`。
```

#### 13.2.5.3 静态语义：属性名称列表
语法导向操作 `PropertyNameList` 不接受参数，返回一个字符串列表。它在以下生成式上逐段定义：

```
PropertyDefinitionList : PropertyDefinition
    1. 令 `propName` 为 `PropertyDefinition` 的 `PropName`。
    2. 如果 `propName` 为空，返回一个新的空列表。
    3. 返回 « propName »。

PropertyDefinitionList : PropertyDefinitionList , PropertyDefinition
    1. 令 `list` 为 `PropertyDefinitionList` 的 `PropertyNameList`。
    2. 令 `propName` 为 `PropertyDefinition` 的 `PropName`。
    3. 如果 `propName` 为空，返回 `list`。
    4. 返回 `list` 和 « propName » 的列表连接。
```

#### 13.2.5.4 运行时语义：求值
```
ObjectLiteral : { }
    1. 返回 `OrdinaryObjectCreate(%Object.prototype%)`。

ObjectLiteral :
    { PropertyDefinitionList }
    { PropertyDefinitionList , }
    1. 令 `obj` 为 `OrdinaryObjectCreate(%Object.prototype%)`。
    2. 使用参数 `obj` 执行 `PropertyDefinitionList` 的 `PropertyDefinitionEvaluation`。
    3. 返回 `obj`。
```

```
LiteralPropertyName : IdentifierName
    1. 返回 `IdentifierName` 的 `StringValue`。

LiteralPropertyName : StringLiteral
    1. 返回 `StringLiteral` 的 `SV`。

LiteralPropertyName : NumericLiteral
    1. 令 `nbr` 为 `NumericLiteral` 的 `NumericValue`。
    2. 返回 `! ToString(nbr)`。

ComputedPropertyName : [ AssignmentExpression ]
    1. 令 `exprValue` 为 `AssignmentExpression` 的 `Evaluation`。
    2. 令 `propName` 为 `GetValue(exprValue)`。
    3. 返回 `ToPropertyKey(propName)`。
```

#### 13.2.5.5 运行时语义：属性定义求值
语法导向操作 `PropertyDefinitionEvaluation` 接受参数 `object`（一个对象），返回一个包含未使用值的正常完成或中断完成。它在以下生成式上逐段定义：

```
PropertyDefinitionList : PropertyDefinitionList , PropertyDefinition
    1. 使用参数 `object` 执行 `PropertyDefinitionList` 的 `PropertyDefinitionEvaluation`。
    2. 使用参数 `object` 执行 `PropertyDefinition` 的 `PropertyDefinitionEvaluation`。
    3. 返回未使用值。
```

```
PropertyDefinition : ... AssignmentExpression
    1. 令 `exprValue` 为 `AssignmentExpression` 的 `Evaluation`。
    2. 令 `fromValue` 为 `GetValue(exprValue)`。
    3. 令 `excludedNames` 为一个新的空列表。
    4. 执行 `CopyDataProperties(object, fromValue, excludedNames)`。
    5. 返回未使用值。
```

```
PropertyDefinition : IdentifierReference
    1. 令 `propName` 为 `IdentifierReference` 的 `StringValue`。
    2. 令 `exprValue` 为 `IdentifierReference` 的 `Evaluation`。
    3. 令 `propValue` 为 `GetValue(exprValue)`。
    4. 断言：`object` 是一个普通的、可扩展的对象，没有不可配置的属性。
    5. 执行 `CreateDataPropertyOrThrow(object, propName, propValue)`。
    6. 返回未使用值。
```

```
PropertyDefinition : PropertyName : AssignmentExpression
    1. 令 `propKey` 为 `PropertyName` 的 `Evaluation`。
    2. 如果此 `PropertyDefinition` 包含在为 `JSON.parse` 解析的脚本中（参见 `JSON.parse` 的步骤 7），则
        a. 令 `isProtoSetter` 为 `false`。
    3. 否则，如果 `propKey` 是 "__proto__" 且 `PropertyName` 的 `IsComputedPropertyKey` 为 `false`，则
        a. 令 `isProtoSetter` 为 `true`。
    4. 否则，
        a. 令 `isProtoSetter` 为 `false`。
    5. 如果 `AssignmentExpression` 的 `IsAnonymousFunctionDefinition` 为 `true` 且 `isProtoSetter` 为 `false`，则
        a. 令 `propValue` 为 `AssignmentExpression` 的 `NamedEvaluation`，参数为 `propKey`。
    6. 否则，
        a. 令 `exprValueRef` 为 `AssignmentExpression` 的 `Evaluation`。
        b. 令 `propValue` 为 `GetValue(exprValueRef)`。
    7. 如果 `isProtoSetter` 为 `true`，则
        a. 如果 `propValue` 是一个对象或 `propValue` 为 `null`，则
            i

. 执行 `object.[[SetPrototypeOf]](propValue)`。
        b. 返回未使用值。
    8. 断言：`object` 是一个普通的、可扩展的对象，没有不可配置的属性。
    9. 执行 `CreateDataPropertyOrThrow(object, propKey, propValue)`。
    10. 返回未使用值。
```

```
PropertyDefinition : MethodDefinition
    1. 使用参数 `object` 和 `true` 执行 `MethodDefinition` 的 `MethodDefinitionEvaluation`。
    2. 返回未使用值。
```

### 13.2.6 函数定义表达式

参见 15.2 中 `PrimaryExpression : FunctionExpression`。

参见 15.5 中 `PrimaryExpression : GeneratorExpression`。

参见 15.7 中 `PrimaryExpression : ClassExpression`。

参见 15.8 中 `PrimaryExpression : AsyncFunctionExpression`。

参见 15.6 中 `PrimaryExpression : AsyncGeneratorExpression`。

### 13.2.7 正则表达式字面量

#### 语法
参见 12.9.5。

#### 13.2.7.1 静态语义：早期错误

`PrimaryExpression : RegularExpressionLiteral`

如果 `IsValidRegularExpressionLiteral(RegularExpressionLiteral)` 为 `false`，则为语法错误。

#### 13.2.7.2 静态语义：IsValidRegularExpressionLiteral（literal）

抽象操作 `IsValidRegularExpressionLiteral` 接受参数 `literal`（一个 `RegularExpressionLiteral` 解析节点）并返回一个布尔值。它确定其参数是否为有效的正则表达式字面量。调用时执行以下步骤：

1. 令 `flags` 为 `literal` 的 `FlagText`。
2. 如果 `flags` 包含除 `d`, `g`, `i`, `m`, `s`, `u`, `v`, 或 `y` 之外的任何代码点，或如果 `flags` 中的任何代码点出现多次，返回 `false`。
3. 如果 `flags` 包含 `u`，令 `u` 为 `true`；否则令 `u` 为 `false`。
4. 如果 `flags` 包含 `v`，令 `v` 为 `true`；否则令 `v` 为 `false`。
5. 令 `patternText` 为 `literal` 的 `BodyText`。
6. 如果 `u` 为 `false` 且 `v` 为 `false`，则
   a. 令 `stringValue` 为 `patternText` 的 `CodePointsToString`。
   b. 将 `patternText` 设置为通过将 `stringValue` 的每个 16 位元素解释为一个 Unicode BMP 代码点而得出的代码点序列。不对这些元素应用 UTF-16 解码。
7. 令 `parseResult` 为 `ParsePattern(patternText, u, v)`。
8. 如果 `parseResult` 是一个解析节点，返回 `true`；否则返回 `false`。

#### 13.2.7.3 运行时语义：求值

`PrimaryExpression : RegularExpressionLiteral`

1. 令 `pattern` 为 `RegularExpressionLiteral` 的 `BodyText` 的 `CodePointsToString`。
2. 令 `flags` 为 `RegularExpressionLiteral` 的 `FlagText` 的 `CodePointsToString`。
3. 返回 `! RegExpCreate(pattern, flags)`。

### 13.2.8 模板字面量

#### 语法
```javascript
TemplateLiteral[Yield, Await, Tagged] :
  NoSubstitutionTemplate
  SubstitutionTemplate[?Yield, ?Await, ?Tagged]

SubstitutionTemplate[Yield, Await, Tagged] :
  TemplateHead Expression[+In, ?Yield, ?Await] TemplateSpans[?Yield, ?Await, ?Tagged]

TemplateSpans[Yield, Await, Tagged] :
  TemplateTail
  TemplateMiddleList[?Yield, ?Await, ?Tagged] TemplateTail

TemplateMiddleList[Yield, Await, Tagged] :
  TemplateMiddle Expression[+In, ?Yield, ?Await]
  TemplateMiddleList[?Yield, ?Await, ?Tagged] TemplateMiddle Expression[+In, ?Yield, ?Await]
```

#### 13.2.8.1 静态语义：早期错误

```javascript
TemplateLiteral[Yield, Await, Tagged] : NoSubstitutionTemplate
  如果没有设置 [Tagged] 参数且 NoSubstitutionTemplate 包含 NotEscapeSequence，则为语法错误。

TemplateLiteral[Yield, Await, Tagged] : SubstitutionTemplate[?Yield, ?Await, ?Tagged]
  如果带有 false 参数的 TemplateLiteral 的 TemplateStrings 元素数量大于等于 2**32，则为语法错误。

SubstitutionTemplate[Yield, Await, Tagged] : TemplateHead Expression[+In, ?Yield, ?Await] TemplateSpans[?Yield, ?Await, ?Tagged]
  如果没有设置 [Tagged] 参数且 TemplateHead 包含 NotEscapeSequence，则为语法错误。

TemplateSpans[Yield, Await, Tagged] : TemplateTail
  如果没有设置 [Tagged] 参数且 TemplateTail 包含 NotEscapeSequence，则为语法错误。

TemplateMiddleList[Yield, Await, Tagged] :
  TemplateMiddle Expression[+In, ?Yield, ?Await]
  TemplateMiddleList[?Yield, ?Await, ?Tagged] TemplateMiddle Expression[+In, ?Yield, ?Await]
  如果没有设置 [Tagged] 参数且 TemplateMiddle 包含 NotEscapeSequence，则为语法错误。
```

#### 13.2.8.2 静态语义：模板字符串

语法导向操作 TemplateStrings 接受参数 raw（一个布尔值）并返回一个字符串或 undefined 的列表。它根据以下生成式定义：

```javascript
TemplateLiteral : NoSubstitutionTemplate
  1. 返回 « TemplateString(NoSubstitutionTemplate, raw) »。

SubstitutionTemplate : TemplateHead Expression TemplateSpans
  1. 令 head 为 « TemplateString(TemplateHead, raw) »。
  2. 令 tail 为带有 raw 参数的 TemplateSpans 的 TemplateStrings。
  3. 返回 head 和 tail 的列表连接。

TemplateSpans : TemplateTail
  1. 返回 « TemplateString(TemplateTail, raw) »。

TemplateSpans : TemplateMiddleList TemplateTail
  1. 令 middle 为带有 raw 参数的 TemplateMiddleList 的 TemplateStrings。
  2. 令 tail 为 « TemplateString(TemplateTail, raw) »。
  3. 返回 middle 和 tail 的列表连接。

TemplateMiddleList : TemplateMiddle Expression
  1. 返回 « TemplateString(TemplateMiddle, raw) »。

TemplateMiddleList : TemplateMiddleList TemplateMiddle Expression
  1. 令 front 为带有 raw 参数的 TemplateMiddleList 的 TemplateStrings。
  2. 令 last 为 « TemplateString(TemplateMiddle, raw) »。
  3. 返回 front 和 last 的列表连接。
```

#### 13.2.8.3 静态语义：TemplateString（templateToken，raw）

抽象操作 TemplateString 接受参数 templateToken（一个 NoSubstitutionTemplate 解析节点，一个 TemplateHead 解析节点，一个 TemplateMiddle 解析节点，或一个 TemplateTail 解析节点）和 raw（一个布尔值）并返回一个字符串或 undefined。当调用时，执行以下步骤：

1. 如果 raw 为 true，则
   a. 令 string 为 templateToken 的 TRV。
2. 否则，
   a. 令 string 为 templateToken 的 TV。
3. 返回 string。

**注意**：如果 raw 为 false 且 templateToken 包含 NotEscapeSequence，则此操作返回 undefined。在所有其他情况下，它返回一个字符串。

#### 13.2.8.4 获取模板对象（templateLiteral）

抽象操作 GetTemplateObject 接受参数 templateLiteral（一个解析节点）并返回一个数组。当调用时，执行以下步骤：

1. 令 realm 为当前的 Realm 记录。
2. 令 templateRegistry 为 realm.[[TemplateMap]]。
3. 对于 templateRegistry 中的每个元素 e，执行
   a. 如果 e.[[Site]] 与 templateLiteral 是相同的解析节点，则
     i. 返回 e.[[Array]]。
4. 令 rawStrings 为带有 true 参数的 templateLiteral 的 TemplateStrings。
5. 断言：rawStrings 是一个字符串列表。
6. 令 cookedStrings 为带有 false 参数的 templateLiteral 的 TemplateStrings。
7. 令 count 为 cookedStrings 列表中的元素数量。
8. 断言：count ≤ 2**32 - 1。
9. 令 template 为 ! ArrayCreate(count)。
10. 令 rawObj 为 ! ArrayCreate(count)。
11. 令 index 为 0。
12. 重复，直到 index < count，
    a. 令 prop 为 ! ToString(𝔽(index))。
    b. 令 cookedValue 为 cookedStrings[index]。
    c. 执行 ! DefinePropertyOrThrow(template, prop, PropertyDescriptor { [[Value]]: cookedValue, [[Writable]]: false, [[Enumerable]]: true, [[Configurable]]: false })。
    d. 令 rawValue 为 rawStrings[index] 的字符串值。
    e. 执行 ! DefinePropertyOrThrow(rawObj, prop, PropertyDescriptor { [[Value]]: rawValue, [[Writable]]: false, [[Enumerable]]: true, [[Configurable]]: false })。
    f. 将 index 设置为 index + 1。
13. 执行 ! SetIntegrityLevel(rawObj, FROZEN)。
14. 执行 ! DefinePropertyOrThrow(template, "raw", PropertyDescriptor { [[Value]]: rawObj, [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false })。
15. 执行 ! SetIntegrityLevel(template, FROZEN)。
16. 将记录 { [[Site]]: templateLiteral, [[Array]]: template } 添加到 realm.[[TemplateMap]] 中。
17. 返回 template。

**注意 1**：创建模板对象不能导致意外完成。

**注意 2**：领域的程序代码中的每个 TemplateLiteral 都与一个唯一的模板对象相关联，该模板对象在标记模板的求值中使用（13.2.8.6）。模板对象是冻结的，并且每次求值特定标记模板时使用相同的模板对象。模板对象是首次求值 TemplateLiteral 时懒创建的还是首次求值前急创建的是实现选择，这对于 ECMAScript 代码来说是不可观察的。

**注意 3**：本规范的未来版本可能会定义模板对象的其他不可枚举属性。

#### 13.2.8.5 运行时语义：替换求值

语法导向操作 SubstitutionEvaluation 不接受参数并返回一个包含 ECMAScript 语言值的列表或意外完成。它根据以下生成式定义：

```javascript
TemplateSpans : TemplateTail
  1. 返回一个新的空列表。

TemplateSpans : TemplateMiddleList TemplateTail
  1. 返回带有 TemplateMiddleList 的 SubstitutionEvaluation。

TemplateMiddleList : TemplateMiddle Expression
  1. 令 subRef 为 ? Evaluation of Expression。
  2. 令 sub 为 ? GetValue(subRef)。
  3. 返回 « sub »。

TemplateMiddleList : TemplateMiddleList TemplateMiddle Expression
  1. 令 preceding 为带有 TemplateMiddleList 的 SubstitutionEvaluation。
  2. 令 nextRef 为 ? Evaluation of Expression。
  3. 令 next 为 ? GetValue(nextRef)。
  4. 返回 preceding 和 « next » 的列表连接。
```

#### 13.2.8.6 运行时语义：求值

```javascript
TemplateLiteral : NoSubstitutionTemplate
  1. 返回 NoSubstitutionTemplate 的 TV，如 12.9.6 中所定义。

SubstitutionTemplate : TemplateHead Expression TemplateSpans
  1. 令 head 为 TemplateHead 的 TV，如 12.9.6 中所定义。
  2. 令 subRef 为 ? Evaluation of Expression。
  3. 令 sub 为 ? GetValue(subRef)。
  4. 令 middle 为 ? ToString(sub)。
  5. 令 tail 为 ? Evaluation of TemplateSpans。
  6. 返回 head、middle 和 tail 的字符串连接。
  
**注意 1**：对 Expression 值应用的字符串转换语义类似于 `String.prototype.concat`，而不是 `+` 运算符。

TemplateSpans : TemplateTail
  1. 返回 TemplateTail 的 TV，如 12.9.6 中所定义。

TemplateSpans : TemplateMiddleList TemplateTail
  1. 令 head 为带有 TemplateMiddleList 的 Evaluation。
  2. 令 tail 为 Template

Tail 的 TV，如 12.9.6 中所定义。
  3. 返回 head 和 tail 的字符串连接。

TemplateMiddleList : TemplateMiddle Expression
  1. 令 head 为 TemplateMiddle 的 TV，如 12.9.6 中所定义。
  2. 令 subRef 为 ? Evaluation of Expression。
  3. 令 sub 为 ? GetValue(subRef)。
  4. 令 middle 为 ? ToString(sub)。
  5. 返回 head 和 middle 的字符串连接。

**注意 2**：对 Expression 值应用的字符串转换语义类似于 `String.prototype.concat`，而不是 `+` 运算符。

TemplateMiddleList : TemplateMiddleList TemplateMiddle Expression
  1. 令 rest 为带有 TemplateMiddleList 的 Evaluation。
  2. 令 middle 为 TemplateMiddle 的 TV，如 12.9.6 中所定义。
  3. 令 subRef 为 ? Evaluation of Expression。
  4. 令 sub 为 ? GetValue(subRef)。
  5. 令 last 为 ? ToString(sub)。
  6. 返回 rest、middle 和 last 的字符串连接。

**注意 3**：对 Expression 值应用的字符串转换语义类似于 `String.prototype.concat`，而不是 `+` 运算符。
```

### 13.2.9 分组操作符

#### 13.2.9.1 静态语义：早期错误
```javascript
PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList
CoverParenthesizedExpressionAndArrowParameterList 必须覆盖一个 ParenthesizedExpression。
```

#### 13.2.9.2 运行时语义：求值
```javascript
PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList
1. 令 expr 为 CoverParenthesizedExpressionAndArrowParameterList 所覆盖的 ParenthesizedExpression。
2. 返回 expr 的 ? Evaluation。
```
```javascript
ParenthesizedExpression : ( Expression )
1. 返回 Expression 的 ? Evaluation。这个结果可能是 Reference 类型。
```
**注意**：这个算法不会对 Expression 的 Evaluation 结果应用 GetValue。这样设计的主要动机是为了使诸如 delete 和 typeof 等操作符可以应用于带括号的表达式。

### 13.3 左侧表达式

#### 语法
```javascript
MemberExpression[Yield, Await] :
  PrimaryExpression[?Yield, ?Await]
  MemberExpression[?Yield, ?Await] [ Expression[+In, ?Yield, ?Await] ]
  MemberExpression[?Yield, ?Await] . IdentifierName
  MemberExpression[?Yield, ?Await] TemplateLiteral[?Yield, ?Await, +Tagged]
  SuperProperty[?Yield, ?Await]
  MetaProperty
  new MemberExpression[?Yield, ?Await] Arguments[?Yield, ?Await]
  MemberExpression[?Yield, ?Await] . PrivateIdentifier

SuperProperty[Yield, Await] :
  super [ Expression[+In, ?Yield, ?Await] ]
  super . IdentifierName

MetaProperty :
  NewTarget
  ImportMeta

NewTarget :
  new . target

ImportMeta :
  import . meta

NewExpression[Yield, Await] :
  MemberExpression[?Yield, ?Await]
  new NewExpression[?Yield, ?Await]

CallExpression[Yield, Await] :
  CoverCallExpressionAndAsyncArrowHead[?Yield, ?Await]
  SuperCall[?Yield, ?Await]
  ImportCall[?Yield, ?Await]
  CallExpression[?Yield, ?Await] Arguments[?Yield, ?Await]
  CallExpression[?Yield, ?Await] [ Expression[+In, ?Yield, ?Await] ]
  CallExpression[?Yield, ?Await] . IdentifierName
  CallExpression[?Yield, ?Await] TemplateLiteral[?Yield, ?Await, +Tagged]
  CallExpression[?Yield, ?Await] . PrivateIdentifier

SuperCall[Yield, Await] :
  super Arguments[?Yield, ?Await]

ImportCall[Yield, Await] :
  import ( AssignmentExpression[+In, ?Yield, ?Await] )

Arguments[Yield, Await] :
  ( )
  ( ArgumentList[?Yield, ?Await] )
  ( ArgumentList[?Yield, ?Await] , )

ArgumentList[Yield, Await] :
  AssignmentExpression[+In, ?Yield, ?Await]
  ... AssignmentExpression[+In, ?Yield, ?Await]
  ArgumentList[?Yield, ?Await] , AssignmentExpression[+In, ?Yield, ?Await]
  ArgumentList[?Yield, ?Await] , ... AssignmentExpression[+In, ?Yield, ?Await]

OptionalExpression[Yield, Await] :
  MemberExpression[?Yield, ?Await] OptionalChain[?Yield, ?Await]
  CallExpression[?Yield, ?Await] OptionalChain[?Yield, ?Await]
  OptionalExpression[?Yield, ?Await] OptionalChain[?Yield, ?Await]

OptionalChain[Yield, Await] :
  ?. Arguments[?Yield, ?Await]
  ?. [ Expression[+In, ?Yield, ?Await] ]
  ?. IdentifierName
  ?. TemplateLiteral[?Yield, ?Await, +Tagged]
  ?. PrivateIdentifier
  OptionalChain[?Yield, ?Await] Arguments[?Yield, ?Await]
  OptionalChain[?Yield, ?Await] [ Expression[+In, ?Yield, ?Await] ]
  OptionalChain[?Yield, ?Await] . IdentifierName
  OptionalChain[?Yield, ?Await] TemplateLiteral[?Yield, ?Await, +Tagged]
  OptionalChain[?Yield, ?Await] . PrivateIdentifier

LeftHandSideExpression[Yield, Await] :
  NewExpression[?Yield, ?Await]
  CallExpression[?Yield, ?Await]
  OptionalExpression[?Yield, ?Await]
```

#### 补充语法
在处理生成式 CallExpression : CoverCallExpressionAndAsyncArrowHead 时，使用以下语法细化 CoverCallExpressionAndAsyncArrowHead 的解释：
```javascript
CallMemberExpression[Yield, Await] :
  MemberExpression[?Yield, ?Await] Arguments[?Yield, ?Await]
```

### 13.3.1 静态语义

#### 13.3.1.1 静态语义：早期错误
```javascript
OptionalChain :
  ?. TemplateLiteral
  OptionalChain TemplateLiteral
```
如果任何源代码文本与此生成式匹配，则这是一个语法错误。

**注意**：
该生成式存在的目的是防止自动分号插入规则（12.10）应用于如下代码：
```javascript
a?.b
`c`
```
使其被解释为两个有效的语句。其目的是保持与没有可选链的类似代码的一致性：
```javascript
a.b
`c`
```
这是一个有效的语句，且不会应用自动分号插入。

```javascript
ImportMeta :
  import . meta
```
如果语法目标符号不是 Module，则这是一个语法错误。

### 13.3.2 属性访问器

**注意**：
属性通过名称访问，使用点符号或括号符号：

```javascript
MemberExpression . IdentifierName
CallExpression . IdentifierName
```
或者括号符号：

```javascript
MemberExpression [ Expression ]
CallExpression [ Expression ]
```
点符号解释如下：

```javascript
MemberExpression . IdentifierName
```
其行为与下述形式相同：

```javascript
MemberExpression [ <identifier-name-string> ]
```
同样，

```javascript
CallExpression . IdentifierName
```
其行为与下述形式相同：

```javascript
CallExpression [ <identifier-name-string> ]
```
其中 `<identifier-name-string>` 是 IdentifierName 的 StringValue。

#### 13.3.2.1 运行时语义：求值
```javascript
MemberExpression : MemberExpression [ Expression ]
1. 令 baseReference 为 MemberExpression 的 ? Evaluation。
2. 令 baseValue 为 baseReference 的 ? GetValue。
3. 令 strict 为 IsStrict(this MemberExpression)。
4. 返回 ? EvaluatePropertyAccessWithExpressionKey(baseValue, Expression, strict)。

MemberExpression : MemberExpression . IdentifierName
1. 令 baseReference 为 MemberExpression 的 ? Evaluation。
2. 令 baseValue 为 baseReference 的 ? GetValue。
3. 令 strict 为 IsStrict(this MemberExpression)。
4. 返回 EvaluatePropertyAccessWithIdentifierKey(baseValue, IdentifierName, strict)。

MemberExpression : MemberExpression . PrivateIdentifier
1. 令 baseReference 为 MemberExpression 的 ? Evaluation。
2. 令 baseValue 为 baseReference 的 ? GetValue。
3. 令 fieldNameString 为 PrivateIdentifier 的 StringValue。
4. 返回 MakePrivateReference(baseValue, fieldNameString)。

CallExpression : CallExpression [ Expression ]
1. 令 baseReference 为 CallExpression 的 ? Evaluation。
2. 令 baseValue 为 baseReference 的 ? GetValue。
3. 令 strict 为 IsStrict(this CallExpression)。
4. 返回 ? EvaluatePropertyAccessWithExpressionKey(baseValue, Expression, strict)。

CallExpression : CallExpression . IdentifierName
1. 令 baseReference 为 CallExpression 的 ? Evaluation。
2. 令 baseValue 为 baseReference 的 ? GetValue。
3. 令 strict 为 IsStrict(this CallExpression)。
4. 返回 EvaluatePropertyAccessWithIdentifierKey(baseValue, IdentifierName, strict)。

CallExpression : CallExpression . PrivateIdentifier
1. 令 baseReference 为 CallExpression 的 ? Evaluation。
2. 令 baseValue 为 baseReference 的 ? GetValue。
3. 令 fieldNameString 为 PrivateIdentifier 的 StringValue。
4. 返回 MakePrivateReference(baseValue, fieldNameString)。
```

### 13.3.3 EvaluatePropertyAccessWithExpressionKey ( baseValue, expression, strict )

抽象操作 `EvaluatePropertyAccessWithExpressionKey` 接受参数 baseValue（一个 ECMAScript 语言值）、expression（一个 Expression 解析节点）和 strict（一个布尔值），并返回一个包含引用记录的正常完成或一个突发完成。调用时执行以下步骤：

1. 令 propertyNameReference 为 expression 的 ? Evaluation。
2. 令 propertyNameValue 为 propertyNameReference 的 ? GetValue。
3. **注意**：在大多数情况下，ToPropertyKey 将在此步骤之后立即对 propertyNameValue 执行。然而，在 a[b] = c 的情况下，它将在评估 c 之后执行。
4. 返回引用记录 { [[Base]]: baseValue, [[ReferencedName]]: propertyNameValue, [[Strict]]: strict, [[ThisValue]]: EMPTY }。

### 13.3.4 EvaluatePropertyAccessWithIdentifierKey ( baseValue, identifierName, strict )

抽象操作 `EvaluatePropertyAccessWithIdentifierKey` 接受参数 baseValue（一个 ECMAScript 语言值）、identifierName（一个 IdentifierName 解析节点）和 strict（一个布尔值），并返回一个引用记录。调用时执行以下步骤：

1. 令 propertyNameString 为 identifierName 的 StringValue。
2. 返回引用记录 { [[Base]]: baseValue, [[ReferencedName]]: propertyNameString, [[Strict]]: strict, [[ThisValue]]: EMPTY }。

### 13.3.5 new 操作符

#### 13.3.5.1 运行时语义：求值
```javascript
NewExpression : new NewExpression
1. 返回 ? EvaluateNew(NewExpression, EMPTY)。

MemberExpression : new MemberExpression Arguments
1. 返回 ? EvaluateNew(MemberExpression, Arguments)。
```

##### 13.3.5.1.1 EvaluateNew ( constructExpr, arguments )

抽象操作 `EvaluateNew` 接受参数 constructExpr（一个 NewExpression 解析节点或一个 MemberExpression 解析节点）和 arguments（EMPTY 或 Arguments 解析节点），并返回一个包含 ECMAScript 语言值的正常完成或一个突发完成。调用时执行以下步骤：

1. 令 ref 为 constructExpr 的 ? Evaluation。
2. 令 constructor 为 ref 的 ? GetValue。
3. 如果 arguments 是 EMPTY，
  a. 令 argList 为一个新的空列表。
4. 否则，
  a. 令 argList 为 arguments 的 ? ArgumentListEvaluation。
5. 如果 IsConstructor(constructor) 为 false，抛出一个 TypeError 异常。
6. 返回 ? Construct(constructor, argList)。

### 13.3.6 函数调用

#### 13.3.6.1 运行时语义：求值
```javascript
CallExpression : CoverCallExpressionAndAsyncArrowHead
1. 令 expr 为 CoverCallExpressionAndAsyncArrowHead 所覆盖的 CallMemberExpression。
2. 令 memberExpr 为 expr 的 MemberExpression。
3. 令 arguments 为 expr 的 Arguments。
4. 令 ref 为 memberExpr 的 ? Evaluation。
5. 令 func 为 ref 的 ? GetValue。
6. 如果 ref 是一个引用记录，IsPropertyReference(ref) 为 false，并且 ref.[[ReferencedName]] 是 "eval"，那么
  a. 如果 SameValue(func, %eval%) 为 true，
    i. 令 argList 为 arguments 的 ? ArgumentListEvaluation。
    ii. 如果 argList 没有元素，返回 undefined。
    iii. 令 evalArg 为 argList 的第一个元素。
    iv. 如果 IsStrict(this CallExpression) 为 true，令 strictCaller 为 true。否则令 strictCaller 为 false。
    v. 返回 ? PerformEval(evalArg, strictCaller, true)。
7. 令 thisCall 为 this CallExpression。
8. 令 tailCall 为 IsInTailPosition(thisCall)。
9. 返回 ? EvaluateCall(func, ref, arguments, tailCall)。

CallExpression : CallExpression Arguments
1. 令 ref 为 CallExpression 的 ? Evaluation。
2. 令 func 为 ref 的 ? GetValue。
3. 令 thisCall 为 this CallExpression。
4. 令 tailCall 为 IsInTailPosition(thisCall)。
5. 返回 ? EvaluateCall(func, ref, Arguments, tailCall)。
```

#### 13.3.6.2 EvaluateCall ( func, ref, arguments, tailPosition )

抽象操作 `EvaluateCall` 接受参数 func（一个 ECMAScript 语言值）、ref（一个 ECMAScript 语言值或一个引用记录）、arguments（一个解析节点）和 tailPosition（一个布尔值），并返回一个包含 ECMAScript 语言值的正常完成或一个突发完成。调用时执行以下步骤：

1. 如果 ref 是一个引用记录，
  a. 如果 IsPropertyReference(ref) 为 true，
    i. 令 thisValue 为 GetThisValue(ref)。
  b. 否则，
    i. 令 refEnv 为 ref.[[Base]]。
    ii. 断言：refEnv 是一个环境记录。
    iii. 令 thisValue 为 refEnv.WithBaseObject()。
2. 否则，
  a. 令 thisValue 为 undefined。
3. 令 argList 为 arguments 的 ? ArgumentListEvaluation。
4. 如果 func 不是对象，抛出一个 TypeError 异常。
5. 如果 IsCallable(func) 为 false，抛出一个 TypeError 异常。
6. 如果 tailPosition 为 true，执行 PrepareForTailCall()。
7. 返回 ? Call(func, thisValue, argList)。

### 13.3.7 super 关键字

#### 13.3.7.1 运行时语义：求值
```javascript
SuperProperty : super [ Expression ]
1. 令 env 为 GetThisEnvironment()。
2. 令 actualThis 为 ? env.GetThisBinding()。
3. 令 propertyNameReference 为 Expression 的 ? Evaluation。
4. 令 propertyNameValue 为 propertyNameReference 的 ? GetValue。
5. 令 strict 为 IsStrict(this SuperProperty)。
6. 注意：在大多数情况下，ToPropertyKey 将在此步骤之后立即对 propertyNameValue 执行。然而，在 super[b] = c 的情况下，它将在评估 c 之后执行。
7. 返回 ? MakeSuperPropertyReference(actualThis, propertyNameValue, strict)。

SuperProperty : super . IdentifierName
1. 令 env 为 GetThisEnvironment()。
2. 令 actualThis 为 ? env.GetThisBinding()。
3. 令 propertyKey 为 IdentifierName 的 StringValue。
4. 令 strict 为 IsStrict(this SuperProperty)。
5. 返回 ? MakeSuperPropertyReference(actualThis, propertyKey, strict)。

SuperCall : super Arguments
1. 令 newTarget 为 GetNewTarget()。
2. 断言：newTarget 是一个对象。
3. 令 func 为 GetSuperConstructor()。
4. 令 argList 为 Arguments 的 ? ArgumentListEvaluation。
5. 如果 IsConstructor(func) 为 false，抛出一个 TypeError 异常。
6. 令 result 为 ? Construct(func, argList, newTarget)。
7. 令 thisER 为 GetThisEnvironment()。
8. 执行 ? thisER.BindThisValue(result)。
9. 令 F 为 thisER.[[FunctionObject]]。
10. 断言：F 是一个 ECMAScript 函数对象。
11. 执行 ? InitializeInstanceElements(result, F)。
12. 返回 result。
```

#### 13.3.7.2 GetSuperConstructor ( )
抽象操作 `GetSuperConstructor` 不接受任何参数，返回一个 ECMAScript 语言值。调用时执行以下步骤：

1. 令 envRec 为 GetThisEnvironment()。
2. 断言：envRec 是一个函数环境记录。
3. 令 activeFunction 为 envRec.[[FunctionObject]]。
4. 断言：activeFunction 是一个 ECMAScript 函数对象。
5. 令 superConstructor 为 ! activeFunction.[[GetPrototypeOf]]()。
6. 返回 superConstructor。

#### 13.3.7.3 MakeSuperPropertyReference ( actualThis, propertyKey, strict )
抽象操作 `MakeSuperPropertyReference` 接受参数 actualThis（一个 ECMAScript 语言值）、propertyKey（一个 ECMAScript 语言值）和 strict（一个布尔值），并返回一个包含超级引用记录的正常完成或一个抛出完成。调用时执行以下步骤：

1. 令 env 为 GetThisEnvironment()。
2. 断言：env.HasSuperBinding() 为 true。
3. 令 baseValue 为 ? env.GetSuperBase()。
4. 返回引用记录 { [[Base]]: baseValue, [[ReferencedName]]: propertyKey, [[Strict]]: strict, [[ThisValue]]: actualThis }。

### 13.3.8 参数列表

**注意**：
参数列表的求值产生一个值的列表。

#### 13.3.8.1 运行时语义：ArgumentListEvaluation
语法导向操作 `ArgumentListEvaluation` 不接受任何参数，返回一个包含 ECMAScript 语言值列表的正常完成或一个突发完成。它根据以下生成式分片定义：

```javascript
Arguments : ( )
1. 返回一个新的空列表。

ArgumentList : AssignmentExpression
1. 令 ref 为 AssignmentExpression 的 ? Evaluation。
2. 令 arg 为 ref 的 ? GetValue。
3. 返回 « arg »。

ArgumentList : ... AssignmentExpression
1. 令 list 为一个新的空列表。
2. 令 spreadRef 为 AssignmentExpression 的 ? Evaluation。
3. 令 spreadObj 为 spreadRef 的 ? GetValue。
4. 令 iteratorRecord 为 ? GetIterator(spreadObj, SYNC)。
5. 重复，
  a. 令 next 为 iteratorRecord 的 ? IteratorStepValue。
  b. 如果 next 是 DONE，返回 list。
  c. 将 next 添加到 list。

ArgumentList : ArgumentList , AssignmentExpression
1. 令 precedingArgs 为 ArgumentList 的 ? ArgumentListEvaluation。
2. 令 ref 为 AssignmentExpression 的 ? Evaluation。
3. 令 arg 为 ref 的 ? GetValue。
4. 返回 precedingArgs 和 « arg » 的列表连接。

ArgumentList : ArgumentList , ... AssignmentExpression
1. 令 precedingArgs 为 ArgumentList 的 ? ArgumentListEvaluation。
2. 令 spreadRef 为 AssignmentExpression 的 ? Evaluation。
3. 令 iteratorRecord 为 ? GetIterator(? GetValue(spreadRef), SYNC)。
4. 重复，
  a. 令 next 为 iteratorRecord 的 ? IteratorStepValue。
  b. 如果 next 是 DONE，返回 precedingArgs。
  c. 将 next 添加到 precedingArgs。

TemplateLiteral : NoSubstitutionTemplate
1. 令 templateLiteral 为 this TemplateLiteral。
2. 令 siteObj 为 GetTemplateObject(templateLiteral)。
3. 返回 « siteObj »。

TemplateLiteral : SubstitutionTemplate
1. 令 templateLiteral 为 this TemplateLiteral。
2. 令 siteObj 为 GetTemplateObject(templateLiteral)。
3. 令 remaining 为 SubstitutionTemplate 的 ? ArgumentListEvaluation。
4. 返回 « siteObj » 和 remaining 的列表连接。

SubstitutionTemplate : TemplateHead Expression TemplateSpans
1. 令 firstSubRef 为 Expression 的 ? Evaluation。
2. 令 firstSub 为 firstSubRef 的 ? GetValue。
3. 令 restSub 为 TemplateSpans 的 ? SubstitutionEvaluation。
4. 断言：restSub 是一个可能为空的列表。
5. 返回 « firstSub » 和 restSub 的列表连接。
```

### 13.3.9 可选链

**注意**：
可选链是一系列一个或多个属性访问和函数调用，其中第一个以 ?. 令牌开头。

#### 13.3.9.1 运行时语义：求值
```javascript
OptionalExpression :
  MemberExpression OptionalChain
  1. 令 baseReference 为 MemberExpression 的 ? Evaluation。
  2. 令 baseValue 为 baseReference 的 ? GetValue。
  3. 如果 baseValue 是 undefined 或 null，
    a. 返回 undefined。
  4. 返回 OptionalChain 的 ? ChainEvaluation，参数为 baseValue 和 baseReference。

OptionalExpression :
  CallExpression OptionalChain
  1. 令 baseReference 为 CallExpression 的 ? Evaluation。
  2. 令 baseValue 为 baseReference 的 ? GetValue。
  3. 如果 baseValue 是 undefined 或 null，
    a. 返回 undefined。
  4. 返回 OptionalChain 的 ? ChainEvaluation，参数为 baseValue 和 baseReference。

OptionalExpression :
  OptionalExpression OptionalChain
  1. 令 baseReference 为 OptionalExpression 的 ? Evaluation。
  2. 令 baseValue 为 baseReference 的 ? GetValue。
  3. 如果 baseValue 是 undefined 或 null，
    a. 返回 undefined。
  4. 返回 OptionalChain 的 ? ChainEvaluation，参数为 baseValue 和 baseReference。
```

#### 13.3.9.2 运行时语义：ChainEvaluation
语法导向操作 `ChainEvaluation` 接受参数 baseValue（一个 ECMAScript 语言值）和 baseReference（一个 ECMAScript 语言值或引用记录），返回一个包含 ECMAScript 语言值或引用记录的正常完成或一个突发完成。它根据以下生成式分片定义：

```javascript
OptionalChain : ?. Arguments
1. 令 thisChain 为 this OptionalChain。
2. 令 tailCall 为 IsInTailPosition(thisChain)。
3. 返回 ? EvaluateCall(baseValue, baseReference, Arguments, tailCall)。

OptionalChain : ?. [ Expression ]
1. 令 strict 为 IsStrict(this OptionalChain)。
2. 返回 ? EvaluatePropertyAccessWithExpressionKey(baseValue, Expression, strict)。

OptionalChain : ?. IdentifierName
1. 令 strict 为 IsStrict(this OptionalChain)。
2. 返回 EvaluatePropertyAccessWithIdentifierKey(baseValue, IdentifierName, strict)。

OptionalChain : ?. PrivateIdentifier
1. 令 fieldNameString 为 PrivateIdentifier 的 StringValue。
2. 返回 MakePrivateReference(baseValue, fieldNameString)。

OptionalChain : OptionalChain Arguments
1. 令 optionalChain 为 OptionalChain。
2. 令 newReference 为 optionalChain 的 ? ChainEvaluation，参数为 baseValue 和 baseReference。
3. 令 newValue 为 newReference 的 ? GetValue。
4. 令 thisChain 为 this OptionalChain。
5. 令 tailCall 为 IsInTailPosition(thisChain)。
6. 返回 ? EvaluateCall(newValue, newReference, Arguments, tailCall)。

OptionalChain : OptionalChain [ Expression ]
1. 令 optionalChain 为 OptionalChain。
2. 令 newReference 为 optionalChain 的 ? ChainEvaluation，参数为 baseValue 和 baseReference。
3. 令 newValue 为 newReference 的 ? GetValue。
4. 令 strict 为 IsStrict(this OptionalChain)。
5. 返回 ? EvaluatePropertyAccessWithExpressionKey(newValue, Expression, strict)。

OptionalChain : OptionalChain . IdentifierName
1. 令 optionalChain 为 OptionalChain。
2. 令 newReference 为 optionalChain 的 ? ChainEvaluation，参数为

 baseValue 和 baseReference。
3. 令 newValue 为 newReference 的 ? GetValue。
4. 令 strict 为 IsStrict(this OptionalChain)。
5. 返回 EvaluatePropertyAccessWithIdentifierKey(newValue, IdentifierName, strict)。

OptionalChain : OptionalChain . PrivateIdentifier
1. 令 optionalChain 为 OptionalChain。
2. 令 newReference 为 optionalChain 的 ? ChainEvaluation，参数为 baseValue 和 baseReference。
3. 令 newValue 为 newReference 的 ? GetValue。
4. 令 fieldNameString 为 PrivateIdentifier 的 StringValue。
5. 返回 MakePrivateReference(newValue, fieldNameString)。
```

### 13.3.10 Import 调用

#### 13.3.10.1 运行时语义：求值
```javascript
ImportCall : import ( AssignmentExpression )
1. 令 referrer 为 GetActiveScriptOrModule()。
2. 如果 referrer 为 null，设置 referrer 为当前的 Realm Record。
3. 令 argRef 为 AssignmentExpression 的 ? Evaluation。
4. 令 specifier 为 argRef 的 ? GetValue。
5. 令 promiseCapability 为 ! NewPromiseCapability(%Promise%)。
6. 令 specifierString 为 Completion(ToString(specifier))。
7. IfAbruptRejectPromise(specifierString, promiseCapability)。
8. 执行 HostLoadImportedModule(referrer, specifierString, EMPTY, promiseCapability)。
9. 返回 promiseCapability.[[Promise]]。
```

#### 13.3.10.1.1 ContinueDynamicImport ( promiseCapability, moduleCompletion )
抽象操作 `ContinueDynamicImport` 接受参数 promiseCapability（一个 PromiseCapability 记录）和 moduleCompletion（包含模块记录的正常完成或一个抛出完成），并返回 UNUSED。它完成由 import() 调用启动的动态导入过程，根据需要解析或拒绝由该调用返回的承诺。调用时执行以下步骤：

1. 如果 moduleCompletion 是一个突发完成，
  a. 执行 ! Call(promiseCapability.[[Reject]], undefined, « moduleCompletion.[[Value]] »)。
  b. 返回 UNUSED。
2. 令 module 为 moduleCompletion.[[Value]]。
3. 令 loadPromise 为 module.LoadRequestedModules()。
4. 令 rejectedClosure 为一个新的抽象闭包，参数为 (reason)，捕获 promiseCapability 并在调用时执行以下步骤：
  a. 执行 ! Call(promiseCapability.[[Reject]], undefined, « reason »)。
  b. 返回 UNUSED。
5. 令 onRejected 为 CreateBuiltinFunction(rejectedClosure, 1, "", « »)。
6. 令 linkAndEvaluateClosure 为一个新的抽象闭包，没有参数，捕获 module, promiseCapability 和 onRejected，并在调用时执行以下步骤：
  a. 令 link 为 Completion(module.Link())。
  b. 如果 link 是一个突发完成，
    i. 执行 ! Call(promiseCapability.[[Reject]], undefined, « link.[[Value]] »)。
    ii. 返回 UNUSED。
  c. 令 evaluatePromise 为 module.Evaluate()。
  d. 令 fulfilledClosure 为一个新的抽象闭包，没有参数，捕获 module 和 promiseCapability，并在调用时执行以下步骤：
    i. 令 namespace 为 GetModuleNamespace(module)。
    ii. 执行 ! Call(promiseCapability.[[Resolve]], undefined, « namespace »)。
    iii. 返回 UNUSED。
  e. 令 onFulfilled 为 CreateBuiltinFunction(fulfilledClosure, 0, "", « »)。
  f. 执行 PerformPromiseThen(evaluatePromise, onFulfilled, onRejected)。
  g. 返回 UNUSED。
7. 令 linkAndEvaluate 为 CreateBuiltinFunction(linkAndEvaluateClosure, 0, "", « »)。
8. 执行 PerformPromiseThen(loadPromise, linkAndEvaluate, onRejected)。
9. 返回 UNUSED。

### 13.3.11 标记模板

**注意**：
标记模板是一个函数调用，其中调用的参数来自 TemplateLiteral (13.2.8)。实际参数包括一个模板对象 (13.2.8.4) 和通过评估嵌入在 TemplateLiteral 中的表达式所产生的值。

#### 13.3.11.1 运行时语义：求值
```javascript
MemberExpression : MemberExpression TemplateLiteral
1. 令 tagRef 为 MemberExpression 的 ? Evaluation。
2. 令 tagFunc 为 tagRef 的 ? GetValue。
3. 令 thisCall 为 this MemberExpression。
4. 令 tailCall 为 IsInTailPosition(thisCall)。
5. 返回 ? EvaluateCall(tagFunc, tagRef, TemplateLiteral, tailCall)。

CallExpression : CallExpression TemplateLiteral
1. 令 tagRef 为 CallExpression 的 ? Evaluation。
2. 令 tagFunc 为 tagRef 的 ? GetValue。
3. 令 thisCall 为 this CallExpression。
4. 令 tailCall 为 IsInTailPosition(thisCall)。
5. 返回 ? EvaluateCall(tagFunc, tagRef, TemplateLiteral, tailCall)。
```

### 13.3.12 元属性

#### 13.3.12.1 运行时语义：求值
```javascript
NewTarget : new . target
1. 返回 GetNewTarget()。

ImportMeta : import . meta
1. 令 module 为 GetActiveScriptOrModule()。
2. 断言：module 是一个源文本模块记录。
3. 令 importMeta 为 module.[[ImportMeta]]。
4. 如果 importMeta 为 EMPTY，
  a. 设置 importMeta 为 OrdinaryObjectCreate(null)。
  b. 令 importMetaValues 为 HostGetImportMetaProperties(module)。
  c. 对于 importMetaValues 中的每个记录 { [[Key]], [[Value]] } p，
    i. 执行 ! CreateDataPropertyOrThrow(importMeta, p.[[Key]], p.[[Value]])。
  d. 执行 HostFinalizeImportMeta(importMeta, module)。
  e. 设置 module.[[ImportMeta]] 为 importMeta。
  f. 返回 importMeta。
5. 否则，
  a. 断言：importMeta 是一个对象。
  b. 返回 importMeta。
```

#### 13.3.12.1.1 HostGetImportMetaProperties ( moduleRecord )
宿主定义的抽象操作 `HostGetImportMetaProperties` 接受参数 moduleRecord（一个模块记录）并返回一个具有字段 [[Key]]（属性键）和 [[Value]]（ECMAScript 语言值）的记录列表。它允许宿主为从 import.meta 返回的对象提供属性键和值。

默认实现 `HostGetImportMetaProperties` 是返回一个新的空列表。

#### 13.3.12.1.2 HostFinalizeImportMeta ( importMeta, moduleRecord )
宿主定义的抽象操作 `HostFinalizeImportMeta` 接受参数 importMeta（一个对象）和 moduleRecord（一个模块记录），并返回 UNUSED。它允许宿主执行任何特殊操作以准备从 import.meta 返回的对象。

大多数宿主只需定义 `HostGetImportMetaProperties`，并保持 `HostFinalizeImportMeta` 的默认行为。然而，`HostFinalizeImportMeta` 为需要在对象暴露给 ECMAScript 代码之前直接操作对象的宿主提供了一个“逃生口”。

默认实现 `HostFinalizeImportMeta` 是返回 UNUSED。

### 13.4 更新表达式

#### 语法
```javascript
UpdateExpression[Yield, Await] :
  LeftHandSideExpression[?Yield, ?Await]
  LeftHandSideExpression[?Yield, ?Await] [no LineTerminator here] ++
  LeftHandSideExpression[?Yield, ?Await] [no LineTerminator here] --
  ++ UnaryExpression[?Yield, ?Await]
  -- UnaryExpression[?Yield, ?Await]
```

#### 13.4.1 静态语义：早期错误
```javascript
UpdateExpression :
  LeftHandSideExpression ++
  LeftHandSideExpression --
```
如果 `LeftHandSideExpression` 的 `AssignmentTargetType` 不是 `SIMPLE`，则为早期语法错误。

```javascript
UpdateExpression :
  ++ UnaryExpression
  -- UnaryExpression
```
如果 `UnaryExpression` 的 `AssignmentTargetType` 不是 `SIMPLE`，则为早期语法错误。

#### 13.4.2 后缀递增操作符

##### 13.4.2.1 运行时语义：求值
```javascript
UpdateExpression : LeftHandSideExpression ++
1. 令 lhs 为 LeftHandSideExpression 的 ? Evaluation。
2. 令 oldValue 为 ? ToNumeric(? GetValue(lhs))。
3. 如果 oldValue 是一个 Number，
  a. 令 newValue 为 Number::add(oldValue, 1𝔽)。
4. 否则，
  a. 断言：oldValue 是一个 BigInt。
  b. 令 newValue 为 BigInt::add(oldValue, 1ℤ)。
5. 执行 ? PutValue(lhs, newValue)。
6. 返回 oldValue。
```

#### 13.4.3 后缀递减操作符

##### 13.4.3.1 运行时语义：求值
```javascript
UpdateExpression : LeftHandSideExpression --
1. 令 lhs 为 LeftHandSideExpression 的 ? Evaluation。
2. 令 oldValue 为 ? ToNumeric(? GetValue(lhs))。
3. 如果 oldValue 是一个 Number，
  a. 令 newValue 为 Number::subtract(oldValue, 1𝔽)。
4. 否则，
  a. 断言：oldValue 是一个 BigInt。
  b. 令 newValue 为 BigInt::subtract(oldValue, 1ℤ)。
5. 执行 ? PutValue(lhs, newValue)。
6. 返回 oldValue。
```

#### 13.4.4 前缀递增操作符

##### 13.4.4.1 运行时语义：求值
```javascript
UpdateExpression : ++ UnaryExpression
1. 令 expr 为 UnaryExpression 的 ? Evaluation。
2. 令 oldValue 为 ? ToNumeric(? GetValue(expr))。
3. 如果 oldValue 是一个 Number，
  a. 令 newValue 为 Number::add(oldValue, 1𝔽)。
4. 否则，
  a. 断言：oldValue 是一个 BigInt。
  b. 令 newValue 为 BigInt::add(oldValue, 1ℤ)。
5. 执行 ? PutValue(expr, newValue)。
6. 返回 newValue。
```

#### 13.4.5 前缀递减操作符

##### 13.4.5.1 运行时语义：求值
```javascript
UpdateExpression : -- UnaryExpression
1. 令 expr 为 UnaryExpression 的 ? Evaluation。
2. 令 oldValue 为 ? ToNumeric(? GetValue(expr))。
3. 如果 oldValue 是一个 Number，
  a. 令 newValue 为 Number::subtract(oldValue, 1𝔽)。
4. 否则，
  a. 断言：oldValue 是一个 BigInt。
  b. 令 newValue 为 BigInt::subtract(oldValue, 1ℤ)。
5. 执行 ? PutValue(expr, newValue)。
6. 返回 newValue。
```


### 13.5 一元运算符

#### 语法
```javascript
UnaryExpression[Yield, Await] :
  UpdateExpression[?Yield, ?Await]
  delete UnaryExpression[?Yield, ?Await]
  void UnaryExpression[?Yield, ?Await]
  typeof UnaryExpression[?Yield, ?Await]
  + UnaryExpression[?Yield, ?Await]
  - UnaryExpression[?Yield, ?Await]
  ~ UnaryExpression[?Yield, ?Await]
  ! UnaryExpression[?Yield, ?Await]
  [+Await] AwaitExpression[?Yield]
```

#### 13.5.1 `delete` 运算符

##### 13.5.1.1 静态语义：早期错误
```javascript
UnaryExpression : delete UnaryExpression
```
如果 `IsStrict(UnaryExpression)` 为 true 并且派生的 `UnaryExpression` 是 `PrimaryExpression : IdentifierReference`、`MemberExpression : MemberExpression . PrivateIdentifier`、`CallExpression : CallExpression . PrivateIdentifier`、`OptionalChain : ?. PrivateIdentifier` 或 `OptionalChain : OptionalChain . PrivateIdentifier`，则为语法错误。

如果派生的 `UnaryExpression` 是 `PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList` 并且 `CoverParenthesizedExpressionAndArrowParameterList` 最终派生出的短语在 `UnaryExpression` 的位置会根据这些规则产生语法错误，则为语法错误。此规则递归应用。

**注**: 最后一条规则意味着表达式如 `delete (((foo)))` 因为递归应用第一条规则会产生早期错误。

##### 13.5.1.2 运行时语义：求值
```javascript
UnaryExpression : delete UnaryExpression
1. 令 ref 为 UnaryExpression 的 ? Evaluation。
2. 如果 ref 不是一个引用记录，返回 true。
3. 如果 `IsUnresolvableReference(ref)` 为 true，则
  a. 断言：ref.[[Strict]] 为 false。
  b. 返回 true。
4. 如果 `IsPropertyReference(ref)` 为 true，则
  a. 断言：`IsPrivateReference(ref)` 为 false。
  b. 如果 `IsSuperReference(ref)` 为 true，抛出一个 ReferenceError 异常。
  c. 令 baseObj 为 ? ToObject(ref.[[Base]])。
  d. 如果 ref.[[ReferencedName]] 不是一个属性键，则
    i. 将 ref.[[ReferencedName]] 设置为 ? ToPropertyKey(ref.[[ReferencedName]])。
  e. 令 deleteStatus 为 ? baseObj.[[Delete]](ref.[[ReferencedName]])。
  f. 如果 deleteStatus 为 false 并且 ref.[[Strict]] 为 true，抛出一个 TypeError 异常。
  g. 返回 deleteStatus。
5. 否则，
  a. 令 base 为 ref.[[Base]]。
  b. 断言：base 是一个环境记录。
  c. 返回 ? base.DeleteBinding(ref.[[ReferencedName]])。
```

**注1**: 当 `delete` 运算符在严格模式代码中出现时，如果它的 `UnaryExpression` 是对变量、函数参数或函数名称的直接引用，则抛出一个 `SyntaxError` 异常。此外，如果 `delete` 运算符在严格模式代码中出现并且要删除的属性具有属性 `[[Configurable]]: false`（或不能被删除），则抛出一个 `TypeError` 异常。

**注2**: 在步骤 4.c 中创建的对象在上述抽象操作和普通对象 `[[Delete]]` 内部方法之外不可访问。实现可能选择避免实际创建该对象。

#### 13.5.2 `void` 运算符

##### 13.5.2.1 运行时语义：求值
```javascript
UnaryExpression : void UnaryExpression
1. 令 expr 为 UnaryExpression 的 ? Evaluation。
2. 执行 ? GetValue(expr)。
3. 返回 undefined。
```

**注**: `GetValue` 必须被调用，即使其值未被使用，因为它可能具有可观察的副作用。

#### 13.5.3 `typeof` 运算符

##### 13.5.3.1 运行时语义：求值
```javascript
UnaryExpression : typeof UnaryExpression
1. 令 val 为 UnaryExpression 的 ? Evaluation。
2. 如果 val 是一个引用记录，则
  a. 如果 `IsUnresolvableReference(val)` 为 true，返回 "undefined"。
3. 将 val 设置为 ? GetValue(val)。
4. 如果 val 是 `undefined`，返回 "undefined"。
5. 如果 val 是 `null`，返回 "object"。
6. 如果 val 是 `String`，返回 "string"。
7. 如果 val 是 `Symbol`，返回 "symbol"。
8. 如果 val 是 `Boolean`，返回 "boolean"。
9. 如果 val 是 `Number`，返回 "number"。
10. 如果 val 是 `BigInt`，返回 "bigint"。
11. 断言：val 是一个对象。
12. **注**: 此步骤在 B.3.6.3 节中被替换。
13. 如果 val 具有 `[[Call]]` 内部槽，返回 "function"。
14. 返回 "object"。
```

#### 13.5.4 一元 `+` 运算符

**注**: 一元 `+` 运算符将其操作数转换为 `Number` 类型。

##### 13.5.4.1 运行时语义：求值
```javascript
UnaryExpression : + UnaryExpression
1. 令 expr 为 UnaryExpression 的 ? Evaluation。
2. 返回 ? ToNumber(? GetValue(expr))。
```

#### 13.5.5 一元 `-` 运算符

**注**: 一元 `-` 运算符将其操作数转换为数值，然后取反。对 `+0𝔽` 取反得到 `-0𝔽`，对 `-0𝔽` 取反得到 `+0𝔽`。

##### 13.5.5.1 运行时语义：求值
```javascript
UnaryExpression : - UnaryExpression
1. 令 expr 为 UnaryExpression 的 ? Evaluation。
2. 令 oldValue 为 ? ToNumeric(? GetValue(expr))。
3. 如果 oldValue 是一个 `Number`，
  a. 返回 `Number::unaryMinus(oldValue)`。
4. 否则，
  a. 断言：oldValue 是一个 `BigInt`。
  b. 返回 `BigInt::unaryMinus(oldValue)`。
```

#### 13.5.6 按位非运算符 (`~`)

##### 13.5.6.1 运行时语义：求值
```javascript
UnaryExpression : ~ UnaryExpression
1. 令 expr 为 UnaryExpression 的 ? Evaluation。
2. 令 oldValue 为 ? ToNumeric(? GetValue(expr))。
3. 如果 oldValue 是一个 `Number`，
  a. 返回 `Number::bitwiseNOT(oldValue)`。
4. 否则，
  a. 断言：oldValue 是一个 `BigInt`。
  b. 返回 `BigInt::bitwiseNOT(oldValue)`。
```

#### 13.5.7 逻辑非运算符 (`!`)

##### 13.5.7.1 运行时语义：求值
```javascript
UnaryExpression : ! UnaryExpression
1. 令 expr 为 UnaryExpression 的 ? Evaluation。
2. 令 oldValue 为 `ToBoolean(? GetValue(expr))`。
3. 如果 oldValue 为 `true`，返回 `false`。
4. 返回 `true`。
```

### 13.6 幂运算符
#### 语法
```javascript
ExponentiationExpression[Yield, Await] :
  UnaryExpression[?Yield, ?Await]
  UpdateExpression[?Yield, ?Await] ** ExponentiationExpression[?Yield, ?Await]
```

#### 13.6.1 运行时语义：求值
```javascript
ExponentiationExpression : UpdateExpression ** ExponentiationExpression
1. 返回 ? EvaluateStringOrNumericBinaryExpression(UpdateExpression, **, ExponentiationExpression)。
```

### 13.7 乘法运算符
#### 语法
```javascript
MultiplicativeExpression[Yield, Await] :
  ExponentiationExpression[?Yield, ?Await]
  MultiplicativeExpression[?Yield, ?Await] MultiplicativeOperator ExponentiationExpression[?Yield, ?Await]

MultiplicativeOperator : one of
  * / %
```

**注意**：
- `*` 运算符进行乘法运算，产生操作数的乘积。
- `/` 运算符进行除法运算，产生操作数的商。
- `%` 运算符产生操作数除法后的余数。

#### 13.7.1 运行时语义：求值
```javascript
MultiplicativeExpression : MultiplicativeExpression MultiplicativeOperator ExponentiationExpression
1. 令 opText 为 MultiplicativeOperator 匹配的源文本。
2. 返回 ? EvaluateStringOrNumericBinaryExpression(MultiplicativeExpression, opText, ExponentiationExpression)。
```

### 13.8 加法运算符
#### 语法
```javascript
AdditiveExpression[Yield, Await] :
  MultiplicativeExpression[?Yield, ?Await]
  AdditiveExpression[?Yield, ?Await] + MultiplicativeExpression[?Yield, ?Await]
  AdditiveExpression[?Yield, ?Await] - MultiplicativeExpression[?Yield, ?Await]
```

#### 13.8.1 加法运算符 (`+`)
**注意**：加法运算符进行字符串连接或数值加法运算。

##### 13.8.1.1 运行时语义：求值
```javascript
AdditiveExpression : AdditiveExpression + MultiplicativeExpression
1. 返回 ? EvaluateStringOrNumericBinaryExpression(AdditiveExpression, +, MultiplicativeExpression)。
```

#### 13.8.2 减法运算符 (`-`)
**注意**：`-` 运算符进行减法运算，产生操作数的差值。

##### 13.8.2.1 运行时语义：求值
```javascript
AdditiveExpression : AdditiveExpression - MultiplicativeExpression
1. 返回 ? EvaluateStringOrNumericBinaryExpression(AdditiveExpression, -, MultiplicativeExpression)。
```

### 13.9 按位移位运算符
#### 语法
```javascript
ShiftExpression[Yield, Await] :
  AdditiveExpression[?Yield, ?Await]
  ShiftExpression[?Yield, ?Await] << AdditiveExpression[?Yield, ?Await]
  ShiftExpression[?Yield, ?Await] >> AdditiveExpression[?Yield, ?Await]
  ShiftExpression[?Yield, ?Await] >>> AdditiveExpression[?Yield, ?Await]
```

#### 13.9.1 左移运算符 (`<<`)
**注意**：对左操作数进行按位左移运算，移位的位数由右操作数指定。

##### 13.9.1.1 运行时语义：求值
```javascript
ShiftExpression : ShiftExpression << AdditiveExpression
1. 返回 ? EvaluateStringOrNumericBinaryExpression(ShiftExpression, <<, AdditiveExpression)。
```

#### 13.9.2 带符号右移运算符 (`>>`)
**注意**：对左操作数进行符号填充的按位右移运算，移位的位数由右操作数指定。

##### 13.9.2.1 运行时语义：求值
```javascript
ShiftExpression : ShiftExpression >> AdditiveExpression
1. 返回 ? EvaluateStringOrNumericBinaryExpression(ShiftExpression, >>, AdditiveExpression)。
```

#### 13.9.3 无符号右移运算符 (`>>>`)
**注意**：对左操作数进行零填充的按位右移运算，移位的位数由右操作数指定。

##### 13.9.3.1 运行时语义：求值
```javascript
ShiftExpression : ShiftExpression >>> AdditiveExpression
1. 返回 ? EvaluateStringOrNumericBinaryExpression(ShiftExpression, >>>, AdditiveExpression)。
```

### 13.10 关系运算符
**注意1**：求值关系运算符的结果总是布尔类型，反映运算符命名的关系在其两个操作数之间是否成立。

#### 语法
```javascript
RelationalExpression[In, Yield, Await] :
  ShiftExpression[?Yield, ?Await]
  RelationalExpression[?In, ?Yield, ?Await] < ShiftExpression[?Yield, ?Await]
  RelationalExpression[?In, ?Yield, ?Await] > ShiftExpression[?Yield, ?Await]
  RelationalExpression[?In, ?Yield, ?Await] <= ShiftExpression[?Yield, ?Await]
  RelationalExpression[?In, ?Yield, ?Await] >= ShiftExpression[?Yield, ?Await]
  RelationalExpression[?In, ?Yield, ?Await] instanceof ShiftExpression[?Yield, ?Await]
  [+In] RelationalExpression[+In, ?Yield, ?Await] in ShiftExpression[?Yield, ?Await]
  [+In] PrivateIdentifier in ShiftExpression[?Yield, ?Await]
```

**注意2**：`[In]` 语法参数是为了避免在关系表达式中将 `in` 运算符与 `for` 语句中的 `in` 运算符混淆。

#### 13.10.1 运行时语义：求值
```javascript
RelationalExpression : RelationalExpression < ShiftExpression
1. 令 lref 为 RelationalExpression 的 ? Evaluation。
2. 令 lval 为 ? GetValue(lref)。
3. 令 rref 为 ShiftExpression 的 ? Evaluation。
4. 令 rval 为 ? GetValue(rref)。
5. 令 r 为 ? IsLessThan(lval, rval, true)。
6. 如果 r 为 undefined，返回 false。否则，返回 r。

RelationalExpression : RelationalExpression > ShiftExpression
1. 令 lref 为 RelationalExpression 的 ? Evaluation。
2. 令 lval 为 ? GetValue(lref)。
3. 令 rref 为 ShiftExpression 的 ? Evaluation。
4. 令 rval 为 ? GetValue(rref)。
5. 令 r 为 ? IsLessThan(rval, lval, false)。
6. 如果 r 为 undefined，返回 false。否则，返回 r。

RelationalExpression : RelationalExpression <= ShiftExpression
1. 令 lref 为 RelationalExpression 的 ? Evaluation。
2. 令 lval 为 ? GetValue(lref)。
3. 令 rref 为 ShiftExpression 的 ? Evaluation。
4. 令 rval 为 ? GetValue(rref)。
5. 令 r 为 ? IsLessThan(rval, lval, false)。
6. 如果 r 为 true 或 undefined，返回 false。否则，返回 true。

RelationalExpression : RelationalExpression >= ShiftExpression
1. 令 lref 为 RelationalExpression 的 ? Evaluation。
2. 令 lval 为 ? GetValue(lref)。
3. 令 rref 为 ShiftExpression 的 ? Evaluation。
4. 令 rval 为 ? GetValue(rref)。
5. 令 r 为 ? IsLessThan(lval, rval, true)。
6. 如果 r 为 true 或 undefined，返回 false。否则，返回 true。

RelationalExpression : RelationalExpression instanceof ShiftExpression
1. 令 lref 为 RelationalExpression 的 ? Evaluation。
2. 令 lval 为 ? GetValue(lref)。
3. 令 rref 为 ShiftExpression 的 ? Evaluation。
4. 令 rval 为 ? GetValue(rref)。
5. 返回 ? InstanceofOperator(lval, rval)。

RelationalExpression : RelationalExpression in ShiftExpression
1. 令 lref 为 RelationalExpression 的 ? Evaluation。
2. 令 lval 为 ? GetValue(lref)。
3. 令 rref 为 ShiftExpression 的 ? Evaluation。
4. 令 rval 为 ? GetValue(rref)。
5. 如果 rval 不是对象，抛出一个 TypeError 异常。
6. 返回 ? HasProperty(rval, ? ToPropertyKey(lval))。

RelationalExpression : PrivateIdentifier in ShiftExpression
1. 令 privateIdentifier 为 PrivateIdentifier 的 StringValue。
2. 令 rref 为 ShiftExpression 的 ? Evaluation。
3. 令 rval 为 ? GetValue(rref)。
4. 如果 rval 不是对象，抛出一个 TypeError 异常。
5. 令 privateEnv 为当前执行上下文的 PrivateEnvironment。
6. 令 privateName 为 `ResolvePrivateIdentifier(privateEnv, privateIdentifier)`。
7. 如果 `PrivateElementFind(rval, privateName)` 不是 EMPTY，返回 true。
8. 返回 false。
```

#### 13.10.2 `InstanceofOperator (

V, target)`
```javascript
InstanceofOperator (V, target)
抽象操作 `InstanceofOperator` 接受参数 `V`（一个 ECMAScript 语言值）和 `target`（一个 ECMAScript 语言值）并返回一个布尔值或抛出异常。它实现了通用算法，通过查询 `target` 的 `@@hasInstance` 方法或如果不存在，通过确定 `target` 的 "prototype" 属性值是否存在于 `V` 的原型链中来确定 `V` 是否是 `target` 的实例。它在调用时执行以下步骤：

1. 如果 `target` 不是对象，抛出一个 TypeError 异常。
2. 令 `instOfHandler` 为 `GetMethod(target, @@hasInstance)` 的返回值。
3. 如果 `instOfHandler` 不是 `undefined`，则
  a. 返回 `ToBoolean(? Call(instOfHandler, target, « V »))`。
4. 如果 `IsCallable(target)` 为 false，抛出一个 TypeError 异常。
5. 返回 `? OrdinaryHasInstance(target, V)`。
```

**注意**：步骤 4 和 5 提供与以前版本 ECMAScript 的兼容性，这些版本没有使用 `@@hasInstance` 方法来定义 `instanceof` 运算符语义。如果对象未定义或继承 `@@hasInstance`，则使用默认 `instanceof` 语义。

### 13.11 相等运算符
**注意**：求值相等运算符的结果总是布尔类型，反映运算符命名的关系在其两个操作数之间是否成立。

#### 语法
```javascript
EqualityExpression[In, Yield, Await] :
  RelationalExpression[?In, ?Yield, ?Await]
  EqualityExpression[?In, ?Yield, ?Await] == RelationalExpression[?In, ?Yield, ?Await]
  EqualityExpression[?In, ?Yield, ?Await] != RelationalExpression[?In, ?Yield, ?Await]
  EqualityExpression[?In, ?Yield, ?Await] === RelationalExpression[?In, ?Yield, ?Await]
  EqualityExpression[?In, ?Yield, ?Await] !== RelationalExpression[?In, ?Yield, ?Await]
```

#### 13.11.1 运行时语义：求值
```javascript
EqualityExpression : EqualityExpression == RelationalExpression
1. 令 lref 为 EqualityExpression 的 ? Evaluation。
2. 令 lval 为 ? GetValue(lref)。
3. 令 rref 为 RelationalExpression 的 ? Evaluation。
4. 令 rval 为 ? GetValue(rref)。
5. 返回 ? IsLooselyEqual(rval, lval)。

EqualityExpression : EqualityExpression != RelationalExpression
1. 令 lref 为 EqualityExpression 的 ? Evaluation。
2. 令 lval 为 ? GetValue(lref)。
3. 令 rref 为 RelationalExpression 的 ? Evaluation。
4. 令 rval 为 ? GetValue(rref)。
5. 令 r 为 ? IsLooselyEqual(rval, lval)。
6. 如果 r 为 true，返回 false。否则，返回 true。

EqualityExpression : EqualityExpression === RelationalExpression
1. 令 lref 为 EqualityExpression 的 ? Evaluation。
2. 令 lval 为 ? GetValue(lref)。
3. 令 rref 为 RelationalExpression 的 ? Evaluation。
4. 令 rval 为 ? GetValue(rref)。
5. 返回 `IsStrictlyEqual(rval, lval)`。

EqualityExpression : EqualityExpression !== RelationalExpression
1. 令 lref 为 EqualityExpression 的 ? Evaluation。
2. 令 lval 为 ? GetValue(lref)。
3. 令 rref 为 RelationalExpression 的 ? Evaluation。
4. 令 rval 为 ? GetValue(rref)。
5. 令 r 为 `IsStrictlyEqual(rval, lval)`。
6. 如果 r 为 true，返回 false。否则，返回 true。
```

**注意1**：鉴于上述相等定义：

字符串比较可以通过 `${a} == ${b}` 强制进行。
数字比较可以通过 `+a == +b` 强制进行。
布尔比较可以通过 `!a == !b` 强制进行。

**注意2**：相等运算符保持以下不变性：

`A != B` 等价于 `!(A == B)`。
`A == B` 等价于 `B == A`，除了 `A` 和 `B` 的求值顺序。

**注意3**：相等运算符并不总是传递的。例如，可能存在两个不同的字符串对象，每个都表示相同的字符串值；每个字符串对象通过 `==` 运算符与字符串值相比会被认为相等，但这两个字符串对象彼此之间不会相等。例如：

```javascript
new String("a") == "a" 和 "a" == new String("a") 都为 true。
new String("a") == new String("a") 为 false。
```

**注意4**：字符串的比较使用对代码单元值序列的简单相等性测试。不会尝试使用 Unicode 规范中定义的更复杂的字符或字符串相等性定义和排序顺序。因此，根据 Unicode 标准规范化相等的字符串值可能被测试为不相等。实际上，这种算法假定两个字符串已经处于规范化形式。

### 13.12 二进制按位运算符
#### 语法
```javascript
BitwiseANDExpression[In, Yield, Await] :
  EqualityExpression[?In, ?Yield, ?Await]
  BitwiseANDExpression[?In, ?Yield, ?Await] & EqualityExpression[?In, ?Yield, ?Await]

BitwiseXORExpression[In, Yield, Await] :
  BitwiseANDExpression[?In, ?Yield, ?Await]
  BitwiseXORExpression[?In, ?Yield, ?Await] ^ BitwiseANDExpression[?In, ?Yield, ?Await]

BitwiseORExpression[In, Yield, Await] :
  BitwiseXORExpression[?In, ?Yield, ?Await]
  BitwiseORExpression[?In, ?Yield, ?Await] | BitwiseXORExpression[?In, ?Yield, ?Await]
```

#### 13.12.1 运行时语义：求值
```javascript
BitwiseANDExpression : BitwiseANDExpression & EqualityExpression
1. 返回 ? EvaluateStringOrNumericBinaryExpression(BitwiseANDExpression, &, EqualityExpression)。

BitwiseXORExpression : BitwiseXORExpression ^ BitwiseANDExpression
1. 返回 ? EvaluateStringOrNumericBinaryExpression(BitwiseXORExpression, ^, BitwiseANDExpression)。

BitwiseORExpression : BitwiseORExpression | BitwiseXORExpression
1. 返回 ? EvaluateStringOrNumericBinaryExpression(BitwiseORExpression, |, BitwiseXORExpression)。
```

### 13.13 二进制逻辑运算符
#### 语法
```javascript
LogicalANDExpression[In, Yield, Await] :
  BitwiseORExpression[?In, ?Yield, ?Await]
  LogicalANDExpression[?In, ?Yield, ?Await] && BitwiseORExpression[?In, ?Yield, ?Await]

LogicalORExpression[In, Yield, Await] :
  LogicalANDExpression[?In, ?Yield, ?Await]
  LogicalORExpression[?In, ?Yield, ?Await] || LogicalANDExpression[?In, ?Yield, ?Await]

CoalesceExpression[In, Yield, Await] :
  CoalesceExpressionHead[?In, ?Yield, ?Await] ?? BitwiseORExpression[?In, ?Yield, ?Await]

CoalesceExpressionHead[In, Yield, Await] :
  CoalesceExpression[?In, ?Yield, ?Await]
  BitwiseORExpression[?In, ?Yield, ?Await]

ShortCircuitExpression[In, Yield, Await] :
  LogicalORExpression[?In, ?Yield, ?Await]
  CoalesceExpression[?In, ?Yield, ?Await]
```

**注意**：`&&` 或 `||` 运算符生成的值不一定是布尔类型。生成的值总是两个操作数表达式之一的值。

#### 13.13.1 运行时语义：求值
```javascript
LogicalANDExpression : LogicalANDExpression && BitwiseORExpression
1. 令 lref 为 LogicalANDExpression 的 ? Evaluation。
2. 令 lval 为 ? GetValue(lref)。
3. 令 lbool 为 ToBoolean(lval)。
4. 如果 lbool 为 false，返回 lval。
5. 令 rref 为 BitwiseORExpression 的 ? Evaluation。
6. 返回 ? GetValue(rref)。

LogicalORExpression : LogicalORExpression || LogicalANDExpression
1. 令 lref 为 LogicalORExpression 的 ? Evaluation。
2. 令 lval 为 ? GetValue(lref)。
3. 令 lbool 为 ToBoolean(lval)。
4. 如果 lbool 为 true，返回 lval。
5. 令 rref 为 LogicalANDExpression 的 ? Evaluation。
6. 返回 ? GetValue(rref)。

CoalesceExpression : CoalesceExpressionHead ?? BitwiseORExpression
1. 令 lref 为 CoalesceExpressionHead 的 ? Evaluation。
2. 令 lval 为 ? GetValue(lref)。
3. 如果 l

val 为 undefined 或 null，则
  a. 令 rref 为 BitwiseORExpression 的 ? Evaluation。
  b. 返回 ? GetValue(rref)。
4. 否则，
  a. 返回 lval。
```

### 13.14 条件运算符（ `? :` ）
#### 语法
```javascript
ConditionalExpression[In, Yield, Await] :
  ShortCircuitExpression[?In, ?Yield, ?Await]
  ShortCircuitExpression[?In, ?Yield, ?Await] ? AssignmentExpression[+In, ?Yield, ?Await] : AssignmentExpression[?In, ?Yield, ?Await]
```

**注意**：ECMAScript 中的 ConditionalExpression 语法与 C 和 Java 中的稍有不同，后者允许第二个子表达式为 Expression，但限制第三个表达式为 ConditionalExpression。ECMAScript 中的这种差异旨在允许条件表达式的任意一个分支包含赋值表达式，并消除逗号表达式作为中心表达式的困惑和几乎无用的情况。

#### 13.14.1 运行时语义：求值
```javascript
ConditionalExpression : ShortCircuitExpression ? AssignmentExpression : AssignmentExpression
1. 令 lref 为 ShortCircuitExpression 的 ? Evaluation。
2. 令 lval 为 ToBoolean(? GetValue(lref))。
3. 如果 lval 为 true，则
  a. 令 trueRef 为第一个 AssignmentExpression 的 ? Evaluation。
  b. 返回 ? GetValue(trueRef)。
4. 否则，
  a. 令 falseRef 为第二个 AssignmentExpression 的 ? Evaluation。
  b. 返回 ? GetValue(falseRef)。
```

### 13.15 赋值运算符

#### 语法
```javascript
AssignmentExpression[In, Yield, Await] :
  ConditionalExpression[?In, ?Yield, ?Await]
  [+Yield] YieldExpression[?In, ?Await]
  ArrowFunction[?In, ?Yield, ?Await]
  AsyncArrowFunction[?In, ?Yield, ?Await]
  LeftHandSideExpression[?Yield, ?Await] = AssignmentExpression[?In, ?Yield, ?Await]
  LeftHandSideExpression[?Yield, ?Await] AssignmentOperator AssignmentExpression[?In, ?Yield, ?Await]
  LeftHandSideExpression[?Yield, ?Await] &&= AssignmentExpression[?In, ?Yield, ?Await]
  LeftHandSideExpression[?Yield, ?Await] ||= AssignmentExpression[?In, ?Yield, ?Await]
  LeftHandSideExpression[?Yield, ?Await] ??= AssignmentExpression[?In, ?Yield, ?Await]

AssignmentOperator : one of
  *= /= %= += -= <<= >>= >>>= &= ^= |= **=
```

#### 13.15.1 静态语义：早期错误
```javascript
AssignmentExpression : LeftHandSideExpression = AssignmentExpression
如果 LeftHandSideExpression 是 ObjectLiteral 或 ArrayLiteral，则 LeftHandSideExpression 必须覆盖 AssignmentPattern。
如果 LeftHandSideExpression 既不是 ObjectLiteral 也不是 ArrayLiteral，则如果 LeftHandSideExpression 的 AssignmentTargetType 不是 SIMPLE，则这是一个语法错误。

AssignmentExpression :
  LeftHandSideExpression AssignmentOperator AssignmentExpression
  LeftHandSideExpression &&= AssignmentExpression
  LeftHandSideExpression ||= AssignmentExpression
  LeftHandSideExpression ??= AssignmentExpression
如果 LeftHandSideExpression 的 AssignmentTargetType 不是 SIMPLE，则这是一个语法错误。
```

#### 13.15.2 运行时语义：求值
```javascript
AssignmentExpression : LeftHandSideExpression = AssignmentExpression
1. 如果 LeftHandSideExpression 既不是 ObjectLiteral 也不是 ArrayLiteral，则
  a. 令 lref 为 LeftHandSideExpression 的 ? Evaluation。
  b. 如果 IsAnonymousFunctionDefinition(AssignmentExpression) 为 true 且 IsIdentifierRef of LeftHandSideExpression 为 true，则
    i. 令 lhs 为 LeftHandSideExpression 的 StringValue。
    ii. 令 rval 为 NamedEvaluation of AssignmentExpression with argument lhs 的 ? Evaluation。
  c. 否则，
    i. 令 rref 为 AssignmentExpression 的 ? Evaluation。
    ii. 令 rval 为 rref 的 ? GetValue。
  d. 执行 ? PutValue(lref, rval)。
  e. 返回 rval。
2. 令 assignmentPattern 为被 LeftHandSideExpression 覆盖的 AssignmentPattern。
3. 令 rref 为 AssignmentExpression 的 ? Evaluation。
4. 令 rval 为 rref 的 ? GetValue。
5. 执行 ? DestructuringAssignmentEvaluation of assignmentPattern with argument rval。
6. 返回 rval。

AssignmentExpression : LeftHandSideExpression AssignmentOperator AssignmentExpression
1. 令 lref 为 LeftHandSideExpression 的 ? Evaluation。
2. 令 lval 为 lref 的 ? GetValue。
3. 令 rref 为 AssignmentExpression 的 ? Evaluation。
4. 令 rval 为 rref 的 ? GetValue。
5. 令 assignmentOpText 为 AssignmentOperator 匹配的源文本。
6. 令 opText 为与以下表中 assignmentOpText 关联的 Unicode 代码点序列：
```plaintext
assignmentOpText    opText
**=                **
*=                 *
/=                 /
%=                 %
+=                 +
-=                 -
<<=                <<
>>=                >>
>>>=               >>>
&=                 &
^=                 ^
|=                 |
```
7. 令 r 为 ? ApplyStringOrNumericBinaryOperator(lval, opText, rval)。
8. 执行 ? PutValue(lref, r)。
9. 返回 r。

AssignmentExpression : LeftHandSideExpression &&= AssignmentExpression
1. 令 lref 为 LeftHandSideExpression 的 ? Evaluation。
2. 令 lval 为 lref 的 ? GetValue。
3. 令 lbool 为 ToBoolean(lval)。
4. 如果 lbool 为 false，返回 lval。
5. 如果 IsAnonymousFunctionDefinition(AssignmentExpression) 为 true 且 IsIdentifierRef of LeftHandSideExpression 为 true，则
  a. 令 lhs 为 LeftHandSideExpression 的 StringValue。
  b. 令 rval 为 NamedEvaluation of AssignmentExpression with argument lhs 的 ? Evaluation。
6. 否则，
  a. 令 rref 为 AssignmentExpression 的 ? Evaluation。
  b. 令 rval 为 rref 的 ? GetValue。
7. 执行 ? PutValue(lref, rval)。
8. 返回 rval。

AssignmentExpression : LeftHandSideExpression ||= AssignmentExpression
1. 令 lref 为 LeftHandSideExpression 的 ? Evaluation。
2. 令 lval 为 lref 的 ? GetValue。
3. 令 lbool 为 ToBoolean(lval)。
4. 如果 lbool 为 true，返回 lval。
5. 如果 IsAnonymousFunctionDefinition(AssignmentExpression) 为 true 且 IsIdentifierRef of LeftHandSideExpression 为 true，则
  a. 令 lhs 为 LeftHandSideExpression 的 StringValue。
  b. 令 rval 为 NamedEvaluation of AssignmentExpression with argument lhs 的 ? Evaluation。
6. 否则，
  a. 令 rref 为 AssignmentExpression 的 ? Evaluation。
  b. 令 rval 为 rref 的 ? GetValue。
7. 执行 ? PutValue(lref, rval)。
8. 返回 rval。

AssignmentExpression : LeftHandSideExpression ??= AssignmentExpression
1. 令 lref 为 LeftHandSideExpression 的 ? Evaluation。
2. 令 lval 为 lref 的 ? GetValue。
3. 如果 lval 既不是 undefined 也不是 null，返回 lval。
4. 如果 IsAnonymousFunctionDefinition(AssignmentExpression) 为 true 且 IsIdentifierRef of LeftHandSideExpression 为 true，则
  a. 令 lhs 为 LeftHandSideExpression 的 StringValue。
  b. 令 rval 为 NamedEvaluation of AssignmentExpression with argument lhs 的 ? Evaluation。
5. 否则，
  a. 令 rref 为 AssignmentExpression 的 ? Evaluation。
  b. 令 rval 为 rref 的 ? GetValue。
6. 执行 ? PutValue(lref, rval)。
7. 返回 rval。
```

**注意**：当该表达式在严格模式代码中出现时，如果步骤 1.d、2、2、2、2 中的 lref 是一个不可解决的引用，则会发生运行时错误。如果是这样，则抛出 ReferenceError 异常。此外，如果步骤 8、7、7、6 中的 lref 是具有属性值 { [[Writable]]: false } 的数据属性的引用，或具有属性值 { [[Set]]: undefined } 的访问器属性的引用，或者是 IsExtensible 谓词返回值为 false 的对象的不存在属性的引用，则会发生运行时错误。在这些情况下会抛出 TypeError 异常。

#### 13.15.3 ApplyStringOrNumericBinaryOperator ( lval, opText, rval )
```javascript
ApplyStringOrNumericBinaryOperator ( lval, opText, rval )
抽象操作 `ApplyStringOrNumericBinaryOperator` 接受参数 `lval`（一个 ECMAScript 语言值），`opText`（**、*、/、%、+、-、<<、>>、>>>、&、^、| 之一），以及 `rval`（一个 ECMAScript 语言值），并返回一个包含字符串、BigInt 或数字的正常完成，或抛出异常。它在调用时执行以下步骤：

1. 如果 opText 是 +，则
  a. 令 lprim 为 lval 的 ? ToPrimitive。
  b. 令 rprim 为 rval 的 ? ToPrimitive。
  c. 如果 lprim 是字符串或 rprim 是字符串，则
    i. 令 lstr 为 lprim 的 ? ToString。
    ii. 令 rstr 为 rprim 的 ? ToString。
    iii. 返回 lstr 和 rstr 的字符串连接。
  d. 设置 lval 为 lprim。
  e. 设置 rval 为 rprim。
2. **注意**：此时，必须是数值运算。
3. 令 lnum 为 lval 的 ? ToNumeric。
4. 令 rnum 为 rval 的 ? ToNumeric。
5. 如果 lnum 的类型不是 rnum 的类型，则抛出 TypeError 异常。
6. 如果 lnum 是 BigInt，则
  a. 如果 opText 是 **，返回 ? BigInt::exponentiate(lnum, rnum)。
  b. 如果 opText 是 /，返回 ? BigInt::divide(lnum, rnum)。
  c. 如果 opText 是 %，返回 ? BigInt::remainder(lnum, rnum)。
  d. 如果 opText 是 >>>，返回 ? BigInt::unsignedRightShift(lnum, rnum)。
7. 令操作为与下表中 opText 和 lnum 类型关联的抽象操作：
```plaintext
opText	Type(lnum)	operation
**	Number	Number::exponentiate
*	Number	Number::multiply
*	BigInt	BigInt::multiply
/	Number	Number::divide
%	Number	Number::remainder
+	Number	Number::add
+	BigInt	BigInt::add
-	Number	Number::

subtract
-	BigInt	BigInt::subtract
<<	Number	Number::leftShift
<<	BigInt	BigInt::leftShift
>>	Number	Number::signedRightShift
>>	BigInt	BigInt::signedRightShift
>>>	Number	Number::unsignedRightShift
&	Number	Number::bitwiseAND
&	BigInt	BigInt::bitwiseAND
^	Number	Number::bitwiseXOR
^	BigInt	BigInt::bitwiseXOR
|	Number	Number::bitwiseOR
|	BigInt	BigInt::bitwiseOR
```
8. 返回 operation(lnum, rnum)。

**注意 1**：在步骤 1.a 和 1.b 中调用 ToPrimitive 时不提供提示。除了日期外，所有标准对象在没有提示的情况下都像给定 NUMBER 一样处理；日期在没有提示的情况下处理得像给定 STRING 一样。奇异对象可能以其他方式处理提示的缺失。

**注意 2**：步骤 1.c 不同于 IsLessThan 算法的步骤 3，使用逻辑或操作而不是逻辑与操作。

#### 13.15.4 EvaluateStringOrNumericBinaryExpression ( leftOperand, opText, rightOperand )
```javascript
EvaluateStringOrNumericBinaryExpression ( leftOperand, opText, rightOperand )
抽象操作 `EvaluateStringOrNumericBinaryExpression` 接受参数 `leftOperand`（一个 Parse Node）、`opText`（Unicode 代码点序列）和 `rightOperand`（一个 Parse Node），并返回一个包含字符串、BigInt 或数字的正常完成，或中断完成。它在调用时执行以下步骤：

1. 令 lref 为 leftOperand 的 ? Evaluation。
2. 令 lval 为 lref 的 ? GetValue。
3. 令 rref 为 rightOperand 的 ? Evaluation。
4. 令 rval 为 rref 的 ? GetValue。
5. 返回 ? ApplyStringOrNumericBinaryOperator(lval, opText, rval)。
```

#### 13.15.5 解构赋值
补充语法
在某些情况下，当处理以下产生式的一个实例时
```javascript
AssignmentExpression : LeftHandSideExpression = AssignmentExpression
```
对 LeftHandSideExpression 的解释会使用以下语法进行改进：

```javascript
AssignmentPattern[Yield, Await] :
  ObjectAssignmentPattern[?Yield, ?Await]
  ArrayAssignmentPattern[?Yield, ?Await]

ObjectAssignmentPattern[Yield, Await] :
  { }
  { AssignmentRestProperty[?Yield, ?Await] }
  { AssignmentPropertyList[?Yield, ?Await] }
  { AssignmentPropertyList[?Yield, ?Await] , AssignmentRestProperty[?Yield, ?Await]opt }

ArrayAssignmentPattern[Yield, Await] :
  [ Elisionopt AssignmentRestElement[?Yield, ?Await]opt ]
  [ AssignmentElementList[?Yield, ?Await] ]
  [ AssignmentElementList[?Yield, ?Await] , Elisionopt AssignmentRestElement[?Yield, ?Await]opt ]

AssignmentRestProperty[Yield, Await] :
  ... DestructuringAssignmentTarget[?Yield, ?Await]

AssignmentPropertyList[Yield, Await] :
  AssignmentProperty[?Yield, ?Await]
  AssignmentPropertyList[?Yield, ?Await] , AssignmentProperty[?Yield, ?Await]

AssignmentElementList[Yield, Await] :
  AssignmentElisionElement[?Yield, ?Await]
  AssignmentElementList[?Yield, ?Await] , AssignmentElisionElement[?Yield, ?Await]

AssignmentElisionElement[Yield, Await] :
  Elisionopt AssignmentElement[?Yield, ?Await]

AssignmentProperty[Yield, Await] :
  IdentifierReference[?Yield, ?Await] Initializer[+In, ?Yield, ?Await]opt
  PropertyName[?Yield, ?Await] : AssignmentElement[?Yield, ?Await]

AssignmentElement[Yield, Await] :
  DestructuringAssignmentTarget[?Yield, ?Await] Initializer[+In, ?Yield, ?Await]opt

AssignmentRestElement[Yield, Await] :
  ... DestructuringAssignmentTarget[?Yield, ?Await]

DestructuringAssignmentTarget[Yield, Await] :
  LeftHandSideExpression[?Yield, ?Await]
```

##### 13.15.5.1 静态语义：早期错误
```javascript
AssignmentProperty : IdentifierReference Initializeropt
如果 IdentifierReference 的 AssignmentTargetType 不是 SIMPLE，则这是一个语法错误。

AssignmentRestProperty : ... DestructuringAssignmentTarget
如果 DestructuringAssignmentTarget 是 ArrayLiteral 或 ObjectLiteral，则这是一个语法错误。

DestructuringAssignmentTarget : LeftHandSideExpression
如果 LeftHandSideExpression 是 ObjectLiteral 或 ArrayLiteral，则 LeftHandSideExpression 必须覆盖 AssignmentPattern。
如果 LeftHandSideExpression 既不是 ObjectLiteral 也不是 ArrayLiteral，则如果 LeftHandSideExpression 的 AssignmentTargetType 不是 SIMPLE，则这是一个语法错误。
```

##### 13.15.5.2 运行时语义：解构赋值求值
```javascript
ObjectAssignmentPattern : { }
1. 执行 ? RequireObjectCoercible(value)。
2. 返回 UNUSED。

ObjectAssignmentPattern :
  { AssignmentPropertyList }
  { AssignmentPropertyList , }
1. 执行 ? RequireObjectCoercible(value)。
2. 执行 ? PropertyDestructuringAssignmentEvaluation of AssignmentPropertyList with argument value。
3. 返回 UNUSED。

ObjectAssignmentPattern : { AssignmentRestProperty }
1. 执行 ? RequireObjectCoercible(value)。
2. 令 excludedNames 为一个新的空列表。
3. 返回 ? RestDestructuringAssignmentEvaluation of AssignmentRestProperty with arguments value and excludedNames。

ObjectAssignmentPattern : { AssignmentPropertyList , AssignmentRestProperty }
1. 执行 ? RequireObjectCoercible(value)。
2. 令 excludedNames 为 PropertyDestructuringAssignmentEvaluation of AssignmentPropertyList with argument value 的 ? 结果。
3. 返回 ? RestDestructuringAssignmentEvaluation of AssignmentRestProperty with arguments value and excludedNames。

ArrayAssignmentPattern : [ ]
1. 令 iteratorRecord 为 GetIterator(value, SYNC) 的 ? 结果。
2. 返回 IteratorClose(iteratorRecord, NormalCompletion(UNUSED)) 的 ? 结果。

ArrayAssignmentPattern : [ Elision ]
1. 令 iteratorRecord 为 GetIterator(value, SYNC) 的 ? 结果。
2. 令 result 为 Completion(IteratorDestructuringAssignmentEvaluation of Elision with argument iteratorRecord)。
3. 如果 iteratorRecord.[[Done]] 为 false，返回 IteratorClose(iteratorRecord, result) 的 ? 结果。
4. 返回 result。

ArrayAssignmentPattern : [ Elisionopt AssignmentRestElement ]
1. 令 iteratorRecord 为 GetIterator(value, SYNC) 的 ? 结果。
2. 如果 Elision 存在，则
  a. 令 status 为 Completion(IteratorDestructuringAssignmentEvaluation of Elision with argument iteratorRecord)。
  b. 如果 status 是一个突发完成，
    i. 断言：iteratorRecord.[[Done]] 为 true。
    ii. 返回 ? status。
3. 令 result 为 Completion(IteratorDestructuringAssignmentEvaluation of AssignmentRestElement with argument iteratorRecord)。
4. 如果 iteratorRecord.[[Done]] 为 false，返回 IteratorClose(iteratorRecord, result) 的 ? 结果。
5. 返回 result。

ArrayAssignmentPattern : [ AssignmentElementList ]
1. 令 iteratorRecord 为 GetIterator(value, SYNC) 的 ? 结果。
2. 令 result 为 Completion(IteratorDestructuringAssignmentEvaluation of AssignmentElementList with argument iteratorRecord)。
3. 如果 iteratorRecord.[[Done]] 为 false，返回 IteratorClose(iteratorRecord, result) 的 ? 结果。
4. 返回 result。

ArrayAssignmentPattern : [ AssignmentElementList , Elisionopt AssignmentRestElementopt ]
1. 令 iteratorRecord 为 GetIterator(value, SYNC) 的 ? 结果。
2. 令 status 为 Completion(IteratorDestructuringAssignmentEvaluation of AssignmentElementList with argument iteratorRecord)。
3. 如果 status 是一个突发完成，
  a. 如果 iteratorRecord.[[Done]] 为 false，返回 IteratorClose(iteratorRecord, status) 的 ? 结果。
  b. 返回 ? status。
4. 如果 Elision 存在，则
  a. 设置 status 为 Completion(IteratorDestructuringAssignmentEvaluation of Elision with argument iteratorRecord)。
  b. 如果 status 是一个突发完成，
    i. 断言：iteratorRecord.[[Done]] 为 true。
    ii. 返回 ? status。
5. 如果 AssignmentRestElement 存在，则
  a. 设置 status 为 Completion(IteratorDestructuringAssignmentEvaluation of AssignmentRestElement with argument iteratorRecord)。
6. 如果 iteratorRecord.[[Done]] 为 false，返回 IteratorClose(iteratorRecord, status) 的 ? 结果。
7. 返回 ? status。
```

##### 13.15.5.3 运行时语义：PropertyDestructuringAssignmentEvaluation
```javascript
PropertyDestructuringAssignmentEvaluation ( value )
语法导向操作 `PropertyDestructuringAssignmentEvaluation` 接受参数 value（一个 ECMAScript 语言值），并返回包含属性键列表的正常完成，或中断完成。它收集所有解构属性键的列表。根据以下产生式分段定义：

AssignmentPropertyList : AssignmentPropertyList , AssignmentProperty
1. 令 propertyNames 为 PropertyDestructuringAssignmentEvaluation of AssignmentPropertyList with argument value 的 ? 结果。
2. 令 nextNames 为 PropertyDestructuringAssignmentEvaluation of AssignmentProperty with

 argument value 的 ? 结果。
3. 返回 propertyNames 和 nextNames 的列表连接。

AssignmentProperty : IdentifierReference Initializeropt
1. 令 P 为 IdentifierReference 的 StringValue。
2. 令 lref 为 ResolveBinding(P) 的 ? 结果。
3. 令 v 为 GetV(value, P) 的 ? 结果。
4. 如果 Initializer 存在且 v 为 undefined，则
  a. 如果 IsAnonymousFunctionDefinition(Initializer) 为 true，则
    i. 设置 v 为 NamedEvaluation of Initializer with argument P 的 ? 结果。
  b. 否则，
    i. 令 defaultValue 为 Initializer 的 ? Evaluation。
    ii. 设置 v 为 defaultValue 的 ? GetValue。
5. 执行 ? PutValue(lref, v)。
6. 返回 « P »。

AssignmentProperty : PropertyName : AssignmentElement
1. 令 name 为 PropertyName 的 ? Evaluation。
2. 执行 ? KeyedDestructuringAssignmentEvaluation of AssignmentElement with arguments value and name。
3. 返回 « name »。
```

##### 13.15.5.4 运行时语义：RestDestructuringAssignmentEvaluation
```javascript
RestDestructuringAssignmentEvaluation ( value, excludedNames )
语法导向操作 `RestDestructuringAssignmentEvaluation` 接受参数 value（一个 ECMAScript 语言值）和 excludedNames（属性键列表），并返回包含 UNUSED 的正常完成，或中断完成。根据以下产生式分段定义：

AssignmentRestProperty : ... DestructuringAssignmentTarget
1. 令 lref 为 DestructuringAssignmentTarget 的 ? Evaluation。
2. 令 restObj 为 OrdinaryObjectCreate(%Object.prototype%)。
3. 执行 ? CopyDataProperties(restObj, value, excludedNames)。
4. 返回 ? PutValue(lref, restObj)。
```

##### 13.15.5.5 运行时语义：IteratorDestructuringAssignmentEvaluation
```javascript
IteratorDestructuringAssignmentEvaluation ( iteratorRecord )
语法导向操作 `IteratorDestructuringAssignmentEvaluation` 接受参数 iteratorRecord（一个迭代器记录），并返回包含 UNUSED 的正常完成，或中断完成。根据以下产生式分段定义：

AssignmentElementList : AssignmentElisionElement
1. 返回 IteratorDestructuringAssignmentEvaluation of AssignmentElisionElement with argument iteratorRecord 的 ? 结果。

AssignmentElementList : AssignmentElementList , AssignmentElisionElement
1. 执行 IteratorDestructuringAssignmentEvaluation of AssignmentElementList with argument iteratorRecord 的 ? 结果。
2. 返回 IteratorDestructuringAssignmentEvaluation of AssignmentElisionElement with argument iteratorRecord 的 ? 结果。

AssignmentElisionElement : AssignmentElement
1. 返回 IteratorDestructuringAssignmentEvaluation of AssignmentElement with argument iteratorRecord 的 ? 结果。

AssignmentElisionElement : Elision AssignmentElement
1. 执行 IteratorDestructuringAssignmentEvaluation of Elision with argument iteratorRecord 的 ? 结果。
2. 返回 IteratorDestructuringAssignmentEvaluation of AssignmentElement with argument iteratorRecord 的 ? 结果。

Elision : ,
1. 如果 iteratorRecord.[[Done]] 为 false，则
  a. 执行 IteratorStep(iteratorRecord) 的 ? 结果。
2. 返回 UNUSED。

Elision : Elision ,
1. 执行 IteratorDestructuringAssignmentEvaluation of Elision with argument iteratorRecord 的 ? 结果。
2. 如果 iteratorRecord.[[Done]] 为 false，则
  a. 执行 IteratorStep(iteratorRecord) 的 ? 结果。
3. 返回 UNUSED。

AssignmentElement : DestructuringAssignmentTarget Initializeropt
1. 如果 DestructuringAssignmentTarget 既不是 ObjectLiteral 也不是 ArrayLiteral，则
  a. 令 lref 为 DestructuringAssignmentTarget 的 ? Evaluation。
2. 令 value 为 undefined。
3. 如果 iteratorRecord.[[Done]] 为 false，则
  a. 令 next 为 IteratorStepValue(iteratorRecord) 的 ? 结果。
  b. 如果 next 不是 DONE，则
    i. 设置 value 为 next。
4. 如果 Initializer 存在且 value 为 undefined，则
  a. 如果 IsAnonymousFunctionDefinition(Initializer) 为 true 且 IsIdentifierRef of DestructuringAssignmentTarget 为 true，则
    i. 令 target 为 DestructuringAssignmentTarget 的 StringValue。
    ii. 令 v 为 NamedEvaluation of Initializer with argument target 的 ? 结果。
  b. 否则，
    i. 令 defaultValue 为 Initializer 的 ? Evaluation。
    ii. 令 v 为 defaultValue 的 ? GetValue。
5. 否则，
  a. 令 v 为 value。
6. 如果 DestructuringAssignmentTarget 是 ObjectLiteral 或 ArrayLiteral，则
  a. 令 nestedAssignmentPattern 为被 DestructuringAssignmentTarget 覆盖的 AssignmentPattern。
  b. 返回 DestructuringAssignmentEvaluation of nestedAssignmentPattern with argument v 的 ? 结果。
7. 返回 ? PutValue(lref, v)。

**注意**：从左到右的求值顺序通过在访问迭代器或求值 Initializer 之前求值一个不是解构模式的 DestructuringAssignmentTarget 来维护。

AssignmentRestElement : ... DestructuringAssignmentTarget
1. 如果 DestructuringAssignmentTarget 既不是 ObjectLiteral 也不是 ArrayLiteral，则
  a. 令 lref 为 DestructuringAssignmentTarget 的 ? Evaluation。
2. 令 A 为 ! ArrayCreate(0)。
3. 令 n 为 0。
4. 重复，直到 iteratorRecord.[[Done]] 为 false，
  a. 令 next 为 IteratorStepValue(iteratorRecord) 的 ? 结果。
  b. 如果 next 不是 DONE，则
    i. 执行 ! CreateDataPropertyOrThrow(A, ! ToString(𝔽(n)), next)。
    ii. 设置 n 为 n + 1。
5. 如果 DestructuringAssignmentTarget 既不是 ObjectLiteral 也不是 ArrayLiteral，则
  a. 返回 ? PutValue(lref, A)。
6. 令 nestedAssignmentPattern 为被 DestructuringAssignmentTarget 覆盖的 AssignmentPattern。
7. 返回 DestructuringAssignmentEvaluation of nestedAssignmentPattern with argument A 的 ? 结果。
```

##### 13.15.5.6 运行时语义：KeyedDestructuringAssignmentEvaluation
```javascript
KeyedDestructuringAssignmentEvaluation ( value, propertyName )
语法导向操作 `KeyedDestructuringAssignmentEvaluation` 接受参数 value（一个 ECMAScript 语言值）和 propertyName（一个属性键），并返回包含 UNUSED 的正常完成，或中断完成。根据以下产生式分段定义：

AssignmentElement : DestructuringAssignmentTarget Initializeropt
1. 如果 DestructuringAssignmentTarget 既不是 ObjectLiteral 也不是 ArrayLiteral，则
  a. 令 lref 为 DestructuringAssignmentTarget 的 ? Evaluation。
2. 令 v 为 GetV(value, propertyName) 的 ? 结果。
3. 如果 Initializer 存在且 v 为 undefined，则
  a. 如果 IsAnonymousFunctionDefinition(Initializer) 为 true 且 IsIdentifierRef of DestructuringAssignmentTarget 为 true，则
    i. 令 target 为 DestructuringAssignmentTarget 的 StringValue。
    ii. 令 rhsValue 为 NamedEvaluation of Initializer with argument target 的 ? 结果。
  b. 否则，
    i. 令 defaultValue 为 Initializer 的 ? Evaluation。
    ii. 令 rhsValue 为 defaultValue 的 ? GetValue。
4. 否则，
  a. 令 rhsValue 为 v。
5. 如果 DestructuringAssignmentTarget 是 ObjectLiteral 或 ArrayLiteral，则
  a. 令 assignmentPattern 为被 DestructuringAssignmentTarget 覆盖的 AssignmentPattern。
  b. 返回 DestructuringAssignmentEvaluation of assignmentPattern with argument rhsValue 的 ? 结果。
6. 返回 ? PutValue(lref, rhsValue)。
```

### 13.16 逗号运算符 ( , )

#### 语法
```javascript
Expression[In, Yield, Await] :
  AssignmentExpression[?In, ?Yield, ?Await]
  Expression[?In, ?Yield, ?Await] , AssignmentExpression[?In, ?Yield, ?Await]
```

#### 13.16.1 运行时语义：求值
```javascript
Expression : Expression , AssignmentExpression
1. 令 lref 为 Expression 的 ? Evaluation。
2. 执行 lref 的 ? GetValue。
3. 令 rref 为 AssignmentExpression 的 ? Evaluation。
4. 返回 rref 的 ? GetValue。

**注意**：必须调用 GetValue，即使其值未被使用，因为它可能具有可观察的副作用。
```

### 14 ECMAScript 语言：语句和声明

#### 语法
```javascript
Statement[Yield, Await, Return] :
  BlockStatement[?Yield, ?Await, ?Return]
  VariableStatement[?Yield, ?Await]
  EmptyStatement
  ExpressionStatement[?Yield, ?Await]
  IfStatement[?Yield, ?Await, ?Return]
  BreakableStatement[?Yield, ?Await, ?Return]
  ContinueStatement[?Yield, ?Await]
  BreakStatement[?Yield, ?Await]
  [+Return] ReturnStatement[?Yield, ?Await]
  WithStatement[?Yield, ?Await, ?Return]
  LabelledStatement[?Yield, ?Await, ?Return]
  ThrowStatement[?Yield, ?Await]
  TryStatement[?Yield, ?Await, ?Return]
  DebuggerStatement
Declaration[Yield, Await] :
  HoistableDeclaration[?Yield, ?Await, ~Default]
  ClassDeclaration[?Yield, ?Await, ~Default]
  LexicalDeclaration[+In, ?Yield, ?Await]
HoistableDeclaration[Yield, Await, Default] :
  FunctionDeclaration[?Yield, ?Await, ?Default]
  GeneratorDeclaration[?Yield, ?Await, ?Default]
  AsyncFunctionDeclaration[?Yield, ?Await, ?Default]
  AsyncGeneratorDeclaration[?Yield, ?Await, ?Default]
BreakableStatement[Yield, Await, Return] :
  IterationStatement[?Yield, ?Await, ?Return]
  SwitchStatement[?Yield, ?Await, ?Return]
```

#### 14.1 语句语义

##### 14.1.1 运行时语义：求值

**HoistableDeclaration** : GeneratorDeclaration / AsyncFunctionDeclaration / AsyncGeneratorDeclaration
1. 返回 EMPTY。

**HoistableDeclaration** : FunctionDeclaration
1. 返回 FunctionDeclaration 的 ? 求值结果。

**BreakableStatement** : IterationStatement / SwitchStatement
1. 令 newLabelSet 为一个新的空列表。
2. 返回带有 newLabelSet 参数的此 BreakableStatement 的 ? LabelledEvaluation 结果。

#### 14.2 代码块

##### 语法
```javascript
BlockStatement[Yield, Await, Return] :
  Block[?Yield, ?Await, ?Return]

Block[Yield, Await, Return] :
  { StatementList[?Yield, ?Await, ?Return]opt }

StatementList[Yield, Await, Return] :
  StatementListItem[?Yield, ?Await, ?Return]
  StatementList[?Yield, ?Await, ?Return] StatementListItem[?Yield, ?Await, ?Return]

StatementListItem[Yield, Await, Return] :
  Statement[?Yield, ?Await, ?Return]
  Declaration[?Yield, ?Await]
```

##### 14.2.1 静态语义：早期错误
**Block** : { **StatementList** }
- 如果 StatementList 的 LexicallyDeclaredNames 包含任何重复条目，则为语法错误。
- 如果 StatementList 的 LexicallyDeclaredNames 中的任何元素也出现在 StatementList 的 VarDeclaredNames 中，则为语法错误。

##### 14.2.2 运行时语义：求值
**Block** : { }
1. 返回 EMPTY。

**Block** : { **StatementList** }
1. 令 oldEnv 为运行执行上下文的 LexicalEnvironment。
2. 令 blockEnv 为 NewDeclarativeEnvironment(oldEnv)。
3. 执行 BlockDeclarationInstantiation(StatementList, blockEnv)。
4. 将运行执行上下文的 LexicalEnvironment 设置为 blockEnv。
5. 令 blockValue 为 Completion(Evaluation of StatementList)。
6. 将运行执行上下文的 LexicalEnvironment 设置回 oldEnv。
7. 返回 ? blockValue。

**注意1**：无论如何控制离开 Block，LexicalEnvironment 总是恢复到其原始状态。

**StatementList** : StatementList StatementListItem
1. 令 sl 为 StatementList 的 ? 求值结果。
2. 令 s 为 StatementListItem 的 Completion(Evaluation) 结果。
3. 返回 ? UpdateEmpty(s, sl)。

**注意2**：StatementList 的值是 StatementList 中最后一个值产生项的值。例如，以下对 eval 函数的调用都返回值 1：

```javascript
eval("1;;;;;")
eval("1;{}")
eval("1;var a;")
```

##### 14.2.3 BlockDeclarationInstantiation (code, env)
抽象操作 BlockDeclarationInstantiation 接受参数 code（一个解析节点）和 env（一个声明环境记录）并返回 UNUSED。code 是对应块体的解析节点。env 是要创建绑定的环境记录。

**注意**：当评估 Block 或 CaseBlock 时，会创建一个新的声明环境记录，并在环境记录中实例化每个块作用域变量、常量、函数或类的绑定。

调用时执行以下步骤：
1. 令 declarations 为 code 的 LexicallyScopedDeclarations。
2. 令 privateEnv 为运行执行上下文的 PrivateEnvironment。
3. 对于 declarations 中的每个元素 d，
  a. 对于 d 的 BoundNames 中的每个元素 dn，
    i. 如果 d 的 IsConstantDeclaration 为 true，
      1. 执行 ! env.CreateImmutableBinding(dn, true)。
    ii. 否则，
      1. 执行 ! env.CreateMutableBinding(dn, false)。**注意**：此步骤在 B.3.2.6 节中被替换。
  b. 如果 d 是 FunctionDeclaration、GeneratorDeclaration、AsyncFunctionDeclaration 或 AsyncGeneratorDeclaration，
    i. 令 fn 为 d 的 BoundNames 的唯一元素。
    ii. 令 fo 为 d 的 InstantiateFunctionObject 结果，参数为 env 和 privateEnv。
    iii. 执行 ! env.InitializeBinding(fn, fo)。**注意**：此步骤在 B.3.2.6 节中被替换。
4. 返回 UNUSED。

#### 14.3 声明和变量声明

##### 14.3.1 let 和 const 声明

**注意**：let 和 const 声明定义的变量作用域为运行执行上下文的 LexicalEnvironment。这些变量在其包含的环境记录实例化时被创建，但在其 LexicalBinding 求值之前不能以任何方式访问。由带有 Initializer 的 LexicalBinding 定义的变量在 LexicalBinding 求值时被赋值为 Initializer 的 AssignmentExpression 的值，而不是在变量创建时。如果 let 声明中的 LexicalBinding 没有 Initializer，则在 LexicalBinding 求值时变量被赋值为 undefined。

##### 语法
```javascript
LexicalDeclaration[In, Yield, Await] :
  LetOrConst BindingList[?In, ?Yield, ?Await] ;

LetOrConst :
  let
  const

BindingList[In, Yield, Await] :
  LexicalBinding[?In, ?Yield, ?Await]
  BindingList[?In, ?Yield, ?Await] , LexicalBinding[?In, ?Yield, ?Await]

LexicalBinding[In, Yield, Await] :
  BindingIdentifier[?Yield, ?Await] Initializer[?In, ?Yield, ?Await]opt
  BindingPattern[?Yield, ?Await] Initializer[?In, ?Yield, ?Await]
```

##### 14.3.1.1 静态语义：早期错误
**LexicalDeclaration** : LetOrConst BindingList ;
- 如果 BindingList 的 BoundNames 包含 "let"，则为语法错误。
- 如果 BindingList 的 BoundNames 包含任何重复条目，则为语法错误。

**LexicalBinding** : BindingIdentifier Initializeropt
- 如果 Initializer 不存在且包含此 LexicalBinding 的 LexicalDeclaration 的 IsConstantDeclaration 为 true，则为语法错误。

##### 14.3.1.2 运行时语义：求值
**LexicalDeclaration** : LetOrConst BindingList ;
1. 执行 BindingList 的 ? 求值。
2. 返回 EMPTY。

**BindingList** : BindingList , LexicalBinding
1. 执行 BindingList 的 ? 求值。
2. 返回 LexicalBinding 的 ? 求值结果。

**LexicalBinding** : BindingIdentifier
1. 令 lhs 为 BindingIdentifier 的 StringValue 的 ! ResolveBinding 结果。
2. 执行 ! InitializeReferencedBinding(lhs, undefined)。
3. 返回 EMPTY。

**注意**：静态语义规则确保此形式的 LexicalBinding 不会出现在 const 声明中。

**LexicalBinding** : BindingIdentifier Initializer
1. 令 bindingId 为 BindingIdentifier 的 StringValue。
2. 令 lhs 为 bindingId 的 ! ResolveBinding 结果。
3. 如果 Initializer 的 IsAnonymousFunctionDefinition 为 true，
  a. 令 value 为 bindingId 参数的 Initializer 的 ? NamedEvaluation 结果。
4. 否则，
  a. 令 rhs 为 Initializer 的 ? 求值结果。
  b. 令 value 为 rhs 的 ? GetValue 结果。
5. 执行 ! InitializeReferencedBinding(lhs, value)。
6. 返回 EMPTY。

**LexicalBinding** : BindingPattern Initializer
1. 令 rhs 为 Initializer 的 ? 求值结果。
2. 令 value 为 rhs 的 ? GetValue 结果。
3. 令 env 为运行执行上下文的 LexicalEnvironment。
4. 返回 BindingPattern 的 BindingInitialization

，参数为 value 和 env。

##### 14.3.2 变量声明

**注意**：var 声明定义的变量作用域为运行执行上下文的 VariableEnvironment。Var 变量在其包含的环境记录实例化时被创建，并在创建时初始化为 undefined。在任何 VariableEnvironment 范围内，VariableDeclaration 中的通用 BindingIdentifier 可能会出现多次，但这些声明只定义一个变量。由带有 Initializer 的 VariableDeclaration 定义的变量在 VariableDeclaration 执行时被赋值为 Initializer 的 AssignmentExpression 的值，而不是在变量创建时。

##### 语法
```javascript
VariableStatement[Yield, Await] :
  var VariableDeclarationList[+In, ?Yield, ?Await] ;

VariableDeclarationList[In, Yield, Await] :
  VariableDeclaration[?In, ?Yield, ?Await]
  VariableDeclarationList[?In, ?Yield, ?Await] , VariableDeclaration[?In, ?Yield, ?Await]

VariableDeclaration[In, Yield, Await] :
  BindingIdentifier[?Yield, ?Await] Initializer[?In, ?Yield, ?Await]opt
  BindingPattern[?Yield, ?Await] Initializer[?In, ?Yield, ?Await]
```

##### 14.3.2.1 运行时语义：求值
**VariableStatement** : var **VariableDeclarationList** ;
1. 执行 VariableDeclarationList 的 ? 求值。
2. 返回 EMPTY。

**VariableDeclarationList** : VariableDeclarationList , **VariableDeclaration**
1. 执行 VariableDeclarationList 的 ? 求值。
2. 返回 VariableDeclaration 的 ? 求值结果。

**VariableDeclaration** : BindingIdentifier
1. 返回 EMPTY。

**VariableDeclaration** : BindingIdentifier Initializer
1. 令 bindingId 为 BindingIdentifier 的 StringValue。
2. 令 lhs 为 bindingId 的 ? ResolveBinding 结果。
3. 如果 Initializer 的 IsAnonymousFunctionDefinition 为 true，
  a. 令 value 为 bindingId 参数的 Initializer 的 ? NamedEvaluation 结果。
4. 否则，
  a. 令 rhs 为 Initializer 的 ? 求值结果。
  b. 令 value 为 rhs 的 ? GetValue 结果。
5. 执行 ? PutValue(lhs, value)。
6. 返回 EMPTY。

**注意**：如果 VariableDeclaration 嵌套在 with 语句中且 VariableDeclaration 中的 BindingIdentifier 与 with 语句的对象环境记录的绑定对象的属性名相同，则第 5 步将为属性赋值，而不是为 Identifier 的 VariableEnvironment 绑定赋值。

**VariableDeclaration** : BindingPattern Initializer
1. 令 rhs 为 Initializer 的 ? 求值结果。
2. 令 rval 为 rhs 的 ? GetValue 结果。
3. 返回 BindingPattern 的 BindingInitialization，参数为 rval 和 undefined。

##### 14.3.3 解构绑定模式

##### 语法
```javascript
BindingPattern[Yield, Await] :
  ObjectBindingPattern[?Yield, ?Await]
  ArrayBindingPattern[?Yield, ?Await]

ObjectBindingPattern[Yield, Await] :
  { }
  { BindingRestProperty[?Yield, ?Await] }
  { BindingPropertyList[?Yield, ?Await] }
  { BindingPropertyList[?Yield, ?Await] , BindingRestProperty[?Yield, ?Await]opt }

ArrayBindingPattern[Yield, Await] :
  [ Elisionopt BindingRestElement[?Yield, ?Await]opt ]
  [ BindingElementList[?Yield, ?Await] ]
  [ BindingElementList[?Yield, ?Await] , Elisionopt BindingRestElement[?Yield, ?Await]opt ]

BindingRestProperty[Yield, Await] :
  ... BindingIdentifier[?Yield, ?Await]

BindingPropertyList[Yield, Await] :
  BindingProperty[?Yield, ?Await]
  BindingPropertyList[?Yield, ?Await] , BindingProperty[?Yield, ?Await]

BindingElementList[Yield, Await] :
  BindingElisionElement[?Yield, ?Await]
  BindingElementList[?Yield, ?Await] , BindingElisionElement[?Yield, ?Await]

BindingElisionElement[Yield, Await] :
  Elisionopt BindingElement[?Yield, ?Await]

BindingProperty[Yield, Await] :
  SingleNameBinding[?Yield, ?Await]
  PropertyName[?Yield, ?Await] : BindingElement[?Yield, ?Await]

BindingElement[Yield, Await] :
  SingleNameBinding[?Yield, ?Await]
  BindingPattern[?Yield, ?Await] Initializer[+In, ?Yield, ?Await]opt

SingleNameBinding[Yield, Await] :
  BindingIdentifier[?Yield, ?Await] Initializer[+In, ?Yield, ?Await]opt

BindingRestElement[Yield, Await] :
  ... BindingIdentifier[?Yield, ?Await]
  ... BindingPattern[?Yield, ?Await]
```

##### 14.3.3.1 运行时语义：属性绑定初始化

语法定向操作 PropertyBindingInitialization 接受参数 value（一个 ECMAScript 语言值）和 environment（一个环境记录或 undefined），返回包含属性键列表的正常完成或突发完成。它收集所有绑定属性名的列表。它在以下规则中分段定义：

**BindingPropertyList** : BindingPropertyList , **BindingProperty**
1. 令 boundNames 为 PropertyBindingInitialization，参数为 value 和 environment 的 ? 求值结果。
2. 令 nextNames 为 BindingProperty，参数为 value 和 environment 的 ? 求值结果。
3. 返回 boundNames 和 nextNames 的列表连接。

**BindingProperty** : SingleNameBinding
1. 令 name 为 SingleNameBinding 的 BoundNames 唯一元素。
2. 执行 KeyedBindingInitialization，参数为 value，environment 和 name 的 ? 求值结果。
3. 返回 « name »。

**BindingProperty** : PropertyName : **BindingElement**
1. 令 P 为 PropertyName 的 ? 求值结果。
2. 执行 KeyedBindingInitialization，参数为 value，environment 和 P 的 ? 求值结果。
3. 返回 « P »。

##### 14.3.3.2 运行时语义：剩余绑定初始化

语法定向操作 RestBindingInitialization 接受参数 value（一个 ECMAScript 语言值），environment（一个环境记录或 undefined）和 excludedNames（一个属性键列表），返回包含 UNUSED 的正常完成或突发完成。它在以下规则中分段定义：

**BindingRestProperty** : ... BindingIdentifier
1. 令 lhs 为 StringValue of BindingIdentifier 的 ? ResolveBinding 结果。
2. 令 restObj 为 OrdinaryObjectCreate(%Object.prototype%)。
3. 执行 CopyDataProperties(restObj, value, excludedNames) 的 ? 求值结果。
4. 如果 environment 是 undefined，则返回 PutValue(lhs, restObj) 的 ? 求值结果。
5. 返回 InitializeReferencedBinding(lhs, restObj) 的 ? 求值结果。

##### 14.3.3.3 运行时语义：键绑定初始化

语法定向操作 KeyedBindingInitialization 接受参数 value（一个 ECMAScript 语言值），environment（一个环境记录或 undefined）和 propertyName（一个属性键），返回包含 UNUSED 的正常完成或突发完成。

**注意**：undefined 作为 environment 传递时表示应该使用 PutValue 操作分配初始化值。对于 var 语句和某些非严格函数的形式参数列表（见 10.2.11），这种情况会发生。在这些情况下，在评估初始化器之前会提升和预初始化词法绑定。

它在以下规则中分段定义：

**BindingElement** : BindingPattern Initializeropt
1. 令 v 为 GetV(value, propertyName) 的 ? 求值结果。
2. 如果 Initializer 存在且 v 是 undefined，
  a. 令 defaultValue 为 Initializer 的 ? 求值结果。
  b. 令 v 为 defaultValue 的 ? GetValue 结果。
3. 返回 BindingPattern 的 BindingInitialization，参数为 v 和 environment 的 ? 求值结果。

**SingleNameBinding** : BindingIdentifier Initializeropt
1. 令 bindingId 为 BindingIdentifier 的 StringValue。
2. 令 lhs 为 bindingId，environment 的 ? ResolveBinding 结果。
3. 令 v 为 GetV(value, propertyName) 的 ? 求值结果。
4. 如果 Initializer 存在且 v 是 undefined，
  a. 如果 Initializer 的 IsAnonymousFunctionDefinition 为 true，
    i. 令 v 为 bindingId 参数的 Initializer 的 ? NamedEvaluation 结果。
  b. 否则，
    i. 令 defaultValue 为 Initializer 的 ? 求值结果。
    ii. 令 v 为 defaultValue 的 ? GetValue 结果。
5. 如果 environment 是 undefined，则返回 PutValue(lhs, v) 的 ? 求值结果。
6. 返回 InitializeReferencedBinding(lhs, v) 的 ? 求值结果。

#### 14.4 空语句

##### 语法
```javascript
EmptyStatement :
  ;
```

##### 14.4.1 运行时语义：求值
**EmptyStatement** : ;
1. 返回 EMPTY。

#### 14.5 表达式语句

##### 语法
```javascript
ExpressionStatement[Yield, Await] :
  [lookahead ∉ { {, function, async [no LineTerminator here] function, class, let [ }] Expression[+In, ?Yield, ?Await

] ;
```

**注意**：表达式语句不能以 U+007B（左花括号）开头，因为这可能会使其与 Block 模糊不清。表达式语句不能以 function 或 class 关键字开头，因为这会使其与 FunctionDeclaration、GeneratorDeclaration 或 ClassDeclaration 模糊不清。表达式语句不能以 async function 开头，因为这会使其与 AsyncFunctionDeclaration 或 AsyncGeneratorDeclaration 模糊不清。表达式语句不能以 let [ 开头，因为这会使其与以 ArrayBindingPattern 开头的 let LexicalDeclaration 模糊不清。

##### 14.5.1 运行时语义：求值
**ExpressionStatement** : Expression ;
1. 令 exprRef 为 Expression 的 ? 求值结果。
2. 返回 exprRef 的 ? GetValue 结果。

#### 14.6 if 语句

##### 语法
```javascript
IfStatement[Yield, Await, Return] :
  if ( Expression[+In, ?Yield, ?Await] ) Statement[?Yield, ?Await, ?Return] else Statement[?Yield, ?Await, ?Return]
  if ( Expression[+In, ?Yield, ?Await] ) Statement[?Yield, ?Await, ?Return] [lookahead ≠ else]
```

**注意**：lookahead-restriction [lookahead ≠ else] 以通常方式解决了经典的“悬挂 else”问题。即，当关联的 if 的选择具有歧义时，else 与最近的（最内层的）候选 if 关联。

##### 14.6.1 静态语义：早期错误
**IfStatement** : if ( **Expression** ) **Statement** else **Statement**
- 如果第一个 Statement 的 IsLabelledFunction 为 true，则为语法错误。
- 如果第二个 Statement 的 IsLabelledFunction 为 true，则为语法错误。

**IfStatement** : if ( **Expression** ) **Statement**
- 如果 Statement 的 IsLabelledFunction 为 true，则为语法错误。

**注意**：仅在实现了 B.3.1 中指定的扩展时才需要应用此规则。

##### 14.6.2 运行时语义：求值
**IfStatement** : if ( **Expression** ) **Statement** else **Statement**
1. 令 exprRef 为 Expression 的 ? 求值结果。
2. 令 exprValue 为 ToBoolean(? GetValue(exprRef))。
3. 如果 exprValue 为 true，
  a. 令 stmtCompletion 为第一个 Statement 的 Completion(Evaluation) 结果。
4. 否则，
  a. 令 stmtCompletion 为第二个 Statement 的 Completion(Evaluation) 结果。
5. 返回 ? UpdateEmpty(stmtCompletion, undefined)。

**IfStatement** : if ( **Expression** ) **Statement**
1. 令 exprRef 为 Expression 的 ? 求值结果。
2. 令 exprValue 为 ToBoolean(? GetValue(exprRef))。
3. 如果 exprValue 为 false，
  a. 返回 undefined。
4. 否则，
  a. 令 stmtCompletion 为 Statement 的 Completion(Evaluation) 结果。
  b. 返回 ? UpdateEmpty(stmtCompletion, undefined)。

#### 14.7 迭代语句

##### 语法
```javascript
IterationStatement[Yield, Await, Return] :
  DoWhileStatement[?Yield, ?Await, ?Return]
  WhileStatement[?Yield, ?Await, ?Return]
  ForStatement[?Yield, ?Await, ?Return]
  ForInOfStatement[?Yield, ?Await, ?Return]
```

##### 14.7.1 语义

###### 14.7.1.1 LoopContinues (completion, labelSet)
抽象操作 LoopContinues 接受参数 completion（一个完成记录）和 labelSet（一个字符串列表），返回布尔值。调用时执行以下步骤：

1. 如果 completion 是正常完成，返回 true。
2. 如果 completion 不是继续完成，返回 false。
3. 如果 completion.[[Target]] 是 EMPTY，返回 true。
4. 如果 labelSet 包含 completion.[[Target]]，返回 true。
5. 返回 false。

**注意**：在 IterationStatement 的 Statement 部分内，可以使用 ContinueStatement 开始新的迭代。

###### 14.7.1.2 运行时语义：LoopEvaluation
语法定向操作 LoopEvaluation 接受参数 labelSet（一个字符串列表），返回包含 ECMAScript 语言值的正常完成或突发完成。它在以下规则中分段定义：

**IterationStatement** : DoWhileStatement
1. 返回 DoWhileStatement 带有 labelSet 参数的 DoWhileLoopEvaluation 结果。

**IterationStatement** : WhileStatement
1. 返回 WhileStatement 带有 labelSet 参数的 WhileLoopEvaluation 结果。

**IterationStatement** : ForStatement
1. 返回 ForStatement 带有 labelSet 参数的 ForLoopEvaluation 结果。

**IterationStatement** : ForInOfStatement
1. 返回 ForInOfStatement 带有 labelSet 参数的 ForInOfLoopEvaluation 结果。

#### 14.7.2 do-while 语句

##### 语法
```javascript
DoWhileStatement[Yield, Await, Return] :
  do Statement[?Yield, ?Await, ?Return] while ( Expression[+In, ?Yield, ?Await] ) ;
```

##### 14.7.2.1 静态语义：早期错误
**DoWhileStatement** : do **Statement** while (**Expression**) ;
- 如果 Statement 的 IsLabelledFunction 为 true，则为语法错误。

**注意**：仅在实现了 B.3.1 中指定的扩展时才需要应用此规则。

##### 14.7.2.2 运行时语义：DoWhileLoopEvaluation
语法定向操作 DoWhileLoopEvaluation 接受参数 labelSet（一个字符串列表），返回包含 ECMAScript 语言值的正常完成或突发完成。它在以下规则中分段定义：

**DoWhileStatement** : do **Statement** while (**Expression**) ;
1. 令 V 为 undefined。
2. 重复以下步骤：
  a. 令 stmtResult 为 Statement 的 Completion(Evaluation) 结果。
  b. 如果 LoopContinues(stmtResult, labelSet) 为 false，返回 ? UpdateEmpty(stmtResult, V)。
  c. 如果 stmtResult.[[Value]] 不是 EMPTY，设置 V 为 stmtResult.[[Value]]。
  d. 令 exprRef 为 Expression 的 ? 求值结果。
  e. 令 exprValue 为 ? GetValue(exprRef)。
  f. 如果 ToBoolean(exprValue) 为 false，返回 V。

#### 14.7.3 while 语句

##### 语法
```javascript
WhileStatement[Yield, Await, Return] :
  while ( Expression[+In, ?Yield, ?Await] ) Statement[?Yield, ?Await, ?Return]
```

##### 14.7.3.1 静态语义：早期错误
**WhileStatement** : while (**Expression**) **Statement**
- 如果 Statement 的 IsLabelledFunction 为 true，则为语法错误。

**注意**：仅在实现了 B.3.1 中指定的扩展时才需要应用此规则。

##### 14.7.3.2 运行时语义：WhileLoopEvaluation
语法定向操作 WhileLoopEvaluation 接受参数 labelSet（一个字符串列表），返回包含 ECMAScript 语言值的正常完成或突发完成。它在以下规则中分段定义：

**WhileStatement** : while (**Expression**) **Statement**
1. 令 V 为 undefined。
2. 重复以下步骤：
  a. 令 exprRef 为 Expression 的 ? 求值结果。
  b. 令 exprValue 为 ? GetValue(exprRef)。
  c. 如果 ToBoolean(exprValue) 为 false，返回 V。
  d. 令 stmtResult 为 Statement 的 Completion(Evaluation) 结果。
  e. 如果 LoopContinues(stmtResult, labelSet) 为 false，返回 ? UpdateEmpty(stmtResult, V)。
  f. 如果 stmtResult.[[Value]] 不是 EMPTY，设置 V 为 stmtResult.[[Value]]。

#### 14.7.4 for 语句

##### 语法
```javascript
ForStatement[Yield, Await, Return] :
  for ( [lookahead ≠ let [] Expression[~In, ?Yield, ?Await]opt ; Expression[+In, ?Yield, ?Await]opt ; Expression[+In, ?Yield, ?Await]opt ) Statement[?Yield, ?Await, ?Return]
  for ( var VariableDeclarationList[~In, ?Yield, ?Await] ; Expression[+In, ?Yield, ?Await]opt ; Expression[+In, ?Yield, ?Await]opt ) Statement[?Yield, ?Await, ?Return]
  for ( LexicalDeclaration[~In, ?Yield, ?Await] Expression[+In, ?Yield, ?Await]opt ; Expression[+In, ?Yield, ?Await]opt ) Statement[?Yield, ?Await, ?Return]
```

##### 14.7.4.1 静态语义：早期错误
**ForStatement** :
```javascript
for ( Expressionopt ; Expressionopt ; Expressionopt ) Statement
for ( var VariableDeclarationList ; Expressionopt ; Expressionopt ) Statement
for ( LexicalDeclaration Expressionopt ; Expressionopt ) Statement
```
- 如果 Statement 的 Is

LabelledFunction 为 true，则为语法错误。

**注意**：仅在实现了 B.3.1 中指定的扩展时才需要应用此规则。

**ForStatement** : for ( LexicalDeclaration Expressionopt ; Expressionopt ) Statement
- 如果 LexicalDeclaration 的 BoundNames 中的任何元素也出现在 Statement 的 VarDeclaredNames 中，则为语法错误。

##### 14.7.4.2 运行时语义：ForLoopEvaluation
语法定向操作 ForLoopEvaluation 接受参数 labelSet（一个字符串列表），返回包含 ECMAScript 语言值的正常完成或突发完成。它在以下规则中分段定义：

**ForStatement** : for ( **Expression**opt ; **Expression**opt ; **Expression**opt ) **Statement**
1. 如果第一个 Expression 存在，
  a. 令 exprRef 为第一个 Expression 的 ? 求值结果。
  b. 执行 ? GetValue(exprRef)。
2. 如果第二个 Expression 存在，令 test 为第二个 Expression；否则，令 test 为 EMPTY。
3. 如果第三个 Expression 存在，令 increment 为第三个 Expression；否则，令 increment 为 EMPTY。
4. 返回 ForBodyEvaluation(test, increment, Statement, « », labelSet) 的 ? 求值结果。

**ForStatement** : for ( var **VariableDeclarationList** ; **Expression**opt ; **Expression**opt ) **Statement**
1. 执行 VariableDeclarationList 的 ? 求值结果。
2. 如果第一个 Expression 存在，令 test 为第一个 Expression；否则，令 test 为 EMPTY。
3. 如果第二个 Expression 存在，令 increment 为第二个 Expression；否则，令 increment 为 EMPTY。
4. 返回 ForBodyEvaluation(test, increment, Statement, « », labelSet) 的 ? 求值结果。

**ForStatement** : for ( **LexicalDeclaration** **Expression**opt ; **Expression**opt ) **Statement**
1. 令 oldEnv 为运行执行上下文的 LexicalEnvironment。
2. 令 loopEnv 为 NewDeclarativeEnvironment(oldEnv)。
3. 令 isConst 为 LexicalDeclaration 的 IsConstantDeclaration 结果。
4. 令 boundNames 为 LexicalDeclaration 的 BoundNames 结果。
5. 对于 boundNames 的每个元素 dn，
  a. 如果 isConst 为 true，
    i. 执行 ! loopEnv.CreateImmutableBinding(dn, true)。
  b. 否则，
    i. 执行 ! loopEnv.CreateMutableBinding(dn, false)。
6. 将运行执行上下文的 LexicalEnvironment 设置为 loopEnv。
7. 令 forDcl 为 LexicalDeclaration 的 Completion(Evaluation) 结果。
8. 如果 forDcl 是突发完成，
  a. 将运行执行上下文的 LexicalEnvironment 设置回 oldEnv。
  b. 返回 forDcl 的 ? 求值结果。
9. 如果 isConst 为 false，令 perIterationLets 为 boundNames；否则令 perIterationLets 为一个新的空列表。
10. 如果第一个 Expression 存在，令 test 为第一个 Expression；否则，令 test 为 EMPTY。
11. 如果第二个 Expression 存在，令 increment 为第二个 Expression；否则，令 increment 为 EMPTY。
12. 令 bodyResult 为 ForBodyEvaluation(test, increment, Statement, perIterationLets, labelSet) 的 Completion 结果。
13. 将运行执行上下文的 LexicalEnvironment 设置回 oldEnv。
14. 返回 bodyResult 的 ? 求值结果。

##### 14.7.4.3 ForBodyEvaluation (test, increment, stmt, perIterationBindings, labelSet)


好的。翻译我下面给的章节，注意准确性和完整性，完成就停止并说明已翻译完成，别乱写，别无中生有===
继续往后翻译，注意准确性和完整性，完成就停止并说明已翻译完成，别乱写，别无中生有
别瞎说，明明后面还有10.4.4等章节，请继续往后翻译，注意准确性和完整性，完成就停止并说明已翻译完成，别乱写，别无中生有