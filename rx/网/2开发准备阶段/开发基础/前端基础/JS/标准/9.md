### 9 可执行代码和执行上下文

#### 9.1 环境记录
环境记录是一种规范类型，用于定义标识符与特定变量和函数的关联，基于 ECMAScript 代码的词法嵌套结构。通常，环境记录与 ECMAScript 代码的某些特定语法结构相关联，如 FunctionDeclaration、BlockStatement 或 TryStatement 的 Catch 子句。每次评估这些代码时，都会创建一个新的环境记录来记录由该代码创建的标识符绑定。

每个环境记录都有一个 [[OuterEnv]] 字段，它要么为 null，要么是对外部环境记录的引用。这用于模拟环境记录值的逻辑嵌套。内（inner）环境记录的外部引用是对逻辑上包围内环境记录的环境记录的引用。当然，外部环境记录也可以有它自己的外部环境记录。一个环境记录可以作为多个内环境记录的外部环境记录。例如，如果一个 FunctionDeclaration 包含两个嵌套的 FunctionDeclaration，那么每个嵌套函数的环境记录将拥有当前评估的外部函数的环境记录作为它们的外部环境记录。

环境记录纯粹是规范机制，不需要对应于 ECMAScript 实现的任何特定工件。ECMAScript 程序不可能直接访问或操作这些值。

#### 9.1.1 环境记录类型层次结构
可以认为环境记录存在于一个简单的面向对象层次结构中，其中环境记录是一个抽象类，具有三个具体子类：声明性环境记录、对象环境记录和全局环境记录。函数环境记录和模块环境记录是声明性环境记录的子类。

**环境记录 (抽象)**

声明性环境记录用于定义 ECMAScript 语言语法元素（如 FunctionDeclaration、VariableDeclaration 和 Catch 子句）的效果，这些元素直接将标识符绑定与 ECMAScript 语言值相关联。

函数环境记录对应于 ECMAScript 函数对象的调用，并包含该函数内的顶层声明绑定。它可能建立一个新的 this 绑定。它还捕获了支持 super 方法调用所需的状态。

模块环境记录包含模块的顶层声明绑定。它还包含模块显式导入的绑定。其 [[OuterEnv]] 是一个全局环境记录。

对象环境记录用于定义 ECMAScript 元素（如 WithStatement）的效果，这些元素将标识符绑定与某个对象的属性相关联。

全局环境记录用于脚本全局声明。它没有外部环境；其 [[OuterEnv]] 为 null。它可能预先填充有标识符绑定，并且包括一个关联的全局对象，其属性提供了一些全局环境的标识符绑定。随着 ECMAScript 代码的执行，可以向全局对象添加其他属性，并且可以修改初始属性。

环境记录抽象类包括表 16 中定义的抽象规范方法。这些抽象方法对每个具体子类都有不同的具体算法。

**表 16: 环境记录的抽象方法**

| 方法                   | 目的                                                                                             |
|------------------------|--------------------------------------------------------------------------------------------------|
| HasBinding(N)          | 确定环境记录是否有字符串值 N 的绑定。如果有，返回 true；否则返回 false。                           |
| CreateMutableBinding(N, D)  | 在环境记录中创建一个新的但未初始化的可变绑定。字符串值 N 是绑定名称的文本。如果布尔参数 D 为 true，则绑定可以随后被删除。  |
| CreateImmutableBinding(N, S)  | 在环境记录中创建一个新的但未初始化的不可变绑定。字符串值 N 是绑定名称的文本。如果 S 为 true，则在初始化后尝试设置它总是会抛出异常，无论引用该绑定的操作的严格模式设置如何。  |
| InitializeBinding(N, V)  | 设置环境记录中已经存在但未初始化的绑定的值。字符串值 N 是绑定名称的文本。V 是绑定的值，可以是任何 ECMAScript 语言类型的值。 |
| SetMutableBinding(N, V, S)  | 设置环境记录中已经存在的可变绑定的值。字符串值 N 是绑定名称的文本。V 是绑定的值，可以是任何 ECMAScript 语言类型的值。S 是一个布尔标志。如果 S 为 true 并且绑定不能被设置，则抛出一个 TypeError 异常。 |
| GetBindingValue(N, S)  | 从环境记录中返回已存在绑定的值。字符串值 N 是绑定名称的文本。S 用于标识来自严格模式代码或其他需要严格模式引用语义的引用。如果 S 为 true 并且绑定不存在，则抛出一个 ReferenceError 异常。如果绑定存在但未初始化，无论 S 的值如何，都会抛出一个 ReferenceError。 |
| DeleteBinding(N)  | 从环境记录中删除绑定。字符串值 N 是绑定名称的文本。如果存在 N 的绑定，删除绑定并返回 true。如果绑定存在但不能被删除，返回 false。如果绑定不存在，返回 true。 |
| HasThisBinding()  | 确定环境记录是否建立了一个 this 绑定。如果是，返回 true；否则返回 false。 |
| HasSuperBinding()  | 确定环境记录是否建立了一个 super 方法绑定。如果是，返回 true；否则返回 false。 |
| WithBaseObject()  | 如果此环境记录与一个 with 语句相关联，则返回 with 对象。否则，返回 undefined。 |

#### 9.1.1.1 声明性环境记录
每个声明性环境记录都与包含变量、常量、let、class、module、import 和/或函数声明的 ECMAScript 程序范围相关联。声明性环境记录绑定其范围内包含的声明定义的标识符集。

声明性环境记录的具体规范方法的行为由以下算法定义。

##### 9.1.1.1.1 HasBinding ( N )
声明性环境记录 envRec 的 HasBinding 具体方法接受参数 N（一个字符串）并返回包含一个布尔值的正常完成。它确定参数标识符是否是记录绑定的标识符之一。调用时执行以下步骤：

1. 如果 envRec 有 N 的绑定，返回 true。
2. 返回 false。

##### 9.1.1.1.2 CreateMutableBinding ( N, D )
声明性环境记录 envRec 的 CreateMutableBinding 具体方法接受参数 N（一个字符串）和 D（一个布尔值），并返回包含 UNUSED 的正常完成。它为名称 N 创建一个新的未初始化的可变绑定。在此环境记录中不应已有 N 的绑定。如果 D 为 true，则新绑定被标记为可以被随后删除。调用时执行以下步骤：

1. 断言：envRec 尚未有 N 的绑定。
2. 在 envRec 中创建一个 N 的可变绑定，并记录它是未初始化的。如果 D 为 true，则记录新创建的绑定可以被后续的 DeleteBinding 调用删除。
3. 返回 UNUSED。

##### 9.1.1.1.3 CreateImmutableBinding ( N, S )
声明性环境记录 envRec 的 CreateImmutableBinding 具体方法接受参数 N（一个字符串）和 S（一个布尔值），并返回包含 UNUSED 的正常完成。它为名称 N 创建一个新的未初始化的不可变绑定。在此环境记录中不应已有 N 的绑定。如果 S 为 true，则新绑定被标记为严格绑定。调用时执行以下步骤：

1. 断言：envRec 尚未有 N 的绑定。
2. 在 envRec 中创建一个 N 的不可变绑定，并记录它是未初始化的。如果 S 为 true，则记录新创建的绑定是严格绑定。
3. 返回 UNUSED。

##### 9.1.1.1.4 InitializeBinding ( N, V )
声明性环境记录 envRec 的 InitializeBinding 具体方法接受参数 N（一个字符串）和 V（一个 ECMAScript 语言值），并返回包含 UNUSED 的正常完成。它用于将名称为 N 的标识符当前绑定的值设置为 V。必须已存在一个未初始化的 N 的绑定。调用时执行以下步骤：

1. 断言：envRec 必须有一个未初始化的 N 的绑定。
2. 将 envRec 中 N 的绑定值设置为 V。
3. 记录 envRec 中 N 的绑定已被初始化。
4. 返回 UNUSED。

##### 9.1.1.1.5 SetMutableBinding ( N, V, S )
声明性环境记录 envRec 的 SetMutableBinding 具体方法接受参数 N（一个字符串）、V（一个 ECMAScript 语言值）和 S（一个布尔值），并返回包含 UNUSED 或一个抛出完成。它试图将名称为 N 的标识符当前绑定的值更改为 V。通常已经存在一个 N 的绑定，但在少数情况下可能没有。如果绑定是不可变绑定，并且 S 为 true，则抛出 TypeError。如果调用时执行以下步骤：

1. 如果 envRec 没有 N 的绑定，
  a. 如果 S 为 true，则抛出一个 ReferenceError 异常。
  b. 执行 ! envRec.CreateMutableBinding(N, true)。
  c. 执行 ! envRec.InitializeBinding(N, V)。
  d. 返回 UNUSED。
2. 如果 envRec 中 N 的绑定是一个严格绑定，则将 S 设置为true。
3. 如果 envRec 中 N 的绑定尚未初始化，
  a. 抛出一个 ReferenceError 异常。
4. 否则，如果 envRec 中 N 的绑定是一个可变绑定，
  a. 将其绑定值更改为 V。
5. 否则，
  a. 断言：这是试图更改不可变绑定的值。
  b. 如果 S 为 true，抛出一个 TypeError 异常。
6. 返回 UNUSED。

##### 9.1.1.1.6 GetBindingValue ( N, S )
声明性环境记录 envRec 的 GetBindingValue 具体方法接受参数 N（一个字符串）和 S（一个布尔值），并返回包含一个 ECMAScript 语言值的正常完成或一个抛出完成。它返回名称为 N 的绑定标识符的值。如果绑定存在但未初始化，则抛出 ReferenceError 异常，无论 S 的值如何。调用时执行以下步骤：

1. 断言：envRec 有 N 的绑定。
2. 如果 envRec 中 N 的绑定是一个未初始化的绑定，抛出一个 ReferenceError 异常。
3. 返回当前绑定到 envRec 中 N 的值。

##### 9.1.1.1.7 DeleteBinding ( N )
声明性环境记录 envRec 的 DeleteBinding 具体方法接受参数 N（一个字符串），并返回包含一个布尔值的正常完成。它只能删除明确指定为可删除的绑定。调用时执行以下步骤：

1. 断言：envRec 有 N 的绑定。
2. 如果 envRec 中 N 的绑定不能被删除，返回 false。
3. 从 envRec 中移除 N 的绑定。
4. 返回 true。

##### 9.1.1.1.8 HasThisBinding ( )
声明性环境记录 envRec 的 HasThisBinding 具体方法不接受参数并返回 false。调用时执行以下步骤：

1. 返回 false。

注意：常规声明性环境记录（即既不是函数环境记录也不是模块环境记录）不提供 this 绑定。

##### 9.1.1.1.9 HasSuperBinding ( )
声明性环境记录 envRec 的 HasSuperBinding 具体方法不接受参数并返回 false。调用时执行以下步骤：

1. 返回 false。

注意：常规声明性环境记录（即既不是函数环境记录也不是模块环境记录）不提供 super 绑定。

##### 9.1.1.1.10 WithBaseObject ( )
声明性环境记录 envRec 的 WithBaseObject 具体方法不接受参数并返回 undefined。调用时执行以下步骤：

1. 返回 undefined。

#### 9.1.1.2 对象环境记录
每个对象环境记录都与一个称为绑定对象的对象相关联。对象环境记录绑定的字符串标识符名称集合直接对应于其绑定对象的属性名称。非字符串形式的属性键不包括在绑定的标识符集合中。无论 [[Enumerable]] 属性的设置如何，既包括自己的属性，也包括继承的属性。由于可以动态添加和删除对象的属性，因此对象环境记录绑定的标识符集合可能会随任何添加或删除属性的操作而改变。由于这种副作用创建的任何绑定即使对应属性的 Writable 属性为 false，也被视为可变绑定。对象环境记录中不存在不可变绑定。

为 with 语句（14.11）创建的对象环境记录可以将其绑定对象作为隐式的 this 值用于函数调用。此功能由一个布尔 [[IsWithEnvironment]] 字段控制。

对象环境记录具有表 17 中列出的附加状态字段。

**表 17: 对象环境记录的附加字段**

| 字段名称                 | 值         | 含义                              |
|-------------------------|------------|----------------------------------|
| [[BindingObject]]       | 一个对象    | 此环境记录的绑定对象。             |
| [[IsWithEnvironment]]   | 一个布尔值  | 表示此环境记录是否为 with 语句创建。 |

对象环境记录的具体规范方法的行为由以下算法定义。

##### 9.1.1.2.1 HasBinding ( N )
对象环境记录 envRec 的 HasBinding 具体方法接受参数 N（一个字符串）并返回包含一个布尔值的正常完成或一个抛出完成。它确定其关联的绑定对象是否具有名称为 N 的属性。调用时执行以下步骤：

1. 令 bindingObject 为 envRec.[[BindingObject]]。
2. 令 foundBinding 为 ? HasProperty(bindingObject, N)。
3. 如果 foundBinding 为 false，返回 false。
4. 如果 envRec.[[IsWithEnvironment]] 为 false，返回 true。
5. 令 unscopables 为 ? Get(bindingObject, @@unscopables)。
6. 如果 unscopables 是一个对象，
  a. 令 blocked 为 ToBoolean(? Get(unscopables, N))。
  b. 如果 blocked 为 true，返回 false。
7. 返回 true。

##### 9.1.1.2.2 CreateMutableBinding ( N, D )
对象环境记录 envRec 的 CreateMutableBinding 具体方法接受参数 N（一个字符串）和 D（一个布尔值），并返回包含 UNUSED 的正常完成或一个抛出完成。它在环境记录的关联绑定对象中创建一个名称为 N 的属性，并将其初始化为 undefined。如果 D 为 true，则新属性的 [[Configurable]] 属性设置为 true；否则设置为 false。调用时执行以下步骤：

1. 令 bindingObject 为 envRec.[[BindingObject]]。
2. 执行 ? DefinePropertyOrThrow(bindingObject, N, PropertyDescriptor { [[Value]]: undefined, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: D })。
3. 返回 UNUSED。

注意：通常 envRec 不会有 N 的绑定，但如果有，DefinePropertyOrThrow 的语义可能会导致现有绑定被替换或遮蔽，或导致返回一个抛出完成。

##### 9.1.1.2.3 CreateImmutableBinding ( N, S )
对象环境记录的 CreateImmutableBinding 具体方法在本规范中从未使用。

##### 9.1.1.2.4 InitializeBinding ( N, V )
对象环境记录 envRec 的 InitializeBinding 具体方法接受参数 N（一个字符串）和 V（一个 ECMAScript 语言值），并返回包含 UNUSED 的正常完成或一个抛出完成。它用于将名称为 N 的标识符当前绑定的值设置为 V。调用时执行以下步骤：

1. 执行 ? envRec.SetMutableBinding(N, V, false)。
2. 返回 UNUSED。

注意：在本规范中，所有为对象环境记录使用的 CreateMutableBinding 都会紧接着调用 InitializeBinding，因此本规范不会显式跟踪对象环境记录中的绑定初始化状态。

##### 9.1.1.2.5 SetMutableBinding ( N, V, S )
对象环境记录 envRec 的 SetMutableBinding 具体方法接受参数 N（一个字符串）、V（一个 ECMAScript 语言值）和 S（一个布尔值），并返回包含 UNUSED 的正常完成或一个抛出完成。它尝试将环境记录的关联绑定对象的名称为 N 的属性的值设置为 V。通常已经存在一个名称为 N 的属性，但如果不存在或当前不可写，错误处理由 S 决定。调用时执行以下步骤：

1. 令 bindingObject 为 envRec.[[BindingObject]]。
2. 令 stillExists 为 ? HasProperty(bindingObject, N)。
3. 如果 stillExists 为 false 且 S 为 true，抛出一个 ReferenceError 异常。
4. 执行 ? Set(bindingObject, N, V, S)。
5. 返回 UNUSED。

##### 9.1.1.2.6 GetBindingValue ( N, S )
对象环境记录 envRec 的 GetBindingValue 具体方法接受参数 N（一个字符串）和 S（一个布尔值），并返回包含一个 ECMAScript 语言值的正常完成或一个抛出完成。它返回其关联绑定对象的名称为 N 的属性的值。属性应该已经存在，但如果不存在，结果取决于 S。调用时执行以下步骤：

1. 令 bindingObject 为 envRec.[[BindingObject]]。
2. 令 value 为 ? HasProperty(bindingObject, N)。
3. 如果 value 为 false，
  a. 如果 S 为 false，返回 undefined；否则抛出一个 ReferenceError 异常。
4. 返回 ? Get(bindingObject, N)。

##### 9.1.1.2.7 DeleteBinding ( N )
对象环境记录 envRec 的 DeleteBinding 具体方法接受参数 N（一个字符串），并返回包含一个布尔值的正常完成或一个抛出完成。它只能删除对应于环境对象属性且其 [[Configurable]] 属性为 true 的绑定。调用时执行以下步骤：

1. 令 bindingObject 为 envRec.[[BindingObject]]。
2. 返回 ? bindingObject.[[Delete]](N)。

##### 9.1.1.2.8 HasThisBinding ( )
对象环境记录 envRec 的 HasThisBinding 具体方法不接受参数并返回 false。调用时执行以下步骤：

1. 返回 false。

注意：对象环境记录不提供 this 绑定。

##### 9.1.1.2.9 HasSuperBinding ( )
对象环境记录 envRec 的 HasSuperBinding 
具体方法不接受参数并返回 false。调用时执行以下步骤：

1. 返回 false。

注意：对象环境记录不提供 super 绑定。

##### 9.1.1.2.10 WithBaseObject ( )
对象环境记录 envRec 的 WithBaseObject 具体方法不接受参数，并返回一个对象或 undefined。调用时执行以下步骤：

1. 如果 envRec.[[IsWithEnvironment]] 为 true，返回 envRec.[[BindingObject]]。
2. 否则，返回 undefined。

#### 9.1.1.3 函数环境记录
函数环境记录是一个声明性环境记录，用于表示函数的顶级作用域，并且如果该函数不是箭头函数，还提供一个 this 绑定。如果一个函数不是箭头函数并且引用了 super，那么它的函数环境记录还包含用于在函数内部执行 super 方法调用的状态。

函数环境记录具有表 18 中列出的附加状态字段。

**表 18: 函数环境记录的附加字段**

| 字段名称              | 值                           | 含义                                     |
|----------------------|------------------------------|----------------------------------------|
| [[ThisValue]]        | 一个 ECMAScript 语言值       | 此函数调用中使用的 this 值。               |
| [[ThisBindingStatus]]| LEXICAL, INITIALIZED, UNINITIALIZED | 如果值为 LEXICAL，则这是一个箭头函数，没有本地的 this 值。 |
| [[FunctionObject]]   | 一个 ECMAScript 函数对象      | 导致创建此环境记录的函数对象。              |
| [[NewTarget]]        | 一个对象或 undefined          | 如果此环境记录是由 [[Construct]] 内部方法创建的，[[NewTarget]] 是 [[Construct]] newTarget 参数的值。否则，其值为 undefined。 |

函数环境记录支持表 16 中列出的所有声明性环境记录方法，并且除了 HasThisBinding 和 HasSuperBinding 方法外，所有这些方法的规范都相同。此外，函数环境记录还支持表 19 中列出的方法：

**表 19: 函数环境记录的附加方法**

| 方法              | 目的                                                                 |
|------------------|----------------------------------------------------------------------|
| BindThisValue(V) | 设置 [[ThisValue]] 并记录它已被初始化。                                |
| GetThisBinding() | 返回此环境记录的 this 绑定的值。如果 this 绑定尚未初始化，则抛出 ReferenceError 异常。 |
| GetSuperBase()   | 返回在此环境记录中绑定的 super 属性访问的基础对象。值为 undefined 表示这种访问将产生运行时错误。 |

函数环境记录附加的具体规范方法的行为由以下算法定义：

##### 9.1.1.3.1 BindThisValue ( V )
函数环境记录 envRec 的 BindThisValue 具体方法接受参数 V（一个 ECMAScript 语言值），并返回包含一个 ECMAScript 语言值的正常完成或一个抛出完成。调用时执行以下步骤：

1. 断言：envRec.[[ThisBindingStatus]] 不是 LEXICAL。
2. 如果 envRec.[[ThisBindingStatus]] 是 INITIALIZED，抛出一个 ReferenceError 异常。
3. 将 envRec.[[ThisValue]] 设置为 V。
4. 将 envRec.[[ThisBindingStatus]] 设置为 INITIALIZED。
5. 返回 V。

##### 9.1.1.3.2 HasThisBinding ( )
函数环境记录 envRec 的 HasThisBinding 具体方法不接受参数并返回一个布尔值。调用时执行以下步骤：

1. 如果 envRec.[[ThisBindingStatus]] 是 LEXICAL，返回 false；否则，返回 true。

##### 9.1.1.3.3 HasSuperBinding ( )
函数环境记录 envRec 的 HasSuperBinding 具体方法不接受参数并返回一个布尔值。调用时执行以下步骤：

1. 如果 envRec.[[ThisBindingStatus]] 是 LEXICAL，返回 false。
2. 如果 envRec.[[FunctionObject]].[[HomeObject]] 是 undefined，返回 false；否则，返回 true。

##### 9.1.1.3.4 GetThisBinding ( )
函数环境记录 envRec 的 GetThisBinding 具体方法不接受参数并返回包含一个 ECMAScript 语言值的正常完成或一个抛出完成。调用时执行以下步骤：

1. 断言：envRec.[[ThisBindingStatus]] 不是 LEXICAL。
2. 如果 envRec.[[ThisBindingStatus]] 是 UNINITIALIZED，抛出一个 ReferenceError 异常。
3. 返回 envRec.[[ThisValue]]。

##### 9.1.1.3.5 GetSuperBase ( )
函数环境记录 envRec 的 GetSuperBase 具体方法不接受参数并返回包含一个对象、null 或 undefined 的正常完成或一个抛出完成。调用时执行以下步骤：

1. 令 home 为 envRec.[[FunctionObject]].[[HomeObject]]。
2. 如果 home 是 undefined，返回 undefined。
3. 断言：home 是一个对象。
4. 返回 ? home.[[GetPrototypeOf]]()。

#### 9.1.1.4 全局环境记录
全局环境记录用于表示所有在同一领域中处理的 ECMAScript 脚本元素共享的最外层作用域。全局环境记录提供内建全局（第 19 章）、全局对象的属性和所有在全局代码中出现的顶级声明（8.2.9，8.2.11）的绑定。

全局环境记录逻辑上是一个单独的记录，但它被指定为一个复合体，封装了一个对象环境记录和一个声明性环境记录。对象环境记录的基础对象是关联领域记录的全局对象。这个全局对象是全局环境记录的 GetThisBinding 具体方法返回的值。全局环境记录的对象环境记录部分包含所有内建全局（第 19 章）和在全局代码中包含的 FunctionDeclaration、GeneratorDeclaration、AsyncFunctionDeclaration、AsyncGeneratorDeclaration 或 VariableStatement 的绑定。所有其他 ECMAScript 声明在全局代码中的绑定包含在全局环境记录的声明性环境记录部分中。

可以直接在全局对象上创建属性。因此，全局环境记录的对象环境记录部分可能包含显式由 FunctionDeclaration、GeneratorDeclaration、AsyncFunctionDeclaration、AsyncGeneratorDeclaration 或 VariableDeclaration 声明创建的绑定，也可能包含隐式作为全局对象的属性创建的绑定。为了识别哪些绑定是使用声明显式创建的，全局环境记录维护一个名称列表，用于记录其 CreateGlobalVarBinding 和 CreateGlobalFunctionBinding 具体方法绑定的名称。

全局环境记录具有表 20 中列出的附加字段和表 21 中列出的附加方法。

**表 20: 全局环境记录的附加字段**

| 字段名称            | 值                     | 含义                                                                                               |
|--------------------|------------------------|--------------------------------------------------------------------------------------------------|
| [[ObjectRecord]]   | 一个对象环境记录        | 绑定对象是全局对象。它包含全局内建绑定以及在关联领域的全局代码中的 FunctionDeclaration、GeneratorDeclaration、AsyncFunctionDeclaration、AsyncGeneratorDeclaration 和 VariableDeclaration 绑定。 |
| [[GlobalThisValue]]| 一个对象               | 在全局作用域中由 this 返回的值。宿主可以提供任何 ECMAScript 对象值。                                                 |
| [[DeclarativeRecord]] | 一个声明性环境记录    | 包含关联领域的全局代码中除 FunctionDeclaration、GeneratorDeclaration、AsyncFunctionDeclaration、AsyncGeneratorDeclaration 和 VariableDeclaration 绑定之外的所有声明绑定。 |
| [[VarNames]]       | 一个字符串列表          | 由 FunctionDeclaration、GeneratorDeclaration、AsyncFunctionDeclaration、AsyncGeneratorDeclaration 和 VariableDeclaration 声明在全局代码中绑定的字符串名称。 |

**表 21: 全局环境记录的附加方法**

| 方法                      | 目的                                                                                                                                                                                                                                                                   |
|---------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| GetThisBinding()          | 返回此环境记录的 this 绑定的值。                                                                                                                                                                                                                                         |
| HasVarDeclaration(N)      | 确定参数标识符是否在此环境记录中具有由 VariableDeclaration、FunctionDeclaration、GeneratorDeclaration、AsyncFunctionDeclaration 或 AsyncGeneratorDeclaration 创建的绑定。                                                                                               |
| HasLexicalDeclaration(N)  | 确定参数标识符是否在此环境记录中具有由词法声明（如 LexicalDeclaration 或 ClassDeclaration）创建的绑定。                                                                                                                                                                 |
| HasRestrictedGlobalProperty(N) | 确定参数是否是全局对象属性的名称，这些属性不能被全局词法绑定所遮蔽。                                                                                                                                                                                                  |
| CanDeclareGlobalVar(N)    | 确定如果为相同参数 N 调用相应的 CreateGlobalVarBinding 调用是否会成功。允许冗余的 var 声明和预先存在的全局对象属性的 var 声明。                                                                                                                                              |
| CanDeclareGlobalFunction(N)| 确定如果为相同参数 N 调用相应的 CreateGlobalFunctionBinding 调用是否会成功。                                                                                                                                                                                              |
| CreateGlobalVarBinding(N, D)| 在 [[ObjectRecord]] 组件的全局环境记录中创建并初始化为 undefined 的全局 var 绑定。绑定将是一个可变绑定。对应的全局对象属性将具有适合 var 的属性值。字符串值 N 是绑定名称。如果 D 为 true，则绑定可以被删除。逻辑上等同于 CreateMutableBinding 之后跟随 SetMutableBinding，但它允许 var 声明获得特殊处理。|
| CreateGlobalFunctionBinding(N, V, D) | 在 [[ObjectRecord]] 组件的全局环境记录中创建并初始化一个全局函数绑定。绑定将是一个可变绑定。对应的全局对象属性将具有适合函数的属性值。字符串值 N 是绑定名称。V 是初始化值。如果布尔参数 D 为 true，则绑定可以被删除。逻辑上等同于 CreateMutableBinding 之后跟随 SetMutableBinding，但它允许函数声明获得特殊处理。|

全局环境记录的具体规范方法的行为由以下算法定义。

##### 9.1.1.4.1 HasBinding ( N )
全局环境记录 envRec 的 HasBinding 具体方法接受参数 N（一个字符串）并返回包含一个布尔值的正常完成或一个抛出完成。它确定参数标识符是否是记录绑定的标识符之一。调用时执行以下步骤：

1. 令 DclRec 为 envRec.[[DeclarativeRecord]]。
2. 如果 ! DclRec.HasBinding(N) 为 true，返回 true。
3. 令 ObjRec 为 envRec.[[ObjectRecord]]。
4. 返回 ? ObjRec.HasBinding(N)。

##### 9.1.1.4.2 CreateMutableBinding ( N, D )
全局环境记录 envRec 的 CreateMutableBinding 具体方法接受参数 N（一个字符串）和 D（一个布尔值），并返回包含 UNUSED 的正常完成或一个抛出完成。它为名称 N 创建一个新的未初始化的可变绑定。绑定在关联的 DeclarativeRecord 中创建。此 DeclarativeRecord 中不应已有 N 的绑定。如果 D 为 true，则新绑定被标记为可以被删除。调用时执行以下步骤：

1. 令 DclRec 为 envRec.[[DeclarativeRecord]]。
2. 如果 ! DclRec.HasBinding(N) 为 true，抛出一个 TypeError 异常。
3. 返回 ! DclRec.CreateMutableBinding(N, D)。

##### 9.1.1.4.3 CreateImmutableBinding ( N, S )
全局环境记录 envRec 的 CreateImmutableBinding 具体方法接受参数 N（一个字符串）和 S（一个布尔值），并返回包含 UNUSED 的正常完成或一个抛出完成。它为名称 N 创建一个新的未初始化的不可变绑定。在此环境记录中不应已有 N 的绑定。如果 S 为 true，则新绑定被标记为严格绑定。调用时执行以下步骤：

1. 令 DclRec 为 envRec.[[DeclarativeRecord]]。
2. 如果 ! DclRec.HasBinding(N) 为 true，抛出一个 TypeError 异常。
3. 返回 ! DclRec.CreateImmutableBinding(N, S)。

##### 9.1.1.4.4 InitializeBinding ( N, V )
全局环境记录 envRec 的 InitializeBinding 具体方法接受参数 N（一个字符串）和 V（一个 ECMAScript 语言值），并返回包含 UNUSED 的正常完成或一个抛出完成。它用于将名称为 N 的标识符当前绑定的值设置为 V。必须已存在一个未初始化的 N 的绑定。调用时执行以下步骤：

1. 令 DclRec 为 envRec.[[DeclarativeRecord]]。
2. 如果 ! DclRec.HasBinding(N) 为 true，
  a. 返回 ! DclRec.InitializeBinding(N, V)。
3. 断言：如果绑定存在，它必须在对象环境记录中。
4. 令 ObjRec 为 envRec.[[ObjectRecord]]。
5. 返回 ? ObjRec.InitializeBinding(N, V)。

##### 9.1.1.4.5 SetMutableBinding ( N, V, S )
全局环境记录 envRec 的 SetMutableBinding 具体方法接受参数 N（一个字符串）、V（一个 ECMAScript 语言值）和 S（一个布尔值），并返回包含 UNUSED 的正常完成或一个抛出完成。它尝试将名称为 N 的标识符当前绑定的值更改为 V。如果绑定是不可变绑定并且 S 为 true，则抛出 TypeError。调用时执行以下步骤：

1. 令 DclRec 为 envRec.[[DeclarativeRecord]]。
2. 如果 ! DclRec.HasBinding(N) 为 true，
  a. 返回 ? DclRec.SetMutableBinding(N, V, S)。
3. 令 ObjRec 为 envRec.[[ObjectRecord]]。
4. 返回 ? ObjRec.SetMutableBinding(N, V, S)。

##### 9.1.1.4.6 GetBindingValue ( N, S )
全局环境记录 envRec 的 GetBindingValue 具体方法接受参数 N（一个字符串）和 S（一个布尔值），并返回包含一个 ECMAScript 语言值的正常完成或一个抛出完成。它返回名称为 N 的绑定标识符的值。如果绑定是未初始化的绑定，则抛出 ReferenceError 异常。调用时执行以下步骤：

1. 令 DclRec 为 envRec.[[DeclarativeRecord]]。
2. 如果 ! DclRec.HasBinding(N) 为 true，
  a. 返回 ? DclRec.GetBindingValue(N, S)。
3. 令 ObjRec 为 envRec.[[ObjectRecord]]。
4. 返回 ? ObjRec.GetBindingValue(N, S)。

##### 9.1.1.4.7 DeleteBinding ( N )
全局环境记录 envRec 的 DeleteBinding 具体方法接受参数 N（一个字符串），并返回包含一个布尔值的正常完成或一个抛出完成。它只能删除明确指定为可删除的绑定。调用时执行以下步骤：

1. 令 DclRec 为 envRec.[[DeclarativeRecord]]。
2. 如果 ! DclRec.HasBinding(N) 为 true，
  a. 返回 ! DclRec.DeleteBinding(N)。
3. 令 ObjRec 为 envRec.[[ObjectRecord]]。
4. 令 globalObject 为 ObjRec.[[BindingObject]]。
5. 令 existingProp 为 ? HasOwnProperty(globalObject, N)。
6. 如果 existingProp 为 true，
  a. 令 status 为 ? ObjRec.DeleteBinding(N)。
  b. 如果 status 为 true 且 envRec.[[VarNames]] 包含 N，
    i. 从 envRec.[[VarNames]] 中移除 N。
  c. 返回 status。
7. 返回 true。

##### 9.1.1.4.8 HasThisBinding ( )
全局环境记录 envRec 的 HasThisBinding 具体方法不接受参数并返回 true。调用时执行以下步骤：

1. 返回 true。

注意：全局环境记录始终提供 this 绑定。

##### 9.1.1.4.9 HasSuperBinding ( )
全局环境记录 envRec 的 HasSuperBinding 具体方法不接受参数并返回 false。调用时执行以下步骤：

1. 返回 false。

注意：全局环境记录不提供 super 绑定。

##### 9.1.1.4.10 WithBaseObject ( )
全局环境记录 envRec 的 WithBaseObject 具体方法不接受参数并返回 undefined。调用时执行以下步骤：

1. 返回 undefined。

##### 9.1.1.4.11 GetThisBinding ( )
全局环境记录 envRec 的 GetThisBinding 具体方法不接受参数并返回一个对象的正常完成。调用时执行以下步骤：

1. 返回 envRec.[[GlobalThisValue]]。

##### 9.1.1.4.12 HasVarDeclaration ( N )
全局环境记录 envRec 的 HasVarDeclaration 具体方法接受参数 N（一个字符串）并返回一个布尔值。它确定参数标识符是否在此记录中具有由 VariableDeclaration、FunctionDeclaration、GeneratorDeclaration、AsyncFunctionDeclaration 或 AsyncGeneratorDeclaration 创建的绑定。调用时执行以下步骤：

1. 令 varDeclaredNames 为 envRec.[[VarNames]]。
2. 如果 varDeclaredNames 包含 N，返回 true。
3. 返回 false。

##### 9.1.1.4.13 HasLexicalDeclaration ( N )
全局环境记录 envRec 的 HasLexicalDeclaration 具体方法接受参数 N（一个字符串）并返回一个布尔值。它确定参数标识符是否在此记录中具有由词法声明（如 LexicalDeclaration 或 ClassDeclaration）创建的绑定。调用时执行以下步骤：

1. 令 DclRec 为 envRec.[[DeclarativeRecord]]。
2. 返回 ! DclRec.HasBinding(N)。

##### 9.1.1.4.14 HasRestrictedGlobalProperty ( N )
全局环境记录 envRec 的 HasRestrictedGlobalProperty 具体方法接受参数 N（一个字符串）并返回包含一个布尔值的正常完成或一个抛出完成。它确定参数标识符是否是全局对象的属性名称，这些属性不能被全局词法绑定所遮蔽。调用时执行以下步骤：

1. 令 ObjRec 为 envRec.[[ObjectRecord]]。
2. 令 globalObject 为 ObjRec.[[BindingObject]]。
3. 令 existingProp 为 ? globalObject.[[GetOwnProperty]](N)。
4. 如果 existingProp 为 undefined，返回 false。
5. 如果 existingProp.[[Configurable]] 为 true，返回 false。
6. 返回 true。

注意：属性可能直接在全局对象上创建，而不是通过 var 或 function 声明创建。不能创建与全局对象不可配置属性同名的全局词法绑定。“undefined” 就是这种属性的一个例子。

##### 9.1.1.4.15 CanDeclareGlobalVar ( N )
全局环境记录 envRec 的 CanDeclareGlobalVar 具体方法接受参数 N（一个字符串），并返回包含一个布尔值的正常完成或一个抛出完成。它确定如果为相同参数 N 调用相应的 CreateGlobalVarBinding 是否会成功。允许冗余的 var 声明和已有的全局对象属性的 var 声明。调用时执行以下步骤：

1. 令 ObjRec 为 envRec.[[ObjectRecord]]。
2. 令 globalObject 为 ObjRec.[[BindingObject]]。
3. 令 hasProperty 为 ? HasOwnProperty(globalObject, N)。
4. 如果 hasProperty 为 true，返回 true。
5. 返回 ? IsExtensible(globalObject)。

##### 9.1.1.4.16 CanDeclareGlobalFunction ( N )
全局环境记录 envRec 的 CanDeclareGlobalFunction 具体方法接受参数 N（一个字符串），并返回包含一个布尔值的正常完成或一个抛出完成。它确定如果为相同参数 N 调用相应的 CreateGlobalFunctionBinding 是否会成功。调用时执行以下步骤：

1. 令 ObjRec 为 envRec.[[ObjectRecord]]。
2. 令 globalObject 为 ObjRec.[[BindingObject]]。
3. 令 existingProp 为 ? globalObject.[[GetOwnProperty]](N)。
4. 如果 existingProp 为 undefined，返回 ? IsExtensible(globalObject)。
5. 如果 existingProp.[[Configurable]] 为 true，返回 true。
6. 如果 IsDataDescriptor(existingProp) 为 true 且 existingProp 的属性值为 { [[Writable]]: true, [[Enumerable]]: true }，返回 true。
7. 返回 false。

##### 9.1.1.4.17 CreateGlobalVarBinding ( N, D )
全局环境记录 envRec 的 CreateGlobalVarBinding 具体方法接受参数 N（一个字符串）和 D（一个布尔值），并返回包含 UNUSED 的正常完成或一个抛出完成。它在关联的对象环境记录中创建并初始化一个全局 var 绑定，并在关联的 [[VarNames]] 列表中记录绑定名称。如果已存在绑定，则重用它并假设它已初始化。调用时执行以下步骤：

1. 令 ObjRec 为 envRec.[[ObjectRecord]]。
2. 令 globalObject 为 ObjRec.[[BindingObject]]。
3. 令 hasProperty 为 ? HasOwnProperty(globalObject, N)。
4. 令 extensible 为 ? IsExtensible(globalObject)。
5. 如果 hasProperty 为 false 且 extensible 为 true，
  a. 执行 ? ObjRec.CreateMutableBinding(N, D)。
  b. 执行 ? ObjRec.InitializeBinding(N, undefined)。
6. 如果 envRec.[[VarNames]] 不包含 N，
  a. 将 N 添加到 envRec.[[VarNames]] 中。
7. 返回 UNUSED。

##### 9.1.1.4.18 CreateGlobalFunctionBinding ( N, V, D )
全局环境记录 envRec 的 CreateGlobalFunctionBinding 具体方法接受参数 N（一个字符串）、V（一个 ECMAScript 语言值）和 D（一个布尔值），并返回包含 UNUSED 的正常完成或一个抛出完成。它在关联的对象环境记录中创建并初始化一个全局函数绑定，并在关联的 [[VarNames]] 列表中记录绑定名称。如果已存在绑定，则替换它。调用时执行以下步骤：

1. 令 ObjRec 为 envRec.[[ObjectRecord]]。
2. 令 globalObject 为 ObjRec.[[BindingObject]]。
3. 令 existingProp 为 ? globalObject.[[GetOwnProperty]](N)。
4. 如果 existingProp 为 undefined 或 existingProp.[[Configurable]] 为 true，
  a. 令 desc 为 PropertyDescriptor { [[Value]]: V, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: D }。
5. 否则，
  a. 令 desc 为 PropertyDescriptor { [[Value]]: V }。
6. 执行 ? DefinePropertyOrThrow(globalObject, N, desc)。
7. 执行 ? Set(globalObject, N, V, false)。
8. 如果 envRec.[[VarNames]] 不包含 N，
  a. 将 N 添加到 envRec.[[VarNames]] 中。
9. 返回 UNUSED。

注意：全局函数声明始终表示为全局对象的自有属性。如果可能，现有的自有属性将被重新配置以具有一组标准属性值。第 7 步等同于调用 InitializeBinding 具体方法所做的，并且如果 globalObject 是一个代理，将产生相同的代理陷阱调用序列。

##### 9.1.1.5 模块环境记录
模块环境记录是一个声明性环境记录，用于表示 ECMAScript 模块的外部作用域。除了常规的可变和不可变绑定外，模块环境记录还提供不可变的导入绑定，这些绑定提供对另一个环境记录中存在的目标绑定的间接访问。

模块环境记录支持表 16 中列出的所有声明性环境记录方法，并且除了 GetBindingValue、DeleteBinding、HasThisBinding 和 GetThisBinding 之外，所有这些方法的规范都相同。此外，模块环境记录还支持表 22 中列出的方法：

**表 22: 模块环境记录的附加方法**

| 方法                     | 目的                                                                                       |
|-------------------------|------------------------------------------------------------------------------------------|
| CreateImportBinding(N, M, N2) | 在模块环境记录中创建一个不可变的间接绑定。字符串值 N 是绑定名称的文本。M 是一个模块记录，N2 是 M 的模块环境记录中存在的绑定。   |
| GetThisBinding()        | 返回此环境记录的 this 绑定的值。                                                           |

模块环境记录附加的具体规范方法的行为由以下算法定义：

##### 9.1.1.5.1 GetBindingValue ( N, S )
模块环境记录 envRec 的 GetBindingValue 具体方法接受参数 N（一个字符串）和 S（一个布尔值），并返回包含一个 ECMAScript 语言值的正常完成或一个抛出完成。它返回名称为 N 的绑定标识符的值。但是，如果绑定是一个间接绑定，则返回目标绑定的值。如果绑定存在但未初始化，则抛出 ReferenceError 异常。调用时执行以下步骤：

1. 断言：S 为 true。
2. 断言：envRec 有 N 的绑定。
3. 如果 N 的绑定是一个间接绑定，
  a. 令 M 和 N2 为创建此 N 绑定时提供的间接值。
  b. 令 targetEnv 为 M.[[Environment]]。
  c. 如果 targetEnv 是 EMPTY，抛出一个 ReferenceError 异常。
  d. 返回 ? targetEnv.GetBindingValue(N2, true)。
4. 如果 envRec 中 N 的绑定是一个未初始化的绑定，抛出一个 ReferenceError 异常。
5. 返回当前绑定到 N 的值在 envRec 中。

注意：S 始终为 true，因为模块始终是严格模式代码。

##### 9.1.1.5.2 DeleteBinding ( N )
模块环境记录的 DeleteBinding 具体方法在本规范中从未使用。

注意：模块环境记录仅在严格代码中使用，并且一个早期错误规则阻止在严格代码中对解析为模块环境记录绑定的引用记录应用 delete 操作符。见 13.5.1.1。

##### 9.1.1.5.3 HasThisBinding ( )
模块环境记录 envRec 的 HasThisBinding 具体方法不接受参数并返回 true。调用时执行以下步骤：

1. 返回 true。

注意：模块环境记录始终提供 this 绑定。

##### 9.1.1.5.4 GetThisBinding ( )
模块环境记录 envRec 的 GetThisBinding 具体方法不接受参数并返回一个包含 undefined 的正常完成。调用时执行以下步骤：

1. 返回 undefined。

##### 9.1.1.5.5 CreateImportBinding ( N, M, N2 )
模块环境记录 envRec 的 CreateImportBinding 具体方法接受参数 N（一个字符串）、M（一个模块记录）和 N2（一个字符串），并返回 UNUSED。它为名称 N 创建一个新的已初始化的不可变间接绑定。在此环境记录中不应已有 N 的绑定。N2 是 M 的模块环境记录中存在的绑定名称。对新绑定值的访问将间接访问目标绑定的值。调用时执行以下步骤：

1. 断言：envRec 尚未有 N 的绑定。
2. 断言：当 M.[[Environment]] 实例化时，它将有一个对 N2 的直接绑定。
3. 在 envRec 中为 N 创建一个不可变的间接绑定，该绑定引用 M 和 N2 作为其目标绑定，并记录该绑定已初始化。
4. 返回 UNUSED。

#### 9.1.2 环境记录操作
本规范中使用以下抽象操作来操作环境记录：

##### 9.1.2.1 GetIdentifierReference ( env, name, strict )
抽象操作 GetIdentifierReference接受参数 env（一个环境记录或 null）、name（一个字符串）和 strict（一个布尔值），并返回包含一个引用记录的正常完成或一个抛出完成。调用时执行以下步骤：

1. 如果 env 为 null，
  a. 返回引用记录 { [[Base]]: UNRESOLVABLE, [[ReferencedName]]: name, [[Strict]]: strict, [[ThisValue]]: EMPTY }。
2. 令 exists 为 ? env.HasBinding(name)。
3. 如果 exists 为 true，
  a. 返回引用记录 { [[Base]]: env, [[ReferencedName]]: name, [[Strict]]: strict, [[ThisValue]]: EMPTY }。
4. 否则，
  a. 令 outer 为 env.[[OuterEnv]]。
  b. 返回 ? GetIdentifierReference(outer, name, strict)。

##### 9.1.2.2 NewDeclarativeEnvironment ( E )
抽象操作 NewDeclarativeEnvironment 接受参数 E（一个环境记录或 null），并返回一个声明性环境记录。调用时执行以下步骤：

1. 令 env 为一个新的声明性环境记录，不包含任何绑定。
2. 将 env.[[OuterEnv]] 设置为 E。
3. 返回 env。

##### 9.1.2.3 NewObjectEnvironment ( O, W, E )
抽象操作 NewObjectEnvironment 接受参数 O（一个对象）、W（一个布尔值）和 E（一个环境记录或 null），并返回一个对象环境记录。调用时执行以下步骤：

1. 令 env 为一个新的对象环境记录。
2. 将 env.[[BindingObject]] 设置为 O。
3. 将 env.[[IsWithEnvironment]] 设置为 W。
4. 将 env.[[OuterEnv]] 设置为 E。
5. 返回 env。

##### 9.1.2.4 NewFunctionEnvironment ( F, newTarget )
抽象操作 NewFunctionEnvironment 接受参数 F（一个 ECMAScript 函数对象）和 newTarget（一个对象或 undefined），并返回一个函数环境记录。调用时执行以下步骤：

1. 令 env 为一个新的函数环境记录，不包含任何绑定。
2. 将 env.[[FunctionObject]] 设置为 F。
3. 如果 F.[[ThisMode]] 为 LEXICAL，将 env.[[ThisBindingStatus]] 设置为 LEXICAL。
4. 否则，将 env.[[ThisBindingStatus]] 设置为 UNINITIALIZED。
5. 将 env.[[NewTarget]] 设置为 newTarget。
6. 将 env.[[OuterEnv]] 设置为 F.[[Environment]]。
7. 返回 env。

##### 9.1.2.5 NewGlobalEnvironment ( G, thisValue )
抽象操作 NewGlobalEnvironment 接受参数 G（一个对象）和 thisValue（一个对象），并返回一个全局环境记录。调用时执行以下步骤：

1. 令 objRec 为 NewObjectEnvironment(G, false, null)。
2. 令 dclRec 为 NewDeclarativeEnvironment(null)。
3. 令 env 为一个新的全局环境记录。
4. 将 env.[[ObjectRecord]] 设置为 objRec。
5. 将 env.[[GlobalThisValue]] 设置为 thisValue。
6. 将 env.[[DeclarativeRecord]] 设置为 dclRec。
7. 将 env.[[VarNames]] 设置为一个新的空列表。
8. 将 env.[[OuterEnv]] 设置为 null。
9. 返回 env。

##### 9.1.2.6 NewModuleEnvironment ( E )
抽象操作 NewModuleEnvironment 接受参数 E（一个环境记录），并返回一个模块环境记录。调用时执行以下步骤：

1. 令 env 为一个新的模块环境记录，不包含任何绑定。
2. 将 env.[[OuterEnv]] 设置为 E。
3. 返回 env。

### 9.2 私有环境记录

私有环境记录是一种规范机制，用于根据 ECMAScript 代码中的类声明（ClassDeclarations）和类表达式（ClassExpressions）的词法嵌套结构来跟踪私有名称（Private Names）。它们类似于环境记录，但有所不同。每个私有环境记录与一个类声明或类表达式相关联。每次评估这样的类时，都会创建一个新的私有环境记录，以记录该类声明的私有名称。

每个私有环境记录都有表 23 中定义的字段。

#### 表 23: 私有环境记录字段

| 字段名称                  | 值类型                          | 含义                                                  |
| ----------------------- | ---------------------------- | --------------------------------------------------- |
| [[OuterPrivateEnvironment]] | 私有环境记录或 null              | 最近的包含类的私有环境记录。如果该私有环境记录关联的类不包含在任何其他类中，则为 null。 |
| [[Names]]                 | 私有名称列表                    | 该类声明的私有名称。                                        |

#### 9.2.1 私有环境记录操作

在本规范中使用以下抽象操作来操作私有环境记录：

##### 9.2.1.1 NewPrivateEnvironment ( outerPrivEnv )
抽象操作 NewPrivateEnvironment 接受参数 outerPrivEnv（一个私有环境记录或 null），并返回一个私有环境记录。调用时执行以下步骤：

1. 令 names 为一个新的空列表。
2. 返回私有环境记录 { [[OuterPrivateEnvironment]]: outerPrivEnv, [[Names]]: names }。

##### 9.2.1.2 ResolvePrivateIdentifier ( privEnv, identifier )
抽象操作 ResolvePrivateIdentifier 接受参数 privEnv（一个私有环境记录）和 identifier（一个字符串），并返回一个私有名称。调用时执行以下步骤：

1. 令 names 为 privEnv.[[Names]]。
2. 对于 names 中的每个私有名称 pn，执行
   a. 如果 pn.[[Description]] 为 identifier，则
      i. 返回 pn。
3. 令 outerPrivEnv 为 privEnv.[[OuterPrivateEnvironment]]。
4. 断言：outerPrivEnv 不是 null。
5. 返回 ResolvePrivateIdentifier(outerPrivEnv, identifier)。

### 9.3 范围（Realms）

在评估之前，所有 ECMAScript 代码必须与一个范围相关联。从概念上讲，一个范围由一组内在对象、一个 ECMAScript 全局环境、在该全局环境范围内加载的所有 ECMAScript 代码以及其他相关状态和资源组成。

在本规范中，一个范围表示为一个范围记录（Realm Record），其字段在表 24 中规定：

#### 表 24: 范围记录字段

| 字段名称             | 值                             | 含义                                                        |
| ----------------- | --------------------------- | --------------------------------------------------------- |
| [[AgentSignifier]] | 一个代理标识符                  | 拥有该范围的代理                                            |
| [[Intrinsics]]     | 一个记录，其字段名称为内在键，其值为对象 | 与该范围相关的代码使用的内在值                                  |
| [[GlobalObject]]   | 一个对象或 undefined         | 该范围的全局对象                                              |
| [[GlobalEnv]]      | 一个全局环境记录                | 该范围的全局环境                                              |
| [[TemplateMap]]    | 一个记录列表，字段 [[Site]]（一个模板文字解析节点）和 [[Array]]（一个数组） | 模板对象分别为每个范围使用其范围记录的 [[TemplateMap]] 进行规范化。每个 [[Site]] 值是一个模板文字解析节点。关联的 [[Array]] 值是传递给标签函数的相应模板对象。 |
| [[LoadedModules]]  | 一个记录列表，字段 [[Specifier]]（一个字符串）和 [[Module]]（一个模块记录） | 从此范围导入的说明符字符串到已解析模块记录的映射。列表中不包含具有相同 [[Specifier]] 的两个不同记录。    |
| [[HostDefined]]    | 任意值（默认值为 undefined）   | 保留供需要与范围记录关联其他信息的主机使用的字段。                          |

#### 9.3.1 InitializeHostDefinedRealm ( )
抽象操作 InitializeHostDefinedRealm 不接受任何参数，返回包含 UNUSED 的正常完成或抛出完成。调用时执行以下步骤：

1. 令 realm 为一个新的范围记录。
2. 执行 CreateIntrinsics(realm)。
3. 将 realm.[[AgentSignifier]] 设置为 AgentSignifier()。
4. 将 realm.[[GlobalObject]] 设置为 undefined。
5. 将 realm.[[GlobalEnv]] 设置为 undefined。
6. 将 realm.[[TemplateMap]] 设置为一个新的空列表。
7. 令 newContext 为一个新的执行上下文。
8. 将 newContext 的 Function 设置为 null。
9. 将 newContext 的 Realm 设置为 realm。
10. 将 newContext 的 ScriptOrModule 设置为 null。
11. 将 newContext 推入执行上下文栈；newContext 现在是正在运行的执行上下文。
12. 如果主机需要使用一个异质对象作为 realm 的全局对象，
   a. 令 global 为以主机定义的方式创建的这样的对象。
13. 否则，
   a. 令 global 为 OrdinaryObjectCreate(realm.[[Intrinsics]].[[%Object.prototype%]])。
14. 如果主机需要 realm 的全局范围内的 this 绑定返回全局对象以外的对象，
   a. 令 thisValue 为以主机定义的方式创建的这样的对象。
15. 否则，
   a. 令 thisValue 为 global。
16. 将 realm.[[GlobalObject]] 设置为 global。
17. 将 realm.[[GlobalEnv]] 设置为 NewGlobalEnvironment(global, thisValue)。
18. 执行 ? SetDefaultGlobalBindings(realm)。
19. 在 global 上创建任何主机定义的全局对象属性。
20. 返回 UNUSED。

#### 9.3.2 CreateIntrinsics ( realmRec )
抽象操作 CreateIntrinsics 接受参数 realmRec（一个范围记录），并返回 UNUSED。调用时执行以下步骤：

1. 将 realmRec.[[Intrinsics]] 设置为一个新的记录。
2. 使用表 6 中列出的值设置 realmRec.[[Intrinsics]] 的字段。字段名称是表第一列中列出的名称。每个字段的值是一个新的对象值，完全且递归地填充了该对象在第 19 到 28 节中定义的属性值。所有对象属性值都是新创建的对象值。所有内置函数对象的值都是通过执行 CreateBuiltinFunction(steps, length, name, slots, realmRec, prototype) 创建的，其中 steps 是本规范提供的该函数的定义，name 是该函数 "name" 属性的初始值，length 是该函数 "length" 属性的初始值，slots 是函数指定的内部插槽的名称列表（如果有），prototype 是函数的 [[Prototype]] 内部插槽的指定值。内在对象及其属性的创建顺序必须避免对尚未创建的对象的依赖。
3. 执行 AddRestrictedFunctionProperties(realmRec.[[Intrinsics]].[[%Function.prototype%]], realmRec)。
4. 返回 UNUSED。

#### 9.3.3 SetDefaultGlobalBindings ( realmRec )
抽象操作 SetDefaultGlobalBindings 接受参数 realmRec（一个范围记录），并返回包含 UNUSED 的正常完成或抛出完成。调用时执行以下步骤：

1. 令 global 为 realmRec.[[GlobalObject]]。
2. 对于第 19 节中指定的全局对象的每个属性，执行
   a. 令 name 为属性名称的字符串值。
   b. 令 desc 为该属性的完全填充的数据属性描述符，包含该属性的指定属性。对于 19.2、19.3 或 19.4 中列出的属性，[[Value]] 属性的值是 realmRec 中相应的内在对象。
   c. 执行 ? DefinePropertyOrThrow(global, name, desc)。
3. 返回 UNUSED。

### 9.4 执行上下文

执行上下文是一个规范设备，用于跟踪 ECMAScript 实现代码的运行时评估。在任何时候，每个代理最多只有一个实际执行代码的执行上下文。这被称为代理的运行执行上下文。本规范中所有对运行执行上下文的引用均表示周围代理的运行执行上下文。

执行上下文栈用于跟踪执行上下文。运行执行上下文始终是该栈的顶元素。每当控制从当前运行执行上下文关联的可执行代码转移到与该上下文不关联的可执行代码时，都会创建一个新的执行上下文。新创建的执行上下文被推入栈中并成为运行执行上下文。

执行上下文包含跟踪其关联代码的执行进度所需的任何实现特定状态。每个执行上下文至少包含表 25 中列出的状态组件。

#### 表 25: 所有执行上下文的状态组件

| 组件                      | 目的                                                                 |
| ----------------------- | ------------------------------------------------------------------ |
| 代码评估状态               | 执行与此执行上下文关联的代码所需的任何状态，包括暂停和恢复评估。                               |
| 函| 组件            | 目的                                                                 |
| ------------- | ------------------------------------------------------------------ |
| 函数            | 如果此执行上下文正在评估一个函数对象的代码，那么该组件的值是该函数对象。如果上下文正在评估一个脚本或模块的代码，该值为 null。 |
| Realm         | 该上下文所关联代码访问 ECMAScript 资源的范围记录。                                |
| ScriptOrModule| 该上下文所关联代码的模块记录或脚本记录。如果没有关联的脚本或模块，例如在 InitializeHostDefinedRealm 创建的初始执行上下文的情况，该值为 null。 |

通过运行执行上下文的代码评估可以在本规范定义的各种点暂停。一旦运行执行上下文被暂停，另一个执行上下文可能成为运行执行上下文并开始评估其代码。在稍后的某个时间，已暂停的执行上下文可能再次成为运行执行上下文并从先前暂停的点继续评估其代码。运行执行上下文状态在执行上下文之间的转换通常以堆栈的后进先出方式进行。然而，一些 ECMAScript 特性需要非 LIFO 的运行执行上下文转换。

运行执行上下文的 Realm 组件的值也称为当前范围记录。运行执行上下文的函数组件的值也称为活动函数对象。

ECMAScript 代码执行上下文有表 26 中列出的其他状态组件。

#### 表 26: ECMAScript 代码执行上下文的其他状态组件

| 组件               | 目的                                                                      |
| ---------------- | ----------------------------------------------------------------------- |
| 词法环境（LexicalEnvironment） | 标识用于在此执行上下文中解析标识符引用的环境记录。                                       |
| 变量环境（VariableEnvironment） | 标识在此执行上下文中由 VariableStatements 创建的绑定的环境记录。                        |
| 私有环境（PrivateEnvironment）  | 标识由最近包含的类中的 ClassElements 创建的私有名称的私有环境记录。如果没有包含类，则为 null。 |

词法环境和变量环境组件始终是环境记录。

代表生成器评估的执行上下文有表 27 中列出的其他状态组件。

#### 表 27: 生成器执行上下文的其他状态组件

| 组件       | 目的                                      |
| -------- | --------------------------------------- |
| 生成器       | 此执行上下文正在评估的生成器。                         |

在大多数情况下，只有运行执行上下文（执行上下文栈的顶部）由本规范中的算法直接操作。因此，当术语“词法环境”和“变量环境”不加修饰地使用时，它们是指运行执行上下文的这些组件。

执行上下文纯粹是一个规范机制，不必对应于 ECMAScript 实现的任何特定工件。ECMAScript 代码无法直接访问或观察执行上下文。

#### 9.4.1 GetActiveScriptOrModule ( )
抽象操作 GetActiveScriptOrModule 不接受任何参数，返回一个脚本记录、模块记录或 null。它用于根据运行执行上下文确定正在运行的脚本或模块。调用时执行以下步骤：

1. 如果执行上下文栈为空，返回 null。
2. 令 ec 为执行上下文栈中顶层的 ScriptOrModule 组件不为 null 的执行上下文。
3. 如果不存在这样的执行上下文，返回 null。否则，返回 ec 的 ScriptOrModule。

#### 9.4.2 ResolveBinding ( name [ , env ] )
抽象操作 ResolveBinding 接受参数 name（一个字符串）和可选参数 env（一个环境记录或 undefined），返回一个包含参考记录的正常完成或抛出完成。它用于确定 name 的绑定。env 可用于显式提供要搜索绑定的环境记录。调用时执行以下步骤：

1. 如果未提供 env 或 env 为 undefined，
   a. 将 env 设置为运行执行上下文的词法环境。
2. 断言：env 是一个环境记录。
3. 令 strict 为正在评估的语法生成的 IsStrict。
4. 返回 ? GetIdentifierReference(env, name, strict)。

注意：ResolveBinding 的结果始终是一个其 [[ReferencedName]] 字段为 name 的参考记录。

#### 9.4.3 GetThisEnvironment ( )
抽象操作 GetThisEnvironment 不接受任何参数，返回一个环境记录。它查找当前提供 this 绑定的环境记录。调用时执行以下步骤：

1. 令 env 为运行执行上下文的词法环境。
2. 重复，
   a. 令 exists 为 env.HasThisBinding()。
   b. 如果 exists 为 true，返回 env。
   c. 令 outer 为 env.[[OuterEnv]]。
   d. 断言：outer 不是 null。
   e. 将 env 设置为 outer。

注意：步骤 2 中的循环总会终止，因为环境列表总是以提供 this 绑定的全局环境结束。

#### 9.4.4 ResolveThisBinding ( )
抽象操作 ResolveThisBinding 不接受任何参数，返回一个包含 ECMAScript 语言值的正常完成或抛出完成。它使用运行执行上下文的词法环境确定 this 的绑定。调用时执行以下步骤：

1. 令 envRec 为 GetThisEnvironment()。
2. 返回 ? envRec.GetThisBinding()。

#### 9.4.5 GetNewTarget ( )
抽象操作 GetNewTarget 不接受任何参数，返回一个对象或 undefined。它使用运行执行上下文的词法环境确定 NewTarget 的值。调用时执行以下步骤：

1. 令 envRec 为 GetThisEnvironment()。
2. 断言：envRec 具有 [[NewTarget]] 字段。
3. 返回 envRec.[[NewTarget]]。

#### 9.4.6 GetGlobalObject ( )
抽象操作 GetGlobalObject 不接受任何参数，返回一个对象。它返回当前运行执行上下文使用的全局对象。调用时执行以下步骤：

1. 令 currentRealm 为当前范围记录。
2. 返回 currentRealm.[[GlobalObject]]。


### 9.5 任务和主机操作来安排任务

任务是一个没有参数的抽象闭包，当没有其他 ECMAScript 计算正在进行时启动一个 ECMAScript 计算。

ECMAScript 主机环境在特定代理中安排任务执行。本规范描述了用于安排任务的主机钩子 `HostEnqueueGenericJob`、`HostEnqueueFinalizationRegistryCleanupJob`、`HostEnqueuePromiseJob` 和 `HostEnqueueTimeoutJob`。本规范中的主机钩子根据对任务安排施加的额外约束进行组织。主机可以定义其他安排任务的抽象操作。这些操作接受一个任务抽象闭包和一个 realm（一个 Realm 记录或 null）作为参数。如果提供了 Realm 记录，这些操作会安排在提供的 Realm 中在其拥有的代理上执行任务。如果提供的是 null，那么任务不会评估 ECMAScript 代码。它们的实现必须符合以下要求：

在将来的某个时间点，当任务安排的代理中没有运行上下文且该代理的执行上下文堆栈为空时，实施必须：
1. 执行任何主机定义的准备步骤。
2. 调用任务抽象闭包。
3. 执行任何主机定义的清理步骤，之后执行上下文堆栈必须为空。
4. 在任何时间点，一个代理中只能有一个任务在进行评估。
5. 一旦任务评估开始，必须在评估任何其他任务之前完成。
6. 抽象闭包必须返回正常完成，自己处理错误。

**注意 1**：主机环境不需要统一对待任务安排。例如，Web 浏览器和 Node.js 将 Promise 处理任务视为比其他工作更高的优先级；未来的特性可能会添加不被如此优先对待的任务。

在特定时间点，如果以下所有条件为真，则 scriptOrModule（一个脚本记录、一个模块记录或 null）是活动的脚本或模块：
1. `GetActiveScriptOrModule()` 是 scriptOrModule。
2. 如果 scriptOrModule 是一个脚本记录或模块记录，则令 ec 为执行上下文堆栈中顶层的执行上下文，其 ScriptOrModule 组件为 scriptOrModule。ec 的 Realm 组件是 scriptOrModule.[[Realm]]。

在特定时间点，如果以下所有条件为真，则一个执行准备评估 ECMAScript 代码：
1. 执行上下文堆栈不为空。
2. 执行上下文堆栈顶层的执行上下文的 Realm 组件是一个 Realm 记录。

**注意 2**：主机环境可以通过将执行上下文推送到执行上下文堆栈来准备评估代码。具体步骤由实现定义。

特定的 Realm 选择由主机环境决定。这个初始执行上下文和 Realm 仅在任何回调函数被调用之前使用。当与任务相关的回调函数（如 Promise 处理程序）被调用时，调用会推送其自身的执行上下文和 Realm。

特定类型的任务有额外的合规要求。

### 9.5.1 JobCallback 记录

JobCallback 记录是一个用于存储函数对象和主机定义值的记录值。通过主机安排的任务调用的函数对象可能有额外的主机定义上下文。为了传递状态，任务抽象闭包不应直接捕获和调用函数对象。相反，使用 `HostMakeJobCallback` 和 `HostCallJobCallback`。

**注意**：例如，WHATWG HTML 规范（<https://html.spec.whatwg.org/>）使用主机定义值来传递 Promise 回调的现有设置对象。

JobCallback 记录有表 28 中列出的字段。

#### 表 28: JobCallback 记录字段

| 字段名         | 值                 | 含义                         |
| ------------- | ------------------ | -------------------------- |
| [[Callback]]  | 一个函数对象       | 当任务被调用时调用的函数。      |
| [[HostDefined]] | 任意值（默认值为空） | 预留给主机使用的字段。          |

### 9.5.2 HostMakeJobCallback ( callback )

主机定义的抽象操作 `HostMakeJobCallback` 接受参数 callback（一个函数对象）并返回一个 JobCallback 记录。

`HostMakeJobCallback` 的实现必须符合以下要求：
1. 它必须返回一个 JobCallback 记录，其 [[Callback]] 字段是 callback。

默认的 `HostMakeJobCallback` 实现执行以下步骤：

1. 返回 JobCallback 记录 { [[Callback]]: callback, [[HostDefined]]: EMPTY }。

非 Web 浏览器的 ECMAScript 主机必须使用默认的 `HostMakeJobCallback` 实现。

**注意**：在将回调传递给负责最终安排和运行的函数时调用此操作。例如，`promise.then(thenAction)` 在调用 `Promise.prototype.then` 时对 thenAction 调用 `MakeJobCallback`，而不是在安排反应任务时。

### 9.5.3 HostCallJobCallback ( jobCallback, V, argumentsList )

主机定义的抽象操作 `HostCallJobCallback` 接受参数 jobCallback（一个 JobCallback 记录）、V（一个 ECMAScript 语言值）和 argumentsList（一个 ECMAScript 语言值的列表），返回一个包含 ECMAScript 语言值的正常完成或抛出完成。

`HostCallJobCallback` 的实现必须符合以下要求：
1. 它必须执行并返回 `Call(jobCallback.[[Callback]], V, argumentsList)` 的结果。

**注意**：此要求意味着主机不能更改本规范中定义的函数对象的 [[Call]] 行为。

默认的 `HostCallJobCallback` 实现执行以下步骤：

1. 断言：`IsCallable(jobCallback.[[Callback]])` 为 true。
2. 返回 `? Call(jobCallback.[[Callback]], V, argumentsList)`。

非 Web 浏览器的 ECMAScript 主机必须使用默认的 `HostCallJobCallback` 实现。

### 9.5.4 HostEnqueueGenericJob ( job, realm )

主机定义的抽象操作 `HostEnqueueGenericJob` 接受参数 job（一个任务抽象闭包）和 realm（一个 Realm 记录）并返回 UNUSED。它在 realm 代表的代理中安排在某个未来时间执行任务。与此算法一起使用的抽象闭包旨在安排而没有额外的约束，例如优先级和排序。

`HostEnqueueGenericJob` 的实现必须符合 9.5 中的要求。

### 9.5.5 HostEnqueuePromiseJob ( job, realm )

主机定义的抽象操作 `HostEnqueuePromiseJob` 接受参数 job（一个任务抽象闭包）和 realm（一个 Realm 记录或 null）并返回 UNUSED。它安排任务在某个未来时间执行。与此算法一起使用的抽象闭包旨在与 Promise 处理操作相关或以与 Promise 处理操作相等的优先级安排。

`HostEnqueuePromiseJob` 的实现必须符合 9.5 中的要求以及以下要求：

1. 如果 realm 不是 null，每次调用 job 时，实施必须执行实现定义的步骤，以便在调用 job 时准备好评估 ECMAScript 代码。
2. 令 scriptOrModule 为调用 `HostEnqueuePromiseJob` 时的 `GetActiveScriptOrModule()`。如果 realm 不是 null，每次调用 job 时，实施必须执行实现定义的步骤，以便在调用 job 时 scriptOrModule 是活动的脚本或模块。
3. 任务必须按照安排它们的 `HostEnqueuePromiseJob` 调用的顺序运行。

**注意**：`NewPromiseResolveThenableJob` 返回的任务的 realm 通常是调用 then 函数对象上的 `GetFunctionRealm` 的结果。`NewPromiseReactionJob` 返回的任务的 realm 通常是调用处理程序（如果处理程序不是 undefined）上的 `GetFunctionRealm` 的结果。如果处理程序是 undefined，realm 为 null。对于这两种任务，当 `GetFunctionRealm` 异常完成时（例如，在被撤销的 Proxy 上调用），realm 是 `GetFunctionRealm` 调用时的当前 Realm 记录。当 realm 为 null 时，不会评估用户 ECMAScript 代码，也不会创建新的 ECMAScript 对象（例如错误对象）。例如，WHATWG HTML 规范（<https://html.spec.whatwg.org/>）使用 realm 检查运行脚本的能力和入口概念。

### 9.5.6 HostEnqueueTimeoutJob ( timeoutJob, realm, milliseconds )

主机定义的抽象操作 `HostEnqueueTimeoutJob` 接受参数 timeoutJob（一个任务抽象闭包）、realm（一个 Realm 记录）和 milliseconds（一个非负有限数字）并返回 UNUSED。它在 realm 代表的代理中安排在至少 milliseconds 毫秒后执行任务。

`HostEnqueueTimeoutJob` 的实现必须符合 9.5 中的要求。

### 9.6 代理

代理包括一组 ECMAScript 执行上下文、一个执行上下文堆栈、一个运行执行上下文、一个代理记录和一个执行线程。除了执行线程，代理的组成部分专属于该代理。

代理的执行线程独立于其他代理执行### 代理的执行上下文，除非某个代理共享的执行线程具有多个代理，并且没有代理记录的 [[CanBlock]] 字段为 true。

**注意 1**：例如，一些 Web 浏览器在多个不相关的浏览器窗口选项卡之间共享单个执行线程。

当代理的执行线程正在执行算法步骤时，该代理是这些步骤的周围代理。这些步骤使用周围代理访问代理内持有的规范级执行对象：运行执行上下文、执行上下文堆栈和代理记录的字段。

代理标识符是一个全局唯一的、不透明的值，用于标识一个代理。

#### 表 29：代理记录字段

| 字段名            | 值                | 含义                                                                 |
| ----------------- | ----------------- | -------------------------------------------------------------------- |
| [[LittleEndian]]  | 布尔值            | 当算法 GetValueFromBuffer 和 SetValueInBuffer 需要时计算的 isLittleEndian 参数的默认值。选择是实现定义的，应选择对实现最有效的替代方案。一旦观察到该值，它就不能更改。       |
| [[CanBlock]]      | 布尔值            | 确定代理是否可以阻塞。                                               |
| [[Signifier]]     | 代理标识符        | 唯一标识代理集群中的代理。                                           |
| [[IsLockFree1]]   | 布尔值            | 如果对一个字节值的原子操作是无锁的，则为 true，否则为 false。         |
| [[IsLockFree2]]   | 布尔值            | 如果对两个字节值的原子操作是无锁的，则为 true，否则为 false。         |
| [[IsLockFree8]]   | 布尔值            | 如果对八个字节值的原子操作是无锁的，则为 true，否则为 false。         |
| [[CandidateExecution]] | 候选执行记录  | 参见内存模型。                                                      |
| [[KeptAlive]]     | 对象或符号的列表 | 最初是一个新的空列表，表示直到当前任务结束为止要保持活跃的对象和/或符号的列表。 |

一旦集群中的任何代理观察到 [[Signifier]]、[[IsLockFree1]] 和 [[IsLockFree2]] 的值，它们就不能更改。

**注意 2**：[[IsLockFree1]] 和 [[IsLockFree2]] 的值不一定由硬件决定，还可能反映实现选择，这些选择可能会随时间和 ECMAScript 实现而有所不同。

没有 [[IsLockFree4]] 字段：4 字节的原子操作始终是无锁的。

实际上，如果原子操作使用任何类型的锁，该操作就不是无锁的。无锁不意味着无等待：没有上限，说明完成无锁原子操作可能需要多少机器步骤。

原子访问大小 n 的无锁性并不暗示非原子访问大小 n 的（感知的）原子性，具体来说，非原子访问可能仍作为多个独立的内存访问序列执行。有关详细信息，请参阅 ReadSharedMemory 和 WriteSharedMemory。

**注意 3**：代理是一个规范机制，不必对应于任何特定的 ECMAScript 实现工件。

### 9.6.1 AgentSignifier ( )

抽象操作 AgentSignifier 不接受参数并返回一个代理标识符。它在调用时执行以下步骤：

1. 令 AR 为周围代理的代理记录。
2. 返回 AR.[[Signifier]]。

### 9.6.2 AgentCanSuspend ( )

抽象操作 AgentCanSuspend 不接受参数并返回一个布尔值。它在调用时执行以下步骤：

1. 令 AR 为周围代理的代理记录。
2. 返回 AR.[[CanBlock]]。

**注意**：在某些环境中，某个代理可能无法合理地挂起。例如，在 Web 浏览器环境中，可能不允许挂起文档的主事件处理线程，而允许挂起工人的事件处理线程。

### 9.7 代理集群

代理集群是可以通过操作共享内存进行通信的代理的最大集合。

**注意 1**：不同代理中的程序可能通过未指定的方法共享内存。最小化，共享数组缓冲区的底层内存可以在集群中的代理之间共享。

可能有一些代理可以通过消息传递进行通信，但不能共享内存；它们永远不会在同一个代理集群中。

每个代理正好属于一个代理集群。

**注意 2**：集群中的代理不必在特定时间点全部活跃。如果代理 A 创建了另一个代理 B，随后 A 终止且 B 创建了代理 C，则这三个代理处于同一个集群中，如果 A 可以与 B 共享一些内存且 B 可以与 C 共享一些内存。

集群中的所有代理必须在各自代理记录的 [[LittleEndian]] 字段中具有相同的值。

**注意 3**：如果代理集群中的不同代理具有不同的 [[LittleEndian]] 值，共享内存进行多字节数据处理会变得困难。

集群中的所有代理必须在各自代理记录的 [[IsLockFree1]] 字段中具有相同的值；类似地，对于 [[IsLockFree2]] 字段。

集群中的所有代理必须在各自代理记录的 [[Signifier]] 字段中具有不同的值。

嵌入可以在不通知或配合代理的情况下停用（停止前进进程）或激活（恢复前进进程）代理。如果嵌入这样做，它不得无限期地让集群中的某些代理保持活跃而让其他代理停用。

**注意 4**：上述限制的目的是避免代理死锁或饿死的情况。例如，如果一个 HTML 共享工人的生命周期独立于任何窗口中的文档，并且允许它与此类独立文档的专用工人共享内存，而文档及其专用工人停用时（例如，文档被推入其窗口的历史中），如果专用工人持有锁并且共享工人尝试获取锁，则共享工人将被阻塞，直到专用工人再次激活（如果有的话）。与此同时，尝试从其他窗口访问共享工人的其他工人将饿死。

上述限制意味着，无法在嵌入中共享内存的代理之间共享内存。

嵌入可以在没有集群其他代理事先通知或配合的情况下终止代理。如果代理不是通过其自身或集群中其他代理的程序动作终止，而是通过集群外部的力量终止，则嵌入必须选择两种策略之一：要么终止集群中的所有代理，要么提供可靠的 API，使集群中的代理能够协调，以便至少一个剩余成员能够检测到终止，终止数据包含足够的信息来识别被终止的代理。

**注意 5**：这种类型终止的示例包括：操作系统或用户终止运行在单独进程中的代理；当每代理资源计数指示代理失控时，嵌入本身终止与其他代理在同一进程中运行的代理。

以下每个规范值及其传递可达的值正好属于一个代理集群：

- 候选执行记录
- 共享数据块
- 等待者列表记录

在集群中的任何代理评估任何 ECMAScript 代码之前，所有代理的代理记录中的 [[CandidateExecution]] 字段设置为初始候选执行。初始候选执行是一个空候选执行，其 [[EventsRecords]] 字段是一个包含每个代理的代理事件记录的列表，每个代理事件记录的 [[AgentSignifier]] 字段是该代理的代理标识符，其 [[EventList]] 和 [[AgentSynchronizesWith]] 字段为空列表。

**注意 6**：集群中的所有代理在其代理记录的 [[CandidateExecution]] 字段中共享相同的候选执行。候选执行是内存模型使用的规范机制。

**注意 7**：代理集群是一个规范机制，不必对应于任何特定的 ECMAScript 实现工件。

### 9.8 前进进度

代理进行前进进度是指其根据本规范执行评估步骤。

当代理的运行执行上下文同步且无限期地等待外部事件时，该代理被阻塞。只有代理记录的 [[CanBlock]] 字段为 true 的代理才能以这种方式被阻塞。未阻塞的代理是未被阻塞的代理。

实施必须确保：

- 每个具有专用执行线程的未阻塞代理最终进行前进进度
- 在共享执行线程的一组代理中，一个代理最终进行前进进度
- 除非通过显式 API 提供阻塞，否则代理不会导致另一个代理被阻塞

**注意**：这与内存模型中的活性保证一起，确保所有 SEQ-CST 写入最终对所有代理可观察。

### 9.9 弱引用和终结注册表目标的处理模型

#### 9.9.1 目标

本规范不保证任何对象或符号将被垃圾回收。非活动对象或符号可能在长时间后释放，也可能永远不会释放。因此，本规范在描述由垃圾回收触发的行为时使用了“可能”一词。

弱引用和终结注册表的语义基于在特定时间点发生的两个操作：

1. 当调用 `WeakRef.prototype.deref` 时，引用对象（如果未返回 undefined）将保持活跃，以便后续同步访问也返回相同的值。当通过 `ClearKeptObjects` 抽象操作进行同步工作时，此列表将被重置。
2. 当一个对象或符号与一个终结注册表关联变得不可访问时，可能会在同步 ECMAScript 执行完成后最终调用终结注册表的清理回调。终结注册表清理通过 `CleanupFinalizationRegistry` 抽象操作进行。

这些操作（`ClearKeptObjects` 或 `CleanupFinalizationRegistry`）都不得中断同步 ECMAScript 执行。由于主机可以组合更长的同步 ECMAScript 执行运行，本规范将 `ClearKeptObjects` 和 `CleanupFinalizationRegistry` 的调度推迟到主机环境。

一些 ECMAScript 实现包括在后台运行的垃圾收集器，包括 ECMAScript 空闲时运行的垃圾收集器。让主机环境调度 `CleanupFinalizationRegistry` 允许它恢复 ECMAScript 执行以运行终结器工作，这可能释放持有的值，减少整体内存使用。

#### 9.9.2 活跃性

对于对象和/或符号集 S，一个假设的弱引用无关的执行（相对于 S）是一个执行，其中 `WeakRefDeref` 对一个弱引用，其引用对象是 S 的元素，总是返回 undefined。

**注意 1**：弱引用无关性与活跃性捕捉了两个概念。首先，弱引用本身不会保持其引用对象活跃。其次，活跃性中的循环并不意味着值是活跃的。具体来说，如果确定 v 的活跃性依赖于确定弱引用引用对象 r 的活跃性，r 的活跃性不能假设 v 的活跃性，否则将是循环推理。

**注意 2**：弱引用无关性是针对对象或符号集而不是单个值定义的，以处理循环。如果定义在单个值上，则在循环中的弱引用引用对象将被视为活跃，即使它的身份仅通过循环中的其他弱引用引用对象观察到。

**注意 3**：通俗地说，如果包含某个值的每个集合都是活跃的，则我们说该单个对象或符号是活跃的。

在评估期间的任何时候，如果对象和/或符号集 S 满足以下任一条件，则 S 被认为是活跃的：

- S 中的任何元素包含在任何代理的 `[[KeptAlive]]` 列表中。
- 存在一个有效的未来假设弱引用无关的执行，相对于 S，该执行观察到 S 中任何值的身份。

**注意 4**：上述第二个条件旨在捕捉这样一种直觉，即如果一个值的身份通过非弱引用手段可观察，则该值是活跃的。通过观察严格相等比较或观察将该值用作 Map 的键，可以观察到一个值的身份。

**注意 5**：值在字段、内部插槽或属性中的存在并不意味着该值是活跃的。例如，如果该值从未传递回程序，则无法观察到它。这是弱映射中的键、弱集合的成员以及终结注册表单元记录的 `[[WeakRefTarget]]` 和 `[[UnregisterToken]]` 字段的情况。

上述定义意味着，如果弱映射中的键不是活跃的，则其对应的值也不一定是活跃的。

**注意 6**：活跃性是保证哪些弱引用引擎不得清空的下限。此处定义的活跃性是不可判定的。实际上，引擎使用保守的近似，如可达性。预计会有显著的实现余地。

#### 9.9.3 执行

在任何时候，如果对象和/或符号集 S 不是活跃的，则 ECMAScript 实现可能原子地执行以下步骤：

1. 对于 S 的每个元素值，执行以下步骤：
   a. 对于每个弱引用 ref，使 ref.[[WeakRefTarget]] 为 value，执行以下步骤：
      i. 将 ref.[[WeakRefTarget]] 设置为 EMPTY。
   b. 对于每个终结注册表 fg，使 fg.[[Cells]] 包含记录 cell，其 [[WeakRefTarget]] 为 value，执行以下步骤：
      i. 将 cell.[[WeakRefTarget]] 设置为 EMPTY。
      ii. 可选地，执行 `HostEnqueueFinalizationRegistryCleanupJob(fg)`。
   c. 对于每个弱映射 map，使 map.[[WeakMapData]] 包含记录 r，其 [[Key]] 为 value，执行以下步骤：
      i. 将 r.[[Key]] 设置为 EMPTY。
      ii. 将 r.[[Value]] 设置为 EMPTY。
   d. 对于每个弱集合 set，使 set.[[WeakSetData]] 包含 value，执行以下步骤：
      i. 将 set.[[WeakSetData]] 中值为 value 的元素替换为值为 EMPTY 的元素。

**注意 1**：结合活跃性的定义，此条款规定了实现可以应用的关于弱引用的优化。

可以访问对象而不观察其身份。对非逃逸对象的属性进行标量替换和死变量消除等优化是允许的，这些优化因此允许可观察地清空指向这些对象的弱引用。

另一方面，如果对象的身份是可观察的，并且该对象位于弱引用的 `[[WeakRefTarget]]` 内部插槽中，则禁止可观察地清空该弱引用的优化，如重新物化。

由于调用 `HostEnqueueFinalizationRegistryCleanupJob` 是可选的，注册在终结注册表中的对象不会必然保持该终结注册表活跃。实现可以由于任何原因省略终结注册表回调，例如，如果终结注册表本身变为非活动，或如果应用程序正在关闭。

**注意 2**：实现没有义务为非活跃对象或符号的最大集合清空弱引用。

如果实现选择了一个非活跃的集合 S 以清空弱引用，此定义要求它同时清空 S 中所有值的弱引用。换句话说，实现不可符合规范地仅清空指向值 v 的弱引用，而不清空其他可能导致观察到 v 值的弱引用。

#### 9.9.4 主机钩子

##### 9.9.4.1 HostEnqueueFinalizationRegistryCleanupJob ( finalizationRegistry )

主机定义的抽象操作 `HostEnqueueFinalizationRegistryCleanupJob` 接受参数 finalizationRegistry（一个终结注册表）并返回 UNUSED。

令 cleanupJob 为一个没有参数的新任务抽象闭包，该闭包捕获 finalizationRegistry 并在调用时执行以下步骤：

1. 令 cleanupResult 为 `Completion(CleanupFinalizationRegistry(finalizationRegistry))`。
2. 如果 cleanupResult 是一个异常完成，则执行任何主机定义的错误报告步骤。
3. 返回 UNUSED。

`HostEnqueueFinalizationRegistryCleanupJob` 的实现安排 cleanupJob 在某个将来的时间执行（如果可能）。它还必须符合 9.5 中的要求。

### 9.10 ClearKeptObjects ( )

抽象操作 `ClearKeptObjects` 不接受参数并返回 UNUSED。预期 ECMAScript 实现会在同步 ECMAScript 执行序列完成时调用 `ClearKeptObjects`。它在调用时执行以下步骤：

1. 令 agentRecord 为周围代理的代理记录。
2. 将 agentRecord.[[KeptAlive]] 设置为一个新的空列表。
3. 返回 UNUSED。

### 9.11 AddToKeptObjects ( value )

抽象操作 `AddToKeptObjects` 接受参数 value（一个对象或符号）并返回 UNUSED。它在调用时执行以下步骤：

1. 令 agentRecord 为周围代理的代理记录。
2. 将 value 附加到 agentRecord.[[KeptAlive]]。
3. 返回 UNUSED。

**注意**：当抽象操作 `AddToKeptObjects` 被调用并传递一个目标对象或符号时，它将目标添加到一个列表中，该列表在调用 `ClearKeptObjects` 之前将强烈指向目标。

### 9.12 CleanupFinalizationRegistry ( finalizationRegistry )

抽象操作 `CleanupFinalizationRegistry` 接受参数 finalizationRegistry（一个终结注册表）并返回包含 UNUSED 的正常完成或抛出完成。它在调用时执行以下步骤：

1. 断言：finalizationRegistry 有 `[[Cells]]` 和 `[[CleanupCallback]]` 内部插槽。
2. 令 callback 为 finalizationRegistry.[[CleanupCallback]]。
3. 当 finalizationRegistry.[[Cells]] 包含一个记录 cell 且 cell.[[WeakRefTarget]] 为 EMPTY 时，实现可以执行以下步骤：
   a. 选择任何此类 cell。
   b. 从 finalizationRegistry.[[Cells]] 中移除 cell。
   c. 执行 `?HostCallJobCallback(callback, undefined, « cell.[[HeldValue]] »)`。
4. 返回 UNUSED。

### 9.13 CanBeHeldWeakly ( v )

抽象操作 `CanBeHeldWeakly` 接受参数 v（一个 ECMAScript 语言值）并返回一个布尔值。它在调用时执行以下步骤：

1. 如果 v 是一个对象，返回 true。
2. 如果 v 是一个符号且 `KeyForSymbol(v)` 为 undefined，返回 true。
3. 返回 false。

**注意**：没有语言身份的语言值无法被引用，且不适合作为弱引用。例如，Symbol 值是通过 `Symbol.for` 生成的，与其他 Symbol 值不同，没有语言身份且不适合作为弱引用。众所周知的符号可能永远不会被回收，但仍然被视为适合作为弱引用，因为它们数量有限，可以通过多种实现方法进行管理。然而，任何关联到活跃弱映射中的众所周知符号的值都不太可能被回收，并可能在实现中“泄漏”内存资源。

### 10. 普通对象和异变对象的行为

### 10.1 普通对象的内部方法和内部槽

所有普通对象都有一个名为 `[[Prototype]]` 的内部槽。该内部槽的值要么是 `null` 要么是一个对象，用于实现继承。假设普通对象 O 缺少名为 P 的属性，但其 `[[Prototype]]` 对象上存在 P 属性。如果 P 是 `[[Prototype]]` 对象上的数据属性，则 O 继承它的获取访问行为，使得 P 看起来像是 O 的属性。如果 P 是 `[[Prototype]]` 对象上的可写数据属性，则在 O 上设置 P 会创建一个名为 P 的新数据属性。如果 P 是 `[[Prototype]]` 对象上的不可写数据属性，则在 O 上设置 P 会失败。如果 P 是 `[[Prototype]]` 对象上的访问器属性，则 O 会继承该访问器的获取和设置访问。

每个普通对象都有一个布尔值的 `[[Extensible]]` 内部槽，用于满足 6.1.7.3 中指定的与扩展性相关的内部方法不变量。即，一旦对象的 `[[Extensible]]` 内部槽的值被设置为 `false`，就无法再向该对象添加属性、修改该对象的 `[[Prototype]]` 内部槽的值或将 `[[Extensible]]` 的值更改为 `true`。

在以下算法描述中，假设 O 是一个普通对象，P 是一个属性键值，V 是任何 ECMAScript 语言值，Desc 是一个属性描述符记录。

每个普通对象的内部方法都委托给一个类似命名的抽象操作。如果这样的抽象操作依赖于另一个内部方法，则在 O 上调用内部方法，而不是直接调用类似命名的抽象操作。这些语义确保当普通对象内部方法应用于异变对象时，异变对象的重载内部方法会被调用。

#### 10.1.1 `[[GetPrototypeOf]] ( )`
普通对象 O 的 `[[GetPrototypeOf]]` 内部方法不接受参数，返回一个包含对象或 `null` 的正常完成。调用时执行以下步骤：

1. 返回 `OrdinaryGetPrototypeOf(O)`。

#### 10.1.1.1 `OrdinaryGetPrototypeOf ( O )`
抽象操作 `OrdinaryGetPrototypeOf` 接受参数 O（一个对象），返回一个对象或 `null`。调用时执行以下步骤：

1. 返回 O.`[[Prototype]]`。

#### 10.1.2 `[[SetPrototypeOf]] ( V )`
普通对象 O 的 `[[SetPrototypeOf]]` 内部方法接受参数 V（一个对象或 `null`），返回一个包含布尔值的正常完成。调用时执行以下步骤：

1. 返回 `OrdinarySetPrototypeOf(O, V)`。

#### 10.1.2.1 `OrdinarySetPrototypeOf ( O, V )`
抽象操作 `OrdinarySetPrototypeOf` 接受参数 O（一个对象）和 V（一个对象或 `null`），返回一个布尔值。调用时执行以下步骤：

1. 令 current 为 O.`[[Prototype]]`。
2. 如果 `SameValue(V, current)` 为 `true`，返回 `true`。
3. 令 extensible 为 O.`[[Extensible]]`。
4. 如果 extensible 为 `false`，返回 `false`。
5. 令 p 为 V。
6. 令 done 为 `false`。
7. 重复，直到 done 为 `false`，
   a. 如果 p 为 `null`，则
      i. 令 done 为 `true`。
   b. 否则如果 `SameValue(p, O)` 为 `true`，则
      i. 返回 `false`。
   c. 否则，
      i. 如果 p.`[[GetPrototypeOf]]` 不是 10.1.1 中定义的普通对象内部方法，令 done 为 `true`。
      ii. 否则，令 p 为 p.`[[Prototype]]`。
8. 将 O.`[[Prototype]]` 设置为 V。
9. 返回 `true`。

**注意**：第 7 步中的循环保证了任何仅包含使用普通对象定义 `[[GetPrototypeOf]]` 和 `[[SetPrototypeOf]]` 的对象的原型链中不会有循环。

#### 10.1.3 `[[IsExtensible]] ( )`
普通对象 O 的 `[[IsExtensible]]` 内部方法不接受参数，返回一个包含布尔值的正常完成。调用时执行以下步骤：

1. 返回 `OrdinaryIsExtensible(O)`。

#### 10.1.3.1 `OrdinaryIsExtensible ( O )`
抽象操作 `OrdinaryIsExtensible` 接受参数 O（一个对象），返回一个布尔值。调用时执行以下步骤：

1. 返回 O.`[[Extensible]]`。

#### 10.1.4 `[[PreventExtensions]] ( )`
普通对象 O 的 `[[PreventExtensions]]` 内部方法不接受参数，返回一个包含 `true` 的正常完成。调用时执行以下步骤：

1. 返回 `OrdinaryPreventExtensions(O)`。

#### 10.1.4.1 `OrdinaryPreventExtensions ( O )`
抽象操作 `OrdinaryPreventExtensions` 接受参数 O（一个对象），返回 `true`。调用时执行以下步骤：

1. 将 O.`[[Extensible]]` 设置为 `false`。
2. 返回 `true`。

#### 10.1.5 `[[GetOwnProperty]] ( P )`
普通对象 O 的 `[[GetOwnProperty]]` 内部方法接受参数 P（一个属性键），返回一个包含属性描述符或未定义的正常完成。调用时执行以下步骤：

1. 返回 `OrdinaryGetOwnProperty(O, P)`。

#### 10.1.5.1 `OrdinaryGetOwnProperty ( O, P )`
抽象操作 `OrdinaryGetOwnProperty` 接受参数 O（一个对象）和 P（一个属性键），返回一个属性描述符或未定义。调用时执行以下步骤：

1. 如果 O 没有键值为 P 的自有属性，返回未定义。
2. 令 D 为一个新创建的没有字段的属性描述符。
3. 令 X 为 O 的键值为 P 的自有属性。
4. 如果 X 是一个数据属性，则
   a. 将 D.`[[Value]]` 设置为 X 的 `[[Value]]` 属性的值。
   b. 将 D.`[[Writable]]` 设置为 X 的 `[[Writable]]` 属性的值。
5. 否则，
   a. 断言：X 是一个访问器属性。
   b. 将 D.`[[Get]]` 设置为 X 的 `[[Get]]` 属性的值。
   c. 将 D.`[[Set]]` 设置为 X 的 `[[Set]]` 属性的值。
6. 将 D.`[[Enumerable]]` 设置为 X 的 `[[Enumerable]]` 属性的值。
7. 将 D.`[[Configurable]]` 设置为 X 的 `[[Configurable]]` 属性的值。
8. 返回 D。

#### 10.1.6 `[[DefineOwnProperty]] ( P, Desc )`
普通对象 O 的 `[[DefineOwnProperty]]` 内部方法接受参数 P（一个属性键）和 Desc（一个属性描述符），返回一个包含布尔值的正常完成或一个抛出完成。调用时执行以下步骤：

1. 返回 `? OrdinaryDefineOwnProperty(O, P, Desc)`。

#### 10.1.6.1 `OrdinaryDefineOwnProperty ( O, P, Desc )`
抽象操作 `OrdinaryDefineOwnProperty` 接受参数 O（一个对象），P（一个属性键）和 Desc（一个属性描述符），返回一个包含布尔值的正常完成或一个抛出完成。调用时执行以下步骤：

1. 令 current 为 `? O.[[GetOwnProperty]](P)`。
2. 令 extensible 为 `? IsExtensible(O)`。
3. 返回 `ValidateAndApplyPropertyDescriptor(O, P, extensible, Desc, current)`。

#### 10.1.6.2 `IsCompatiblePropertyDescriptor ( Extensible, Desc, Current )`
抽象操作 `IsCompatiblePropertyDescriptor` 接受参数 Extensible（一个布尔值），Desc（一个属性描述符）和 Current（一个属性描述符或未定义），返回一个布尔值。调用时执行以下步骤：

1. 返回 `ValidateAndApplyPropertyDescriptor(undefined, "", Extensible, Desc, Current)`。

#### 10.1.6.3 `ValidateAndApplyPropertyDescriptor ( O, P, extensible, Desc, current )`
抽象操作 `ValidateAndApplyPropertyDescriptor` 接受参数 O（一个对象或未定义），P（一个属性键），extensible（一个布尔值），Desc（一个属性描述符）和 current（一个属性描述符或未定义），返回一个布尔值。当且仅当 Desc 可以在保持不变量的情况下作为具有指定扩展性和当前属性 current 的对象的属性应用时，返回 `true`。当这种应用可能且 O 不为未定义时，它会为名为 P 的属性执行（如果需要的话创建该属性）。调用时执行以下步骤：

1. 断言：P 是一个属性键1. 断言：P 是一个属性键。
2. 如果 current 为 undefined，则
   a. 如果 extensible 为 false，返回 false。
   b. 如果 O 为 undefined，返回 true。
   c. 如果 IsAccessorDescriptor(Desc) 为 true，则
      i. 创建对象 O 的名为 P 的自有访问器属性，其 `[[Get]]`、`[[Set]]`、`[[Enumerable]]` 和 `[[Configurable]]` 属性设置为 Desc 中相应字段的值，如果 Desc 没有该字段，则设置为属性的默认值。
   d. 否则，
      i. 创建对象 O 的名为 P 的自有数据属性，其 `[[Value]]`、`[[Writable]]`、`[[Enumerable]]` 和 `[[Configurable]]` 属性设置为 Desc 中相应字段的值，如果 Desc 没有该字段，则设置为属性的默认值。
   e. 返回 true。
3. 断言：current 是一个完全填充的属性描述符。
4. 如果 Desc 没有任何字段，返回 true。
5. 如果 current.`[[Configurable]]` 为 false，则
   a. 如果 Desc 有 `[[Configurable]]` 字段且 Desc.`[[Configurable]]` 为 true，返回 false。
   b. 如果 Desc 有 `[[Enumerable]]` 字段且 Desc.`[[Enumerable]]` 不等于 current.`[[Enumerable]]`，返回 false。
   c. 如果 IsGenericDescriptor(Desc) 为 false 且 IsAccessorDescriptor(Desc) 不等于 IsAccessorDescriptor(current)，返回 false。
   d. 如果 IsAccessorDescriptor(current) 为 true，则
      i. 如果 Desc 有 `[[Get]]` 字段且 `SameValue(Desc.[[Get]], current.[[Get]])` 为 false，返回 false。
      ii. 如果 Desc 有 `[[Set]]` 字段且 `SameValue(Desc.[[Set]], current.[[Set]])` 为 false，返回 false。
   e. 否则，如果 current.`[[Writable]]` 为 false，则
      i. 如果 Desc 有 `[[Writable]]` 字段且 Desc.`[[Writable]]` 为 true，返回 false。
      ii. 如果 Desc 有 `[[Value]]` 字段且 `SameValue(Desc.[[Value]], current.[[Value]])` 为 false，返回 false。
6. 如果 O 不为 undefined，则
   a. 如果 IsDataDescriptor(current) 为 true 且 IsAccessorDescriptor(Desc) 为 true，则
      i. 如果 Desc 有 `[[Configurable]]` 字段，令 configurable 为 Desc.`[[Configurable]]`；否则令 configurable 为 current.`[[Configurable]]`。
      ii. 如果 Desc 有 `[[Enumerable]]` 字段，令 enumerable 为 Desc.`[[Enumerable]]`；否则令 enumerable 为 current.`[[Enumerable]]`。
      iii. 用一个访问器属性替换对象 O 的名为 P 的属性，其 `[[Configurable]]` 和 `[[Enumerable]]` 属性设置为 configurable 和 enumerable，且其 `[[Get]]` 和 `[[Set]]` 属性设置为 Desc 中相应字段的值，如果 Desc 没有该字段，则设置为属性的默认值。
   b. 否则如果 IsAccessorDescriptor(current) 为 true 且 IsDataDescriptor(Desc) 为 true，则
      i. 如果 Desc 有 `[[Configurable]]` 字段，令 configurable 为 Desc.`[[Configurable]]`；否则令 configurable 为 current.`[[Configurable]]`。
      ii. 如果 Desc 有 `[[Enumerable]]` 字段，令 enumerable 为 Desc.`[[Enumerable]]`；否则令 enumerable 为 current.`[[Enumerable]]`。
      iii. 用一个数据属性替换对象 O 的名为 P 的属性，其 `[[Configurable]]` 和 `[[Enumerable]]` 属性设置为 configurable 和 enumerable，且其 `[[Value]]` 和 `[[Writable]]` 属性设置为 Desc 中相应字段的值，如果 Desc 没有该字段，则设置为属性的默认值。
   c. 否则，
      i. 对于 Desc 的每个字段，将对象 O 的名为 P 的属性的相应属性设置为该字段的值。
7. 返回 true。

#### 10.1.7 `[[HasProperty]] ( P )`
普通对象 O 的 `[[HasProperty]]` 内部方法接受参数 P（一个属性键），返回一个包含布尔值的正常完成或一个抛出完成。调用时执行以下步骤：

1. 返回 `? OrdinaryHasProperty(O, P)`。

#### 10.1.7.1 `OrdinaryHasProperty ( O, P )`
抽象操作 `OrdinaryHasProperty` 接受参数 O（一个对象）和 P（一个属性键），返回一个包含布尔值的正常完成或一个抛出完成。调用时执行以下步骤：

1. 令 hasOwn 为 `? O.[[GetOwnProperty]](P)`。
2. 如果 hasOwn 不为 undefined，返回 true。
3. 令 parent 为 `? O.[[GetPrototypeOf]]()`。
4. 如果 parent 不为 null，则
   a. 返回 `? parent.[[HasProperty]](P)`。
5. 返回 false。

#### 10.1.8 `[[Get]] ( P, Receiver )`
普通对象 O 的 `[[Get]]` 内部方法接受参数 P（一个属性键）和 Receiver（一个 ECMAScript 语言值），返回一个包含 ECMAScript 语言值的正常完成或一个抛出完成。调用时执行以下步骤：

1. 返回 `? OrdinaryGet(O, P, Receiver)`。

#### 10.1.8.1 `OrdinaryGet ( O, P, Receiver )`
抽象操作 `OrdinaryGet` 接受参数 O（一个对象）、P（一个属性键）和 Receiver（一个 ECMAScript 语言值），返回一个包含 ECMAScript 语言值的正常完成或一个抛出完成。调用时执行以下步骤：

1. 令 desc 为 `? O.[[GetOwnProperty]](P)`。
2. 如果 desc 为 undefined，则
   a. 令 parent 为 `? O.[[GetPrototypeOf]]()`。
   b. 如果 parent 为 null，返回 undefined。
   c. 返回 `? parent.[[Get]](P, Receiver)`。
3. 如果 IsDataDescriptor(desc) 为 true，返回 desc.`[[Value]]`。
4. 断言：IsAccessorDescriptor(desc) 为 true。
5. 令 getter 为 desc.`[[Get]]`。
6. 如果 getter 为 undefined，返回 undefined。
7. 返回 `? Call(getter, Receiver)`。

#### 10.1.9 `[[Set]] ( P, V, Receiver )`
普通对象 O 的 `[[Set]]` 内部方法接受参数 P（一个属性键）、V（一个 ECMAScript 语言值）和 Receiver（一个 ECMAScript 语言值），返回一个包含布尔值的正常完成或一个抛出完成。调用时执行以下步骤：

1. 返回 `? OrdinarySet(O, P, V, Receiver)`。

#### 10.1.9.1 `OrdinarySet ( O, P, V, Receiver )`
抽象操作 `OrdinarySet` 接受参数 O（一个对象）、P（一个属性键）、V（一个 ECMAScript 语言值）和 Receiver（一个 ECMAScript 语言值），返回一个包含布尔值的正常完成或一个抛出完成。调用时执行以下步骤：

1. 令 ownDesc 为 `? O.[[GetOwnProperty]](P)`。
2. 返回 `? OrdinarySetWithOwnDescriptor(O, P, V, Receiver, ownDesc)`。

#### 10.1.9.2 `OrdinarySetWithOwnDescriptor ( O, P, V, Receiver, ownDesc )`
抽象操作 `OrdinarySetWithOwnDescriptor` 接受参数 O（一个对象）、P（一个属性键）、V（一个 ECMAScript 语言值）、Receiver（一个 ECMAScript 语言值）和 ownDesc（一个属性描述符或未定义），返回一个包含布尔值的正常完成或一个抛出完成。调用时执行以下步骤：

1. 如果 ownDesc 为 undefined，则
   a. 令 parent 为 `? O.[[GetPrototypeOf]]()`。
   b. 如果 parent 不为 null，则
      i. 返回 `? parent.[[Set]](P, V, Receiver)`。
   c. 否则，
      i. 将 ownDesc 设置为属性描述符 `{ [[Value]]: undefined, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true }`。
2. 如果 IsDataDescriptor(ownDesc) 为 true，则
   a. 如果 ownDesc.`[[Writable]]` 为 false，返回 false。
   b. 如果 Receiver 不是一个对象，返回 false。
   c. 令 existingDescriptor 为 `? Receiver.[[GetOwnProperty]](P)`。
   d. 如果 existingDescriptor 不为 undefined，则
      i. 如果 IsAccessorDescriptor(existingDescriptor) 为 true，返回 false。
      ii. 如果 existingDescriptor.`[[Writable]]` 为 false，返回 false。
      iii. 令 valueDesc 为属性描述符 `{ [[Value]]: V }`。
      iv. 返回 `? Receiver.[[DefineOwnProperty]](P, valueDesc)`。
   e. 否则，
      i. 断言：Receiver 当前没有属性 P。
      ii. 返回 `? CreateDataProperty(Receiver, P, V)`。
3. 断断言：IsAccessorDescriptor(ownDesc) 为 true。
4. 令 setter 为 ownDesc.`[[Set]]`。
5. 如果 setter 为 undefined，返回 false。
6. 执行 `? Call(setter, Receiver, « V »)`。
7. 返回 true。

#### 10.1.10 `[[Delete]] ( P )`
普通对象 O 的 `[[Delete]]` 内部方法接受参数 P（一个属性键），返回一个包含布尔值的正常完成或一个抛出完成。调用时执行以下步骤：

1. 返回 `? OrdinaryDelete(O, P)`。

#### 10.1.10.1 `OrdinaryDelete ( O, P )`
抽象操作 `OrdinaryDelete` 接受参数 O（一个对象）和 P（一个属性键），返回一个包含布尔值的正常完成或一个抛出完成。调用时执行以下步骤：

1. 令 desc 为 `? O.[[GetOwnProperty]](P)`。
2. 如果 desc 为 undefined，返回 true。
3. 如果 desc.`[[Configurable]]` 为 true，则
   a. 从 O 中移除键名为 P 的自有属性。
   b. 返回 true。
4. 返回 false。

#### 10.1.11 `[[OwnPropertyKeys]] ( )`
普通对象 O 的 `[[OwnPropertyKeys]]` 内部方法不接受参数，返回一个包含属性键列表的正常完成。调用时执行以下步骤：

1. 返回 `OrdinaryOwnPropertyKeys(O)`。

#### 10.1.11.1 `OrdinaryOwnPropertyKeys ( O )`
抽象操作 `OrdinaryOwnPropertyKeys` 接受参数 O（一个对象），返回一个属性键列表。调用时执行以下步骤：

1. 令 keys 为一个新的空列表。
2. 对于 O 的每个键名为 P 的自有属性，按数组索引递增顺序，
   a. 将 P 添加到 keys。
3. 对于 O 的每个键名为 P 的字符串属性，按属性创建的时间顺序，
   a. 将 P 添加到 keys。
4. 对于 O 的每个键名为 P 的符号属性，按属性创建的时间顺序，
   a. 将 P 添加到 keys。
5. 返回 keys。

#### 10.1.12 `OrdinaryObjectCreate ( proto [ , additionalInternalSlotsList ] )`
抽象操作 `OrdinaryObjectCreate` 接受参数 proto（一个对象或 `null`）和可选参数 additionalInternalSlotsList（一个内部槽名称列表），返回一个对象。它用于指定创建新普通对象的运行时过程。additionalInternalSlotsList 包含对象必须定义的额外内部槽的名称，除了 `[[Prototype]]` 和 `[[Extensible]]`。如果没有提供 additionalInternalSlotsList，则使用一个新的空列表。调用时执行以下步骤：

1. 令 internalSlotsList 为 « `[[Prototype]]`, `[[Extensible]]` »。
2. 如果提供了 additionalInternalSlotsList，将 internalSlotsList 设置为 internalSlotsList 和 additionalInternalSlotsList 的列表连接。
3. 令 O 为 `MakeBasicObject(internalSlotsList)`。
4. 将 O.`[[Prototype]]` 设置为 proto。
5. 返回 O。

**注意**：尽管 `OrdinaryObjectCreate` 做的只是调用 `MakeBasicObject`，其使用传达了创建普通对象而非异变对象的意图。因此，在本规范中，它不被任何随后修改对象内部方法以使结果变为非普通对象的算法调用。创建异变对象的操作直接调用 `MakeBasicObject`。

#### 10.1.13 `OrdinaryCreateFromConstructor ( constructor, intrinsicDefaultProto [ , internalSlotsList ] )`
抽象操作 `OrdinaryCreateFromConstructor` 接受参数 constructor（一个构造函数）和 intrinsicDefaultProto（一个字符串），以及可选参数 internalSlotsList（内部槽名称列表），返回一个包含对象的正常完成或一个抛出完成。它创建一个普通对象，其 `[[Prototype]]` 值从构造函数的 "prototype" 属性中获取（如果存在）。否则，使用 intrinsicDefaultProto 指定的内在对象作为 `[[Prototype]]`。internalSlotsList 包含必须作为对象一部分定义的额外内部槽的名称。如果没有提供 internalSlotsList，则使用一个新的空列表。调用时执行以下步骤：

1. 断言：intrinsicDefaultProto 是本规范中一个内在对象的名称。相应的对象必须是用于作为对象的 `[[Prototype]]` 值的内在对象。
2. 令 proto 为 `? GetPrototypeFromConstructor(constructor, intrinsicDefaultProto)`。
3. 如果提供了 internalSlotsList，令 slotsList 为 internalSlotsList。
4. 否则，令 slotsList 为一个新的空列表。
5. 返回 `OrdinaryObjectCreate(proto, slotsList)`。

#### 10.1.14 `GetPrototypeFromConstructor ( constructor, intrinsicDefaultProto )`
抽象操作 `GetPrototypeFromConstructor` 接受参数 constructor（一个函数对象）和 intrinsicDefaultProto（一个字符串），返回一个包含对象的正常完成或一个抛出完成。它确定应当用于创建与特定构造函数对应的对象的 `[[Prototype]]` 值。该值从构造函数的 "prototype" 属性中获取（如果存在）。否则，使用 intrinsicDefaultProto 指定的内在对象作为 `[[Prototype]]`。调用时执行以下步骤：

1. 断言：intrinsicDefaultProto 是本规范中一个内在对象的名称。相应的对象必须是用于作为对象的 `[[Prototype]]` 值的内在对象。
2. 令 proto 为 `? Get(constructor, "prototype")`。
3. 如果 proto 不是一个对象，则
   a. 令 realm 为 `? GetFunctionRealm(constructor)`。
   b. 将 proto 设置为 realm 的名为 intrinsicDefaultProto 的内在对象。
4. 返回 proto。

**注意**：如果构造函数未提供 `[[Prototype]]` 值，使用的默认值是从构造函数函数的 realm 获取的，而不是从运行执行上下文获取的。

#### 10.1.15 `RequireInternalSlot ( O, internalSlot )`
抽象操作 `RequireInternalSlot` 接受参数 O（一个 ECMAScript 语言值）和 internalSlot（一个内部槽名称），返回一个包含 UNUSED 的正常完成或一个抛出完成。除非 O 是一个对象并且有给定的内部槽，否则它会抛出异常。调用时执行以下步骤：

1. 如果 O 不是一个对象，抛出一个 TypeError 异常。
2. 如果 O 没有 internalSlot 内部槽，抛出一个 TypeError 异常。
3. 返回 UNUSED。

### 10.3 内置函数对象

内置函数对象是一个普通对象；它必须满足 10.1 中规定的普通对象的要求。

除了每个普通对象所需的内部槽（参见 10.1）之外，内置函数对象还必须具有以下内部槽：

- `[[Realm]]`，表示创建函数的领域的领域记录。
- `[[InitialName]]`，一个字符串，是函数的初始名称。它在 20.2.3.5 中使用。

除非另有说明，内置函数对象的 `[[Prototype]]` 内部槽的初始值为 %Function.prototype%。

内置函数对象必须有一个符合 10.3.1 中定义的 `[[Call]]` 内部方法。

只有当一个内置函数对象被描述为“构造函数”或者本规范中的某些算法明确设置了其 `[[Construct]]` 内部方法时，该对象才具有 `[[Construct]]` 内部方法。这样的 `[[Construct]]` 内部方法必须符合 10.3.2 中的定义。

实现可以提供本规范中未定义的额外内置函数对象。

#### 10.3.1 `[[Call]] ( thisArgument, argumentsList )`
内置函数对象 F 的 `[[Call]]` 内部方法接受参数 `thisArgument`（一个 ECMAScript 语言值）和 `argumentsList`（一个 ECMAScript 语言值的列表），并返回一个包含 ECMAScript 语言值的正常完成或一个抛出完成。调用时执行以下步骤：

1. 返回 `? BuiltinCallOrConstruct(F, thisArgument, argumentsList, undefined)`。

#### 10.3.2 `[[Construct]] ( argumentsList, newTarget )`
内置函数对象 F 的 `[[Construct]]` 内部方法（当该方法存在时）接受参数 `argumentsList`（一个 ECMAScript 语言值的列表）和 `newTarget`（一个构造函数），并返回一个包含对象的正常完成或一个抛出完成。调用时执行以下步骤：

1. 返回 `? BuiltinCallOrConstruct(F, UNINITIALIZED, argumentsList, newTarget)`。

#### 10.3.3 `BuiltinCallOrConstruct ( F, thisArgument, argumentsList, newTarget )`
抽象操作 `BuiltinCallOrConstruct` 接受参数 F（一个内置函数对象），`thisArgument`（一个 ECMAScript 语言值或 UNINITIALIZED），`argumentsList`（一个 ECMAScript 语言值的列表），以及 `newTarget`（一个构造函数或 undefined），并返回一个包含 ECMAScript 语言值的正常完成或一个抛出完成。调用时执行以下步骤：

1. 令 `callerContext` 为正在运行的执行上下文。
2. 如果 `callerContext` 尚未被挂起，则挂起 `callerContext`。
3. 令 `calleeContext` 为一个新的执行上下文。
4. 将 `calleeContext` 的函数设置为 F。
5. 令 `calleeRealm` 为 F 的 `[[Realm]]`。
6. 将 `calleeContext` 的领域设置为 `calleeRealm`。
7. 将 `calleeContext` 的 `ScriptOrModule` 设置为 null。
8. 执行任何必要的实现定义的 `calleeContext` 初始化。
9. 将 `calleeContext` 压入执行上下文栈；`calleeContext` 现在是正在运行的执行上下文。
10. 令 `result` 为评估 F 的结果的完成记录，结果应当符合 F 的规范。如果 `thisArgument` 为 UNINITIALIZED，则 `this` 值未初始化；否则，`thisArgument` 提供 `this` 值。`argumentsList` 提供命名参数。`newTarget` 提供 `NewTarget` 值。
11. **注意**：如果 F 在本文档中定义，“F 的规范”是通过算法步骤或其他方式为其指定的行为。
12. 从执行上下文栈中移除 `calleeContext` 并恢复 `callerContext` 作为正在运行的执行上下文。
13. 返回 `? result`。

**注意**：当 `calleeContext` 从执行上下文栈中移除时，如果它已经被挂起并由一个可访问的生成器保留以供稍后恢复，则不能销毁它。

#### 10.3.4 `CreateBuiltinFunction ( behaviour, length, name, additionalInternalSlotsList [ , realm [ , prototype [ , prefix ] ] ] )`
抽象操作 `CreateBuiltinFunction` 接受参数 `behaviour`（一个抽象闭包、一组算法步骤或本规范中提供的其他函数行为定义）、`length`（一个非负整数或 +∞）、`name`（一个属性键或私有名称）和 `additionalInternalSlotsList`（一个内部槽名称列表），以及可选参数 `realm`（一个领域记录）、`prototype`（一个对象或 null）和 `prefix`（一个字符串），并返回一个函数对象。`additionalInternalSlotsList` 包含必须定义为对象一部分的额外内部槽的名称。此操作创建一个内置函数对象。调用时执行以下步骤：

1. 如果未提供 `realm`，将 `realm` 设置为当前领域记录。
2. 如果未提供 `prototype`，将 `prototype` 设置为 `realm.[[Intrinsics]].[[%Function.prototype%]]`。
3. 令 `internalSlotsList` 为一个包含即将创建的内置函数对象的所有内部槽名称的列表。
4. 将 `additionalInternalSlotsList` 的元素追加到 `internalSlotsList`。
5. 令 `func` 为一个新的内置函数对象，当被调用时，它使用 `behaviour` 描述的行为并使用提供的参数作为 `behaviour` 指定的对应参数的值。新函数对象具有内部槽，其名称是 `internalSlotsList` 的元素，以及一个 `[[InitialName]]` 内部槽。
6. 将 `func.[[Prototype]]` 设置为 `prototype`。
7. 将 `func.[[Extensible]]` 设置为 true。
8. 将 `func.[[Realm]]` 设置为 `realm`。
9. 将 `func.[[InitialName]]` 设置为 null。
10. 执行 `SetFunctionLength(func, length)`。
11. 如果未提供 `prefix`，则
    a. 执行 `SetFunctionName(func, name)`。
12. 否则，
    a. 执行 `SetFunctionName(func, name, prefix)`。
13. 返回 `func`。

本规范中定义的每个内置函数都是通过调用 `CreateBuiltinFunction` 抽象操作创建的。

### 10.4 内置异变对象的内部方法和槽
本规范定义了几种内置异变对象。这些对象通常在大多数情况下行为类似于普通对象，除了某些特定情况。以下异变对象使用普通对象的内部方法，除非下面明确规定了例外情况：

#### 10.4.1 绑定函数异变对象
绑定函数异变对象是包装另一个函数对象的异变对象。绑定函数异变对象是可调用的（它具有 `[[Call]]` 内部方法，并且可能具有 `[[Construct]]` 内部方法）。调用绑定函数异变对象通常会调用其包装的函数。

如果一个对象的 `[[Call]]` 方法和（如果适用）`[[Construct]]` 方法使用以下实现，并且其其他基本内部方法使用 10.1 中的定义，则该对象是一个绑定函数异变对象。这些方法是在 `BoundFunctionCreate` 中安装的。

绑定函数异变对象没有表 30 中列出的 ECMAScript 函数对象的内部槽。相反，它们具有表 31 中列出的内部槽，除了 `[[Prototype]]` 和 `[[Extensible]]`。

表 31：绑定函数异变对象的内部槽
| 内部槽 | 类型 | 描述 |
| --- | --- | --- |
| `[[BoundTargetFunction]]` | 一个可调用的对象 | 包装的函数对象。 |
| `[[BoundThis]]` | 一个 ECMAScript 语言值 | 调用包装函数时始终传递的 `this` 值。 |
| `[[BoundArguments]]` | 一个 ECMAScript 语言值的列表 | 用作调用包装函数的第一个参数的值列表。 |

##### 10.4.1.1 `[[Call]] ( thisArgument, argumentsList )`
绑定函数异变对象 F 的 `[[Call]]` 内部方法接受参数 `thisArgument`（一个 ECMAScript 语言值）和 `argumentsList`（一个 ECMAScript 语言值的列表），并返回一个包含 ECMAScript 语言值的正常完成或一个抛出完成。调用时执行以下步骤：

1. 令 `target` 为 F 的 `[[BoundTargetFunction]]`。
2. 令 `boundThis` 为 F 的 `[[BoundThis]]`。
3. 令 `boundArgs` 为 F 的 `[[BoundArguments]]`。
4. 令 `args` 为 `boundArgs` 和 `argumentsList` 的列表连接。
5. 返回 `? Call(target, boundThis, args)`。

##### 10.4.1.2 `[[Construct]] ( argumentsList, newTarget )`
绑定函数异变对象 F 的 `[[Construct]]` 内方法接受参数 `argumentsList`（一个 ECMAScript 语言值的列表）和 `newTarget`（一个构造函数），并返回一个包含对象的正常完成或一个抛出完成。调用时执行以下步骤：

1. 令 `target` 为 F 的 `[[BoundTargetFunction]]`。
2. 断言：`IsConstructor(target)` 为 true。
3. 令 `boundArgs` 为 F 的 `[[BoundArguments]]`。
4. 令 `args` 为 `boundArgs` 和 `argumentsList` 的列表连接。
5. 如果 `SameValue(F, newTarget)` 为 true，则将 `newTarget` 设置为 `target`。
6. 返回 `? Construct(target, args, newTarget)`。

##### 10.4.1.3 `BoundFunctionCreate ( targetFunction, boundThis, boundArgs )`
抽象操作 `BoundFunctionCreate` 接受参数 `targetFunction`（一个函数对象）、`boundThis`（一个 ECMAScript 语言值）和 `boundArgs`（一个 ECMAScript 语言值的列表），并返回一个包含函数对象的正常完成或一个抛出完成。此操作用于指定创建新的绑定函数异变对象。调用时执行以下步骤：

1. 令 `proto` 为 `? targetFunction.[[GetPrototypeOf]]()`。
2. 令 `internalSlotsList` 为 `« [[Prototype]], [[Extensible]] »` 和表 31 中列出的内部槽的列表连接。
3. 令 `obj` 为 `MakeBasicObject(internalSlotsList)`。
4. 将 `obj.[[Prototype]]` 设置为 `proto`。
5. 按照 10.4.1.1 中的描述设置 `obj.[[Call]]`。
6. 如果 `IsConstructor(targetFunction)` 为 true，则
   a. 按照 10.4.1.2 中的描述设置 `obj.[[Construct]]`。
7. 将 `obj.[[BoundTargetFunction]]` 设置为 `targetFunction`。
8. 将 `obj.[[BoundThis]]` 设置为 `boundThis`。
9. 将 `obj.[[BoundArguments]]` 设置为 `boundArgs`。
10. 返回 `obj`。

#### 10.4.2 数组异变对象
数组是一种对数组索引属性键（见 6.1.7）进行特殊处理的异变对象。属性名为数组索引的属性也称为元素。每个数组都有一个不可配置的“length”属性，其值始终是小于 2**32 的非负整数。数组的“length”属性值在数学上大于每个自身属性的数组索引名；每当创建或更改数组的自身属性时，其他属性会相应调整以保持此不变量。具体来说，每当添加一个名为数组索引的自身属性时，“length”属性的值如果有必要将变为比该数组索引大一；每当更改“length”属性的值时，所有名为数组索引且值不小于新长度的自身属性将被删除。此约束仅适用于数组的自身属性，并且不受从其原型继承的“length”或数组索引属性的影响。

如果一个对象的 `[[DefineOwnProperty]]` 内部方法使用以下实现，并且其其他基本内部方法使用 10.1 中的定义，则该对象是一个数组异变对象（或简称数组）。这些方法是在 `ArrayCreate` 中安装的。

##### 10.4.2.1 `[[DefineOwnProperty]] ( P, Desc )`
数组异变对象 A 的 `[[DefineOwnProperty]]` 内部方法接受参数 P（一个属性键）和 Desc（一个属性描述符），并返回一个包含布尔值的正常完成或一个抛出完成。调用时执行以下步骤：

1. 如果 P 是 "length"，则
   a. 返回 `? ArraySetLength(A, Desc)`。
2. 否则如果 P 是数组索引，则
   a. 令 `lengthDesc` 为 `OrdinaryGetOwnProperty(A, "length")`。
   b. 断言：`IsDataDescriptor(lengthDesc)` 为 true。
   c. 断言：`lengthDesc.[[Configurable]]` 为 false。
   d. 令 `length` 为 `lengthDesc.[[Value]]`。
   e. 断言：`length` 是一个非负整数。
   f. 令 `index` 为 `! ToUint32(P)`。
   g. 如果 `index ≥ length` 并且 `lengthDesc.[[Writable]]` 为 false，则返回 false。
   h. 令 `succeeded` 为 `! OrdinaryDefineOwnProperty(A, P, Desc)`。
   i. 如果 `succeeded` 为 false，则返回 false。
   j. 如果 `index ≥ length`，则
      i. 将 `lengthDesc.[[Value]]` 设置为 `index + 1𝔽`。
      ii. 将 `succeeded` 设置为 `! OrdinaryDefineOwnProperty(A, "length", lengthDesc)`。
      iii. 断言：`succeeded` 为 true。
   k. 返回 true。
3. 返回 `? OrdinaryDefineOwnProperty(A, P, Desc)`。

##### 10.4.2.2 `ArrayCreate ( length [ , proto ] )`
抽象操作 `ArrayCreate` 接受参数 `length`（一个非负整数）和可选参数 `proto`（一个对象），并返回一个包含数组异变对象的正常完成或一个抛出完成。此操作用于指定创建新的数组。调用时执行以下步骤：

1. 如果 `length > 2**32 - 1`，则抛出一个 `RangeError` 异常。
2. 如果未提供 `proto`，则将 `proto` 设置为 `%Array.prototype%`。
3. 令 `A` 为 `MakeBasicObject(« [[Prototype]], [[Extensible]] »)`。
4. 将 `A.[[Prototype]]` 设置为 `proto`。
5. 按照 10.4.2.1 中的描述设置 `A.[[DefineOwnProperty]]`。
6. 执行 `! OrdinaryDefineOwnProperty(A, "length", PropertyDescriptor { [[Value]]: 𝔽(length), [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false })`。
7. 返回 `A`。

##### 10.4.2.3 `ArraySpeciesCreate ( originalArray, length )`
抽象操作 `ArraySpeciesCreate` 接受参数 `originalArray`（一个对象）和 `length`（一个非负整数），并返回一个包含对象的正常完成或一个抛出完成。此操作用于指定使用从 `originalArray` 派生的构造函数创建新的数组或类似对象。它不强制构造函数返回一个数组。调用时执行以下步骤：

1. 令 `isArray` 为 `? IsArray(originalArray)`。
2. 如果 `isArray` 为 false，则返回 `? ArrayCreate(length)`。
3. 令 `C` 为 `? Get(originalArray, "constructor")`。
4. 如果 `IsConstructor(C)` 为 true，则
   a. 令 `thisRealm` 为当前的领域记录。
   b. 令 `realmC` 为 `? GetFunctionRealm(C)`。
   c. 如果 `thisRealm` 和 `realmC` 不是同一个领域记录，则
      i. 如果 `SameValue(C, realmC.[[Intrinsics]].[[%Array%]])` 为 true，则将 `C` 设置为 undefined。
5. 如果 `C` 是一个对象，则
   a. 将 `C` 设置为 `? Get(C, @@species)`。
   b. 如果 `C` 为 null，则将 `C` 设置为 undefined。
6. 如果 `C` 为 undefined，则返回 `? ArrayCreate(length)`。
7. 如果 `IsConstructor(C)` 为 false，则抛出一个 `TypeError` 异常。
8. 返回 `? Construct(C, « 𝔽(length) »)`。

**注意**：如果 `originalArray` 是使用标准内置数组构造函数创建的，并且其领域不是正在运行的执行上下文的领域，则使用正在运行的执行上下文的领域创建一个新的数组。这保持了与过去 Web 浏览器的兼容性，这些浏览器历史上对现在使用 `ArraySpeciesCreate` 定义的 `Array.prototype` 方法具有这种行为。

##### 10.4.2.4 `ArraySetLength ( A, Desc )`
抽象操作 `ArraySetLength` 接受参数 `A`（一个数组）和 `Desc`（一个属性描述符），并返回一个包含布尔值的正常完成或一个抛出完成。调用时执行以下步骤：

1. 如果 `Desc` 没有 `[[Value]]` 字段，则
   a. 返回 `! OrdinaryDefineOwnProperty(A, "length", Desc)`。
2. 令 `newLenDesc` 为 `Desc` 的副本。
3. 令 `newLen` 为 `? ToUint32(Desc.[[Value]])`。
4. 令 `numberLen` 为 `? ToNumber(Desc.[[Value]])`。
5. 如果 `SameValueZero(newLen, numberLen)` 为 false，则抛出一个 `RangeError` 异常。
6. 将`newLenDesc.[[Value]]` 设置为 `newLen`。
7. 令 `oldLenDesc` 为 `OrdinaryGetOwnProperty(A, "length")`。
8. 断言：`IsDataDescriptor(oldLenDesc)` 为 true。
9. 断言：`oldLenDesc.[[Configurable]]` 为 false。
10. 令 `oldLen` 为 `oldLenDesc.[[Value]]`。
11. 如果 `newLen ≥ oldLen`，则
    a. 返回 `! OrdinaryDefineOwnProperty(A, "length", newLenDesc)`。
12. 如果 `oldLenDesc.[[Writable]]` 为 false，则返回 false。
13. 如果 `newLenDesc` 没有 `[[Writable]]` 字段或 `newLenDesc.[[Writable]]` 为 true，则
    a. 令 `newWritable` 为 true。
14. 否则，
    a. **注意**：将 `[[Writable]]` 属性设置为 false 被延后，以防某些元素无法删除。
    b. 令 `newWritable` 为 false。
    c. 将 `newLenDesc.[[Writable]]` 设置为 true。
15. 令 `succeeded` 为 `! OrdinaryDefineOwnProperty(A, "length", newLenDesc)`。
16. 如果 `succeeded` 为 false，则返回 false。
17. 对于 `A` 的每个自身属性键 `P`，如果 `P` 是数组索引并且 `! ToUint32(P) ≥ newLen`，按降序数值索引顺序执行以下步骤：
    a. 令 `deleteSucceeded` 为 `! A.[[Delete]](P)`。
    b. 如果 `deleteSucceeded` 为 false，则
        i. 将 `newLenDesc.[[Value]]` 设置为 `! ToUint32(P) + 1𝔽`。
        ii. 如果 `newWritable` 为 false，则将 `newLenDesc.[[Writable]]` 设置为 false。
        iii. 执行 `! OrdinaryDefineOwnProperty(A, "length", newLenDesc)`。
        iv. 返回 false。
18. 如果 `newWritable` 为 false，则
    a. 令 `succeeded` 为 `! OrdinaryDefineOwnProperty(A, "length", PropertyDescriptor { [[Writable]]: false })`。
    b. 断言：`succeeded` 为 true。
19. 返回 true。

**注意**：在步骤 3 和 4 中，如果 `Desc.[[Value]]` 是一个对象，则其 `valueOf` 方法会被调用两次。这是从本规范第 2 版开始指定的具有此效果的遗留行为。

#### 10.4.3 字符串异变对象
字符串对象是一种封装字符串值并暴露与字符串值的各个代码单元元素相对应的虚拟整数索引数据属性的异变对象。字符串异变对象始终具有名为“length”的数据属性，其值为所封装的字符串值的长度。代码单元数据属性和“length”属性都是不可写和不可配置的。

如果一个对象的 `[[GetOwnProperty]]`、`[[DefineOwnProperty]]` 和 `[[OwnPropertyKeys]]` 内部方法使用以下实现，并且其其他基本内部方法使用 10.1 中的定义，则该对象是一个字符串异变对象（或简称字符串对象）。这些方法是在 `StringCreate` 中安装的。

字符串异变对象具有与普通对象相同的内部槽。它们还具有一个 `[[StringData]]` 内部槽。

##### 10.4.3.1 `[[GetOwnProperty]] ( P )`
字符串异变对象 S 的 `[[GetOwnProperty]]` 内部方法接受参数 P（一个属性键），并返回一个包含属性描述符或 undefined 的正常完成。调用时执行以下步骤：

1. 令 `desc` 为 `OrdinaryGetOwnProperty(S, P)`。
2. 如果 `desc` 不为 undefined，则返回 `desc`。
3. 返回 `StringGetOwnProperty(S, P)`。

##### 10.4.3.2 `[[DefineOwnProperty]] ( P, Desc )`
字符串异变对象 S 的 `[[DefineOwnProperty]]` 内部方法接受参数 P（一个属性键）和 Desc（一个属性描述符），并返回一个包含布尔值的正常完成。调用时执行以下步骤：

1. 令 `stringDesc` 为 `StringGetOwnProperty(S, P)`。
2. 如果 `stringDesc` 不为 undefined，则
    a. 令 `extensible` 为 `S.[[Extensible]]`。
    b. 返回 `IsCompatiblePropertyDescriptor(extensible, Desc, stringDesc)`。
3. 返回 `! OrdinaryDefineOwnProperty(S, P, Desc)`。

##### 10.4.3.3 `[[OwnPropertyKeys]] ( )`
字符串异变对象 O 的 `[[OwnPropertyKeys]]` 内部方法不接受任何参数，返回一个包含属性键列表的正常完成。调用时执行以下步骤：

1. 令 `keys` 为一个新的空列表。
2. 令 `str` 为 `O.[[StringData]]`。
3. 断言：`str` 是一个字符串。
4. 令 `len` 为 `str` 的长度。
5. 对于每个整数 `i`，如果 `0 ≤ i < len`，按升序执行以下步骤：
    a. 将 `! ToString(𝔽(i))` 追加到 `keys`。
6. 对于 `O` 的每个自身属性键 `P`，如果 `P` 是数组索引并且 `! ToIntegerOrInfinity(P) ≥ len`，按升序数值索引顺序执行以下步骤：
    a. 将 `P` 追加到 `keys`。
7. 对于 `O` 的每个自身属性键 `P`，如果 `P` 是字符串并且 `P` 不是数组索引，按属性创建的时间顺序升序执行以下步骤：
    a. 将 `P` 追加到 `keys`。
8. 对于 `O` 的每个自身属性键 `P`，如果 `P` 是符号，按属性创建的时间顺序升序执行以下步骤：
    a. 将 `P` 追加到 `keys`。
9. 返回 `keys`。

##### 10.4.3.4 `StringCreate ( value, prototype )`
抽象操作 `StringCreate` 接受参数 `value`（一个字符串）和 `prototype`（一个对象），并返回一个字符串异变对象。此操作用于指定创建新的字符串异变对象。调用时执行以下步骤：

1. 令 `S` 为 `MakeBasicObject(« [[Prototype]], [[Extensible]], [[StringData]] »)`。
2. 将 `S.[[Prototype]]` 设置为 `prototype`。
3. 将 `S.[[StringData]]` 设置为 `value`。
4. 按照 10.4.3.1 中的描述设置 `S.[[GetOwnProperty]]`。
5. 按照 10.4.3.2 中的描述设置 `S.[[DefineOwnProperty]]`。
6. 按照 10.4.3.3 中的描述设置 `S.[[OwnPropertyKeys]]`。
7. 令 `length` 为 `value` 的长度。
8. 执行 `! DefinePropertyOrThrow(S, "length", PropertyDescriptor { [[Value]]: 𝔽(length), [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false })`。
9. 返回 `S`。

##### 10.4.3.5 `StringGetOwnProperty ( S, P )`
抽象操作 `StringGetOwnProperty` 接受参数 `S`（一个具有 `[[StringData]]` 内部槽的对象）和 `P`（一个属性键），并返回一个属性描述符或 undefined。调用时执行以下步骤：

1. 如果 `P` 不是字符串，则返回 undefined。
2. 令 `index` 为 `CanonicalNumericIndexString(P)`。
3. 如果 `index` 为 undefined，则返回 undefined。
4. 如果 `index` 不是整数，则返回 undefined。
5. 如果 `index` 为 -0𝔽，则返回 undefined。
6. 令 `str` 为 `S.[[StringData]]`。
7. 断言：`str` 是一个字符串。
8. 令 `len` 为 `str` 的长度。
9. 如果 ℝ(index) < 0 或 `len ≤ ℝ(index)`，则返回 undefined。
10. 令 `resultStr` 为从 ℝ(index) 到 ℝ(index) + 1 的 `str` 子字符串。
11. 返回属性描述符 `{ [[Value]]: resultStr, [[Writable]]: false, [[Enumerable]]: true, [[Configurable]]: false }`。

好的，我会继续翻译以下的章节内容。

### 10.4.4 参数异变对象
大多数 ECMAScript 函数都会为其代码提供一个 `arguments` 对象。根据函数定义的特性，其 `arguments` 对象要么是普通对象，要么是参数异变对象。参数异变对象是一种异变对象，其数组索引属性键映射到与其关联的 ECMAScript 函数调用的形式参数绑定。

如果一个对象的内部方法使用以下实现，则该对象是参数异变对象，而未指定的方法则使用 10.1 中的定义。这些方法是在 `CreateMappedArgumentsObject` 中安装的。

**注意 1**：尽管 `CreateUnmappedArgumentsObject` 归类在此条款中，它创建的是普通对象，而不是参数异变对象。

参数异变对象具有与普通对象相同的内部槽。它们还具有一个 `[[ParameterMap]]` 内部槽。普通的 `arguments` 对象也具有一个 `[[ParameterMap]]` 内部槽，其值始终为 `undefined`。对于普通的 `arguments` 对象，`[[ParameterMap]]` 内部槽仅用于 `Object.prototype.toString`（20.1.3.6）以标识它们。

**注意 2**：参数异变对象的整数索引数据属性，其数值名称值小于对应函数对象的形式参数数量，最初与函数的执行上下文中的相应参数绑定共享其值。这意味着更改属性会更改相应参数绑定的值，反之亦然。如果删除此类属性然后重新定义，或将其更改为访问器属性，则这种对应关系将被打破。如果 `arguments` 对象是普通对象，则其属性值只是传递给函数的参数的副本，并且属性值与形式参数值之间没有动态链接。

**注意 3**：`ParameterMap` 对象及其属性值用于指定 `arguments` 对象与参数绑定的对应关系。`ParameterMap` 对象及其属性值并不会从 ECMAScript 代码中直接可观察到。ECMAScript 实现不需要实际创建或使用此类对象来实现指定的语义。

**注意 4**：普通 `arguments` 对象定义了一个名为 `callee` 的不可配置访问器属性，在访问时会抛出 `TypeError` 异常。对于参数异变对象，该属性的定义仅适用于某些非严格模式的函数。普通变体中的 `callee` 属性的定义存在是为了确保符合 ECMAScript 实现不会以任何其他方式定义它。

**注意 5**：ECMAScript 实现的参数异变对象历史上包含一个名为 `caller` 的访问器属性。在 ECMAScript 2017 之前，本规范包括了对普通 `arguments` 对象上的 `caller` 属性的抛出定义。由于实现不再包含此扩展，因此 ECMAScript 2017 删除了对抛出 `caller` 访问器的要求。

#### 10.4.4.1 `[[GetOwnProperty]] ( P )`
参数异变对象 `args` 的 `[[GetOwnProperty]]` 内部方法接受参数 `P`（一个属性键），并返回一个包含属性描述符或 `undefined` 的正常完成。调用时执行以下步骤：

1. 令 `desc` 为 `OrdinaryGetOwnProperty(args, P)`。
2. 如果 `desc` 为 `undefined`，则返回 `undefined`。
3. 令 `map` 为 `args.[[ParameterMap]]`。
4. 令 `isMapped` 为 `! HasOwnProperty(map, P)`。
5. 如果 `isMapped` 为 true，则
    a. 将 `desc.[[Value]]` 设置为 `! Get(map, P)`。
6. 返回 `desc`。

#### 10.4.4.2 `[[DefineOwnProperty]] ( P, Desc )`
参数异变对象 `args` 的 `[[DefineOwnProperty]]` 内部方法接受参数 `P`（一个属性键）和 `Desc`（一个属性描述符），并返回一个包含布尔值的正常完成。调用时执行以下步骤：

1. 令 `map` 为 `args.[[ParameterMap]]`。
2. 令 `isMapped` 为 `! HasOwnProperty(map, P)`。
3. 令 `newArgDesc` 为 `Desc`。
4. 如果 `isMapped` 为 true 并且 `IsDataDescriptor(Desc)` 为 true，则
    a. 如果 `Desc` 没有 `[[Value]]` 字段、`Desc` 具有 `[[Writable]]` 字段且 `Desc.[[Writable]]` 为 false，则
        i. 将 `newArgDesc` 设置为 `Desc` 的副本。
        ii. 将 `newArgDesc.[[Value]]` 设置为 `! Get(map, P)`。
5. 令 `allowed` 为 `! OrdinaryDefineOwnProperty(args, P, newArgDesc)`。
6. 如果 `allowed` 为 false，则返回 false。
7. 如果 `isMapped` 为 true，则
    a. 如果 `Desc` 是访问器描述符，则
        i. 执行 `! map.[[Delete]](P)`。
    b. 否则，
        i. 如果 `Desc` 具有 `[[Value]]` 字段，则
            1. 断言：由于参数异变对象映射的形式参数始终是可写的，因此以下 `Set` 将成功。
            2. 执行 `! Set(map, P, Desc.[[Value]], false)`。
        ii. 如果 `Desc` 具有 `[[Writable]]` 字段且 `Desc.[[Writable]]` 为 false，则
            1. 执行 `! map.[[Delete]](P)`。
8. 返回 true。

#### 10.4.4.3 `[[Get]] ( P, Receiver )`
参数异变对象 `args` 的 `[[Get]]` 内部方法接受参数 `P`（一个属性键）和 `Receiver`（一个 ECMAScript 语言值），并返回一个包含 ECMAScript 语言值或抛出完成的正常完成。调用时执行以下步骤：

1. 令 `map` 为 `args.[[ParameterMap]]`。
2. 令 `isMapped` 为 `! HasOwnProperty(map, P)`。
3. 如果 `isMapped` 为 false，则
    a. 返回 `? OrdinaryGet(args, P, Receiver)`。
4. 否则，
    a. 断言：`map` 包含 `P` 的形式参数映射。
    b. 返回 `! Get(map, P)`。

#### 10.4.4.4 `[[Set]] ( P, V, Receiver )`
参数异变对象 `args` 的 `[[Set]]` 内部方法接受参数 `P`（一个属性键）、`V`（一个 ECMAScript 语言值）和 `Receiver`（一个 ECMAScript 语言值），并返回一个包含布尔值或抛出完成的正常完成。调用时执行以下步骤：

1. 如果 `SameValue(args, Receiver)` 为 false，则
    a. 令 `isMapped` 为 false。
2. 否则，
    a. 令 `map` 为 `args.[[ParameterMap]]`。
    b. 令 `isMapped` 为 `! HasOwnProperty(map, P)`。
3. 如果 `isMapped` 为 true，则
    a. 断言：由于参数异变对象映射的形式参数始终是可写的，因此以下 `Set` 将成功。
    b. 执行 `! Set(map, P, V, false)`。
4. 返回 `? OrdinarySet(args, P, V, Receiver)`。

#### 10.4.4.5 `[[Delete]] ( P )`
参数异变对象 `args` 的 `[[Delete]]` 内部方法接受参数 `P`（一个属性键），并返回一个包含布尔值或抛出完成的正常完成。调用时执行以下步骤：

1. 令 `map` 为 `args.[[ParameterMap]]`。
2. 令 `isMapped` 为 `! HasOwnProperty(map, P)`。
3. 令 `result` 为 `? OrdinaryDelete(args, P)`。
4. 如果 `result` 为 true 并且 `isMapped` 为 true，则
    a. 执行 `! map.[[Delete]](P)`。
5. 返回 `result`。

#### 10.4.4.6 `CreateUnmappedArgumentsObject ( argumentsList )`
抽象操作 `CreateUnmappedArgumentsObject` 接受参数 `argumentsList`（一个 ECMAScript 语言值列表），并返回一个普通对象。调用时执行以下步骤：

1. 令 `len` 为 `argumentsList` 中元素的数量。
2. 令 `obj` 为 `OrdinaryObjectCreate(%Object.prototype%, « [[ParameterMap]] »)`。
3. 将 `obj.[[ParameterMap]]` 设置为 `undefined`。
4. 执行 `! DefinePropertyOrThrow(obj, "length", PropertyDescriptor { [[Value]]: 𝔽(len), [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true })`。
5. 令 `index` 为 0。
6. 重复好的，继续翻译：

6. 重复执行以下步骤，直到 `index` 等于 `len`:
    a. 令 `val` 为 `argumentsList[index]`。
    b. 执行 `! CreateDataPropertyOrThrow(obj, ! ToString(𝔽(index)), val)`。
    c. 将 `index` 增加 1。

7. 执行 `! DefinePropertyOrThrow(obj, @@iterator, PropertyDescriptor { [[Value]]: %Array.prototype.values%, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true })`。
8. 执行 `! DefinePropertyOrThrow(obj, "callee", PropertyDescriptor { [[Get]]: %ThrowTypeError%, [[Set]]: %ThrowTypeError%, [[Enumerable]]: false, [[Configurable]]: false })`。
9. 返回 `obj`。

#### 10.4.4.7 `CreateMappedArgumentsObject ( func, formals, argumentsList, env )`
抽象操作 `CreateMappedArgumentsObject` 接受参数 `func`（一个对象）、`formals`（一个解析节点）、`argumentsList`（一个 ECMAScript 语言值列表）和 `env`（一个环境记录），并返回一个参数异变对象。调用时执行以下步骤：

1. 断言：`formals` 不包含剩余参数、任何绑定模式或任何初始化器。它可能包含重复的标识符。
2. 令 `len` 为 `argumentsList` 中元素的数量。
3. 令 `obj` 为 `MakeBasicObject(« [[Prototype]], [[Extensible]], [[ParameterMap]] »)`。
4. 设置 `obj.[[GetOwnProperty]]` 为 10.4.4.1 中的规范。
5. 设置 `obj.[[DefineOwnProperty]]` 为 10.4.4.2 中的规范。
6. 设置 `obj.[[Get]]` 为 10.4.4.3 中的规范。
7. 设置 `obj.[[Set]]` 为 10.4.4.4 中的规范。
8. 设置 `obj.[[Delete]]` 为 10.4.4.5 中的规范。
9. 设置 `obj.[[Prototype]]` 为 `%Object.prototype%`。
10. 令 `map` 为 `OrdinaryObjectCreate(null)`。
11. 将 `obj.[[ParameterMap]]` 设置为 `map`。
12. 令 `parameterNames` 为 `formals` 的绑定名称。
13. 令 `numberOfParameters` 为 `parameterNames` 中元素的数量。
14. 令 `index` 为 0。
15. 重复执行以下步骤，直到 `index` 等于 `len`:
    a. 令 `val` 为 `argumentsList[index]`。
    b. 执行 `! CreateDataPropertyOrThrow(obj, ! ToString(𝔽(index)), val)`。
    c. 将 `index` 增加 1。

16. 执行 `! DefinePropertyOrThrow(obj, "length", PropertyDescriptor { [[Value]]: 𝔽(len), [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true })`。
17. 令 `mappedNames` 为一个新的空列表。
18. 将 `index` 设置为 `numberOfParameters - 1`。
19. 重复执行以下步骤，直到 `index` 小于 0:
    a. 令 `name` 为 `parameterNames[index]`。
    b. 如果 `mappedNames` 不包含 `name`，则
        i. 将 `name` 附加到 `mappedNames`。
        ii. 如果 `index` 小于 `len`，则
            1. 令 `g` 为 `MakeArgGetter(name, env)`。
            2. 令 `p` 为 `MakeArgSetter(name, env)`。
            3. 执行 `! map.[[DefineOwnProperty]](! ToString(𝔽(index)), PropertyDescriptor { [[Set]]: p, [[Get]]: g, [[Enumerable]]: false, [[Configurable]]: true })`。
    c. 将 `index` 减少 1。

20. 执行 `! DefinePropertyOrThrow(obj, @@iterator, PropertyDescriptor { [[Value]]: %Array.prototype.values%, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true })`。
21. 执行 `! DefinePropertyOrThrow(obj, "callee", PropertyDescriptor { [[Value]]: func, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true })`。
22. 返回 `obj`。

##### 10.4.4.7.1 `MakeArgGetter ( name, env )`
抽象操作 `MakeArgGetter` 接受参数 `name`（一个字符串）和 `env`（一个环境记录），并返回一个函数对象。它创建了一个内置函数对象，该函数执行时返回在 `env` 中绑定的 `name` 的值。调用时执行以下步骤：

1. 令 `getterClosure` 为一个新的抽象闭包，没有参数，捕获 `name` 和 `env`，并在调用时执行以下步骤：
    a. 返回 `env.GetBindingValue(name, false)`。

2. 令 `getter` 为 `CreateBuiltinFunction(getterClosure, 0, "", « »)`。
3. **注意**：`getter` 不会直接暴露给 ECMAScript 代码。
4. 返回 `getter`。

##### 10.4.4.7.2 `MakeArgSetter ( name, env )`
抽象操作 `MakeArgSetter` 接受参数 `name`（一个字符串）和 `env`（一个环境记录），并返回一个函数对象。它创建了一个内置函数对象，该函数执行时在 `env` 中设置 `name` 的值。调用时执行以下步骤：

1. 令 `setterClosure` 为一个新的抽象闭包，参数为 `(value)`，捕获 `name` 和 `env`，并在调用时执行以下步骤：
    a. 返回 `! env.SetMutableBinding(name, value, false)`。

2. 令 `setter` 为 `CreateBuiltinFunction(setterClosure, 1, "", « »)`。
3. **注意**：`setter` 不会直接暴露给 ECMAScript 代码。
4. 返回 `setter`。

#### 10.4.5 类型化数组异变对象
类型化数组是一种对整数索引属性键进行特殊处理的异变对象。

类型化数组具有与普通对象相同的内部槽，另外还包括 `[[ViewedArrayBuffer]]`、`[[ArrayLength]]`、`[[ByteOffset]]`、`[[ContentType]]` 和 `[[TypedArrayName]]` 内部槽。

如果一个对象的 `[[GetOwnProperty]]`、`[[HasProperty]]`、`[[DefineOwnProperty]]`、`[[Get]]`、`[[Set]]`、`[[Delete]]` 和 `[[OwnPropertyKeys]]` 内部方法使用本节中的定义，并且其其他基本内部方法使用 10.1 中的定义，则该对象是类型化数组。这些方法是在 `TypedArrayCreate` 中安装的。

##### 10.4.5.1 `[[GetOwnProperty]] ( P )`
类型化数组 `O` 的 `[[GetOwnProperty]]` 内部方法接受参数 `P`（一个属性键），并返回一个包含属性描述符或 `undefined` 的正常完成。调用时执行以下步骤：

1. 如果 `P` 是字符串，则
    a. 令 `numericIndex` 为 `CanonicalNumericIndexString(P)`。
    b. 如果 `numericIndex` 不为 `undefined`，则
        i. 令 `value` 为 `TypedArrayGetElement(O, numericIndex)`。
        ii. 如果 `value` 为 `undefined`，则返回 `undefined`。
        iii. 返回属性描述符 `{ [[Value]]: value, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true }`。

2. 返回 `OrdinaryGetOwnProperty(O, P)`。

##### 10.4.5.2 `[[HasProperty]] ( P )`
类型化数组 `O` 的 `[[HasProperty]]` 内部方法接受参数 `P`（一个属性键），并返回一个包含布尔值的正常完成。调用时执行以下步骤：

1. 如果 `P` 是字符串，则
    a. 令 `numericIndex` 为 `CanonicalNumericIndexString(P)`。
    b. 如果 `numericIndex` 不为 `undefined`，返回 `IsValidIntegerIndex(O, numericIndex)`。

2. 返回 `? OrdinaryHasProperty(O, P)`。

##### 10.4.5.3 `[[DefineOwnProperty]] ( P, Desc )`
类型化数组 `O` 的 `[[DefineOwnProperty]]` 内部方法接受参数 `P`（一个属性键）和 `Desc`（一个属性描述符），并返回一个包含布尔值的正常完成。调用时执行以下步骤：

1. 如果 `P` 是字符串，则
    a. 令 `numericIndex` 为 `CanonicalNumericIndexString(P)`。
    b. 如果 `numericIndex` 不为 `undefined`，则
        i. 如果 `IsValidIntegerIndex(O, numericIndex)` 为 false，返回 false。
       

 ii. 如果 `Desc` 具有 `[[Configurable]]` 字段且 `Desc.[[Configurable]]` 为 false，返回 false。
        iii. 如果 `Desc` 具有 `[[Enumerable]]` 字段且 `Desc.[[Enumerable]]` 为 false，返回 false。
        iv. 如果 `IsAccessorDescriptor(Desc)` 为 true，返回 false。
        v. 如果 `Desc` 具有 `[[Writable]]` 字段且 `Desc.[[Writable]]` 为 false，返回 false。
        vi. 如果 `Desc` 具有 `[[Value]]` 字段，执行 `? TypedArraySetElement(O, numericIndex, Desc.[[Value]])`。
        vii. 返回 true。

2. 返回 `! OrdinaryDefineOwnProperty(O, P, Desc)`。

##### 10.4.5.4 `[[Get]] ( P, Receiver )`
类型化数组 `O` 的 `[[Get]]` 内部方法接受参数 `P`（一个属性键）和 `Receiver`（一个 ECMAScript 语言值），并返回一个包含 ECMAScript 语言值或抛出完成的正常完成。调用时执行以下步骤：

1. 如果 `P` 是字符串，则
    a. 令 `numericIndex` 为 `CanonicalNumericIndexString(P)`。
    b. 如果 `numericIndex` 不为 `undefined`，则
        i. 返回 `TypedArrayGetElement(O, numericIndex)`。

2. 返回 `? OrdinaryGet(O, P, Receiver)`。

##### 10.4.5.5 `[[Set]] ( P, V, Receiver )`
类型化数组 `O` 的 `[[Set]]` 内部方法接受参数 `P`（一个属性键）、`V`（一个 ECMAScript 语言值）和 `Receiver`（一个 ECMAScript 语言值），并返回一个包含布尔值或抛出完成的正常完成。调用时执行以下步骤：

1. 如果 `P` 是字符串，则
    a. 令 `numericIndex` 为 `CanonicalNumericIndexString(P)`。
    b. 如果 `numericIndex` 不为 `undefined`，则
        i. 如果 `SameValue(O, Receiver)` 为 true，则
            1. 执行 `? TypedArraySetElement(O, numericIndex, V)`。
            2. 返回 true。
        ii. 如果 `IsValidIntegerIndex(O, numericIndex)` 为 false，返回 true。

2. 返回 `? OrdinarySet(O, P, V, Receiver)`。

##### 10.4.5.6 `[[Delete]] ( P )`
类型化数组 `O` 的 `[[Delete]]` 内部方法接受参数 `P`（一个属性键），并返回一个包含布尔值的正常完成。调用时执行以下步骤：

1. 如果 `P` 是字符串，则
    a. 令 `numericIndex` 为 `CanonicalNumericIndexString(P)`。
    b. 如果 `numericIndex` 不为 `undefined`，则
        i. 如果 `IsValidIntegerIndex(O, numericIndex)` 为 false，返回 true；否则返回 false。

2. 返回 `! OrdinaryDelete(O, P)`。

##### 10.4.5.7 `[[OwnPropertyKeys]] ( )`
类型化数组 `O` 的 `[[OwnPropertyKeys]]` 内部方法不接受参数，并返回一个包含属性键列表的正常完成。调用时执行以下步骤：

1. 令 `taRecord` 为 `MakeTypedArrayWithBufferWitnessRecord(O, SEQ-CST)`。
2. 令 `keys` 为一个新的空列表。
3. 如果 `IsTypedArrayOutOfBounds(taRecord)` 为 false，则
    a. 令 `length` 为 `TypedArrayLength(taRecord)`。
    b. 对于每个整数 `i`，使 0 ≤ i < length，以升序顺序执行以下步骤：
        i. 将 `! ToString(𝔽(i))` 附加到 `keys`。

4. 对于 `O` 的每个自己的属性键 `P`，如果 `P` 是字符串且 `P` 不是整数索引，则按属性创建的时间顺序升序执行以下步骤：
    a. 将 `P` 附加到 `keys`。

5. 对于 `O` 的每个自己的属性键 `P`，如果 `P` 是符号，则按属性创建的时间顺序升序执行以下步骤：
    a. 将 `P` 附加到 `keys`。

6. 返回 `keys`。

##### 10.4.5.8 `TypedArray With Buffer Witness Records`
`TypedArray With Buffer Witness Record` 是一种记录值，用于封装一个类型化数组以及视图缓冲区的缓存字节长度。当视图缓冲区是可增长的 `SharedArrayBuffer` 时，它有助于确保单个共享内存读取事件的数据块字节长度。

`TypedArray With Buffer Witness Records` 具有表 32 中列出的字段。

**表 32：TypedArray With Buffer Witness Record 字段**

| 字段名                | 值               | 含义                                                |
| -------------------- | --------------- | -------------------------------------------------- |
| `[[Object]]`         | 一个类型化数组   | 加载其缓冲区字节长度的类型化数组。                  |
| `[[CachedBufferByteLength]]` | 非负整数或 `DETACHED` | 创建记录时对象的 `[[ViewedArrayBuffer]]` 的字节长度。|

##### 10.4.5.9 `MakeTypedArrayWithBufferWitnessRecord ( obj, order )`
抽象操作 `MakeTypedArrayWithBufferWitnessRecord` 接受参数 `obj`（一个类型化数组）和 `order`（SEQ-CST 或 UNORDERED），并返回一个 `TypedArray With Buffer Witness Record`。调用时执行以下步骤：

1. 令 `buffer` 为 `obj.[[ViewedArrayBuffer]]`。
2. 如果 `IsDetachedBuffer(buffer)` 为 true，则
    a. 将 `byteLength` 设置为 `DETACHED`。
3. 否则，
    a. 将 `byteLength` 设置为 `ArrayBufferByteLength(buffer, order)`。

4. 返回 `TypedArray With Buffer Witness Record { [[Object]]: obj, [[CachedBufferByteLength]]: byteLength }`。

##### 10.4.5.10 `TypedArrayCreate ( prototype )`
抽象操作 `TypedArrayCreate` 接受参数 `prototype`（一个对象），并返回一个类型化数组。调用时执行以下步骤：

1. 令 `internalSlotsList` 为 `« [[Prototype]], [[Extensible]], [[ViewedArrayBuffer]], [[TypedArrayName]], [[ContentType]], [[ByteLength]], [[ByteOffset]], [[ArrayLength]] »`。
2. 令 `A` 为 `MakeBasicObject(internalSlotsList)`。
3. 设置 `A.[[GetOwnProperty]]` 为 10.4.5.1 中的规范。
4. 设置 `A.[[HasProperty]]` 为 10.4.5.2 中的规范。
5. 设置 `A.[[DefineOwnProperty]]` 为 10.4.5.3 中的规范。
6. 设置 `A.[[Get]]` 为 10.4.5.4 中的规范。
7. 设置 `A.[[Set]]` 为 10.4.5.5 中的规范。
8. 设置 `A.[[Delete]]` 为 10.4.5.6 中的规范。
9. 设置 `A.[[OwnPropertyKeys]]` 为 10.4.5.7 中的规范。
10. 设置 `A.[[Prototype]]` 为 `prototype`。
11. 返回 `A`。

##### 10.4.5.11 `TypedArrayByteLength ( taRecord )`
抽象操作 `TypedArrayByteLength` 接受参数 `taRecord`（一个 `TypedArray With Buffer Witness Record`），并返回一个非负整数。调用时执行以下步骤：

1. 如果 `IsTypedArrayOutOfBounds(taRecord)` 为 true，返回 0。
2. 令 `length` 为 `TypedArrayLength(taRecord)`。
3. 如果 `length` 等于 0，返回 0。
4. 令 `O` 为 `taRecord.[[Object]]`。
5. 如果 `O.[[ByteLength]]` 不是 `AUTO`，返回 `O.[[ByteLength]]`。
6. 令 `elementSize` 为 `TypedArrayElementSize(O)`。
7. 返回 `length × elementSize`。

##### 10.4.5.12 `TypedArrayLength ( taRecord )`
抽象操作 `TypedArrayLength` 接受参数 `taRecord`（一个 `TypedArray With Buffer Witness Record`），并返回一个非负整数。调用时执行以下步骤：

1. 断言：`IsTypedArrayOutOfBounds(taRecord)` 为 false。
2. 令 `O` 为 `taRecord.[[Object]]`。
3. 如果 `O.[[ArrayLength]]` 不是 `AUTO`，返回 `O.[[ArrayLength]]`。
4. 断言：`IsFixedLengthArrayBuffer(O.[[ViewedArrayBuffer]])` 为 false。
5. 令 `byteOffset` 为 `O.[[ByteOffset]]`。
6. 令 `elementSize` 为 `TypedArrayElementSize(O)`。
7. 令 `byteLength` 为 `taRecord.[[CachedBufferByteLength]]`

。
8. 断言：`byteLength` 不是 `DETACHED`。
9. 返回 `floor((byteLength - byteOffset) / elementSize)`。

##### 10.4.5.13 `IsTypedArrayOutOfBounds ( taRecord )`
抽象操作 `IsTypedArrayOutOfBounds` 接受参数 `taRecord`（一个 `TypedArray With Buffer Witness Record`），并返回一个布尔值。它检查对象的任何数字属性是否引用了不包含在底层缓冲区范围内的索引值。调用时执行以下步骤：

1. 令 `O` 为 `taRecord.[[Object]]`。
2. 令 `bufferByteLength` 为 `taRecord.[[CachedBufferByteLength]]`。
3. 断言：如果 `IsDetachedBuffer(O.[[ViewedArrayBuffer]])` 为 true，则 `bufferByteLength` 为 `DETACHED`。
4. 如果 `bufferByteLength` 为 `DETACHED`，返回 true。
5. 令 `byteOffsetStart` 为 `O.[[ByteOffset]]`。
6. 如果 `O.[[ArrayLength]]` 为 `AUTO`，则
    a. 令 `byteOffsetEnd` 为 `bufferByteLength`。
7. 否则，
    a. 令 `elementSize` 为 `TypedArrayElementSize(O)`。
    b. 令 `byteOffsetEnd` 为 `byteOffsetStart + O.[[ArrayLength]] × elementSize`。

8. 如果 `byteOffsetStart > bufferByteLength` 或 `byteOffsetEnd > bufferByteLength`，返回 true。
9. **注意**：长度为 0 的类型化数组不被认为是越界的。
10. 返回 false。

##### 10.4.5.14 `IsValidIntegerIndex ( O, index )`
抽象操作 `IsValidIntegerIndex` 接受参数 `O`（一个类型化数组）和 `index`（一个数字），并返回一个布尔值。调用时执行以下步骤：

1. 如果 `IsDetachedBuffer(O.[[ViewedArrayBuffer]])` 为 true，返回 false。
2. 如果 `index` 不是整数数字，返回 false。
3. 如果 `index` 为 -0𝔽，返回 false。
4. 令 `taRecord` 为 `MakeTypedArrayWithBufferWitnessRecord(O, UNORDERED)`。
5. **注意**：当 `O` 的后备缓冲区是可增长的 `SharedArrayBuffer` 时，边界检查不是同步操作。
6. 如果 `IsTypedArrayOutOfBounds(taRecord)` 为 true，返回 false。
7. 令 `length` 为 `TypedArrayLength(taRecord)`。
8. 如果 ℝ(index) < 0 或 ℝ(index) ≥ length，返回 false。
9. 返回 true。

##### 10.4.5.15 `TypedArrayGetElement ( O, index )`
抽象操作 `TypedArrayGetElement` 接受参数 `O`（一个类型化数组）和 `index`（一个数字），并返回一个数字、BigInt 或 `undefined`。调用时执行以下步骤：

1. 如果 `IsValidIntegerIndex(O, index)` 为 false，返回 `undefined`。
2. 令 `offset` 为 `O.[[ByteOffset]]`。
3. 令 `elementSize` 为 `TypedArrayElementSize(O)`。
4. 令 `byteIndexInBuffer` 为 `(ℝ(index) × elementSize) + offset`。
5. 令 `elementType` 为 `TypedArrayElementType(O)`。
6. 返回 `GetValueFromBuffer(O.[[ViewedArrayBuffer]], byteIndexInBuffer, elementType, true, UNORDERED)`。

##### 10.4.5.16 `TypedArraySetElement ( O, index, value )`
抽象操作 `TypedArraySetElement` 接受参数 `O`（一个类型化数组）、`index`（一个数字）和 `value`（一个 ECMAScript 语言值），并返回一个包含 `UNUSED` 或抛出完成的正常完成。调用时执行以下步骤：

1. 如果 `O.[[ContentType]]` 为 `BIGINT`，令 `numValue` 为 `? ToBigInt(value)`。
2. 否则，令 `numValue` 为 `? ToNumber(value)`。
3. 如果 `IsValidIntegerIndex(O, index)` 为 true，则
    a. 令 `offset` 为 `O.[[ByteOffset]]`。
    b. 令 `elementSize` 为 `TypedArrayElementSize(O)`。
    c. 令 `byteIndexInBuffer` 为 `(ℝ(index) × elementSize) + offset`。
    d. 令 `elementType` 为 `TypedArrayElementType(O)`。
    e. 执行 `SetValueInBuffer(O.[[ViewedArrayBuffer]], byteIndexInBuffer, elementType, numValue, true, UNORDERED)`。

4. 返回 `UNUSED`。

**注意**：此操作总是看似成功，但尝试写入类型化数组末尾之后或写入由分离的 `ArrayBuffer` 支持的类型化数组时无效。

##### 10.4.5.17 `IsArrayBufferViewOutOfBounds ( O )`
抽象操作 `IsArrayBufferViewOutOfBounds` 接受参数 `O`（一个类型化数组或 `DataView`），并返回一个布尔值。它检查类型化数组的任何数字属性或 `DataView` 对象的方法是否可以引用底层数据块边界之外的值。此抽象操作存在作为上游规范的便利。调用时执行以下步骤：

1. 如果 `O` 具有 `[[DataView]]` 内部槽，则
    a. 令 `viewRecord` 为 `MakeDataViewWithBufferWitnessRecord(O, SEQ-CST)`。
    b. 返回 `IsViewOutOfBounds(viewRecord)`。

2. 令 `taRecord` 为 `MakeTypedArrayWithBufferWitnessRecord(O, SEQ-CST)`。
3. 返回 `IsTypedArrayOutOfBounds(taRecord)`。

#### 10.4.6 模块命名空间异变对象
模块命名空间异变对象是一种异变对象，用于公开从 ECMAScript 模块导出的绑定（参见 16.2.3）。模块命名空间异变对象的字符串键自己的属性与模块导出的绑定名称一一对应。导出的绑定包括使用 `export *` 导出项间接导出的任何绑定。每个字符串值自己的属性键是对应导出绑定名称的 `StringValue`。这些是模块命名空间异变对象的唯一字符串键属性。每个这样的属性具有 `{ [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: false }` 属性。模块命名空间异变对象不可扩展。

如果一个对象的 `[[GetPrototypeOf]]`、`[[SetPrototypeOf]]`、`[[IsExtensible]]`、`[[PreventExtensions]]`、`[[GetOwnProperty]]`、`[[DefineOwnProperty]]`、`[[HasProperty]]`、`[[Get]]`、`[[Set]]`、`[[Delete]]` 和 `[[OwnPropertyKeys]]` 内部方法使用本节中的定义，并且其其他基本内部方法使用 10.1 中的定义，则该对象是模块命名空间异变对象。这些方法是在 `ModuleNamespaceCreate` 中安装的。

模块命名空间异变对象具有表 33 中定义的内部槽。

**表 33：模块命名空间异变对象的内部槽**

| 内部槽      | 类型            | 描述                                     |
| ---------- | --------------- | --------------------------------------- |
| `[[Module]]` | 一个模块记录     | 该模块记录，其导出此命名空间公开。       |
| `[[Exports]]` | 一个字符串列表   | 元素是作为此对象自己的属性公开的导出名称的字符串值的列表。列表按字典代码单元顺序排序。 |

##### 10.4.6.1 `[[GetPrototypeOf]] ( )`
模块命名空间异变对象的 `[[GetPrototypeOf]]` 内部方法不接受参数，并返回一个包含 `null` 的正常完成。调用时执行以下步骤：

1. 返回 `null`。

##### 10.4.6.2 `[[SetPrototypeOf]] ( V )`
模块命名空间异变对象 `O` 的 `[[SetPrototypeOf]]` 内部方法接受参数 `V`（一个对象或 `null`），并返回一个包含布尔值的正常完成。调用时执行以下步骤：

1. 返回 `! SetImmutablePrototype(O, V)`。

##### 10.4.6.3 `[[IsExtensible]] ( )`
模块命名空间异变对象的 `[[IsExtensible]]` 内部方法不接受参数，并返回一个包含 `false` 的正常完成。调用时执行以下步骤：

1. 返回 `false`。

##### 10.4.6.4 `[[PreventExtensions]] ( )`
模块命名空间异变对象的 `[[PreventExtensions]]` 内部方法不接受参数，并返回一个包含 `true` 的正常完成。调用时执行以下步骤：

1. 返回 `true`。

##### 10.4.6.5 `[[GetOwnProperty]] ( P )`
模块命名空间异变对象 `O` 的 `[[GetOwnProperty]]` 内部方法接受

参数 `P`（一个属性键），并返回一个包含属性描述符或 `undefined` 的正常完成或抛出完成。调用时执行以下步骤：

1. 如果 `P` 是符号，返回 `OrdinaryGetOwnProperty(O, P)`。
2. 令 `exports` 为 `O.[[Exports]]`。
3. 如果 `exports` 不包含 `P`，返回 `undefined`。
4. 令 `value` 为 `? O.[[Get]](P, O)`。
5. 返回属性描述符 `{ [[Value]]: value, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: false }`。

##### 10.4.6.6 `[[DefineOwnProperty]] ( P, Desc )`
模块命名空间异变对象 `O` 的 `[[DefineOwnProperty]]` 内部方法接受参数 `P`（一个属性键）和 `Desc`（一个属性描述符），并返回一个包含布尔值的正常完成或抛出完成。调用时执行以下步骤：

1. 如果 `P` 是符号，返回 `! OrdinaryDefineOwnProperty(O, P, Desc)`。
2. 令 `current` 为 `? O.[[GetOwnProperty]](P)`。
3. 如果 `current` 为 `undefined`，返回 false。
4. 如果 `Desc` 具有 `[[Configurable]]` 字段且 `Desc.[[Configurable]]` 为 true，返回 false。
5. 如果 `Desc` 具有 `[[Enumerable]]` 字段且 `Desc.[[Enumerable]]` 为 false，返回 false。
6. 如果 `IsAccessorDescriptor(Desc)` 为 true，返回 false。
7. 如果 `Desc` 具有 `[[Writable]]` 字段且 `Desc.[[Writable]]` 为 false，返回 false。
8. 如果 `Desc` 具有 `[[Value]]` 字段，返回 `SameValue(Desc.[[Value]], current.[[Value]])`。
9. 返回 true。

##### 10.4.6.7 `[[HasProperty]] ( P )`
模块命名空间异变对象 `O` 的 `[[HasProperty]]` 内部方法接受参数 `P`（一个属性键），并返回一个包含布尔值的正常完成。调用时执行以下步骤：

1. 如果 `P` 是符号，返回 `! OrdinaryHasProperty(O, P)`。
2. 令 `exports` 为 `O.[[Exports]]`。
3. 如果 `exports` 包含 `P`，返回 true。
4. 返回 false。

##### 10.4.6.8 `[[Get]] ( P, Receiver )`
模块命名空间异变对象 `O` 的 `[[Get]]` 内部方法接受参数 `P`（一个属性键）和 `Receiver`（一个 ECMAScript 语言值），并返回一个包含 ECMAScript 语言值或抛出完成的正常完成。调用时执行以下步骤：

1. 如果 `P` 是符号，则
    a. 返回 `! OrdinaryGet(O, P, Receiver)`。

2. 令 `exports` 为 `O.[[Exports]]`。
3. 如果 `exports` 不包含 `P`，返回 `undefined`。
4. 令 `m` 为 `O.[[Module]]`。
5. 令 `binding` 为 `m.ResolveExport(P)`。
6. 断言：`binding` 是一个已解析的绑定记录。
7. 令 `targetModule` 为 `binding.[[Module]]`。
8. 断言：`targetModule` 不为 `undefined`。
9. 如果 `binding.[[BindingName]]` 为 `NAMESPACE`，则
    a. 返回 `GetModuleNamespace(targetModule)`。

10. 令 `targetEnv` 为 `targetModule.[[Environment]]`。
11. 如果 `targetEnv` 为 `EMPTY`，抛出 `ReferenceError` 异常。
12. 返回 `? targetEnv.GetBindingValue(binding.[[BindingName]], true)`。

**注意**：`ResolveExport` 无副作用。每次使用特定的 `exportName` 和 `resolveSet` 参数调用此操作时，它必须返回相同的结果。实现可能选择预先计算或缓存 `ResolveExport` 对模块命名空间异变对象的 `[[Exports]]` 的结果。

##### 10.4.6.9 `[[Set]] ( P, V, Receiver )`
模块命名空间异变对象的 `[[Set]]` 内部方法接受参数 `P`（一个属性键）、`V`（一个 ECMAScript 语言值）和 `Receiver`（一个 ECMAScript 语言值），并返回一个包含 `false` 的正常完成。调用时执行以下步骤：

1. 返回 false。

##### 10.4.6.10 `[[Delete]] ( P )`
模块命名空间异变对象 `O` 的 `[[Delete]]` 内部方法接受参数 `P`（一个属性键），并返回一个包含布尔值的正常完成。调用时执行以下步骤：

1. 如果 `P` 是符号，则
    a. 返回 `! OrdinaryDelete(O, P)`。

2. 令 `exports` 为 `O.[[Exports]]`。
3. 如果 `exports` 包含 `P`，返回 false。
4. 返回 true。

##### 10.4.6.11 `[[OwnPropertyKeys]] ( )`
模块命名空间异变对象 `O` 的 `[[OwnPropertyKeys]]` 内部方法不接受参数，并返回一个包含属性键列表的正常完成。调用时执行以下步骤：

1. 令 `exports` 为 `O.[[Exports]]`。
2. 令 `symbolKeys` 为 `OrdinaryOwnPropertyKeys(O)`。
3. 返回 `exports` 和 `symbolKeys` 的列表连接。

##### 10.4.6.12 `ModuleNamespaceCreate ( module, exports )`
抽象操作 `ModuleNamespaceCreate` 接受参数 `module`（一个模块记录）和 `exports`（一个字符串列表），并返回一个模块命名空间异变对象。调用时执行以下步骤：

1. 断言：`module.[[Namespace]]` 为空。
2. 令 `internalSlotsList` 为表 33 中列出的内部槽。
3. 令 `M` 为 `MakeBasicObject(internalSlotsList)`。
4. 将 `M` 的基本内部方法设置为 10.4.6 中指定的定义。
5. 将 `M.[[Module]]` 设置为 `module`。
6. 令 `sortedExports` 为一个列表，其元素是按字典代码单元顺序排序的 `exports` 的元素。
7. 将 `M.[[Exports]]` 设置为 `sortedExports`。
8. 创建与 28.3 中的定义相对应的 `M` 的自己的属性。
9. 将 `module.[[Namespace]]` 设置为 `M`。
10. 返回 `M`。

#### 10.4.7 不可变原型异变对象
不可变原型异变对象是一种异变对象，其 `[[Prototype]]` 内部槽在初始化后不会更改。

如果一个对象的 `[[SetPrototypeOf]]` 内部方法使用以下实现（其其他基本内部方法可能使用任何实现，取决于具体的不可变原型异变对象），则该对象是不可变原型异变对象。

**注意**：与其他异变对象不同，不可变原型异变对象没有提供专用的创建抽象操作。这是因为它们仅用于 `%Object.prototype%` 和主机环境，在主机环境中，相关对象可能以其他方式是异变的，因此需要专用的创建操作。

##### 10.4.7.1 `[[SetPrototypeOf]] ( V )`
不可变原型异变对象 `O` 的 `[[SetPrototypeOf]]` 内部方法接受参数 `V`（一个对象或 `null`），并返回一个包含布尔值或抛出完成的正常完成。调用时执行以下步骤：

1. 返回 `? SetImmutablePrototype(O, V)`。

##### 10.4.7.2 `SetImmutablePrototype ( O, V )`
抽象操作 `SetImmutablePrototype` 接受参数 `O`（一个对象）和 `V`（一个对象或 `null`），并返回一个包含布尔值或抛出完成的正常完成。调用时执行以下步骤：

1. 令 `current` 为 `? O.[[GetPrototypeOf]]()`。
2. 如果 `SameValue(V, current)` 为 true，返回 true。
3. 返回 false。

### 10.5 代理对象的内部方法和内部槽

代理对象是一种特殊的对象，其基本内部方法部分由 ECMAScript 代码实现。每个代理对象都有一个名为 `[[ProxyHandler]]` 的内部槽。`[[ProxyHandler]]` 的值是一个对象，称为代理的处理程序对象，或者为 null。处理程序对象的方法（见表 34）可用于增强一个或多个代理对象的内部方法的实现。每个代理对象还有一个名为 `[[ProxyTarget]]` 的内部槽，其值要么是一个对象，要么是 null 值。这个对象被称为代理的目标对象。

如果一个对象的基本内部方法（包括 `[[Call]]` 和 `[[Construct]]`，如果适用）使用本节中的定义，则该对象是一个代理特殊对象。这些内部方法在 `ProxyCreate` 中被安装。

**表 34：代理处理程序方法**

| 内部方法                     | 处理程序方法              |
|-----------------------------|---------------------------|
| `[[GetPrototypeOf]]`        | getPrototypeOf            |
| `[[SetPrototypeOf]]`        | setPrototypeOf            |
| `[[IsExtensible]]`          | isExtensible              |
| `[[PreventExtensions]]`     | preventExtensions         |
| `[[GetOwnProperty]]`        | getOwnPropertyDescriptor  |
| `[[DefineOwnProperty]]`     | defineProperty            |
| `[[HasProperty]]`           | has                       |
| `[[Get]]`                   | get                       |
| `[[Set]]`                   | set                       |
| `[[Delete]]`                | deleteProperty            |
| `[[OwnPropertyKeys]]`       | ownKeys                   |
| `[[Call]]`                  | apply                     |
| `[[Construct]]`             | construct                 |

当调用处理程序方法来实现代理对象的内部方法时，处理程序方法会将代理的目标对象作为参数传递。代理的处理程序对象不一定具有对应于每个基本内部方法的方法。如果处理程序对象没有与内部陷阱对应的方法，则在代理上调用内部方法会调用代理目标对象上的相应内部方法。

代理对象的 `[[ProxyHandler]]` 和 `[[ProxyTarget]]` 内部槽在对象创建时总是被初始化，并且通常不允许修改。某些代理对象的创建方式允许它们在创建后被撤销。当代理被撤销时，其 `[[ProxyHandler]]` 和 `[[ProxyTarget]]` 内部槽被设置为 null，导致随后在该代理对象上调用内部方法时抛出 TypeError 异常。

由于代理对象允许通过任意 ECMAScript 代码来实现内部方法，因此可以定义一个其处理程序方法违反 6.1.7.3 中定义的不变量的代理对象。6.1.7.3 中定义的一些内部方法不变量是基本完整性不变量。这些不变量由本节中指定的代理对象内部方法明确执行。ECMAScript 实现必须能够在所有可能的不变量违反情况下保持健壮。

在以下算法描述中，假定 `O` 是一个 ECMAScript 代理对象，`P` 是一个属性键值，`V` 是任何 ECMAScript 语言值，`Desc` 是一个属性描述符记录。

#### 10.5.1 `[[GetPrototypeOf]] ( )`
代理特殊对象 `O` 的 `[[GetPrototypeOf]]` 内部方法不接受参数，并返回一个包含一个对象或 null 的正常完成，或者返回一个抛出完成。调用时执行以下步骤：

1. 执行 `? ValidateNonRevokedProxy(O)`。
2. 令 `target` 为 `O.[[ProxyTarget]]`。
3. 令 `handler` 为 `O.[[ProxyHandler]]`。
4. 断言：`handler` 是一个对象。
5. 令 `trap` 为 `? GetMethod(handler, "getPrototypeOf")`。
6. 如果 `trap` 是 undefined，
    a. 返回 `? target.[[GetPrototypeOf]]()`。
7. 令 `handlerProto` 为 `? Call(trap, handler, « target »)`。
8. 如果 `handlerProto` 不是一个对象且 `handlerProto` 不是 null，抛出 TypeError 异常。
9. 令 `extensibleTarget` 为 `? IsExtensible(target)`。
10. 如果 `extensibleTarget` 为 true，返回 `handlerProto`。
11. 令 `targetProto` 为 `? target.[[GetPrototypeOf]]()`。
12. 如果 `SameValue(handlerProto, targetProto)` 为 false，抛出 TypeError 异常。
13. 返回 `handlerProto`。

**注意** `[[GetPrototypeOf]]` 对代理对象执行以下不变量：

- `[[GetPrototypeOf]]` 的结果必须是一个对象或 null。
- 如果目标对象不可扩展，则对代理对象应用 `[[GetPrototypeOf]]` 必须返回与对代理对象的目标对象应用 `[[GetPrototypeOf]]` 相同的值。

#### 10.5.2 `[[SetPrototypeOf]] ( V )`
代理特殊对象 `O` 的 `[[SetPrototypeOf]]` 内部方法接受参数 `V`（一个对象或 null），并返回一个包含布尔值的正常完成，或者返回一个抛出完成。调用时执行以下步骤：

1. 执行 `? ValidateNonRevokedProxy(O)`。
2. 令 `target` 为 `O.[[ProxyTarget]]`。
3. 令 `handler` 为 `O.[[ProxyHandler]]`。
4. 断言：`handler` 是一个对象。
5. 令 `trap` 为 `? GetMethod(handler, "setPrototypeOf")`。
6. 如果 `trap` 是 undefined，
    a. 返回 `? target.[[SetPrototypeOf]](V)`。
7. 令 `booleanTrapResult` 为 `ToBoolean(? Call(trap, handler, « target, V »))`。
8. 如果 `booleanTrapResult` 为 false，返回 false。
9. 令 `extensibleTarget` 为 `? IsExtensible(target)`。
10. 如果 `extensibleTarget` 为 true，返回 true。
11. 令 `targetProto` 为 `? target.[[GetPrototypeOf]]()`。
12. 如果 `SameValue(V, targetProto)` 为 false，抛出 TypeError 异常。
13. 返回 true。

**注意** `[[SetPrototypeOf]]` 对代理对象执行以下不变量：

- `[[SetPrototypeOf]]` 的结果是一个布尔值。
- 如果目标对象不可扩展，参数值必须与应用于目标对象的 `[[GetPrototypeOf]]` 的结果相同。

#### 10.5.3 `[[IsExtensible]] ( )`
代理特殊对象 `O` 的 `[[IsExtensible]]` 内部方法不接受参数，并返回一个包含布尔值的正常完成，或者返回一个抛出完成。调用时执行以下步骤：

1. 执行 `? ValidateNonRevokedProxy(O)`。
2. 令 `target` 为 `O.[[ProxyTarget]]`。
3. 令 `handler` 为 `O.[[ProxyHandler]]`。
4. 断言：`handler` 是一个对象。
5. 令 `trap` 为 `? GetMethod(handler, "isExtensible")`。
6. 如果 `trap` 是 undefined，
    a. 返回 `? IsExtensible(target)`。
7. 令 `booleanTrapResult` 为 `ToBoolean(? Call(trap, handler, « target »))`。
8. 令 `targetResult` 为 `? IsExtensible(target)`。
9. 如果 `booleanTrapResult` 不等于 `targetResult`，抛出 TypeError 异常。
10. 返回 `booleanTrapResult`。

**注意** `[[IsExtensible]]` 对代理对象执行以下不变量：

- `[[IsExtensible]]` 的结果是一个布尔值。
- 对代理对象应用 `[[IsExtensible]]` 必须返回与对代理对象的目标对象应用 `[[IsExtensible]]` 相同的值。

#### 10.5.4 `[[PreventExtensions]] ( )`
代理特殊对象 `O` 的 `[[PreventExtensions]]` 内部方法不接受参数，并返回一个包含布尔值的正常完成，或者返回一个抛出完成。调用时执行以下步骤：

1. 执行 `? ValidateNonRevokedProxy(O)`。
2. 令 `target` 为 `O.[[ProxyTarget]]`。
3. 令 `handler` 为 `O.[[ProxyHandler]]`。
4. 断言：`handler` 是一个对象。
5. 令 `trap` 为 `? GetMethod(handler, "preventExtensions")`。
6. 如果 `trap` 是 undefined，
    a. 返回 `? target.[[PreventExtensions]]()`。
7. 令 `booleanTrapResult` 为 `ToBoolean(? Call(trap, handler, « target »))`。
8. 如果 `booleanTrapResult` 为 true，
    a. 令 `extensibleTarget` 为 `? IsExtensible(target)`。
    b. 如果 `extensibleTarget` 为 true，抛出 TypeError 异常。
9. 返回 `booleanTrapResult`。

**注意** `[[PreventExtensions]]` 对代理对象执行以下不变量：

- `[[PreventExtensions]]` 的结果

是一个布尔值。
- 只有当对代理对象的目标对象应用 `[[IsExtensible]]` 为 false 时，才会对代理对象应用 `[[PreventExtensions]]` 返回 true。

#### 10.5.5 `[[GetOwnProperty]] ( P )`
代理特殊对象 `O` 的 `[[GetOwnProperty]]` 内部方法接受参数 `P`（一个属性键），并返回一个包含一个属性描述符或 undefined 的正常完成，或者返回一个抛出完成。调用时执行以下步骤：

1. 执行 `? ValidateNonRevokedProxy(O)`。
2. 令 `target` 为 `O.[[ProxyTarget]]`。
3. 令 `handler` 为 `O.[[ProxyHandler]]`。
4. 断言：`handler` 是一个对象。
5. 令 `trap` 为 `? GetMethod(handler, "getOwnPropertyDescriptor")`。
6. 如果 `trap` 是 undefined，
    a. 返回 `? target.[[GetOwnProperty]](P)`。
7. 令 `trapResultObj` 为 `? Call(trap, handler, « target, P »)`。
8. 如果 `trapResultObj` 不是一个对象且 `trapResultObj` 不是 undefined，抛出 TypeError 异常。
9. 令 `targetDesc` 为 `? target.[[GetOwnProperty]](P)`。
10. 如果 `trapResultObj` 是 undefined，
    a. 如果 `targetDesc` 是 undefined，返回 undefined。
    b. 如果 `targetDesc.[[Configurable]]` 为 false，抛出 TypeError 异常。
    c. 令 `extensibleTarget` 为 `? IsExtensible(target)`。
    d. 如果 `extensibleTarget` 为 false，抛出 TypeError 异常。
    e. 返回 undefined。
11. 令 `extensibleTarget` 为 `? IsExtensible(target)`。
12. 令 `resultDesc` 为 `? ToPropertyDescriptor(trapResultObj)`。
13. 执行 `CompletePropertyDescriptor(resultDesc)`。
14. 令 `valid` 为 `IsCompatiblePropertyDescriptor(extensibleTarget, resultDesc, targetDesc)`。
15. 如果 `valid` 为 false，抛出 TypeError 异常。
16. 如果 `resultDesc.[[Configurable]]` 为 false，
    a. 如果 `targetDesc` 是 undefined 或 `targetDesc.[[Configurable]]` 为 true，则
        i. 抛出 TypeError 异常。
    b. 如果 `resultDesc` 有 `[[Writable]]` 字段且 `resultDesc.[[Writable]]` 为 false，则
        i. 断言：`targetDesc` 有 `[[Writable]]` 字段。
        ii. 如果 `targetDesc.[[Writable]]` 为 true，抛出 TypeError 异常。
17. 返回 `resultDesc`。

**注意** `[[GetOwnProperty]]` 对代理对象执行以下不变量：

- `[[GetOwnProperty]]` 的结果必须是一个对象或 undefined。
- 如果目标对象的一个属性是不可配置的自有属性，则该属性不能被报告为不存在。
- 如果目标对象不可扩展，则一个属性不能被报告为不存在，除非它不存在于目标对象的自有属性中。
- 一个属性不能被报告为不可配置，除非它存在于目标对象的不可配置的自有属性中。
- 一个属性不能被报告为既不可配置又不可写，除非它存在于目标对象的既不可配置又不可写的自有属性中。

已翻译完成。


好的。翻译我下面给的章节，注意准确性和完整性，完成就停止并说明已翻译完成，别乱写，别无中生有===
继续往后翻译，注意准确性和完整性，完成就停止并说明已翻译完成，别乱写，别无中生有
别瞎说，明明后面还有10.4.4等章节，请继续往后翻译，注意准确性和完整性，完成就停止并说明已翻译完成，别乱写，别无中生有