# WebKit 的核心组件

- WebCore：

  - HTML 解析器：负责将 HTML 文档解析成 DOM 树结构。
  - CSS 解析器：解析 CSS 文件并计算样式信息。
  - 渲染引擎：负责将 DOM 树和样式信息转换成可见的页面内容，包括布局和绘制。
  - 事件处理：处理用户交互事件，如点击、滚动和输入。

- JavaScriptCore：

  - 解析器：将 JavaScript 代码解析成抽象语法树（AST）。
  - 编译器：将 AST 编译成字节码或机器码以供执行。
    - 字节码是一种中间代码，比源代码更接近机器码，但仍需解释执行。
    - 在某些情况下，JavaScriptCore 的即时编译（Just-In-Time, JIT）编译器会将字节码进一步编译成机器码，以提高执行效率。
      - 循环或频繁调用的函数。
      - 对于一些复杂的代码段，JIT 编译器会进行更高级的优化，例如内联函数调用、消除冗余代码等。
      - 如果某段代码在运行过程中表现出较高的性能需求，JIT 编译器可能会选择将其编译成机器码。
  - 运行时环境：负责 JavaScript 代码的执行和垃圾回收。
    - JavaScriptCore 的运行时环境负责执行的是编译后的字节码或机器码。
    - 垃圾回收（Garbage Collection, GC）指自动管理内存，JavaScriptCore 使用了一种基于标记-清除算法的垃圾回收器。它会在内存达到一定阈值或空闲时进行垃圾回收，标记出不再使用的对象，并清除这些对象所占用的内存。

- 网络模块：

  - 网络请求处理：负责处理 HTTP 请求和响应，管理网络连接。
  - 缓存管理：管理浏览器缓存，提高资源加载速度。
  - Cookie 管理：处理 Cookie 的存储和发送。

- 图形和媒体模块：

  - 图形绘制：负责绘制页面中的图形元素，包括文本、图片和图形。
  - 视频和音频播放：处理媒体文件的播放和控制。

- 平台抽象层：

  - 跨平台支持：提供平台独立的接口，使得 WebKit 可以在不同的操作系统和硬件上运行。
  - 平台特定优化：根据不同平台的特性进行优化，提高性能和兼容性。

- 辅助模块：
  - 插件支持：支持第三方插件的加载和运行。
  - 安全机制：实现同源策略、沙盒机制等安全策略，保障用户数据安全。
  - 辅助功能：支持无障碍浏览，提高对残障用户的友好性。

# WebKit 的应用

- 桌面浏览器：
  - Safari：由 Apple 开发，基于 WebKit 引擎，是 macOS 和 iOS 的默认浏览器。
  - 早期版本的 Chrome： 直到 2013 年 Google 推出了基于 WebKit 的分支 Blink，之后 Chrome 切换到了 Blink 引擎。
- 移动浏览器：
  - iOS 浏览器：所有 iOS 平台上的浏览器都基于 WebKit，这是 Apple 的政策要求。因此，iOS 设备上的 Safari、Chrome、Firefox 等浏览器都使用 WebKit 作为渲染引擎。
  - Android 浏览器：早期版本的 Android 默认浏览器也使用 WebKit 作为其渲染引擎，直到后来切换到 Blink 引擎。
- 嵌入式系统：
  - 许多智能电视和机顶盒使用 WebKit 作为浏览器引擎，提供网页浏览和 Web 应用支持。
  - 一些汽车制造商选择 WebKit 作为其信息娱乐系统的浏览器引擎，提供导航、娱乐和信息服务。
- Web 开发工具：
  - 许多 Web 开发者工具（如 Web Inspector）基于 WebKit，提供网页调试和性能分析功能。
- 操作系统组件：
  - 邮件客户端（如 Mail）、帮助查看器
- 其他应用：
  - 一些跨平台应用框架（如 Electron 的早期版本）使用 WebKit 来渲染桌面应用的用户界面。
  - 一些电子书阅读器使用 WebKit 来渲染 HTML 格式的电子书内容。

# WebKit 渲染引擎

- HTML 解析和 DOM 树构建

  - DOM 树（Document Object Model Tree）是 HTML 文档的内存表示，它反映了文档的结构和内容。
  - HTML 解析过程
    - 分词（tokenization）：解析器读取 HTML 文档的内容，将其分解成一系列的标记（tags）、文本和其他语法成分。
    - 语法分析：分词器生成的标记被送到语法分析器。语法分析器根据 HTML 规范，将标记组装成节点，并构建 DOM 树。
    - 树构建：语法分析器根据 HTML 标记的嵌套关系，将节点组织成一棵树状结构，即 DOM 树。

- DOM 树的节点类型

  - 元素节点：每个元素节点都有一个标签名、属性和子节点。
  - 文本节点：文本节点没有子节点，只包含纯文本数据。
  - 注释节点：注释节点不会被渲染，但会被保留在 DOM 树中。
  - 文档节点：代表整个 HTML 文档的根节点，是 DOM 树的根。

- 错误处理

  - WebKit 的 HTML 解析器遵循 HTML 规范中的错误处理规则，尽量容错并生成合理的 DOM 树。例如，未闭合的标签会被自动补全，嵌套错误的标签会被重新排列等。

- 交互和动态更新
  - 通过 JavaScript，可以添加、删除或修改 DOM 节点，从而改变页面内容和结构。

# CSS 解析与样式计算

- CSS 解析过程

  - 分词（tokenization）：解析器读取 CSS 样式表，将其分解成一系列的标记（tokens），包括选择器、属性和值。
  - 语法分析：语法分析器根据 CSS 规范，将标记组装成规则集（rule sets），每个规则集包含一个选择器和若干声明（declarations），声明包含要应用到这些元素的样式属性和值。

- 选择器匹配

  - 基本选择器：类型选择器、类选择器、ID 选择器
  - 组合选择器：后代选择器、子选择器、相邻兄弟选择器（div + p）、一般兄弟选择器（div ~ p）
  - 伪类和伪元素：伪类【选择特定状态的元素】（:hover、:nth-child(2)）、伪元素【选择元素的特定部分】（::before）

- 样式计算

  - 层叠和优先级：当多个规则集匹配同一个元素时，CSS 使用层叠规则决定哪些样式生效。
  - 继承：一些样式属性会从父元素继承到子元素，例如字体样式和颜色。
  - 计算样式：算过程会考虑层叠、优先级和继承等因素，生成一个完整的样式对象。
    - 计算样式过程
      - 收集所有相关样式：
        - 浏览器默认样式：如 body 的默认字体和颜色。
        - 内部样式表：<style>标签中的样式。
        - 外部样式表：通过<link>标签引用的样式。
        - 内联样式：元素的 style 属性中的样式。
      - 选择器匹配和特异性计算：
        - 内联样式：特异性最高，直接应用到元素。
        - ID 选择器：特异性较高，每个 ID 选择器增加特异性值。
        - 类选择器、属性选择器和伪类：中等特异性。
        - 类型选择器和伪元素：最低特异性。
      - 样式层叠和优先级处理：
        - 样式表来源：浏览器默认样式 < 用户样式表 < 作者样式表 < 内 - 联样式。
        - 选择器特异性：特异性高的选择器覆盖特异性低的选择器。
        - 声明的顺序：相同特异性的规则，后面的声明覆盖前面的声明。
      - 样式继承：
        - 一些样式属性（如字体、颜色）会从父元素继承到子元素。继承的样式与直接应用的样式一起决定最终的样式。
      - 生成计算样式：计算过程考虑层叠、特异性、继承和默认值，生成一个完整的样式对象。

- 可继承的 CSS 属性

  - 字体相关属性：

    - font-family：字体系列。
    - font-size：字体大小。
    - font-style：字体样式（如斜体）。
    - font-variant：字体变体（如小型大写字母）。
    - font-weight：字体粗细。
    - font：简写属性，包含所有字体相关属性。

  - 文本相关属性：

    - color：文本颜色。
    - text-align：文本对齐方式。
    - text-indent：首行缩进。
    - text-transform：文本转换（如大写、小写）。
    - text-shadow：文本阴影。
    - white-space：空白处理。
    - word-spacing：单词间距。
    - letter-spacing：字母间距。
    - line-height：行高。
    - direction：文本方向。
    - unicode-bidi：双向文本支持。
    - text-decoration-color：文本装饰颜色。
    - text-decoration-line：文本装饰线（如下划线）。
    - text-decoration-style：文本装饰样式（如实线、虚线）。

  - 列表相关属性：

    - list-style-type：列表项标记的类型。
    - list-style-image：列表项标记的图像。
    - list-style-position：列表项标记的位置。
    - list-style：简写属性，包含所有列表相关属性。

  - 表格相关属性：

    - caption-side：表格标题的位置。
    - border-collapse：表格边框的折叠方式。
    - border-spacing：表格单元格之间的边框间距。
    - empty-cells：是否显示空单元格的边框。

  - 其他属性：

    - visibility：可见性。
    - cursor：光标样式。
    - quotes：引号样式。

# 布局和绘制的实现原理

在 HTML 解析和 CSS 样式计算完成后，WebKit 渲染引擎需要将 DOM 树和样式信息转换为实际的页面布局，并进行绘制。

- 布局（Layout）【又称为“重排”（reflow），它决定了每个元素在页面中的位置和大小。】
  - 构建渲染树（Render Tree）：只包含可见元素。不可见的元素（如 display: none 的元素）不会出现在渲染树中。
  - 布局计算：从渲染树的根节点开始，递归计算每个渲染对象的位置和大小。这个过程遵循 CSS 盒模型和布局规则。
  - 流式布局：在流式布局中，元素按照文档流的顺序排列。块级元素从上到下排列，内联元素从左到右排列。
  - 浮动和定位布局：浮动元素（float）脱离文档流，向左或向右浮动。相邻的内联元素环绕在浮动元素周围。绝对定位元素相对于最近的定位祖先元素进行布局，而固定定位元素相对于视口进行布局。
- 绘制（Painting），将布局计算生成的渲染树转换为实际的像素输出。
  - 分层（Layering）：渲染树中的一些节点会被提升为独立的图层（Layers）。例如，包含 position: fixed 或 transform 属性的元素通常会成为独立图层。独立图层的优点是可以单独绘制和合成，提高绘制效率和性能。
    - 提升为独立图层的节点条件
      - 3D 变换：使用了 transform 属性且值为 3D 变换（例如 transform: translate3d(0, 0, 0)）。
      - CSS 动画和过渡：包含动画或过渡属性（例如 animation 或 transition）的元素。
      - 视频和插件：包含<video>或<object>、<embed>标签的元素
      - Canvas 元素：使用了<canvas>标签的元素。
      - Fixed 定位：使用了 position: fixed 属性的元素。
      - Will-Change 属性：例如 will-change: transform
      - Alpha 透明度：使用了 opacity 属性且值小于 1 的元素。
      - 过滤器：使用了 filter 属性（例如 filter: blur(5px)）。
      - 遮罩：使用了 mask 属性（例如 mask-image）。
      - 混合模式：使用了 mix-blend-mode 属性（例如 mix-blend-mode: multiply）。
      - 背面可见性：使用了 backface-visibility: hidden 属性的元素。
  - 绘制顺序：每个图层的绘制顺序按照树形结构和 CSS 层叠上下文（stacking context）确定。绘制顺序从后向前，即先绘制背景和边框，再绘制内容，最后绘制前景内容（如悬浮元素和伪元素）。
  - 绘制过程：WebKit 使用图形库（如 Skia 或 Core Graphics）将每个图层的内容绘制到位图（bitmap）上。绘制过程包括文本绘制、图像绘制、形状绘制和阴影绘制等。
    - 图形库如 Skia 和 Core Graphics 是 WebKit 渲染引擎与底层绘制硬件之间的桥梁, 提供了一套高效的图形绘制 API，用于处理复杂的图形操作。Skia 提供了跨平台的绘制 API，使得 WebKit 可以在不同操作系统上使用相同的绘制代码。
    - 位图（bitmap）是一个二维像素数组，用于存储图像的像素数据。每个图层会对应一个位图。为每个独立图层分配内存，创建一个空白的位图。绘制操作：文本绘制\图像绘制\形状绘制\阴影和渐变, 反锯齿和透明度处理。
  - 合成（Compositing）：根据图层的绘制顺序和透明度等属性，将各个图层的位图叠加在一起，生成最终的屏幕图像。最终的组合图像被传递到显示设备，呈现在用户的屏幕上。合成过程通常在 GPU 上进行，以提高性能。

# 示例展示了 WebKit 如何使用图形库将每个图层的内容绘制到位图上，并最终合成显示在屏幕上。

- 生成渲染树和图层：#box 元素由于使用了 position: absolute 和 transform 属性，会被提升为一个独立图层。
- 创建位图：为#box 图层创建一个 100px x 100px 的位图。
- 使用图形库绘制：使用 Skia 或 Core Graphics 创建绘制上下文，将位图作为目标。绘制#box 的背景色和旋转效果。处理透明度，使得#box 的内容在绘制时具有 80%的不透明度。
- 合成和输出：将#box 图层的位图与其他图层（如背景）进行合成。最终图像输出到屏幕，用户看到旋转且半透明的#box。
